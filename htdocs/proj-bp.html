<html>

<head>
<title>Bounds Checking in C & C++ using Bounded Pointers</title>
<link rev="made" href="mailto:greg@mcgary.org">
</head>

<body>
<h1 align="center">Bounds Checking Projects</h1>

<p>This page describes work in progress to add fine-grained bounds
checking to GCC's C and C++ front-ends.  Interested parties are
invited to port to Objective C as well.  Please contact <a
href="mailto:greg@mcgary.org">Greg McGary, greg@mcgary.org</a> if you
wish to assist with development or testing.

<p><strong>Contents:</strong>
<ul>
<li><a href="#overview">Overview of Bounded Pointers</a>
<li><a href="#status">Project Status</a>
<li><a href="#goals">Goals</a>
<li><a href="#nongoals">Non-Goals</a>
<li><a href="#maybegoals">Maybe Goals</a>
<li><a href="#toolchain">Other Links in the Toolchain</a>
<li><a href="#building">Building GCC and glibc for Bounded Pointers</a>
<li><a href="#testing">Testing with Bounded Pointers</a>
<li><a href="#porting">How to Port to a new CPU</a>
<li><a href="#gccdetails">GCC Implementation Details</a>
</ul>

<hr>

<p><h2><a name="overview">Overview</a></h2>

<p>Bounded Pointers are easy to understand.  GCC augments every
pointer datum with two additional pointers that hold the low bound and
high bound of the object to which the pointer is seated.  Prior to
dereference, GCC generates code to test whether the pointer's value
lies within the bounds, and if bounds are violated, to generate a
machine exception.

<p>Many find the notion of changing the size of a fundamental data
type alarming, but for well-formed higher-level C code that uses
accurate function prototypes and avoids abusing pointer/integer casts,
this is seldom a problem in practice.  Even low-level code can use
bounded pointers with some extra care.

<h2><a name="status">Project Status (updated 2000-07-31)</a></h2>

<ul>

<p><li><h3>Working for Intel x86</h3> Basic functionality is present
for Intel x86 using GCC code on the CVS branch tag
``<code>bounded-pointers-branch</code>''.  Basic functionality includes

<ul>
<p><li> synthesis of a datum's bounds upon application of <code>addressof</code>.
(Bounded pointers are also returned by memory allocators such as
<code>malloc</code>, but that's implemented by the allocator library.)
<p><li> propagation of bounds via pointer assignment,
function argument passing and function value return
<p><li>programmer control over boundedness of pointer types via new qualifiers
``<code>__bounded</code>'' and ``<code>__unbounded</code>.''
</ul>

<p>I have tested BPs on <code>fileutils</code>, <code>textutils</code>
and in bootstrapping gcc itself.  I have completed a full bootstrap of
GCC for <code>LANGUAGES=c</code> passing
<code>-fbounded-pointers</code> at all stages.  It wasn't a complete
success however, as the final compare failed for some files.  95% of
the C torture test passes in BP mode.  (I have not done any gcc tests
for more than a month, since I have been working exclusively on BP
support in <code>glibc</code>.)

<p><li><h3>GNU C Library</h3> I have recently committed support for
bounded pointers to the trunk of the GNU C library CVS tree.  Intel
x86 is functional.  PowerPC is in progress but still incomplete.  75%
of the <code>glibc</code> testsuite passes in BP mode for Intel x86.  C library
support includes thunks for system calls that accept bounded pointer
arguments, check their bounds and pass simple pointers on to the
OS kernel.

<p><li><h3>Committing GCC Changes</h3> My primary is on getting GCC
changes out of the branch and committed to the CVS trunk.

<p><li><h3>Documentation</h3> My secondary focus is on writing
documentation.  As much as I prefer to write & debug code,
documentation is necessary in order to inform and motivate new
volunteers.

<p><li><h3>Unfinished Business</h3> The most important unfinished bits are:

<ul>
<p><li>C++ front end.
<p><li>Optimize to eliminate redundant bounds checks.
<p><li>Relax gcc's requirement that structs reside in memory
so that elements of a bounded pointer may be independently assigned to machine registers.
<p><li>Port to more CPU architectures.  (PowerPC port is in progress.)
See <a href="#porting">How to Port to a new CPU</a>.
</ul>

</ul>

<p><h2><a name="goals">Goals</a></h2>

<ul>

<p><li><h3>Finest Granularity</h3> Bounded pointers enforce
data-integrity at the finest possible granularity.  Once a pointer is
seated to a datum, be it a scalar, array, array element, structure, or
structure member, references through that pointer may not exceed the
bounds of the datum.  Purify won't do this for you.  As long as a
pointer references valid memory, purify won't protest that your
program blew the bounds of an array and started overwriting an
adjacent data structure.

<p><li><h3>Prevent Unwanted Mixing of Checked and Unchecked Code</h3>
Functions having pointers in their return-type/arg-types signature are
incompatible between the BP and non-BP modes.  In order to prevent
unwanted mixing (i.e., calling a function in BP mode when it is
defined in non-BP mode, and vice-versa), GCC ``mangles'' the symbols
of all BP mode functions that have pointers in their signatures.
The presence of BP-mangled symbols causes unwanted mixing to be
detected at link time, rather than at runtime where the debug cost
is very much higher.

<p>As of this writing, the C function names are mangled by prepending
``<code>__BP_</code>''.  This is subject to change, since using a
suffix might work better with gdb (see <a href="#toolchain">Other
Links in the Toolchain</a>).  At this time, only function names are so
mangled.  It would be better to also mangle the names of global data
structures that contain pointers.

<p>For C++, whose functions are already mangled, I intend to add a
boundedness qualifier to the mangling scheme, perhaps adding the
letter `X' after the `P' that indicates pointer.  C++ does not mangle
the type of a function's return value, but in BP mode, this
information is essential.  The calling convention for returning a
bounded-pointer is incompatible with that for returning a single word.
A bounded pointer is represented as a three-word struct, so returning
one means returning a struct by value, which requires that the caller
designate space for the return value and pass a hidden first argument
that points to it.  The presence of the hidden pointer argument shifts
the argument list by one slot, making it incompatible with the
non-BP-return case.

<p><li><h3>Low Overhead</h3> Space and time overheads for
bounded-pointer programs are both approx 150%..200% (i.e., 2.5x..3x
slowdown and 2.5x..3x code size increase).  A couple years back I
implemented bounded pointers in gcc-2.7.2 with much hackage at the RTL
layer, and using a special BP machine mode (akin to the complex-number
machine modes) that allowed gcc to assign BP components individually
to registers, and to pass/return BPs components in registers.  This
version had space and time overhead of only 75%, and that was without
any optimizations to eliminate redundant checks.

<p>This experience leads me to believe that with optimizations to
eliminate redundant bounds checks, and with the ability to assign BP
components individually to registers, space and time overhead can be
brought under 50% (i.e., 1.5x slowdown and 1.5x code size increase).

</ul>

<p><h2><a name="nongoals">Non-Goals</a></h2>

<p>Bounded pointers do not detect the following errors in memory-usage:

<ul>
<li>Memory Leaks
<li>References through Dangling Pointers
<li>References to Uninitialized Memory
</ul>

Memory checks are done by Purify or <code>Checker</code> (Refer to
GCC's <code>-fcheck-memory-usage</code> option).  The checks provided
by bounded pointers and the memory-usage checkers complement each
other nicely without overlap.

<p><h2><a name="maybegoals">Maybe Goals</a></h2>

<ul>
<p><li><h3>Support Controlled Mixing of Checked and Unchecked Code</h3>

<p>Mixing checked and unchecked code is something that's theoretically
possible using two mechanisms: (1) explicit qualification of the
boundedness of declarations and (2) thunks that translate between
bounded-pointer and unbounded-pointer function interfaces.
[ FIXME: I have more to say about this ... ]

<p>In practice, the amount of work to properly control mixing is
unpredictable.  For instance, it's bloody difficult to build
bounded-pointer applications of reasonable complexity with an
unbounded-pointer C library.  On the other hand, it's considerably
easier to mix bounded-pointer application code with unbounded-pointer
X11 libraries.

<p>I have implemented the beginnings of automatic thunk-generation in
GCC, but so far it has only proven useful for building the C torture
testsuite in the days before I had a BP-capable C library.

<p>I consider this to be a back-burner project, since I believe that with
proper optimization, a 100% bounded-pointer program can be built and
run with acceptable space & time overhead.  In the absence of a
performance justification for mixing unchecked code, the other reason
to mix unchecked code is because one has only binaries.  As a
free-software project, bounded pointers in GCC exist primarily to
benefit the free-software community, so I don't intend to go out of my
way to accommodate programs that can't be built entirely from source
code.

<p>A third reason to mix unchecked code might be to work in stages on
converting a large system to become bounded-pointer capable.  It would
be nice to provide this option, but other things are more important
for now, particularly optimizations and broadening the list of
supported CPUs.

</ul>

<p><h2><a name="toolchain">Other Links in the Toolchain</a></h2>

<ul>

<p><li><h3>ld</h3> GCC synthesizes bounds with the
<code>addressof</code> operation.  A data object declared as
``<code>extern</code>'' with an incomplete type (or with a structure type
containing a flexible array member) has unknown size, but might have
its address taken.  Since GCC can't compute the high bound based on an
unknown size, it generates datum <code>foo</code>'s high bound as a
reference to the synthetic symbol ``<code>foo.high_bound</code>''.  If
<code>foo</code> is defined as initialized data, GCC generates the
label definition of <code>foo.high_bound</code> immediately following
<code>foo</code>'s initializers.  However, if <code>foo</code> resides
in uninitialized data (BSS or common), GCC cannot do this, and it's
left to the linker to synthesize <code>foo.high_bound</code>.
I have a small patch to GNU ld that does this for ELF targets.
(<a href="proj-bp-patch-ld.txt">Get the ld patch from here</a>)

<p><li><h3>gdb</h3>

<p>Bounded pointers introduce two nuisances for debugging:

<p>First, bounded pointers are represented internally as three-member
structures containing simple pointer members for the value, low bound
and high bound.  Gdb currently knows nothing about bounded pointers
and treats them according to the information in the symbol table.
Print a pointer variable and you'll see a three member struct.
Attempt to dereference a pointer variable via the expression
``<code>*foo</code>'', and you'll get an error because gdb thinks foo is
a struct--you must dereference with ``<code>*foo.value</code>''.

<p>Second, if a function has a pointers as any of its return type or
argument types, its assembler-name is prefixed with
``<code>__BP_</code>''.  Therefore, you need to prefix such function
names when setting breakpoints or printing function addresses.

<p>It would be useful to teach gdb about these two idiosyncrasies of
bounded pointers.

<p><li><h3><a name="autoconf">autoconf</a></h3>

<p>The ``<code>__BP_</code>'' prefix that is applied to functions
having pointers in their return-type/arg-types signature presents
problems for autoconf.  Autoconf tests for the presence of library
functions by creating a tiny test program that compiles and links with
a library.  If the test program fails to link, then the function is
considered to be absent from the library and the package supplies a
substitute.  The declaration coded into the test program is a phony
one of this form: ``<code>char foo ();</code>''.  If one wishes to
configure with the GCC option ``<code>-fbounded-pointers</code>'', and
<code>foo</code> has pointers in its signature, its library definition
will be as ``<code>__BP_foo</code>'', but the phony declaration will
compile as a reference to the simple ``<code>foo</code>'' and thus
yield a false negative.  A work-around is to always configure with the
non-BP version of a library.  I hope that a long-term solution will
come with extensions to autoconf that arrange to get a prototype for
the function under test.

</ul>

<p><h2><a name="building">Building GCC and GLIBC for Bounded Pointers</a></h2>

<p>If you wish to help with development and/or testing, you must first
build a baseline.  In the examples below, the shell variables
``<code>$..._dir</code>'' represent the directory names of your
toplevel <code>gcc</code>, <code>glibc</code>, <code>ld</code> and
<code>gdb</code> trees.  The shell variables
``<code>$..._repo</code>'' hold the names of the gcc and
<code>glibc</code> CVS repositories.  The values of these repository
variables will depend on whether you have write access or have
readonly access through <code>pserver/anoncvs</code> mode.  I'll
assume you know enough about CVS and about configuring and building
GNU packages to adapt the procedure below to fit your environment.

<ol>

<p><li><h3>Checkout, build and install gcc</h3>

<pre>
$ mkdir -p $gcc_dir/BUILD
$ cd $gcc_dir
$ cvs -d $gcc_repo co -rbounded-pointers-branch -d src gcc
$ cd BUILD
$ ../src/configure --prefix=$gcc_dir
$ make LANGUAGES=c
$ make LANGUAGES=c install-gcc
</pre>

<p>For convenience, you might wish to install a symlink called
``<code>gcc-bp</code>'' in one of your bin directories that refers to
<code>$gcc_dir/bin/gcc</code>.

<p><li><h3>Checkout, build and install glibc</h3>

<pre>
$ mkdir -p $glibc_dir/BUILD
$ cd $glibc_dir
$ cvs -d $glibc_repo co -d src libc
$ cd BUILD
$ env CC=$gcc_dir/bin/gcc ../src/configure --prefix=$glibc_dir \
	--enable-bounded --disable-profile --disable-shared
$ make
$ make install
</pre>

<p>I recommend ``<code>--disable-profile</code>'' and
``<code>--disable-shared</code>'' in order to shorten build time since
you won't need these targets.

<p><li><h3>Obtain, patch, build and install GNU ld</h3>

I won't give detailed instructions here, because there's nothing out
of the ordinary.  Download a modern binutils release, or get the code
from CVS.

You will need a small patch to GNU ld so that it will synthesize
``<code>foo.high_bound</code>'' symbols for common & bss symbols.  (<a
href="proj-bp-patch-ld.txt">Get the ld patch from here</a>) The patch
is relative to <code>binutils-2.10</code>, but will work on
<code>binutils-2.9</code> as well.

<p><li><h3>Obtain, patch, build and install gdb</h3>

I won't give detailed instructions here, because there's nothing out
of the ordinary.  Download a modern gdb release, or get the code from
CVS.

You will need a small patch to gdb so that it won't crash starting up
on a BP-mode program.  <a href="proj-bp-patch-gdb.txt">Get the gdb
patch from here.</a> The patch is relative to <code>gdb-5.0</code>,
but will work on <code>gdb-4.18</code> as well, if you supply the
`<code>-l</code>' option to <code>patch</code> to make it more lenient
about whitespace differences.

</ol>

<p><h2><a name="testing">Testing with Bounded Pointers</a></h2>

<p>Now that you have the essentials for working with bounded pointers,
here are some suggestions for testing.  I present them in order of
increasing difficulty.  You will be testing two things: (1)
correctness of BP-mode code generated by gcc, and (2) correctness of
the code under test.  My recent experience has been that most bugs
uncovered are legitimate bounds violations in the code under test.

<ul>

<p><li><h3>Run glibc's test suite</h3>

<p>This is easy.  Just run ``<code>make check</code>'' after building.
Most tests pass.  As for the test, pick one and debug it.

<p>These tests crash on bounds violations and dump core:

<pre>
grp/testgrp-bp *
iconv/tst-iconv1-bp
libio/tst-widetext-bp
localedata/tst-digits-bp
nss/test-netdb-bp *
posix/tst-fnmatch-bp
pwd/tst-getpw-bp *
stdio-common/tfformat-bp
stdlib/test-canon-bp
</pre>

<p><code>[*]</code> The starred tests crash in
<code>nss_parse_service_list</code> because of a GCC bug.

<p>These tests go into an infinite loop:

<pre>
assert/test-assert-bp
assert/test-assert-perr-bp
setjmp/jmpbug-bp
</pre>

<p><li><h3>Run GCC's test suite for C</h3>

<p>Here's how to run the GCC C torture tests in BP mode:

<pre>
$ make check-gcc RUNTESTFLAGS="--tool_opts=\"-g -fbounded-pointers -static \
                               -B$glibc_build_dir/csu/ -L$glibc_build_dir\""
</pre>

<p>Remember that ``<code>$..._dir</code>'' variables represent directory
names from your system.  Note the use of
``<code>-B$glibc_build_dir/csu/</code>'' to get <code>bcrt1.o</code>,
and ``<code>-L$glibc_build_dir</code>'' to get libraries.  Both of
these options refer to your C library build directories, not to the
directories in which you installed the C library.  This is
intentional.  The only thing you really need from the install tree is
the header tree in ``<code>$glibc_dir/include</code>''.  For the rest,
it is more convenient to get the files directly from the build tree,
so that when you rebuild <code>glibc</code> after fixing a bug, you
can avoid the install step.  Naturally, if you change a public header
file, you'll need to do the install, but this happens much less
frequently.

<p><li><h3>Build some other package and run its test suite</h3>

<p>Pick a favorite package and have at it.  Don't forget to build
a BP version of any extra libraries the package requires.

<p>Because of the <a href="#autoconf">problems with <code>autoconf</code></a>
mentioned above, the best workaround is to configure with the static
non-BP version of the C library you built alongside the BP version.
Your installed C library will invariably be an older version of
<code>glibc</code>, and will yield different configuration results, so
you don't want to use it.

<p>I use a couple of ``wrapper'' script to prefix the
<code>configure</code> command that gives me a suitable environment
for using the newly-built C library.

<p>This one is called ``<code>ubpenv</code>'':

<pre>
#!/bin/bash
export CC=$gcc_dir/bin/gcc
export LDFLAGS="-static -B$glibc_build_dir/csu/ -L$glibc_build_dir"
export CFLAGS="-isystem $glibc_dir/include -O2"
"$@"
</pre>

<p>This one is called ``<code>bpenv</code>'', and differs only in the
value of <code>CFLAGS</code>:

<pre>
#!/bin/bash
export CC=$gcc_dir/bin/gcc
export LDFLAGS="-static -B$glibc_build_dir/csu/ -L$glibc_build_dir"
export CFLAGS="-isystem $glibc_dir/include -fbounded-pointers \
               -fno-optimize-sibling-calls -O2 -g"
"$@"
</pre>

<p>I recommend that you turn off sibling-call optimizations in order to
preserve complete call traces and avoid surprises while debugging.

<p>In order to override the configured value of CFLAGS, you need to build
like so:

<pre>
$ bpenv eval make 'CFLAGS="$CFLAGS"'
</pre>

<p>To save some typing, I have a third script called ``<code>bpmake</code>'':

<pre>
#!/bin/bash
bpenv eval make 'CC="$CC"' "$@"
</pre>

<p>With these scripts, the sequence for building and testing a GNU
package in BP mode is this:

<pre>
$ ubpenv ./configure
$ bpmake
$ bpmake check
</pre>

<p>Unfortunately, as of this writing (2000-08-01),
<code>fileutils</code> and <code>textutils</code> fail to build
properly, showing errors like this:

<pre>
/var/tmp/cc9uRQpo.s: Assembler messages:
/var/tmp/cc9uRQpo.s:817: Error: undefined symbol __BP_ in operation
/var/tmp/cc9uRQpo.s:817: Error: undefined symbol fopen64 in operation
</pre>

<p>You'll know it has been fixed when this bit disappears from the page.

<p><li><h3>Bootstrap GCC</h3>

<p>This is more difficult.  (Stay tuned for details...)

</ul>

<p><h2><a name="porting">How to Port to a new CPU</a></h2>

Most of the bounded pointers implementation is machine independent,
both in GCC and in the C library.  These are the machine-dependent
parts:

<ul>

<p><li><h3>Conditional Traps in GCC Machine Description</h3>

<p>Bounded pointers depend on conditional trap patterns being defined
in the machine description.  Some machine descriptions already have
them, namely SPARC, rs6000 (PowerPC), m68k, m88k and i960.  All of
these have machine instructions that implement conditional traps with
one instruction.  Beginning with ISA-II, MIPS has conditional trap
instructions as well, but its GCC machine description so far lacks
them.  Intel x86 has no conditional trap instructions, but I defined
conditional trap patterns that expand to primitive instructions to
test and conditionally jump around an ``<code>int 5</code>''
instruction.  If the CPU you wish to support has no conditional trap
instructions, you should define pseudo conditional traps as I have
done for x86.

<p>Conditional traps are important for the sake of optimization.
Without them, GCC would need to emit conditional branches as RTL,
whose presence would artificially partition basic blocks and inhibit
other optimizations.  Also conditional trap RTL expressions are
readily identifiable and thus more conveniently checked for
redundancies that can be eliminated.

<p><li><h3>Assembler Language Functions in GNU C Library</h3>

<p>Most CPUs on which the GNU C library runs define some functions in
assembler which have pointers in their signatures.  Some are coded in
assembler because they are performance critical, such as the memory
and string functions (<code>bcopy</code>, <code>bzero</code>,
<code>memcpy</code>, <code>memcmp</code>, <code>memset</code>,
<code>strchr</code>, <code>strcpy</code>, <code>strcmp</code>,
<code>strlen</code>, <code>strtok</code>, etc), and primitives for
multi-precision arithmetic (<code>add_n</code>, <code>addmul_1</code>,
<code>mul_1</code>, <code>sub_n</code>, <code>submul_1</code>,
<code>lshift</code>, and <code>rshift</code>).  A few are coded in
assembler because they have special semantics that can't be achieved
with plain C, namely <code>setjmp</code> and <code>longjmp</code>.

<p>The assembler functions need to conditionally compile in BP and
non-BP modes.  In BP mode, they must accommodate the calling
convention where pointer arguments and return value are structs
passed by value, and they must check the bounds of their arguments.
The best way to proceed is to study what's already been done for Intel
x86, a CISC target, and for PowerPC, a RISC target.

<p><li><h3>Startup Functions in GNU C Library</h3>

<p>Again, the best way to proceed is to study what's already been
done for Intel x86 and (soon) for PowerPC.

</ul>

<p><h2><a name="gccdetails">GCC Implementation Details</a></h2>

<p>Sorry, nothing yet...  This stuff properly belongs in either the
GCC manual or the GCC ``Internal Representation'' document.


<p><hr>

<p><address>Greg McGary,
<a href="mailto:greg@mcgary.org">greg@mcgary.org</a>
</address>

</body>
</html>
