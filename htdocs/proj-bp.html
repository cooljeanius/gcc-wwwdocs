<html>

<head>
<title>Bounds Checking in C & C++ using Bounded Pointers</title>
<link rev="made" href="mailto:greg@mcgary.org">
</head>

<body>
<h1 align="center">Bounds Checking Projects</h1>

<p>This page describes work in progress to add fine-grained bounds
checking to GCC's C and C++ front-ends.  Interested parties are
invited to port to Objective C as well.  Please contact <a
href="mailto:greg@mcgary.org">Greg McGary, greg@mcgary.org</a> if you
wish to assist with development or testing.

<p><strong>Contents:</strong>
<ul>
<li><a href="#overview">Overview of Bounded Pointers</a>
<li><a href="#status">Project Status</a>
<li><a href="#goals">Goals</a>
<li><a href="#nongoals">Non-Goals</a>
<li><a href="#maybegoals">Maybe Goals</a>
<li><a href="#toolchain">Other Links in the Toolchain</a>
<li><a href="#gccdetails">GCC Implementation Details</a>
<li><a href="#getstarted">Getting Started</a>
</ul>

<hr>

<p><h2><a name="overview">Overview</a></h2>

<p>Bounded Pointers are easy to understand.  GCC augments every
pointer datum with two additional pointers that hold the low bound and
high bound of the object to which the pointer is seated.  Prior to
dereference, GCC generates code to test whether the pointer's value
lies within the bounds, and if bounds are violated, to generate a
machine exception.

<p>Many find the notion of changing the size of a fundamental data
type alarming, but for well-formed higher-level C code that uses
accurate function prototypes and avoids abusing pointer/integer casts,
this is seldom a problem in practice.  Even low-level code can use
bounded pointers with some extra care.

<h2><a name="status">Project Status (updated 2000-07-31)</a></h2>

<ul>

<p><li><h3>Working for Intel x86</h3> Basic functionality is present
for Intel x86 using GCC code on the CVS branch tag
``<code>bounded-pointers-branch</code>''.  Basic functionality includes

<ol>
<p><li> synthesis of a datum's bounds upon application of <code>addressof</code>.
(Bounded pointers are also returned by memory allocators such as
<code>malloc</code>, but that's implemented by the allocator library.)
<p><li> propagation of bounds via pointer assignment,
function argument passing and function value return
<p><li>programmer control over boundedness of pointer types via new qualifiers
``<code>__bounded</code>'' and ``<code>__unbounded</code>.''
</ol>

<p>I have tested BPs on <code>fileutils</code>, <code>textutils</code>
and in bootstrapping gcc itself.  I have completed a full bootstrap of
GCC for <code>LANGUAGES=c</code> passing
<code>-fbounded-pointers</code> at all stages.  It wasn't a complete
success however, as the final compare failed for some files.  95% of
the C torture test passes in BP mode.  (I have not done any gcc tests
for more than a month, since I have been working exclusively on BP
support in glibc.)

<p><li><h3>GNU C Library</h3> I have recently committed support for
bounded pointers to the trunk of the GNU C library CVS tree.  Intel
x86 is functional.  PowerPC is in progress but still incomplete.  75%
of the glibc testsuite passes in BP mode for Intel x86.  C library
support includes thunks for system calls that accept bounded pointer
arguments, check their bounds and pass simple pointers on to the
OS kernel.

<p><li><h3>Committing GCC Changes</h3> My primary is on getting GCC
changes out of the branch and committed to the CVS trunk.

<p><li><h3>Documentation</h3> My secondary focus is on writing
documentation.  As much as I prefer to write & debug code,
documentation is necessary in order to inform and motivate new
volunteers.

<p><li><h3>Unfinished Business</h3> The most important unfinished bits
are: C++ front end; eliminate redundant bounds checks; relax gcc's
requirement that structs reside in memory so that elements of a
bounded pointer may be independently assigned to machine registers.
Port to more CPU architectures (PowerPC work is in progress).

</ul>

<p><h2><a name="goals">Goals</a></h2>

<ul>

<p><li><h3>Finest Granularity</h3> Bounded pointers enforce
data-integrity at the finest possible granularity.  Once a pointer is
seated to a datum, be it a scalar, array, array element, structure, or
structure member, references through that pointer may not exceed the
bounds of the datum.  Purify won't do this for you.  As long as a
pointer references valid memory, purify won't protest that your
program blew the bounds of an array and started overwriting an
adjacent data structure.

<p><li><h3>Low Overhead</h3> Space and time overheads for
bounded-pointer programs are both approx 150%..200% (i.e., 2.5x..3x
slowdown and 2.5x..3x code size increase).  A couple years back I
implemented bounded pointers in gcc-2.7.2 with much hackage at the RTL
layer, and using a special BP machine mode (akin to the complex-number
machine modes) that allowed gcc to assign BP components individually
to registers, and to pass/return BPs components in registers.  This
version had space and time overhead of only 75%, and that was without
any optimizations to eliminate redundant checks.

<p>This experience leads me to believe that with optimizations to
eliminate redundant bounds checks, and with the ability to assign BP
components individually to registers, space and time overhead can be
brought under 50% (i.e., 1.5x slowdown and 1.5x code size increase).

</ul>

<p><h2><a name="nongoals">Non-Goals</a></h2>

<p>Bounded pointers do not detect the following errors in memory-usage:

<ul>
<li>Memory Leaks
<li>References through Dangling Pointers
<li>References to Uninitialized Memory
</ul>

Memory checks are done by Purify or <code>Checker</code> (Refer to
GCC's <code>-fcheck-memory-usage</code> option).  The checks provided
by bounded pointers and the memory-usage checkers complement each
other nicely without overlap.

<p><h2><a name="maybegoals">Maybe Goals</a></h2>

<p>Mixing checked and unchecked code is something that's theoretically
possible using two mechanisms: (1) explicit qualification of the
boundedness of declarations and (2) thunks that translate between
bounded-pointer and unbounded-pointer function interfaces.

<p>In practice, how things will go is unpredictable.  For instance, it's
bloody difficult to build bounded-pointer applications of reasonable
complexity with an unbounded-pointer C library.  On the other hand,
it's considerably easier to mix bounded-pointer application code with
unbounded-pointer X11 libraries.

<p>I have implemented the beginnings of automatic thunk-generation in
GCC, but so far it has only proven useful for building the C torture
testsuite in the days before I had a BP-capable C library.

<p>I consider this to be a back-burner project, since I believe that with
proper optimization, a 100% bounded-pointer program can be built and
run with acceptable space & time overhead.  In the absence of a
performance justification for mixing unchecked code, the other reason
to mix unchecked code is because one has only binaries.  As a
free-software project, bounded pointers in GCC exist primarily to
benefit the free-software community, so I don't intend to go out of my
way accommodate programs that can't be built entirely from source
code.

<p>A third reason to mix unchecked code might be to work in stages on
converting a large system to become bounded-pointer capable.  It would
be nice to provide this option, but other things are more important
for now, particularly optimizations and broadening the list of
supported CPUs.

<p><h2><a name="toolchain">Other Links in the Toolchain</a></h2>

<ul>

<p><li><h3>ld</h3> GCC synthesizes bounds with the
<code>addressof</code> operation.  A data object declared as
``<code>extern</code>'' with an incomplete type (or with a structure type
containing a flexible array member) has unknown size, but might have
its address taken.  Since GCC can't compute the high bound based on an
unknown size, it generates datum <code>foo</code>'s high bound as a
reference to the synthetic symbol ``<code>foo.high_bound</code>''.  If
<code>foo</code> is defined as initialized data, GCC generates the
label definition of <code>foo.high_bound</code> immediately following
<code>foo</code>'s initializers.  However, if <code>foo</code> resides
in uninitialized data (BSS or common), GCC cannot do this, and it's
left to the linker to synthesize <code>foo.high_bound</code>.
I have a small patch to GNU ld that does this for ELF targets.
(<a href="proj-bp-patch-ld.txt">Get the ld patch from here.</a>.)

<p><li><h3>gdb</h3>

<p>Bounded pointers introduce two nuisances for debugging:

<p>First, bounded pointers are represented internally as three-member
structures containing simple pointer members for the value, low bound
and high bound.  Gdb currently knows nothing about bounded pointers
and treats them according to the information in the symbol table.
Print a pointer variable and you'll see a three member struct.
Attempt to dereference a pointer variable via the expression
``<code>*foo</code>'', and you'll get an error because gdb thinks foo is
a struct--you must dereference with ``<code>*foo.value</code>''.

<p>Second, if a function has a pointers as any of its return type or
argument types, its assembler-name is prefixed with
``<code>__BP_</code>''.  Therefore, you need to prefix such function
names when setting breakpoints or printing function addresses.

<p>It would be useful to teach gdb about these two idiosyncrasies of
bounded pointers.

<p><li><h3>autoconf</h3>

<p>The ``<code>__BP_</code>'' prefix that is applied to functions
having pointers in their return-type/arg-types signature presents
problems for autoconf.  Autoconf tests for the presence of library
functions by creating a tiny test program that compiles and links with
a library.  If the test program fails to link, then the function is
considered to absent from the library and the package supplies a
substitute.  The declaration coded into the test program is a phony
one of this form: ``<code>char foo ();</code>''.  If one wishes to
configure with the GCC option ``<code>-fbounded-pointers</code>'', and
<code>foo</code> has pointers in its signature, its library definition
will be as ``<code>__BP_foo</code>'', but the phony declaration will
compile as a reference to the simple ``<code>foo</code>'' and thus
yield a false negative.  A work-around is to always configure with the
non-BP version of a library.  I hope that a long-term solution will
come with extensions to autoconf that arrange to get a prototype for
the function under test.

</ul>

<p><h2><a name="gccdetails">GCC Implementation Details</a></h2>

<p>Sorry, nothing yet...  This stuff properly belongs in either the
GCC manual or the GCC ``Internal Representation'' document.

<p><h2><a name="getstarted">Getting Started</a></h2>

<p>If you wish to help with development and/or testing, you must first
build a baseline.  In the examples below, the shell variables
``<code>$..._dir</code>'' represent the directory names of your
toplevel gcc, glibc, ld and gdb trees.  The shell variables
``<code>$..._repo</code>'' hold the names of the gcc and glibc CVS
repositories.  The values of these repository variables will depend on
whether you have write access or have readonly access through
<code>pserver/anoncvs</code> mode.  I'll assume you know enough about
CVS and about configuring and building GNU packages to adapt the
procedure below to fit your environment.

<ol>

<p><li><h3>Checkout, build and install gcc:</h3>

<pre>
$ mkdir -p $gcc_dir/BUILD
$ cd $gcc_dir
$ cvs -d $gcc_repo co -rbounded-pointers-branch -d src gcc
$ cd BUILD
$ ../src/configure --prefix=$gcc_dir
$ make LANGUAGES=c
$ make LANGUAGES=c install-gcc
</pre>

<p>For convenience, you might wish to install a symlink called
``<code>gcc-bp</code>'' in one of your bin directories that refers to
<code>$gcc_dir/bin/gcc</code>.

<p><li><h3>Checkout, build and install glibc:</h3>

<pre>
$ mkdir -p $glibc_dir/BUILD
$ cd $glibc_dir
$ cvs -d $glibc_repo co -d src libc
$ cd BUILD
$ env CC=$gcc_dir/bin/gcc ../src/configure --prefix=$glibc_dir \
	--enable-bounded --disable-profile --disable-shared
$ make
$ make install
</pre>

<p>I recommend ``<code>--disable-profile</code>'' and
``<code>--disable-shared</code>'' in order to shorten build time since
you won't need these targets.

<p><li><h3>Obtain, patch, build and install GNU ld:</h3>

I won't give detailed instructions here, because there's nothing out
of the ordinary.  Download a modern binutils release, or get the code
from CVS.

You will need a small patch to GNU ld so that it will synthesize
``<code>foo.high_bound</code>'' symbols for common & bss symbols.  <a
href="proj-bp-patch-ld.txt">Get the ld patch from here.</a> The patch
is relative to <code>binutils-2.10</code>, but will work on
<code>binutils-2.9</code> as well.

<p><li><h3>Obtain, patch, build and install gdb:</h3>

I won't give detailed instructions here, because there's nothing out
of the ordinary.  Download a modern gdb release, or get the code from
CVS.

You will need a small patch to gdb so that it won't crash starting up
on a BP-mode program.  <a href="proj-bp-patch-gdb.txt">Get the gdb
patch from here.</a> The patch is relative to <code>gdb-5.0</code>,
but will work on <code>gdb-4.18</code> as well, if you supply the
`<code>-l</code>' option to <code>patch</code> to make it more lenient
about whitespace differences.

</ol>

<p>You now have the bare essentials for working with bounded pointers.
Here are some suggestions for the next step (details will follow, so
stay tuned):

<ol>

<p><li> Run GCC's testsuite in BP mode.

<p><li> Run glibc's testsuite in BP mode.

<p><li> Build some other package with BPs and run its testsuite.

</ol>

<p><hr>

<p><address>Greg McGary,
<a href="mailto:greg@mcgary.org">greg@mcgary.org</a>
</address>

</body>
</html>
