<html>

<head>
<title>Porting to GCC 6</title>
</head>

<body>
<h1>Porting to GCC 6</h1>

<p>
The GCC 6 release series differs from previous GCC releases in
<a href="changes.html">a number of ways</a>. Some of
these are a result of bug fixing, and some old behaviors have been
intentionally changed in order to support new standards, or relaxed
in standards-conforming ways to facilitate compilation or run-time
performance.  Some of these changes are not visible to the naked eye
and will not cause problems when updating from older versions.
</p>

<p>
However, some of these changes are visible, and can cause grief to
users porting to GCC 6. This document is an effort to identify major
issues and provide clear solutions in a quick and easily searched
manner. Additions and suggestions for improvement are welcome.
</p>


<h2>Preprocessor issues</h2>


<h2>C language issues</h2>


<h2>C++ language issues</h2>

<h3>Default standard is now GNU++14</h3>

<p>
GCC 6 defaults to <code>-std=gnu++14</code> instead of <code>-std=gnu++98</code>:
the C++14 standard, plus GNU extensions.
This brings several changes that users should be aware of, some new with the C++14
standard, others that appeared with the C++11 standard.  The following
paragraphs describe some of these changes and suggest how to deal with them.
</p>

<p>Some users might prefer to stay with gnu++98, in which case we suggest to
use the <code>-std=gnu++98</code> command-line option, perhaps by putting it
in <code>CXXFLAGS</code> or similar variables in Makefiles.</p>

<p>Alternatively, you might prefer to update to gnu++11, bringing in the C++11
changes but not the C++14 ones.  If so, use the <code>-std=gnu++11</code>
command-line option.</p>

<h4>Narrowing conversions</h4>

<p>
The C++11 standard does not allow "narrowing conversions" inside braced
initialization lists, meaning conversions to a type with less precision or
a smaller range, for example:
</p>
<pre><code>
    int i = 127;
    char s[] = { i, 256 };
</code></pre>

<p>
In the above example the value 127 would fit in <code>char</code> but
because it's not a constant it is still a narrowing conversion. If the value
256 is larger than <code>CHAR_MAX</code> then that is also a narrowing
conversion. Narrowing conversions can be avoided by using an explicit cast,
e.g. <code>(char)i</code>.
</p>

<h4>Invalid literal suffixes</h4>

<p>
The C++11 "user-defined literals" feature allows custom suffixes to be added
to literals, so that for example <code>"Hello, world!"s</code> creates a
<code>std::string</code> object. This means that code relying on string
concatenation of string literals and macros might fail to compile, for
example using <code>printf("%"PRIu64, uint64_value)</code> is not valid in
C++11, because <code>PRIu64</code> is parsed as a literal suffix. To fix
the code to compile in C++11 add whitespace between the string literal and the
macro: <code>printf("%" PRIu64, uint64_value)</code>.
</p>

<h4>Cannot convert 'bool' to 'T*'</h4>

<p>
The current C++ standard only allows integer literals to be used as null
pointer constants, so other constants such as <code>false</code> and
<code>(1 - 1)</code> cannot be used where a null pointer is desired. Code that
fails to compile with this error should be changed to use <code>nullptr</code>,
or <code>0</code>, or <code>NULL</code>.
</p>

<h4>Cannot convert 'std::ostream' to 'bool'</h4>

<p>
As of C++11, iostream classes are no longer implicitly convertible to
<code>void*</code> so it is no longer valid to do something like:
</p>
<pre><code>
  bool valid(std::ostream&amp; os) { return os; }
</code></pre>

<p>
Such code must be changed to convert the iostream object to <code>bool</code>
explicitly, e.g. <code>return (bool)os;</code>
or
<code>return static_cast&lt;bool&gt;(os);</code>
</p>

<h4>Lvalue required as left operand of assignment with complex numbers</h4>

<p>
Since C++11 (as per DR#387) the member functions <code>real()</code> and 
<code>imag()</code> of <code>std::complex</code> can no longer be used as
lvalues, thus the following code is rejected:
</p>
<pre><code>
  std::complex&lt;double&gt; f;
  f.real () = val;
</code></pre>

<p>
To assign <code>val</code> to the real component of <code>f</code>, the
following should be used instead:
</p>
<pre><code>
  std::complex&lt;double&gt; f;
  f.real (val);
</code></pre>

<h4>Destructors are <code>noexcept</code> by default</h4>

<p>
As of C++11, destructors have an implicit <code>noexcept</code>
exception-specification (unless a base class or non-static member variable has
a destructor that is <code>noexcept(false)</code>).  In practice this means that
the following program behaves differently in C++11 than in C++03:
</p>
<pre><code>
  #include &lt;stdexcept&gt;
  struct S
  {
    ~S() { throw std::runtime_error ("oops"); }
  };
  int
  main (void)
  {
    try { S s; }
    catch (...) {
      return 42;
    }
  }
</code></pre>

<p>
While in C++03 this program returns 42, in C++11 it terminates with a call to
<code>std::terminate</code>.  By default GCC will now issue a warning for
throw-expressions in <code>noexcept</code> functions, including destructors,
that would immediately result in a call to terminate.  The new warning can be
disabled with <tt>-Wno-terminate</tt>.  It is possible to restore the old
behavior when defining the destructor like this:
</p>
<pre><code>
    ~S() noexcept(false) { throw std::runtime_error ("oops"); }
</code></pre>

<h3>Header dependency changes</h3>

<p>
The <code>&lt;algorithm&gt;</code> header has been changed to reduce the
number of other headers it includes in C++11 mode or above.
As such, C++ programs that used components defined in
<code>&lt;random&gt;</code>, <code>&lt;vector&gt;</code>, or
<code>&lt;memory&gt;</code> without explicitly including the right headers
will no longer compile.
</p>

<h3>Header <code>&lt;cmath&gt;</code> changes</h3>

<p>
Some C libraries declare obsolete <code>int isinf(double)</code> or
<code>int isnan(double)</code> functions in the <code>&lt;math.h&gt;</code>
header. These functions conflict with standard C++ functions with the same
name but a different return type (the C++ functions return <code>bool</code>).
When the obsolete functions are declared by the C library the C++ library
will use them and import them into namespace <code>std</code>
instead of defining the correct signatures.
</p>

<h3>Header <code>&lt;math.h&gt;</code> changes</h3>

<p>
The C++ library now provides its own <code>&lt;math.h&gt;</code> header that
wraps the C library header of the same name. The C++ header defines
additional overloads of some functions and ensures that all standard
functions are defined as real functions and not as macros.
Code which assumes that <code>sin</code>, <code>cos</code>, <code>pow</code>,
<code>isfinite</code> etc. are macros may no longer compile.
</p>

<h3>Header <code>&lt;stdlib.h&gt;</code> changes</h3>

<p>
The C++ library now provides its own <code>&lt;stdlib.h&gt;</code> header that
wraps the C library header of the same name. The C++ header defines
additional overloads of some functions and ensures that all standard
functions are defined as real functions and not as macros.
Code which assumes that <code>abs</code>, <code>malloc</code> etc.
are macros may no longer compile.
</p>

<p>
Programs which provide their own wrappers for <code>&lt;stdlib.h&gt;</code>
or other standard headers are operating outside the standard and so are
responsible for ensuring their headers work correctly with the headers in
the C++ standard library.
</p>

<h4>Call of overloaded 'abs(unsigned int&)' is ambiguous</h4>

<p>
The additional overloads can cause the compiler to reject invalid code that
was accepted before.  An example of such code is the below:
</p>

<pre><code>
#include &lt;stdlib.h&gt;
int
foo (unsigned x)
{
  return abs (x);
}
</code></pre>

<p>
Since calling <code>abs()</code> on an unsigned value doesn't make sense,
this code will become explicitly invalid as per discussion in the LWG.
</p>

<h3>Optimizations remove null pointer checks for <code>this</code></h3>

<p>
When optimizing, GCC now assumes the <code>this</code> pointer can never be
null, which is guaranteed by the language rules. Invalid programs which 
assume it is OK to invoke a member function through a null pointer (possibly
relying on checks like <code>this != NULL</code>) may crash or otherwise fail
at run-time if null pointer checks are optimized away.
With the <code>-Wnull-dereference</code> option the compiler tries to warn
when it detects such invalid code.
</p>

<p>
If the program cannot be fixed to remove the undefined behaviour then the
option <code>-fno-delete-null-pointer-checks</code> can be used to disable
this optimization. That option also disables other optimizations involving
pointers, not only those involving <code>this</code>.
</p>

<h3>Deprecation of <code>std::auto_ptr</code></h3>

<p>
The <code>std::auto_ptr</code> class template was deprecated in C++11, so GCC
now warns about its usage.  This warning can be suppressed with the
<tt>-Wno-deprecated-declarations</tt> command-line option, though we advise
to port the code to use C++11's <code>std::unique_ptr</code> instead.
</p>

<h2>-Wmisleading-indentation</h2>
<p>
A new warning <code>-Wmisleading-indentation</code> was added
to <code>-Wall</code>, warning about places where the indentation of
the code might mislead a human reader about the control flow:
</p>

<blockquote><pre>
<b>sslKeyExchange.c:</b> In function <b>'SSLVerifySignedServerKeyExchange'</b>:
<b>sslKeyExchange.c:631:8:</b> <span class="boldmagenta">warning:</span> statement is indented as if it were guarded by... [<span class="boldmagenta">-Wmisleading-indentation</span>]
        <span class="boldmagenta">goto</span> fail;
        <span class="boldmagenta">^~~~</span>
<b>sslKeyExchange.c:629:4:</b> <span class="boldcyan">note:</span> ...this 'if' clause, but it is not
    <span class="boldcyan">if</span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
    <span class="boldcyan">^~</span>
</pre></blockquote>

<p>
This has highlighted genuine bugs, often due to missing braces, but it
sometimes reports warnings for poorly-indented files, or on projects
with unusual indentation.  This may cause build errors if you
have <code>-Wall -Werror</code> in your project.
</p>

<p>
The best fix is usually to fix the indentation of the code to match
the block structure, or to fix the block structure by adding missing
braces.  If changing the source is not practical or desirable (e.g. for
autogenerated code, or to avoid churn in the source history), the
warning can be disabled by adding <code>-Wno-misleading-indentation</code>
to the build flags.  Alternatively, you can disable it for just one part of
a source file or function using pragmas:
</p>

<pre><code>
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmisleading-indentation"

/* (code for which the warning is to be disabled)  */

#pragma GCC diagnostic pop
</code></pre>

<p>
Source files with mixed tabs and spaces that don't use 8-space tabs
may lead to warnings.  A real-world example was for such a source file, which
contained an Emacs directive to view tabs to be 4 spaces wide:
</p>

<blockquote><pre>
  /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
</pre></blockquote>

<p>
The mixture of tabs and spaces did correctly reflect the block
structure when viewed in Emacs, but not in other editors, or in an
HTML view of the source repository.
By default, <code>-Wmisleading-indentation</code> assumes tabs to
be 8 spaces wide.  It would have been possible to avoid this warning
by adding <code>-ftabstop=4</code> to the build flags for this file,
but given that the code was confusing when viewed in other editors,
the indentation of the source was fixed instead.
</p>

<h2>Enhanced <code>-Wnonnull</code></h2>
<p>
The <code>-Wnonnull</code> warning has been improved so that it also warns
about comparing parameters declared as nonnull with <code>NULL</code>.  For
example, the compiler will warn about the following code:
</p>

<pre><code>
__attribute__((nonnull)) void
foo (void *p)
{
  if (p == NULL)
    abort ();
  // ...
}
</code></pre>

<h3>Links</h3>

</body>
</html>
