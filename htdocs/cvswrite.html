<html>

<head>
<title>Read-write CVS access</title>
</head>

<body>

<h1 align="center">Read-write CVS access</h1>

<p>We have read/write access to the CVS repository available for all our
significant developers. Maintainers are also encouraged to edit the
<a href="gnatswrite.html">GNATS database</a>.</p>

<hr>
<h3>Contents</h3>
<ol>
  <li><a href="#authenticated">Authenticated access</a>
  <li><a href="#setup">Setting up your local CVS tree</a>
  <li><a href="#policies">Write access policies</a>
  <li><a href="#checkin">Checking in a change</a>
  <li><a href="#example">Example check-in session</a>
</ol>

<hr>
<h2><a name="authenticated">Authenticated access</a></h2>

<p>Authenticated access is provided via ssh, which you can retrieve from
<a href="ftp://ftp.cs.hut.fi/pub/ssh/">ftp://ftp.cs.hut.fi/pub/ssh/</a>.
ssh should build and install without any trouble and the default
configuration files should be suitable for access to our CVS server.</p>

<p>You will need to provide us with your public key.  You can generate one
via the "ssh-keygen" program.  This will store your public key in to the
file .ssh/identity.pub in your home directory.  We need the entire contents
of that file.  You should mail it directly to <a href="mailto:law@cygnus.com">
law@cygnus.com</a>.  Yes, we realize it's a public key, but there's no sense
 in cluttering up the developers list with keys.</p>

<p>Once we have this information we will set up an account on
gcc.gnu.org and inform you by mail.  At this point you should be
able to check out a tree with CVS and add yourself to the MAINTAINERS
file to test write access.  See <a href="#checkin">Checking in a change</a>
for how to proceed with checking in your changes.</p>

<hr>
<h2><a name="setup">Setting up your local CVS tree</a></h2>

<p>Once you can login to the machine, it's trivial to start using ssh from
your remote machine.  Set CVS_RSH in your environment to "ssh".  Then issue
the command

<blockquote><code>
cvs -z 9 -d :ext:username@gcc.gnu.org:/cvs/gcc co gcc
</code></blockquote>

where <code>username</code> is your user name at gcc.gnu.org.
This will check out a new CVS tree that you should be able to work with
in the normal fashion, including committing changes.


<p>It is also possible to convert an existing CVS tree to use ssh by replacing
all the "Root" files in the local tree with the following contents:</p>

<blockquote><code>
username@gcc.gnu.org:/cvs/gcc
</code></blockquote>


<p>To avoid the nuisance of having to supply your passphrase for each
operation, you may want to use <code>ssh-agent</code>(1) followed by
<code>ssh-add</code>(1) and entering your passphrase once for all.
Either start your session as a child of <code>ssh-agent</code> or run
it as a demon and set the values of the environment variables
<code>SSH_AUTHENTICATION_SOCKET</code> and <code>SSH_AGENT_PID</code>
in each relevant process to what <code>ssh-agent</code> prints when it
starts.  To avoid messages about (lack of) X11 forwarding, put in your
<samp>$HOME/.ssh/config</samp> and entry like:
<blockquote><code>
Host gcc.gnu.org<br>
ForwardX11 no
</code></blockquote>

<h2>Web pages</h2>

<p>Note that when you check in changes to our web pages, these will
automatically be checked out into the web server's data area.</p>

<hr>
<h2><a name="policies">Write access policies</a></h2>

<p>The GCC project grants some developers various levels of write access
to the GCC master sources.  CVS doesn't provide fine grained control over
access to the repository; therefore, we depend on each developer to follow
the appropriate policies.</p>

<ul>
  <li>Global write permission.  A very limited number of developers have
  global write permission over the entire repostiory.  This is unfortunately
  necessary because we don't have explicit maintainers for every little
  piece of the compiler.

  <li>Localized write permission.  This is for people who own ports, front
  ends, or significant hunks of code in the compiler.  These folks are
  allowed to make changes in code they maintain without going through any
  kind of approval process.

  <li>Write after approval.  This is folks that make regular contributions,
  but who do not "own" any particular piece of code.  People with write after
  approval need to submit their patches to the list; once the patches have
  been approved by the appropriate maintainers the patches may be checked into
  the GCC sources.
</ul>

<p>The list of folks with write access to the repository can be found in the
<tt>MAINTAINERS</tt> file in the GCC distribution.</p>

<p>Also note that fixes for obvious typos in ChangeLog files, docs, web
pages, comments and similar stuff need not be approved.  Just check in the
fix.  We don't want to get overly anal about checkin policies.</p>

<p>When you have checked in a patch exactly as it has been approved, you
do not no need to tell that to people -- including the approver.  People
interested in when a particular patch is committed can check CVS or the <a
href="http://gcc.gnu.org/ml/gcc-cvs/">gcc-cvs</a> list.</p>

<p>Maintainers are free to import files maintained outside
the tree from their official versions without explicit write approval.   
Such files would include <code>config.guess</code> and 
<code>config.sub</code>.</p>

<hr>
<h2><a name="checkin">Checking in a change</a></h2>

<p>It is expected that before you check in any change you will do the
following:
<ul>
<li>If your change is to code that is not in a front-end, or is to the
    C front-end, verify that the compiler bootstraps with your change.
    You must bootstrap all languages, not just C.  You must bootstrap
    with exactly the change that you intended to check in; it's not
    good enough to have bootstrapped with an earlier variant.  (Unless
    the only changes from the earlier variant are formatting and
    comment changes; if there are <strong>any</strong> changes to the code
    itself you should re-bootstrap.)

<li>If your change is to code that is not in a front-end, or is to   
    the C front-end, verify that the all of the GCC regression tests
    behave identically before and after your patch.   You can do a
    <code>make -k check</code> at the top of the tree to run all of the
    tests.

<li>If your change is to code that is in a front-end, other than the C
    front-end, you need to verify only that the tests for that
    language have not regressed.  You need not bootstrap, or test
    other languages, since there is no way you could have affected
    them.  If there is a run-time library written in the language
    compiled by your front-end, you should, however, verify that it
    continues to build.

<li>When you post your change to <code>gcc-patches</code>, indicate
    what platform you have used for testing.
</ul>

<p>These rules are designed to ensure that checked-in code does not
contain bugs that prevent other people from continuing to get their
work done.  There will always be bugs, but these rules help to
minimize the amount of time where the tree does not build at
all. Repeated failure to adhere to these rules could result in the
revocation of check-in privileges by the Steering Committee.</p>

<p>This is meant to provide a very quick overview of how to check in a
change.  It is not meant to be a replacement for the CVS manual but 
instead a supplement.  The CVS manual is distributed as part of the CVS
sources as a texinfo file.
<a href="http://www.cyclic.com/cvs/doc-blandy.html"> 
http://www.cyclic.com/cvs/doc-blandy.html</a> contains
a link to an reasonably simple introduction to CVS.</p>

<p> In all the commands listed below, you can give an explicit list of
filenames to the cvs command.  We recommend you list files explicitly
when performing checkins to avoid accidental checkins of local code.</p>

<p> Sync your sources with the master repository via "<tt>cvs update</tt>"
before attempting a checkin; this will save you a little time if someone
else has modified that file since the last time you sync'd your sources.
It will also identify any files in your local tree that you have modified.
</p>

<p>Apply the patch to your local tree and update the <tt>ChangeLog</tt>
file.  Use the current date/time for the <tt>ChangeLog</tt> entry, not
the time that the patch was submitted.</p>

<p>Make sure to rebuild any generated files that would be effected by
the patch.  Make sure to check them in along with the files explicitly
modified by the patch.

<p>We recommend using "<tt>cvs diff</tt>" after applying a patch to
a local tree.  Review the output to make sure that only the changes
you wanted to check in will be checked in.  Also check to see if the
copyright dates need to be updated.

<p>Use "<tt>cvs commit</tt>" to check in the patch.  You can enter the
log message via the "<tt>-m</tt>" argument to commit, or wait for the
editor window to appear and enter the log message in the editor window.

<p>After exiting the editor, CVS will connect to the GCC cvs server and
check in your changes.  When your prompt returns the checkin is finished.
A message will be sent to the "<tt>gcc-cvs</tt>" mailing list (when
set up) indicating that a change was made.  CVS will provide a message
if an error occurs and it will not check in any files.

<hr>
<h2><a name="example">Example check-in session</a></h2>

<p>Here's an actual check-in session for a patch John Carr recently sent
to the GCC list.  This was the <tt>ChangeLog</tt> for his change:

<blockquote>
<pre>
Sun Feb  8 08:02:13 1998  John Carr  &lt;jfc@mit.edu>

   * bitmap.c (bitmap_debug_file): HOST_PTR_PRINTF converts a pointer,
   not a HOST_WIDE_INT.

   * calls.c (expand_call): Change test of expand_inline_function
   return value to stop compiler warning.

   * genattrtab.c (RTL_HASH): Cast pointer to long, not HOST_WIDE_INT.
</pre>
</blockquote>

<h3>First, I sync my local respository.</h3>

<blockquote>
<pre>
[/law/gcc] cvs update
? libobjc
? gcc/.ada
? gcc/jump.c.SAVE
? gcc/loop.c.SAVE
M MAINTAINERS
M Makefile.in
M gcc/loop.c
M gcc/cp/parse.c
M gcc/objc/Make-lang.in
M gcc/objc/Makefile.in
</pre>
</blockquote>

<p>The question marks indicate files in my local repository that are not
part of the official sources.  The "M" indicates files I've changed locally
for some unrelated work -- thus I have to be careful to avoid checking
them in.  A "U" would have indicated a file that CVS updated because my
local copy was out of date relative to the master sources.

<p>The local repository is now up to date.

<h3>Apply the patch to the local source</h3>

<blockquote>
<pre>
[/law/gcc/gcc] patch &lt; ~/Mail/gcc/pendingpatches/42 
Hmm...  Looks like a new-style context diff to me...
The text leading up to this was:
<i>[ uninteresting text deleted ]</i>
|*** bitmap.c.egcs      Sat Dec 20 06:31:11 1997
|--- bitmap.c   Sun Feb  8 08:01:32 1998
--------------------------
Patching file bitmap.c using Plan A...
Hunk #1 succeeded at 563.
Hunk #2 succeeded at 573.
Hmm...  The next patch looks like a new-style context diff to me...
The text leading up to this was:
--------------------------
|*** calls.c.egcs       Sun Feb  8 07:44:02 1998
|--- calls.c    Sun Feb  8 08:00:08 1998
--------------------------
Patching file calls.c using Plan A...
Hunk #1 succeeded at 730.
Hmm...  The next patch looks like a new-style context diff to me...
The text leading up to this was:
--------------------------
|*** genattrtab.c.egcs  Sun Feb  8 07:44:04 1998
|--- genattrtab.c       Sun Feb  8 08:05:36 1998
--------------------------
Patching file genattrtab.c using Plan A...
Hunk #1 succeeded at 506.
done
</pre>
</blockquote>

<h3>Add ChangeLog entry by hand</h3>

<p><tt>ChangeLog</tt> entries should be handled as straight text;
patches against <tt>ChangeLog</tt>s rarely apply correctly.

<blockquote>
<pre>
[/law/gcc/gcc] vi ChangeLog
</pre>
</blockquote>

<h3>Review changes for correctness</h3>

<p>The patch and its associated <tt>ChangeLog</tt> entry are in my
local tree; now I run <tt>cvs diff</tt> on the modified files and review
the output.

<blockquote>
<pre>
[/law/gcc/gcc] cvs diff -c3p bitmap.c calls.c genattrtab.c > /tmp/FOO
</pre>
</blockquote>

<p>Look at <tt>/tmp/FOO</tt> and verify that only the changes we want
are in the diff file.

<h3>Update Copyrights</h3>

<p>Review the changed files to see if any copyrights need updating,
in this particular case all three needed their copyrights updated.

<blockquote>
<pre>
[/law/gcc/gcc] vi bitmap.c calls.c genattrtab.c
</pre>
</blockquote>

<h3>Commit the changes to the central repository</h3>

<blockquote>
<pre>
[/law/gcc/gcc] cvs commit ChangeLog bitmap.c calls.c genattrtab.c
</pre>
</blockquote>

<p>My editor starts and I enter the log message; the lines starting with
<TT>CVS:</TT> are automatically added by CVS and will be automatically
removed:

<blockquote>
<pre>
        * bitmap.c (bitmap_debug_file): HOST_PTR_PRINTF converts a pointer,
        not a HOST_WIDE_INT.

        * calls.c (expand_call): Change test of expand_inline_function
        return value to stop compiler warning.

        * genattrtab.c (RTL_HASH): Cast pointer to long, not HOST_WIDE_INT.

CVS: ----------------------------------------------------------------------
CVS: Enter Log.  Lines beginning with `CVS:' are removed automatically
CVS:
CVS: Committing in .
CVS:
CVS: Modified Files:
CVS:    ChangeLog bitmap.c calls.c genattrtab.c
CVS: ----------------------------------------------------------------------
</pre>
</blockquote>

<p>Now write &amp; quit from the editor, and CVS will start the actual
checkin process....

<blockquote>
<pre>
Checking in ChangeLog;
/cvs/gcc/./gcc/ChangeLog,v  &lt;--  ChangeLog
new revision: 1.746; previous revision: 1.745
done
Checking in bitmap.c;
/cvs/gcc/./gcc/bitmap.c,v  &lt;--  bitmap.c
new revision: 1.6; previous revision: 1.5
done
Checking in calls.c;
/cvs/gcc/./gcc/calls.c,v  &lt;--  calls.c
new revision: 1.12; previous revision: 1.11
done
Checking in genattrtab.c;
/cvs/gcc/./gcc/genattrtab.c,v  &lt;--  genattrtab.c
new revision: 1.15; previous revision: 1.14
done
[/law/gcc/gcc] 
</pre>
</blockquote>

<p>Note that only a single CVS log message was used for all the files;
this is the normal and expected behavior.  It is not necessary to perform
multiple commits and split up the CVS log entry on a file by file basis.
Note this implies that each checkin is for a single logical change
that may effect multiple files.  If you have several unrelated changes,
you should check them in with separate cvs commit commands.</p>

<p>And that's it!</p>

</body>
</html>
