<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Porting to GCC 13</title>
<link rel="stylesheet" type="text/css" href="https://gcc.gnu.org/gcc.css">
</head>

<body>
<h1>Porting to GCC 13</h1>

<p>
The GCC 13 release series differs from previous GCC releases in
<a href="changes.html">a number of ways</a>. Some of these are a result
of bug fixing, and some old behaviors have been intentionally changed
to support new standards, or relaxed in standards-conforming ways to
facilitate compilation or run-time performance.
</p>

<p>
Some of these changes are user visible and can cause grief when
porting to GCC 13. This document is an effort to identify common issues
and provide solutions. Let us know if you have suggestions for improvements!
</p>

<h2 id="cxx">C++ language issues</h2>

<h3 id="header-dep-changes">Header dependency changes</h3>
<p>Some C++ Standard Library headers have been changed to no longer include
other headers that were being used internally by the library.
As such, C++ programs that used standard library components without
including the right headers will no longer compile.
</p>
<p>
The following headers are used less widely in libstdc++ and may need to
be included explicitly when compiling with GCC 13:
</p>
<ul>
<li> <code>&lt;string&gt;</code>
  (for <code>std::string</code>, <code>std::to_string</code>,
  <code>std::stoi</code> etc.)
</li>
<li> <code>&lt;system_error&gt;</code>
  (for <code>std::error_code</code>, <code>std::error_category</code>,
  <code>std::system_error</code>).
</li>
<li> <code>&lt;cstdint&gt;</code>
  (for <code>std::int8_t</code>, <code>std::int32_t</code> etc.)
</li>
<li> <code>&lt;cstdio&gt;</code>
  (for <code>std::printf</code>, <code>std::fopen</code> etc.)
</li>
<li> <code>&lt;cstdlib&gt;</code>
  (for <code>std::strtol</code>, <code>std::malloc</code> etc.)
</li>
</ul>

<h3 id="P2266">Implicit move rules change</h3>
<p>
GCC 13 implements C++23 <a href="https://wg21.link/p2266">P2266</a> which
simplified the rules for implicit move.  As a consequence, valid C++20
code that relies on a returned <em>id-expression</em>'s being an lvalue
may change behavior or fail to compile in C++23.  For example:</p>

<pre><code>
   decltype(auto) f(int&& x) { return (x); }  // returns int&&; previously returned int&
   int& g(int&& x) { return x; }  // ill-formed; previously well-formed
</code></pre>

<h3 id="two-stage-or">Two-stage overload resolution for implicit move removed</h3>
<p>GCC 13 removed the two-stage overload resolution when performing
implicit move, whereby the compiler does two separate overload resolutions:
one treating the operand as an rvalue, and then (if that resolution fails)
another one treating the operand as an lvalue.  In the standard this was
introduced in C++11 and implemented in gcc in
<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=4ce8c5dea53d80736b9c0ba6faa7430ed65ed365">
r251035</a>.  In
<a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=1722e2013f05f1f1f99379dbaa0c0df356da731f">
r11-2412</a>, the fallback overload resolution was disabled in C++20 (but
not in C++17).  Then C++23 <a href="https://wg21.link/p2266">P2266</a>
removed the fallback overload resolution, and changed the implicit move
rules once again.</p>

<p>The two overload resolutions approach was complicated and quirky, so users
should transition to the newer model.  This change means that code that
previously didn't compile in C++17 will now compile, for example:</p>

<pre><code>
   struct S1 { S1(S1 &&); };
   struct S2 : S1 {};

   S1
   f (S2 s)
   {
     return s; // OK, derived-to-base, use S1::S1(S1&&)
   }
</code></pre>

<p>Conversely, code that used to work in C++17 may not compile anymore.
For example, the following example used to compile in C++11...17 because
we performed two separate overload resolutions: one treating the operand
as an rvalue, and then (if that resolution failed) another one treating
the operand as an lvalue.<br>

<pre><code>
   struct W {
     W();
   };

   struct F {
     F(W&);
     F(W&&) = delete;
   };

   F fn ()
   {
     W w;
     return w; // use w as rvalue -> use of deleted function F::F(W&&)
   }
</code></pre>

</body>
</html>
