<html>

<head>
<title>GCC 4.7 Release Series &mdash; Changes, New Features, and Fixes</title>
</head>

<!-- GCC maintainers, please do not hesitate to update/contribute entries
     concerning those part of GCC you maintain!  2002-03-23, Gerald.
-->

<body>
<h1>GCC 4.7 Release Series<br />Changes, New Features, and Fixes</h1>

<h2>Caveats</h2>

  <ul>
    <li><p>Support for a number of older systems and recently
    unmaintained or untested target ports of GCC has been declared
    obsolete in GCC 4.7.  Unless there is activity to revive them, the
    next release of GCC will have their sources permanently
    <strong>removed</strong>.</p>

    <p id="obsoleted">The following ports for individual systems on
    particular architectures have been obsoleted:</p>

    <ul>
	  <li>IRIX 6.5 (mips-sgi-irix6.5)</li>
	  <li>MIPS OpenBSD (mips*-*-openbsd*)</li>
	  <li>Solaris 8 (*-*-solaris2.8).  Details can be found in the
	  <a href="http://gcc.gnu.org/ml/gcc-patches/2011-03/msg01263.html">
	      announcement</a>.</li>
	  <li>Tru64 UNIX V5.1 (alpha*-dec-osf5.1*)</li>
    </ul>

    </li>

    <li>Support has been removed for Unix International threads on Solaris
    2, so the <code>--enable-threads=solaris</code> configure option and
    the <code>-threads</code> compiler option don't work any longer.</li>
    <li>Support has been removed for the Solaris BSD Compatibility Package,
    which lives in <code>/usr/ucbinclude</code> and
    <code>/usr/ucblib</code>.  It has been removed from Solaris 11, and was
    only intended as a migration aid from SunOS 4 to SunOS 5.  The
    <code>-compat-bsd</code> compiler option is not recognized any
    longer.</li>

    <li>The ARM port's <code>-mwords-little-endian</code> option has
    been deprecated.  It will be removed in a future release.</li>

    <li>Support has been removed for the NetWare x86 configuration
    obsoleted in GCC 4.6.</li>
  </ul>

<h2>General Optimizer Improvements</h2>

  <ul>
    <li>Support for a new parameter <code>--param case-values-threshold=n</code>
    was added to allow users to control the cutoff between doing switch statements
    as a series of if statements and using a jump table.
    </li>

    <li>Link-time optimization (LTO) improvements:
    <ul>
      <li>Improved scalability and reduced memory usage.  Link time
      optimization of Firefox now requires 3GB of RAM on a 64-bit system,
      while over 8GB was needed previously. Linking time has been improved,
      too. The serial stage of linking Firefox has been sped up by about a
      factor of 10.</li>
      <li>Reduced size of object files and temporary storage used during linking.</li>
      <li>Streaming performance (both outbound and inbound) has been improved.</li>
      <li><code>ld -r</code> is now supported with LTO.</li>
      <li>Several bug fixes, especially in symbol table handling and merging.</li>
    </ul></li>

    <li>Interprocedural optimization improvements:
    <ul>
      <li>Heuristics now take into account that after inlining code will
      be optimized out because of known values (or properties) of function
      parameters.
      For example:
      <pre>
void foo(int a)
{
  if (a&gt;10)
    ... huge code ...
}
void bar (void)
{
  foo (0);
}
      </pre>
      The call of <code>foo</code> will be inlined into <code>bar</code> even when
      optimizing for code size. Constructs based on <code>__builtin_constant_p</code>
      are now understood by the inliner and code size estimates are evaluated a lot
      more realistically.</li>
      <li>The representation of C++ virtual thunks and aliases (both implicit and defined
      via the <code>alias</code> attribute) has been re-engineered. Aliases no
      longer pose optimization barriers and calls to an alias can be inlined
      and otherwise optimized.</li>
      <li>The inter-procedural constant propagation pass has been rewritten.
      It now performs generic function specialization.  For example when
      compiling the following:
      <pre>
void foo(bool flag)
{
  if (flag)
    ... do something ...
  else
    ... do something else ...
}
void bar (void)
{
  foo (false);
  foo (true);
  foo (false);
  foo (true);
  foo (false);
  foo (true);
}
      </pre>
      GCC will now produce two copies of <code>foo</code>. One with <code>flag</code> being
      <code>true</code>, while other with <code>flag</code> being
      <code>false</code>.  This leads to performance improvements previously
      possibly only by inlining all calls.  Cloning causes a lot less code size
      growth.</li>
    </ul></li>

    <li>A string length optimization pass has been added.  It attempts
      to track string lengths and optimize various standard C string functions
      like <code>strlen</code>, <code>strchr</code>, <code>strcpy</code>,
      <code>strcat</code>, <code>stpcpy</code> and their
      <code>_FORTIFY_SOURCE</code> counterparts into faster alternatives.
      This pass is enabled by default at <code>-O2</code> or above, unless
      optimizing for size, and can be disabled by the
      <code>-fno-optimize-strlen</code> option.  The pass can e.g. optimize
      <pre>
char *bar (const char *a)
{
  size_t l = strlen (a) + 2;
  char *p = malloc (l); if (p == NULL) return p;
  strcpy (p, a); strcat (p, "/"); return p;
}
      </pre>
      into:
      <pre>
char *bar (const char *a)
{
  size_t tmp = strlen (a);
  char *p = malloc (tmp + 2); if (p == NULL) return p;
  memcpy (p, a, tmp); memcpy (p + tmp, "/", 2); return p;
}
      </pre>
      or for hosted compilations where <code>stpcpy</code> is available in the
      runtime and headers provide its prototype, e.g.
      <pre>
void foo (char *a, const char *b, const char *c, const char *d)
{
  strcpy (a, b); strcat (a, c); strcat (a, d);
}
      </pre>
      can be optimized into:
      <pre>
void foo (char *a, const char *b, const char *c, const char *d)
{
  strcpy (stpcpy (stpcpy (a, b), c), d);
}
      </pre>
    </li>
  </ul>

<h2>New Languages and Language specific improvements</h2>

  <ul>
    <li>Version 3.1 of the <a
    href="http://openmp.org/wp/openmp-specifications/">OpenMP specification</a>
    is now supported for the C, C++, and Fortran compilers.</li>
  </ul>

<h3>Ada</h3>

  <ul>
    <li>The command-line option <code>-feliminate-unused-debug-types</code>
      has been re-enabled by default, as it is for the other languages,
      leading to a reduction in debug info size of 12.5% and more for
      relevant cases, as well as to a small compilation speedup.</li>
  </ul>

<h3>C family</h3>

<ul>
  <li>A new built-in, <code>__builtin_assume_aligned</code>, has been added,
      through which the compiler can be hinted about pointer alignment
      and can use it to improve generated code.
  </li>
</ul>

<h3>C++</h3>

<ul>
  <li>G++ now correctly implements the two-phase lookup rules such that an
  unqualified name used in a template must have an appropriate declaration
  found either in scope at the point of definition of the template or by
  argument-dependent lookup at the point of instantiation.  As a result,
  code that relies on a second unqualified lookup at the point of
  instantiation to find functions declared after the template or in
  dependent bases will be rejected.  The compiler will suggest ways to fix
  affected code, and using the <code>-fpermissive</code> compiler flag will
  allow the code to compile with a warning.

    <blockquote><pre>
template &lt;class T&gt;
void f() { g(T()); } // error, g(int) not found by argument-dependent lookup
void g(int) { } // fix by moving this declaration before the declaration of f

template &lt;class T&gt;
struct A: T {
  // error, B::g(B) not found by argument-dependent lookup
  void f() { g(T()); } // fix by using this-&gt;g or A::g
};

struct B { void g(B); };

int main()
{
  f&lt;int&gt;();
  A&lt;B&gt;().f();
}
</pre></blockquote></li>

  <li>G++ now accepts the <tt>-std=c++11</tt>, <tt>-std=gnu++11</tt>,
    and <tt>-Wc++11-compat</tt> options, which are equivalent
    to <tt>-std=c++0x</tt>, <tt>-std=gnu++0x</tt>,
    and <tt>-Wc++0x-compat</tt>, respectively.</li>
  
  <li>G++ now implements <a href="cxx0x_status.html">C++11</a> extended friend syntax:
    <blockquote><pre>
template&lt;class W&gt;
class Q
{
  static const int I = 2;
public:
  friend W;
};

struct B
{
  int ar[Q&lt;B&gt;::I];
};
  </pre></blockquote></li>

  <li>Thanks to Ville Voutilainen, G++ now implements <a href="cxx0x_status.html">C++11</a> explicit override control.
    <blockquote><pre>
struct B {
  virtual void f() const final;
  virtual void f(int);
};

struct D : B {
  void f() const;    // error: D::f attempts to override final B::f
  void f(long) override;     // error: doesn't override anything
  void f(int) override;      // ok
};

struct E final { };
struct F: E { }; // error: deriving from final class
  </pre></blockquote></li>

  <li>G++ now implements <a href="cxx0x_status.html">C++11</a> non-static data member initializers.
    <blockquote><pre>
struct A {
  int i = 42;
} a; // initializes a.i to 42
  </pre></blockquote></li>

  <li>Thanks to Ed Smith-Rowland, G++ now implements 
    <a href="cxx0x_status.html">C++11</a> user-defined literals.
    <blockquote><pre>
// Not actually a good approximation.  :)
constexpr long double operator"" _degrees (long double d) { return d * 0.0175; }
long double pi = 180_degrees;</pre></blockquote></li>

  <li>G++ now sets the predefined macro <code>__cplusplus</code> to the
    correct value, <code>199711L</code>.
  </li>
</ul>
  
  <h4>Runtime Library (libstdc++)</h4>

  <ul>
    <li><a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x">
       Improved experimental support for the upcoming ISO C++ standard, 
       C++0x</a>, including:
       <ul>
         <li> using <code>noexcept</code> in most of the library;</li>
         <li> partial implementations of <code>pointer_traits</code> and 
              <code>allocator_traits</code>;</li>
         <li> implementation of <code>scoped_allocator_adaptor</code>; </li>
         <li> uses-allocator construction for <code>tuple</code>; </li>
         <li> <code>vector</code> meets the allocator-aware container requirements; </li>
         <li> replacing <code>monotonic_clock</code> with <code>steady_clock</code>; </li>
         <li> many small improvements to conform to the FDIS. </li>
       </ul>
     </li>
     <li>Added <code>--enable-clocale=newlib</code> configure option. </li>
     <li>Debug Mode iterators for unordered associative containers. </li>
     <li>Avoid polluting the global namespace by inclusion of <code>&lt;unistd.h&gt;</code>.  </li>


  </ul>

<h3 id="fortran">Fortran</h3>
  <ul>
    <li>The compile flag <a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfstack_002darrays_007d-254"
      ><code>-fstack-arrays</code></a> has been added, which causes
      that all local arrays are put on stack memory. For some
      programs this will improve the performance significantly. If your
      program uses very large local arrays, it is possible that you will
      have to extend your runtime limits for stack memory.</li>
    <li>The <code><a
      href="http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-Ofast-689"
      >-Ofast</a></code> flag now also implies <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfno_002dprotect_002dparens_007d-270"
      >-fno-protect-parens</a></code> and <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfstack_002darrays_007d-254"
      >-fstack-arrays</a></code>.</li>
    <li>Front-end optimizations can now be selected by the
      <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfrontend_002doptimize_007d-275"
      >-ffrontend-optimize</a></code> option and deselected by
      the <code>-fno-frontend-optimize</code> option.</li>
    <li>When front-end optimization removes a function call,
      <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Error-and-Warning-Options.html#index-g_t_0040code_007bWfunction_002delimination_007d-170"
      >-Wfunction-elimination</a></code> warns about that.</li>
    <li>When performing front-end-optimization, the
      <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfaggressive_002dfunction_002delimination_007d-270">-faggressive-function-elimination</a></code> option
      allows the removal of duplicate function calls even for impure
      functions.</li>
    <li>The flag <code><a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Error-and-Warning-Options.html#index-g_t_0040code_007bWreal_002dq_002dconstant_007d-149"
      >-Wreal-q-constant</a></code> has been added, which
      warns if floating-point literals have been specified using
      <code>q</code> (such as <code>1.0q0</code>); the <code>q</code>
      marker is now supported a vendor extension to denote quad precision
      (<code>REAL(16)</code> or, if not available, <code>REAL(10)</code>).
      Consider using a kind parameter (such as in <code>1.0_qp</code>)
      instead, which can be obtained via <a
      href="http://gcc.gnu.org/onlinedocs/gfortran/SELECTED_005fREAL_005fKIND.html"
      ><code>SELECTED_REAL_KIND</code></a>.</li>
    <li>The <code>GFORTRAN_USE_STDERR</code> environment variable has
      been removed. GNU Fortran now always prints error messages to
      standard error. If you wish to redirect standard error, please
      consult the manual for your OS, shell, batch environment etc.
      as appropriate.</li> 
    <li>The <code>-fdump-core</code> option and
      <code>GFORTRAN_ERROR_DUMPCORE</code> environment variable have
      been removed. When encountering a serious error, gfortran will
      now always abort the program. Whether a core dump is generated
      depends on the user environment settings; see for POSIX shells
      the <code>ulimit -c</code> and for C shells the <code>limit
      coredumpsize</code> setting, and see the <a
      href="http://msdn.microsoft.com/en-us/library/bb787181%28v=vs.85%29.aspx"
      >WER user-mode dumps settings</a> on Windows.</li>
    <li>The <a
      href="http://gcc.gnu.org/onlinedocs/gfortran/Debugging-Options.html#index-g_t_0040code_007bfno_002dbacktrace_007d-183"
      ><code>-fbacktrace</code></a> option is now enabled by default.
      When encountering a serious error, gfortran will attempt to
      print a backtrace to standard error before aborting. It can be
      disabled with <code>-fno-backtrace</code>. Note: GNU Fortran does
      not support backtracing on all targets.</li>
    <li>Fortran 2008:
      <ul>
        <li>Support for the <code>DO CONCURRENT</code> construct has been
          added, which allows the user to specify that individual loop
          iterations have no interdependencies.</li>
        <li><a href="http://gcc.gnu.org/wiki/Coarray">Coarrays</a>:
          Full single-image support except for polymorphic coarrays.
          Additionally, preliminary support for multiple images via an
          MPI-based <a href="http://gcc.gnu.org/wiki/CoarrayLib">
          coarray communication library</a> has been added. Note:
          Remote coarray access is not yet possible.</li>
      </ul></li>
    <li>TS 29113:
      <ul>
        <li>New flag <code><a
          href="http://gcc.gnu.org/onlinedocs/gfortran/Fortran-Dialect-Options.html#index-g_t_0040code_007bstd_003d_007d_0040var_007bstd_007d-option-53"
          >-std=f2008ts</a></code> permits programs that are expected
          to conform to the Fortran 2008 standard and the draft Technical
          Specification (TS) 29113 on Further Interoperability of Fortran
          with C.</li>
        <li>The <code>OPTIONAL</code> attribute is now allowed
          for dummy arguments of <code>BIND(C)</code> procedures.</li> 
        <li>The <code>RANK</code> intrinsic has been added.</li>
        <li>The implementation of the <code>ASYNCHRONOUS</code> attribute
          in GCC is compatible with the candidate draft of TS 29113
	  (since GCC 4.6).</li>
      </ul></li>
  </ul>

<h3>Java (GCJ)</h3>

<h2 id="targets">New Targets and Target Specific Improvements</h2>

<h3>C6X</h3>
  <ul>
    <li>Support has been added for the Texas Instruments C6X family of
      processors.</li>
  </ul>

<h3>IA-32/x86-64</h3>
  <ul>
    <li>Support for Intel AVX2 intrinsics, built-in functions and code generation is
	available via <code>-mavx2</code>.</li>
    <li>Support for Intel BMI2 intrinsics, built-in functions and code generation is
	available via <code>-mbmi2</code>.</li>
    <li>Implementation and automatic generation of <code>__builtin_clz*</code> 
      using the <code>lzcnt</code> instruction is available via <code>-mlzcnt</code>.</li>
    <li>Support for Intel FMA3 intrinsics and code generation is available via
      <code>-mfma</code>.</li>
    <li>A new <code>-mfsgsbase</code> command-line option is available that makes GCC
    generate new segment register read/write instructions through dedicated built-ins.</li>
    <li>Support for new Intel <code>rdrnd</code> instruction is available via <code>-mrdrnd</code>.</li>
    <li>Two additional AVX vector conversion instructions are available via <code>-mf16c</code>.</li>
    <li>Support for new Intel processor codename IvyBridge with RDRND, FSGSBASE and F16C
      is available through <code>-march=core-avx-i</code>.</li>
    <li>Support for the new Intel processor codename Haswell with AVX2, FMA, BMI,
      BMI2, LZCNT is available through <code>-march=core-avx2</code>.</li>
    <li>...</li>
  </ul>

<h3>PowerPC/PowerPC64</h3>
  <ul>
    <li>Vectors of type <i>vector long long</i> or <i>vector long</i> are
       passed and returned in the same method as other vectors with the VSX
       instruction set.  Previously the GCC compiler did not adhere to the ABI
       for 128-bit vectors with 64-bit integer base types (PR 48857).
       This will also be fixed in the GCC 4.6.1 and 4.5.4 releases.</li>

     <li>A new option (<code>-mno-r11)</code> was added to allow AIX
       32-bit/64-bit and GNU/Linux 64-bit PowerPC users to specify that
       the compiler should not load up the chain register
       (<code>r11</code>) before calling a
       function through a pointer.  If you use this option, you cannot call
       nested functions through a pointer, or call other languages that might
       use the static chain.
     </li>
  </ul>

<h3>MIPS</h3>

<h3>SPARC</h3>
  <ul>
    <li>The option <code>-mflat</code> has been reinstated.  When it is
        specified, the compiler will generate code for a single register
        window model.  This is essentially a new implementation and the
        corresponding debugger support has been added to GDB 7.4.</li>
    <li>Support for the options <code>-mtune=native</code> and
        <code>-mcpu=native</code> has been added on selected native platforms
        (GNU/Linux and Solaris).</li>
    <li>Support for the Sun UltraSPARC T3 (Niagara 3) processor has been
        added.</li>
    <li>VIS:
      <ul>
        <li>An intrinsics header <code>visintrin.h</code> has been added.</li>
        <li>Builtin intrinsics for the VIS 1.0 edge handling and pixel compare
            instructions has been added.</li>
        <li>The little-endian version of <code>alignaddr</code> is now
            supported.</li>
        <li>When possible, VIS builtins are marked <code>const</code> which
            should increase the compilers ability to optimize VIS
            operations.</li>
        <li>The compiler now properly tracks the <code>%gsr</code> register,
            and how it behaves as an input for various VIS instructions.</li>
        <li>Akin to <code>fzero</code>, the compiler can now generate
            <code>fone</code> instructions in order to set all of the bits
            of a floating-point register to one.</li>
        <li>The documentation for the VIS intrinsics in the GCC manual has
            been brought up to date and many inaccuracies were fixed.</li>
        <li>Intrinsics for the VIS 2.0 bmask, bshuffle, and non-condition-code
	    setting edge instructions have been added.  Their availability
	    is controlled by the new <code>-mvis2</code> and
	    <code>-mno-vis2</code> options.  They are enabled by default
	    on UltraSPARC-III and later CPUs.</li>
      </ul>
    </li>
    <li>Support for UltraSPARC Fused Multiply-Add floating-point
        extensions has been added.  These instructions are enabled by
        default on UltraSPARC T3 (Niagara 3) and later CPUs.</li>
  </ul>

<h3 id="picochip">picochip</h3>

<h3 id="arm">ARM</h3>
    <ul>
    <li>The default vector size in auto-vectorization for NEON is now 128 bits.
      If vectorization fails thusly, the vectorizer tries again with
      64-bit vectors.</li>
    <li>A new option <code>-mvectorize-with-neon-double</code> was added to
      allow users to change the vector size to 64 bits.</li>

  </ul>

<h2>Documentation improvements</h2>

<h2>Other significant improvements</h2>

<ul>
  <li>
    A new option (<code>-grecord-gcc-switches</code>) was added that
    appends compiler command-line options that might affect code
    generation to the <code>DW_AT_producer</code> attribute string in the
    DWARF debugging information.
  </li>

  <li>
    GCC now supports various new GNU extensions to the DWARF debugging
    information format, like
    <a
    href="http://www.dwarfstd.org/ShowIssue.php?issue=100909.1">entry
    value</a> and <a
    href="http://www.dwarfstd.org/ShowIssue.php?issue=100909.2">call
    site</a> information, <a
    href="http://www.dwarfstd.org/doc/040408.1.html">typed DWARF stack</a>
    or <a
    href="http://www.dwarfstd.org/ShowIssue.php?issue=110722.1">a
    more compact macro representation</a>.  Support for these extensions
    will come in GDB 7.4. They can be disabled through the
    <code>-gstrict-dwarf</code> command-line option.
  </li>
</ul>

</body>
</html>
