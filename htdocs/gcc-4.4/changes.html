<html>

<head>
<title>GCC 4.4 Release Series &mdash; Changes, New Features, and Fixes</title>
</head>

<!-- GCC maintainers, please do not hesitate to update/contribute entries
     concerning those part of GCC you maintain!  2002-03-23, Gerald.
-->

<body>
<h1>GCC 4.4 Release Series<br />Changes, New Features, and Fixes</h1>

<h2>Caveats</h2>

  <ul>
    <li><code>__builtin_stdarg_start</code> has been completely
    removed from GCC.  Support for <code>&lt;varargs.h&gt;</code> had
    been deprecated since GCC 4.0.  Use
    <code>__builtin_va_start</code> as a replacement.  </li>

    <li>Some of the errors issued by the C++ front end that could be
    downgraded to warnings in previous releases by using
    <code>-fpermissive</code> are now warnings by default. They can be
    converted into errors by using <code>-pedantic-errors</code>.</li>

    <li>Use of the cpp assertion extension will now emit a warning
    when <code>-Wdeprecated</code> or <code>-pedantic</code> is used.
    This extension has been deprecated for many years, but never
    warned about.</li>

    <li>The MIPS port no longer recognizes the <code>h</code>
    <code>asm</code> constraint.  It was necessary to remove
    this constraint in order to avoid generating unpredictable
    code sequences.

    <p>One of the main uses of the <code>h</code> constraint
    was to extract the high part of a multiplication on
    64-bit targets.  For example:</p>
    <pre>
    asm ("dmultu\t%1,%2" : "=h" (result) : "r" (x), "r" (y));</pre>
    <p>You can now achieve the same effect using 128-bit types:</p>
    <pre>
    typedef unsigned int uint128_t __attribute__((mode(TI)));
    result = ((uint128_t) x * y) >> 64;</pre>
    <p>The second sequence is better in many ways.  For example,
    if <code>x</code> and <code>y</code> are constants, the
    compiler can perform the multiplication at compile time.
    If <code>x</code> and <code>y</code> are not constants,
    the compiler can schedule the runtime multiplication
    better than it can schedule an <code>asm</code> statement.</p>
    </li>
 </ul>

<h2>General Optimizer Improvements</h2>


<h2>New Languages and Language specific improvements</h2>

<h3>C family</h3>

<h3>C++</h3>
  <ul>
    <li><a href="cxx0x_status.html">Improved experimental support for the upcoming
    ISO C++ standard, C++0x</a>, including support for inline namespaces.</li>

    <li> Those errors that may be downgraded to warnings to build
    legacy code now mention <code>-fpermissive</code> when
    <code>-fdiagnostics-show-option</code> is enabled.</li>

  </ul>
  
  <h4>Runtime Library (libstdc++)</h4>

<h3>Fortran</h3>
  <ul>
    <li>GNU Fortran now employs libcpp directly instead of using cc1 as an
    external preprocessor. The <a
    href="http://gcc.gnu.org/onlinedocs/gfortran/Preprocessing-Options.html">
    <code>-cpp</code></a> option was added to allow manual invocation of the
    preprocessor without relying on filename extensions.</li>
  </ul>

<h3>Java (GCJ)</h3>

<h2>New Targets and Target Specific Improvements</h2>

<h3>IA-32/x86-64</h3>
  <ul>
    <li>Support for Intel AES built-in functions and code generation are
	available via <code>-maes</code>.</li>
    <li>Support for Intel PCLMUL built-in function and code generation are
	available via <code>-mpclmul</code>.</li>
  </ul>

<h3>MIPS</h3>
  <ul>
    <li>Support for RMI's XLR processor is now available through the
        <code>-march=xlr</code> and <code>-mtune=xlr</code> options.</li>
    <li>64-bit targets can now perform 128-bit multiplications inline,
        instead of relying on a <code>libgcc</code> function.</li>
  </ul>

<h2>Documentation improvements</h2>

<h2>Other significant improvements</h2>

</body>
</html>
