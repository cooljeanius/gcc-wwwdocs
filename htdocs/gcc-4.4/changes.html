<html>

<head>
<title>GCC 4.4 Release Series &mdash; Changes, New Features, and Fixes</title>
</head>

<!-- GCC maintainers, please do not hesitate to update/contribute entries
     concerning those part of GCC you maintain!  2002-03-23, Gerald.
-->

<body>
<h1>GCC 4.4 Release Series<br />Changes, New Features, and Fixes</h1>

<h2>Caveats</h2>

  <ul>
    <li><code>__builtin_stdarg_start</code> has been completely
    removed from GCC.  Support for <code>&lt;varargs.h&gt;</code> had
    been deprecated since GCC 4.0.  Use
    <code>__builtin_va_start</code> as a replacement.  </li>

    <li>Some of the errors issued by the C++ front end that could be
    downgraded to warnings in previous releases by using
    <code>-fpermissive</code> are now warnings by default. They can be
    converted into errors by using <code>-pedantic-errors</code>.</li>

    <li>Use of the cpp assertion extension will now emit a warning
    when <code>-Wdeprecated</code> or <code>-pedantic</code> is used.
    This extension has been deprecated for many years, but never
    warned about.</li>

    <li>The SCOUNT and POS bits of the MIPS DSP control register are now
    treated as global. Previous versions of GCC treated these fields as
    call-clobbered instead.</li>

    <li>The MIPS port no longer recognizes the <code>h</code>
    <code>asm</code> constraint.  It was necessary to remove
    this constraint in order to avoid generating unpredictable
    code sequences.

    <p>One of the main uses of the <code>h</code> constraint
    was to extract the high part of a multiplication on
    64-bit targets.  For example:</p>
    <pre>
    asm ("dmultu\t%1,%2" : "=h" (result) : "r" (x), "r" (y));</pre>
    <p>You can now achieve the same effect using 128-bit types:</p>
    <pre>
    typedef unsigned int uint128_t __attribute__((mode(TI)));
    result = ((uint128_t) x * y) >> 64;</pre>
    <p>The second sequence is better in many ways.  For example,
    if <code>x</code> and <code>y</code> are constants, the
    compiler can perform the multiplication at compile time.
    If <code>x</code> and <code>y</code> are not constants,
    the compiler can schedule the runtime multiplication
    better than it can schedule an <code>asm</code> statement.</p>
    </li>

    <li><p>Support for a number of older systems and recently
    unmaintained or untested target ports of GCC has been declared
    obsolete in GCC 4.4.  Unless there is activity to revive them, the
    next release of GCC will have their sources permanently
    <strong>removed</strong>.</p>

    <p>The following ports for individual systems on particular
    architectures have been obsoleted:</p>

    <ul>
      <li>Generic a.out on IA32 and m68k (i[34567]86-*-aout*,
        m68k-*-aout*)</li>
      <li>Generic COFF on ARM, H8300, IA32, m68k and SH (arm-*-coff*,
        armel-*-coff*, h8300-*-*, i[34567]86-*-coff*, m68k-*-coff*,
        sh-*-*).  This does not affect other more specific targets
        using the COFF object format on those architectures, or the
        more specific H8300 and SH targets (h8300-*-rtems*,
        h8300-*-elf*, sh-*-elf*, sh-*-symbianelf*, sh-*-linux*,
        sh-*-netbsdelf*, sh-*-rtems*, sh-wrs-vxworks).</li>
      <li>2BSD on PDP-11 (pdp11-*-bsd)</li>
      <li>AIX 4.1 and 4.2 on PowerPC (rs6000-ibm-aix4.[12]*,
        powerpc-ibm-aix4.[12]*)</li>
    </ul>

    </li>

    <li>The <code>protoize</code> and <code>unprotoize</code>
    utilities have been obsoleted and will be removed in GCC 4.5.
    These utilities have not been installed by default since GCC
    3.0.</li>

 </ul>

<h2>General Optimizer Improvements</h2>

  <ul>
    <li>A new command-line switch <code>-ftree-switch-conversion</code> has
      been added.  This new pass turns simple initializations of scalar
      variables in switch statements into initializations from a static array,
      given that all the values are known at compile time and the ratio between
      the new array size and the original switch branches does not exceed 
      the parameter <code>--param switch-conversion-max-branch-ratio</code> 
      (default is eight).  </li>

    <li><p>The <a href="http://gcc.gnu.org/wiki/Graphite">Graphite</a>
      branch has been merged.  This merge has brought in a new
      framework for loop optimizations based on a polyhedral
      intermediate representation.  These optimizations apply to all
      the languages supported by GCC.  The following new code
      transformations are available in GCC 4.4:</p>
      
      <ul>
	<li><code>-floop-interchange</code>
	  performs loop interchange transformations on loops.  Interchanging two
	  nested loops switches the inner and outer loops.  For example, given a
	  loop like:
	  <pre>
          DO J = 1, M
            DO I = 1, N
              A(J, I) = A(J, I) * C
            ENDDO
          ENDDO
	  </pre>
	    <p>loop interchange will transform the loop as if the user had written:</p>
	      <pre>
          DO I = 1, N
            DO J = 1, M
              A(J, I) = A(J, I) * C
            ENDDO
          ENDDO
	      </pre>
	    <p>which can be beneficial when <code>N</code> is larger than the caches,
	      because in Fortran, the elements of an array are stored in memory
	      contiguously by column, and the original loop iterates over rows,
	      potentially creating at each access a cache miss.</p>
	</li>
	<li><code>-floop-strip-mine</code>
	  performs loop strip mining transformations on loops.  Strip mining
	  splits a loop into two nested loops.  The outer loop has strides
	  equal to the strip size and the inner loop has strides of the
	  original loop within a strip.  For example, given a loop like:
	  <pre>
          DO I = 1, N
            A(I) = A(I) + C
          ENDDO
	  </pre>
	  <p>loop strip mining will transform the loop as if the user had written:</p>
	    <pre>
          DO II = 1, N, 4
            DO I = II, min (II + 3, N)
              A(I) = A(I) + C
            ENDDO
          ENDDO
	    </pre>
	</li>
	<li><code>-floop-block</code>
	  performs loop blocking transformations on loops.  Blocking strip mines
	  each loop in the loop nest such that the memory accesses of the
	  element loops fit inside caches.  For example, given a loop like:
	  <pre>
          DO I = 1, N
            DO J = 1, M
              A(J, I) = B(I) + C(J)
            ENDDO
          ENDDO
	  </pre>
	  <p>loop blocking will transform the loop as if the user had written:</p>
	  <pre>
          DO II = 1, N, 64
            DO JJ = 1, M, 64
              DO I = II, min (II + 63, N)
                DO J = JJ, min (JJ + 63, M)
                  A(J, I) = B(I) + C(J)
                ENDDO
              ENDDO
            ENDDO
          ENDDO
	  </pre>
	  <p>which can be beneficial when <code>M</code> is larger than the caches,
	    because the innermost loop will iterate over a smaller amount of data
	    that can be kept in the caches.</p>
	</li>
      </ul>
    </li>
  </ul>

<h2>New Languages and Language specific improvements</h2>

  <ul>
    <li>Version 3.0 of the <a
    href="http://openmp.org/wp/openmp-specifications/">OpenMP specification</a>
    is now supported for the C, C++, and Fortran compilers.</li>
  </ul>

<h3>C family</h3>

  <ul>
    <li>A new <code>optimize</code> attribute was added to allow programmers to
    change the optimization level and particular optimization options for an
    individual function.  You can also change the optimization options via the
    <code>GCC optimize</code> pragma for functions defined after the pragma.
    The <code>GCC push_options</code> pragma and the
    <code>GCC pop_options</code> pragma allow you temporarily save and restore
    the options used.  The <code>GCC reset_options</code> pragma restores the
    options to what was specified on the command line.
    </li>

  </ul>

<h3>C++</h3>
  <ul>
    <li><a href="cxx0x_status.html">Improved experimental support for the upcoming
    ISO C++ standard, C++0x</a>, including support for inline namespaces, generalized initializer lists, defaulted and deleted functions, and scoped enums.</li>

    <li> Those errors that may be downgraded to warnings to build
    legacy code now mention <code>-fpermissive</code> when
    <code>-fdiagnostics-show-option</code> is enabled.</li>

  </ul>
  
  <h4>Runtime Library (libstdc++)</h4>

<h3>Fortran</h3>
  <ul>
    <li>GNU Fortran now employs libcpp directly instead of using cc1 as an
    external preprocessor. The <a
    href="http://gcc.gnu.org/onlinedocs/gfortran/Preprocessing-Options.html">
    <code>-cpp</code></a> option was added to allow manual invocation of the
    preprocessor without relying on filename extensions.</li>

    <li>The <a
    href="http://gcc.gnu.org/onlinedocs/gfortran/Error-and-Warning-Options.html#index-g_t_0040code_007bWarray_002dtemporaries_007d-125">
    <code>-Warray-temporaries</code></a> option warns about array temporaries
    generated by the compiler, as an aid to optimization.</li>

    <li>The <a
    href="http://gcc.gnu.org/onlinedocs/gfortran/Code-Gen-Options.html#index-g_t_0040code_007bfcheck_002darray_002dtemporaries_007d-221">
    <code>-fcheck-array-temporaries</code></a> option has been added, printing
    a notification at run time, when an array temporary had to be created for
    an function argument. Contrary to <code>-Warray-temporaries</code> the
    warning is only printed if the array is noncontiguous.</li>

    <li>Improved generation of DWARF debugging symbols</li>

    <li>If using an intrinsic not part of the selected standard (via
      <code>-std=</code> and <code>-fall-intrinsics</code>) gfortran will now
      treat it as if this procedure were declared <code>EXTERNAL</code> and
      try to link to a user-supplied procedure. <code>-Wintrinsics-std</code>
      will warn whenever this happens. The now-useless option
      <code>-Wnonstd-intrinsic</code> was removed.</li>

    <li>The flag <code>-falign-commons</code> has been added to control the
      alignment of variables in COMMON blocks, which is enabled by default in
      line with previous GCC version. Using <code>-fno-align-commons</code> one
      can force commons to be contiguous in memory as required by the Fortran
      standard, however, this slows down the memory access. The option
      <code>-Walign-commons</code>, which is enabled by default, warns when
      padding bytes were added for alignment. The proper solution is to sort
      the common objects by decreasing storage size, which avoids the alignment
      problems.</li>

    <li>Fortran 2003 support has been extended: 
      <ul>
        <li>Wide characters (ISO 10646, UCS-4, <code>kind=4</code>) and UTF-8
          I/O is now supported (except internal reads from/writes to wide
          strings). <a
          href="http://gcc.gnu.org/onlinedocs/gfortran/Fortran-Dialect-Options.html#index-g_t_0040code_007bbackslash_007d-34">
          <code>-fbackslash</code></a> now supports also
          <code>\u<em>nnnn</em></code> and <code>\U<em>nnnnnnnn</em></code>
          to enter Unicode characters.</li>
        <li>Asynchronous I/O (implemented as synchronous I/O) and the
          <code>decimal=</code>, <code>size=</code>, <code>sign=</code>,
          <code>pad=</code>, <code>blank=</code>, and <code>delim=</code>
          specifiers are now supported in I/O statements.</li>
        <li>Support for Fortran 2003 structure constructors and for
          array constructor with typespec has been added.</li>
        <li>Procedure Pointers (but not yet as component in derived types
          and as function results) are now supported.</li>
        <li>Abstract types, type extension, and type-bound procedures (both
          <code>PROCEDURE</code> and <code>GENERIC</code> but not as
          operators). Note: As <code>CLASS</code>/polymorphyic types are
          not implemented, type-bound procedures with <code>PASS</code>
          accept as non-standard extension <code>TYPE</code> arguments.</li>
      </ul>
    </li>
    <li>Fortran 2008 support has been added:
      <ul>
        <li>The <code>-std=f2008</code> option and support for the file
          extensions <code>.f2008</code> and <code>.F2008</code> has been
          added.</li>
        <li>The g0 format descriptor is now supported.</li>
        <li>The Fortran 2008 mathematical intrinsics <code>ASINH</code>,
          <code>ACOSH</code>, <code>ATANH</code>, <code>ERF</code>,
          <code>ERFC</code>, <code>GAMMA</code>, <code>LOG_GAMMA</code>,
          <code>BESSEL_*</code>, <code>HYPOT</code>,
          and <code>ERFC_SCALED</code> are now available
          (some of them existed as GNU extension before). Note: The hyperbolic
          functions are not yet supporting complex arguments and the three-
          argument version of <code>BESSEL_*N</code> is not available.</li>
        <li>The bit intrinsics <code>LEADZ</code> and <code>TRAILZ</code>
          have been added.</li>
      </ul>
    </li>
  </ul>

<h3>Java (GCJ)</h3>

<h3>Ada</h3>
<ul>
  <li>The Ada runtime now supports multilibs on many platforms including 
    x86_64, SPARC and PowerPC. Their build is enabled by default.</li>
</ul>

<h2>New Targets and Target Specific Improvements</h2>

<h3>AVR</h3>
  <ul>
    <li>Added support for these new AVR devices:
      <ul>
        <li>ATtiny13A</li>
        <li>ATtiny167</li>
        <li>ATmega32C1</li>
        <li>ATmega32M1</li>
        <li>ATmega32U4</li>
        <li>ATmega16HVB</li>
        <li>ATmega4HVD</li>
        <li>ATmega8HVD</li>
        <li>ATmega64C1</li>
        <li>ATmega64M1</li>
        <li>ATmega16U4</li>
        <li>ATmega32U6</li>
      </ul>
    </li>
  </ul>

<h3>IA-32/x86-64</h3>
  <ul>
    <li>Support for Intel AES built-in functions and code generation is
	available via <code>-maes</code>.</li>
    <li>Support for Intel PCLMUL built-in function and code generation is
	available via <code>-mpclmul</code>.</li>
    <li>Support for Intel AVX built-in functions and code generation is
	available via <code>-mavx</code>.</li>
    <li>Automatically align the stack for local variables with alignment
	requirement. </li>
    <li>GCC can now utilize the SVML library for vectorizing calls to
	a set of C99 functions if <code>-mveclibabi=svml</code> is specified
	and you link to an SVML ABI compatible library.</li>
    <li>A new <code>target</code> attribute was added to allow programmers to change the target options like <code>-msse2</code> or <code>-march=k8</code> for an individual function.  You can also change the target options via the <code>GCC target</code> pragma for functions defined after the pragma.</li>

  </ul>

<h3>MIPS</h3>
  <ul>
    <li><p>MIPS Technologies have extended the original MIPS SVR4 ABI
        to include support for procedure linkage tables (PLTs)
        and copy relocations.  These extensions allow GNU/Linux
        executables to use a significantly more efficient code
        model than the one defined by the original ABI.</p>

        <p>GCC support for this code model is available via a
        new command-line option, <code>-mplt</code>.  There is also
        a new configure-time option, <code>--with-mips-plt</code>,
        to make <code>-mplt</code> the default.</p>

        <p>The new code model requires support from the assembler,
        the linker, and the runtime C library.  This support is available
        in binutils 2.19 and GLIBC 2.9.</p></li>
    <li>GCC can now generate MIPS16 code for 32-bit GNU/Linux executables
        and 32-bit GNU/Linux shared libraries.  This feature requires
        GNU binutils 2.19 or above.</li>
    <li>Support for RMI's XLR processor is now available through the
        <code>-march=xlr</code> and <code>-mtune=xlr</code> options.</li>
    <li>64-bit targets can now perform 128-bit multiplications inline,
        instead of relying on a <code>libgcc</code> function.</li>
    <li>Native GNU/Linux toolchains now support <code>-march=native</code>
        and <code>-mtune=native</code>, which select the host processor.</li>
    <li>GCC now supports the R10K, R12K, R14K and R16K processors.  The
        canonical <code>-march=</code> and <code>-mtune=</code> names for
        these processors are <code>r10000</code>, <code>r12000</code>,
        <code>r14000</code> and <code>r16000</code> respectively.</li>
    <li>GCC can now work around the side effects of speculative execution
        on R10K processors.  Please see the documentation of the
        <code>-mr10k-cache-barrier</code> option for details.</li>
    <li>Support for the MIPS64 Release 2 instruction set has been added.  The
        option <code>-march=mips64r2</code> enables generation of these
        instructions.</li>
    <li>GCC now supports Cavium Networks' Octeon processor.  This support is
        available through the <code>-march=octeon</code> and
        <code>-mtune=octeon</code> options.</li>
    <li>GCC now supports STMicroelectronics' Loongson 2E/2F processors.  The
        canonical <code>-march=</code> and <code>-mtune=</code> names for
        these processors are <code>loongson2e</code> and
        <code>loongson2f</code>.</li>
  </ul>

<h3 id="picochip">picochip</h3>

  <p>Picochip is a 16-bit processor.  A typical picoChip contains over 250
  small cores, each with small amounts of memory. There are three processor
  variants (STAN, MEM and CTRL) with different instruction sets and memory
  configurations and they can be chosen using the <code>-mae</code> option.
  </p>

  <p>This port is intended to be a "C" only port.</p>

<h3>S/390, zSeries and System z9/z10</h3>
  <ul>
    <li>Support for the IBM System z10 EC/BC processor has
        been added.  When using the <code>-march=z10</code> option,
        the compiler will generate code making use of instructions
        provided by the General-Instruction-Extension Facility and the
        Execute-Extension Facility.</li>
  </ul>

<h3>Xtensa</h3>
  <ul>
    <li>GCC now supports thread-local storage (TLS) for Xtensa processor
    configurations that include the Thread Pointer option.  TLS also requires
    support from the assembler and linker; this support is provided in the
    GNU binutils beginning with version 2.19.</li>
  </ul>

<h2>Documentation improvements</h2>

<h2>Other significant improvements</h2>

</body>
</html>
