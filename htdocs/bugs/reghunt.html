<html>

<head>
<title>How to Locate GCC Regressions</title>
</head>

<body>

<h1>How to Locate GCC Regressions</h1>

<p>A regression is a bug that did not exist in a previous release.
Problem reports for GCC regressions have a very high priority, and we
make every effort to fix them before the next release.  Knowing which
change caused a regression is valuable information to the developer
who is fixing the problem, even if that patch merely exposed an existing
bug.</p>

<p>People who are familiar with building GCC but who don't have the
knowledge of GCC internals to fix bugs can help a lot by identifying
patches that caused regressions to occur.  The same techniques can be
used to identify the patch that unknowingly fixed a particular bug on
the mainline when that bug also exists as a regression on a release
branch, allowing someone to port the fix to the branch.</p>

<p>These instructions assume that you are already familiar with building
GCC on your platform.</p>

<h2>Search strategies</h2>

<p>If you've got sufficient disk space available, keep old install
tree around for use in finding small windows in which regressions
occur.  Some people who do this regularly add information to GNATS
about particular problem reports for regressions.</p>

<p>Before you start your search, verify that you can reproduce the
problem with GCC built from the current sources.  If not, the bug might
have been fixed, or it might not be relevant for your platform, or the
failure might only happen with particular options.  Next, verify that you
get the expected behavior for the start and end dates of the range.</p>

<p>The basic search strategy is to iterate through the following steps
while the range is too large to investigate by hand:</p>

<ul>
<li><a href="#get">Get GCC sources</a> for that date.</li>
<li><a href="#build">Build GCC</a>, or specific components that are
    needed for testing.</li>
<li><a href="#test">Run the test</a>.</li>
<li>Based on the outcome of the test, find the midpoint of the new
    search range.</li>
</ul>

<p>The first three steps are described below.  They can be automated,
as can the framework for the binary search.  The directory
<code>contrib/reghunt</code> in the GCC CVS repository includes
scripts to do this work.
There are several <a href="#shortcuts">short cuts</a>
that can be used to shorten the elapsed time of the search.</p>

<p>Eventually you'll need to <a href="#identify">identify the patch</a>
and verify that it causes the behavior of the test to change.</p>

<p>There are a variety of problems you might encounter, but many of them
are simple to <a href="#problems">work around</a>.</p>

<h2><a name="get">Get GCC sources</a></h2>

<p>Get a local CVS tree using the <a href="../cvs.html">cvs instructions</a>.
Use a read-only tree that is separate from what you use for development or
other testing, since it's easy to end up with files in strange states.</p>

<h3>rsync</h3>

<p>Using rsync to get a local copy of the GCC CVS repository is highly
recommended for regression hunts.  You'll be checking out the tree used
for the regression search over and over again and won't want to affect
access times for other GCC developers who are using the real repository,
and it will also be faster for you.</p>

<p>Follow the <a href="../rsync.html">rsync instructions</a>.  The full tree
takes a lot of disk space, but it's possible to exclude directories you
won't need for your hunt.  If you're already using rsync, see the
<a href="#shortcuts">short cuts</a> below for making a smaller copy.</p>

<h3>CVS mainline</h3>

<p>Check out the GCC CVS tree, specifying the date you want to test.  You
can keep copies of the various ChangeLog files to compare later when you're
ready to identify the patch that caused the regression.  For example:</p>

<pre>
    cat &lt;&lt;EOF &gt; cplog
    #! /bin/sh
    mkdir -p logs/`dirname ${1}`
    cp ${1} logs/${1}.${2}
    EOF
    chmod +x cplog

    DATE=&quot;2002-05-01 10:15&quot;
    LOGDATE=&quot;`echo ${DATE} | sed 's/[-: ]/_/g'`&quot;
    cvs co -D &quot;${DATE}&quot; gcc &gt; log/${LOG_DATE}.log
    find gcc -name ChangeLog -exec ./cplog {} ${LOG_DATE} \;
</pre>

<p>Don't keep copies of the ChangeLogs in your CVS tree itself; that
will slow down new checkouts.  Rather than keeping copies of the files,
you can also get differences between ChangeLog files using</p>

<pre>
    cvs diff -D <i>date1</i> -D <i>date2</i> ChangeLog
</pre>

<h3>CVS branches</h3>

<p>To get all files for a particular date on the branch, check out the
branchpoint and then update with all changes between the branchpoint and
the desired date.  For example,</p>

<pre>
    BRANCH="gcc-3_2-branch"
    DATE="2002-09-01"
    rm -rf gcc
    cvs co -r ${BRANCH}point gcc
    cvs up -d -j${BRANCH}point -j${BRANCH}:&quot;${DATE}&quot;
</pre>

<p>This method works reliably when it starts with a clean checkout.
Further updates that use the previous date and a new date sometimes run
into problems, with a few files not being updated correctly.</p>

<h2><a name="build">Build GCC</a></h2>

<p>The kind of bug you are investigating will determine what kind of
build is required for testing GCC on a particular date.  In almost
all cases you can do a simple <code>make</code> rather than <code>make
bootstrap</code>, provided that you start with a recent version of
<code>gcc</code> as the build compiler.  When building a full compiler,
enable only the language you'll need to test.  If you're testing a bug
in a library, you'll only need to build that library, provided you've
already got a compatible version of the compiler to test it with.  If
there are dependencies between components, or if you don't know which
component(s) affect the bug, you'll need to update and rebuild
everything for the language.</p>

<p>If you're chasing bugs that are known to be in <code>cc1plus</code>
you can do the following after a normal configure:</p>

<pre>
    cd <i>objdir</i>
    make all-libiberty
    make configure-gcc || true
    cd gcc
    make cc1plus
</pre>

<p>This will build libiberty and <code>cc1plus</code> (the make of
<code>configure-gcc</code> is required for configuration changes that
were added in December 2002).  When you have
<code>cc1plus</code>, you can feed your source code snippet to it:</p>

<pre>
    cc1plus -quiet <i>testcase</i>.ii
</pre>

<h2><a name="test">Run the test</a></h2>

<p>Assuming that there is a self-contained test for the bug, as there
usually is for bugs reported via GNATS, write a small script to run it
and to report whether it passed or failed.  If you're automating your
search then the script should tell you whether the next compiler build
should use earlier or later GCC sources.</p>

<p>Hints for coming up with a self-contained test is beyond the scope
of this document.</p>

<h2><a name="identify">Identify the patch</a></h2>

<p>Differences in the ChangeLog files can help you identify files that
have changed, although you must keep in mind that CVS checkins are not
atomic and ChangeLog diffs between two dates are not always an accurate
reflection of changes to other files.  If the set of changes is small
enough you can guess which patch might have caused the regression and
update only the files changed by that patch.  Remember to look at all
ChangeLogs that might list relevant changes, not just the obvious ones.
To get an accurate list of files that changed between two times, do a
CVS update to the first date and then a CVS update to the second date,
and look for lines in the output from the second update that begin
with "U ".</p>

<p>The following CVS commands can help you identify changes from one
version of a file to another:</p>

<ul>
<li><code>cvs diff -D <i>date1</i> -D <i>date2</i> <i>file</i></code></li>
<li><code>cvs log -N <i>file</i></code></li>
<li><code>cvs log -N -d&quot;<i>date1</i>&lt;<i>date2</i>&quot; <i>file</i>
    </code></li>
<li><code>cvs annotate <i>file</i></code></li>
</ul>

<p>When you've identified the likely patch out of a set of patches
between the current low and high dates of the range, test a source tree
from just before or just after that patch was added and then add or
remove the patch by updating only the affected files.  You can do this by
identifying the revision of each file when the patch was added and then
using <code>ccs update -r<i>rev</i> <i>file</i></code> to get the desired
version of each of those files.  Build and test to verify that this
patch changes the behavior of the test.</p>

<h2><a name="shortcuts">Short cuts</a></h2>

<p>If you've narrowed down the dates sufficiently, it might be faster to
give up on the binary search and start doing forward updates by small
increments and then incremental builds rather than full builds.  Whether
this is worthwhile depends on the relative time it takes to update the
sources, to do a build from scratch, and to do an incremental build.</p>

<p>Similarly, you can do incremental builds when going forward a small
amount from the previous build, and go back to builds in clean object
directories when building from earlier sources.  When moving forward and
doing incremental builds, use <code>contrib/gcc_update</code> rather
than <code>cvs co</code> or <code>cvs update</code>.</p>

<p>Before building a compiler after updating the sources, check that
the new sources are different from the sources for the current ends of
the range.  If not, make this new date one of the endpoints without
doing the build and running the test.  Since CVS checkins are not
atomic, you can't rely on ChangeLog differences to reflect actual
differences to other files.</p>

<p>When you first use rsync you can exclude directories for components
that you know you won't be building.  If you're already using a local
CVS repository via rsync, you can make a cut-down version of it that
leaves out directories you don't need for the regression hunt.  This
makes cvs operations much quicker, making it worthwhile even if the copy
is on the same system.  It's particularly useful if you'll want to copy
it to a system that is low on available disk space.  The following, for
example, makes a smaller copy of the repository that can be used for
finding C and C++ compile-time problems and takes only half the disk
space as the full repository.</p>

<pre>
    cat &lt;&lt;EOF &gt; rsync_exclude
    --exclude=gcc-cvs/benchmarks
    --exclude=gcc-cvs/boehm-gcc
    --exclude=gcc-cvs/old-gcc
    --exclude=gcc-cvs/wwwdocs
    --exclude=gcc-cvs/gcc/libjava
    --exclude=gcc-cvs/gcc/libstdc++-v3
    --exclude=gcc-cvs/gcc/gcc/ada
    --exclude=gcc-cvs/gcc/gcc/testsuite
    EOF

    tar `cat rsync_exclude` -cf - gcc-cvs | gzip &gt; gcc-cvs.tar.gz
</pre>

<h2><a name="problems">Work around problems</a></h2>

<p>If one of the test builds fails, try a date or time slightly earlier or
later and see if that works.  Usually all files in a patch are checked in
at the same time, but if there was a gap you might have hit it.</p>

<p>Sometimes regressions are introduced during a period when bootstraps
are broken on the platform, particularly if that platform is not tested
regularly.  Your best bet here is to find out whether the regression
also occurs on a platform where bootstraps were working at that time.</p>

<p>If a regression occurs at the time of a large merge from a branch,
search the branch.</p>

<p>If a test causes the compiler or the compiled test program to hang,
run it from a <code>csh</code> or <code>tcsh</code> script using
<code>limit cputime <i>mm</i>:<i>ss</i></code> so it will fail if it
requires more than the amount of time you specified.  The same technique
can be used to limit other resources, including memory.</p>

<p>Latent bugs can become apparent due to to small changes in code sizes
or data layout.  Test failures for these bugs can be intermittent,
leading to randomness in a binary search for the patch that introduced
the bug.  This makes it important to see if the patch resulting from a
regression hunt looks as if it's actually related to the bug.  For
example, if a search on <code>i686-pc-linux-gnu</code> comes up with a
change to an unrelated target, you're probably looking for such a bug.</p>

<h2><a name="dates">Branch and release dates</a></h2>

<p>If no one has provided a range of dates for when a particular
mainline regression appeared, you can narrow the search by knowing in
which release it first appeared and then testing the mainline between
the branchpoint for that release and the branchpoint for the previous
release that does not have the bug.  Here are some dates for major CVS
milestones.</p>

<table border="1">
<tr><th>tag</th>
    <th>added on this date</th>
</tr>
<tr><td>gcc-3_3-branchpoint</td>
    <td>2002-12-13</td>
</tr>
<tr><td>gcc-3_2-branchpoint</td>
    <td>2002-07-26
        (from gcc-3_1-branch, not from mainline)</td>
</tr>
<tr><td>gcc-3_1-branchpoint</td>
    <td>2002-02-25</td>
</tr>
<tr><td>gcc-3_0-branchpoint</td>
    <td>2001-02-12</td>
</tr>
<tr><td>gcc-2_95-branchpoint</td>
    <td>1999-05-18</td>
</tr>
</table>

</body>
</html>
