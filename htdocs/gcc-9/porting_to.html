<!DOCTYPE html>
<html lang="en">

<head>
<title>Porting to GCC 9</title>
<link rel="stylesheet" type="text/css" href="https://gcc.gnu.org/gcc.css" />
</head>

<body>
<h1>Porting to GCC 9</h1>

<p>
The GCC 9 release series differs from previous GCC releases in
<a href="changes.html">a number of ways</a>. Some of these are a result
of bug fixing, and some old behaviors have been intentionally changed
to support new standards, or relaxed in standards-conforming ways to
facilitate compilation or run-time performance.
</p>

<p>
Some of these changes are user visible and can cause grief when
porting to GCC 9. This document is an effort to identify common issues
and provide solutions. Let us know if you have suggestions for improvements!
</p>


<!--
<h2 id="cpp">Preprocessor issues</h2>
-->

<h2 id="c">C and C++ language issues</h2>
<h3 id="complit">String functions where bound equals destination size</h3>
<p>
  The strncat, strncpy, etc functions are often misused in ways that can
  result in the destination string missing its NUL terminator.  This
  can in turn lead to runtime faults and even security vulnerabilities.

  GCC 9 analyzes these calls and nearby code to try and determine if the
  resulting string is properly terminated and if it is not GCC 9 will issue
  a warning like:

  <pre><code>
    > <mock-chroot> sh-4.4# gcc -O2 -Wall -c device.i
    > In file included from /usr/include/string.h:494,
    >                   from /builddir/build/BUILD/libmetal-2018.04/build/lib/include/metal/io.h:17,
    >                   from /builddir/build/BUILD/libmetal-2018.04/build/lib/include/metal/device.h:16,
    >                   from /builddir/build/BUILD/libmetal-2018.04/lib/system/linux/device.c:12:
    > In function 'strncpy',
    >      inlined from 'metal_linux_dev_open' at /builddir/build/BUILD/libmetal-2018.04/lib/system/linux/device.c:433:3:
    > /usr/include/bits/string_fortified.h:106:10: warning: '__builtin_strncpy' specified bound 4096 equals destination size [-Wstringop-truncation]
    >    106 |   return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
    >        |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  </code></pre>

  For code like this:

  <pre><code>
    memset(ldev, 0, sizeof(*ldev));
    strncpy(ldev->dev_name, dev_name, sizeof(ldev->dev_name));
    ldev->fd = -1;
    ldev->ldrv = ldrv;
    ldev->device.bus = bus;
    ...
  </code></pre>
</p>

<p>
  The way to fix this depends on how the resulting string is used.  If the
  resulting string is not required to be NUL terminated, then it should be
  marked with the "nonstring" attribute.  This indicates to the compiler
  that NUL termination is not required and the compiler will then check
  that the result is not passed to a routine like strlen which assumes
  its input is NUL terminated.  If the resulting string is supposed to be
  NUL terminated, then terminate the string immediately after the call.
</p>


<h2 id="c">C language issues</h2>

<h3 id="complit">Block scope compound literal's lifetime</h3>

<p>
  The C standard says that compound literals which occur inside of the body
  of a function have automatic storage duration associated with the
  enclosing block.  Older GCC releases were putting such compound literals
  into the scope of the whole function, so their lifetime actually ended
  at the end of containing function.  This has been fixed in GCC 9.
  Code that relied on this extended lifetime needs to be fixed, move the
  compound literals to whatever scope they need to accessible in.
</p>
  <pre><code>
      struct S { int a, b; };
      int foo(void) {
        // The following line no longer compiles
        struct S *p = &amp;({ (struct S) { 1, 2 }; });
        struct S *q;
        {
          q = &(struct S) { 3, 4 };
        }
        // This is invalid use after lifetime of the compound literal
        // ended.
        return q-&gt;b;
      }
  </code></pre>

<h3 id="ompdatasharing">OpenMP data sharing</h3>

<p>
  GCC releases before 9 were implementing an OpenMP 3.1 data sharing rule
  that <code>const</code> qualified variables without <code>mutable</code>
  member are predetermined shared, but as an exception may be specified
  in the <code>firstprivate</code> clause.  OpenMP 4.0 dropped this rule,
  but in the hope that the incompatible change will be reverted GCC kept
  implementing the previous behavior.  Now that for OpenMP 5.0 it has been
  confirmed this is not going to change, GCC 9 started implementing the
  OpenMP 4.0 and later behavior.  When not using <code>default</code>
  clause or when using <code>default(shared)</code>, this makes no
  difference, but if using <code>default(none)</code>, previously the
  choice was not specify the <code>const</code> qualified variables
  on the construct at all, or specify in <code>firstprivate</code> clause.
  In GCC 9 as well as for OpenMP 4.0 compliance, those variables need
  to be specified on constructs in which they are used, either in
  <code>shared</code> or in <code>firstprivate</code> clause.  Specifying
  them in <code>firstprivate</code> clause is one way to achieve
  compatibility with both older GCC versions and GCC 9, another option
  is to drop the <code>default(none)</code> clause.  In C++,
  <code>const</code> variables with constant initializers which are not
  odr-used in the region, but replaced with their constant initializer
  are not considered to be referenced in the region for
  <code>default(none)</code> purposes.
</p>
  <pre><code>
      int get (void);
      void use (int);
      void foo (void) {
        const int a = get ();
        const int b = 1;
        #pragma omp parallel for default(none)
        for (int i = 0; i &lt; a; i += b)
          ;
        // The above used to compile with GCC 8 and older, but will
        // not anymore with GCC 9.  firstprivate(a, b) clause needs
        // to be added for C, for C++ it could be just firstprivate(a)
        // to make it compatible with all GCC releases.
      }
      const int huge_array[1024] = { ... };
      void bar (void) {
        #pragma omp parallel for default(none)
        for (int i = 0; i &lt; 1024; i++)
          use (huge_array[i]);
        // Similarly, this used to compile with GCC 8 and older and
        // will not anymore.  Adding firstprivate(huge_array) is
        // probably undesirable here, so, either
        // default(none) shared(huge_array) should be used and it will
        // only support GCC 9 and later, or default(none) should be
        // removed and then it will be compatible with all GCC releases
        // and huge_array will be shared.
      }
  </code></pre>

<!--
<h2 id="cxx">C++ language issues</h2>
-->

<!--
<h2 id="fortran">Fortran language issues</h2>
-->
 
<!--
<h2 id="links">Links</h2>
-->

</body>
</html>
