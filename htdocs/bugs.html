<html>
<head>
<title>Frequently Reported Bugs in GCC 2.95</title>
</head>
<body>
<h1 align="center">Frequently Reported Bugs in GCC 2.95</h1>

<p>The latest version of this document is always available at <a href="
http://gcc.gnu.org/bugs.html">http://gcc.gnu.org/bugs.html</a>.

<h2>Fortran</h2>
<p> Fortran bugs are documented in the G77 manual rather than explicitly
listed here.  Please see <a href="onlinedocs/g77_bugs.html">"Known
Causes of Trouble with GNU Fortran"</a> in the
<a href="onlinedocs/g77_toc.html">G77 manual.</a>


<h2>C++</h2>

<p>This is the list of bugs in g++ (aka GNU C++) that are reported very often,
but not yet
fixed. While it is certainly better to fix bugs instead of documenting
them, this document might save people the effort of writing a bug
report when the bug is already well-known.
<a href="faq.html#bugreport">How to report bugs</a> tells you how to report a
bug.

<p>There are many reasons why reported bugs don't get fixed. It might
be difficult to fix, or fixing it might break compatibility. Often,
reports get a low priority when there is a simple work-around. In
particular, bugs caused by invalid C++ code have a simple work-around,
<em>fix the code</em>. Now that there is an agreed ISO/ANSI standard
for C++, the compiler has a definitive document to adhere to. Earlier
versions might have accepted source code that is <em>no longer</em>
C++. This means that code which might have `worked' in a previous
version, is now rejected. You should update your code to be C++.

<p>You should try to use the latest stable release of the GNU C++
compiler. This is currently 2.95. Many commonly reported bugs in earlier
releases are fixed in that version.

<h3><a name="access"></a>G++ allows to access private structs</h3>
GCC 2.95 incorrectly accepts code like
<pre>
struct X{
 private:
   struct Y{};
};

X::Y z;
</pre>

Since <CODE>Y</CODE> is a private member of <CODE>X</CODE>,
the definition of <CODE>z</CODE> should be
rejected, but isn't. For other members of classes (functions and
data), access control is implemented.

<h3><a name="export"></a>export not implemented</h3>

As of GCC 2.95, the <CODE>export</CODE> keyword is not implemented. 
This feature, when implemented, will permit moving
definitions of templates out of header files; exported
templates can be instantiated without a visible definition.

<h3><a name="using"></a>Using declarations in classes do not work</h3>

The Annotated Reference Manual (ARM) defines an access declaration for
cases like

<pre>
struct X{
 protected:
   int i;
};

class Y: private X{
  public:
    X::i;
};

void f()
{
  Y y;
  y.i=4;
}
</pre>
Even though <CODE>X::i</CODE> is protected, it is redeclared public in
<CODE>Y</CODE>.

<p>Standard C++ extends this notion and aligns it with <CODE>using</CODE>
declarations available in namespaces. In Standard C++, the following
code is also valid:
<pre>
struct X{
 protected:
   int i(bool);
};

class Y: private X{
  public:
    int i(int);
    using X::i;
};

void f()
{
  Y y;
  y.i(true);
}
</pre>

A <CODE>using</CODE> declaration not only redeclares access, it also permits
merging functions from the base class into the derived class, which is
convenient for overloading. In Standard C++, the ARM-style notation is
equivalent to <CODE>using</CODE> declarations.

<p>GCC 2.95 rejects this code. It treats <CODE>using</CODE> declarations in
the same way as ARM-style access declarations.

<h3><a name="parsing"></a>Parse errors for "simple" code</h3> 

Up to and including GCC 2.95, the compiler will give "parse error" for
seemingly simple code, such as

<pre>
struct A{
  A();
  A(int);
  void func();
};

struct B{
  B(A);
  B(A,A);
  void func();
};

void foo(){
  B b(A(),A(1));     //Variable b, initialized with two temporaries
  B(A(2)).func();    //B temporary, initialized with A temporary
}
</pre>
The problem is that gcc starts to parse the declaration of
<CODE>b</CODE> as a function <CODE>b</CODE> returning <CODE>B</CODE>,
taking a function returning <CODE>A</CODE> as an argument. When it
sees the 1, it is too late. The work-around in these cases is to add
additional parentheses around the expressions that are mistaken as
declarations:
<pre>
  (B(A(2))).func();
</pre>
Sometimes, even that is not enough; to show the compiler that this
should be really an expression, a comma operator with a dummy argument
can be used:
<pre>
  B b((0,A()),A(1));
</pre>
<p>
Another example is the parse error for the <CODE>return</CODE>
statement in
<pre>
struct A{};

struct B{
  A a;
  A f1(bool);
};

A B::f1(bool b)
{
  if (b)
    return (A()); 
  return a;
}
</pre>
The problem is that the compiler interprets <CODE>A()</CODE> as a
function (taking no arguments, returning <CODE>A</CODE>), and
<CODE>(A()</CODE>) as a cast - with a missing expression, hence the
parse error. The work-around is to omit the parentheses:
<pre>
  if (b)
    return A(); 
</pre>
This problem occurs in a number of variants; in <CODE>throw</CODE>
statements, people also frequently put the object in parentheses. The
exact error also somewhat varies with the compiler version. The
work-arounds proposed do not change the semantics of the program at
all; they make them perhaps less readable.

<h3><a name="library"></a>C++ Library not compliant</h3>
In Standard C++, the programmer can use a considerable run-time
library, including the STL (Standard Template Library), iostreams
for single-byte and wide characters, localization features, and
others.

<p>Many of the standard library features are not implemented in GCC
2.95. Others, such as iostreams, are supported, but not in a
compliant way (e.g. <CODE>ostream</CODE> is not
<CODE>basic_ostream&lt;char&gt;</CODE>, and not
declared in <CODE>std::</CODE>).

<p>SGI's implementation of the STL is included, but it is in the
global namespace, not in <CODE>std::</CODE>.

<p>Work is underway to complete a <a href="libstdc++-v3.html">new C++
library</a> which will provide all the functionality in a compliant
way.

<h3><a name="exception"></a>Exception specifiers on function pointers</h3>
<p>Although allowed by the standard, GCC 2.95 will report an
'invalid exception specifications' error if you
declare a function pointer with an exception specification.
<pre>
void (*fptr)() throw();
</pre>

<hr>

<p><a href="index.html">Return to the GCC home page</a> &nbsp;
<a href="faq.html">Return to the GCC FAQ</a>
<p><i>Last modified:  August 17, 1999</i>

</body>
</html>
