<html>
<head>
<title>SSA for Trees</title>
</head>

<body>
<h1>SSA for Trees</h1>

<p>The goal of this project is to build an optimization framework for trees
based on the Static Single Assignment (SSA) form [<a
href="#cytron.ea-91">1</a>].  The implementation currently lives in the
<code>tree-ssa-20020619-branch</code> branch.</p>

<p>The branch is tested daily on several GNU/Linux platforms, including
Alpha, x86, IA64, AMD64, PowerPC and PowerPC64.  Regression test results
are posted to the <a
href="http://gcc.gnu.org/ml/gcc-testresults/">gcc-testresults</a> mailing
list.  <a
href="http://people.redhat.com/dnovillo/nightly-testing/tree-ssa-branch/">Full
build logs</a> are also available.</p>

<p>Daily performance results are available for <a
href="http://people.redhat.com/dnovillo/spec95/tree-ssa-branch/">SPEC
CPU95</a> and <a
href="http://people.redhat.com/dnovillo/spec2000/tree-ssa-branch/">SPEC
CPU2000</a>.</p>

<h2>Table of Contents</h2>

<ul>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#stability">Branch stability</a></li>
<li><a href="#gimple">GENERIC and GIMPLE</a></li>
<li><a href="#ssa">SSA implementation</a></li>
<li><a href="#unparse">Unparsing GENERIC trees</a></li>
<li><a href="#tb">Tree Browser</a></li>
<li><a href="#status">Implementation Status (last updated: 2003-09-07)</a></li>
<li><a href="#status">TODO list (last updated: 2003-06-11)</a></li>
</ul>

<hr />
<h3><a name="documentation">Documentation</a></h3>

<p>API <a
href="http://people.redhat.com/dnovillo/tree-ssa-doc/html/index.html">
documentation</a> for the Tree SSA infrastructure is generated from the
source code using Doxygen.  The documentation is updated regularly.</p>

<p>A high-level overview of GENERIC/GIMPLE and the SSA implementation may
be found in the <a
href="http://www.linux.org.uk/~ajh/gcc/gccsummit-2003-proceedings.pdf">
Proceedings of the 2003 GCC Developers Summit</a> (pages 171-193).
Presentation slides for Tree SSA are also <a
href="http://people.redhat.com/dnovillo/Papers/tree-ssa-gccs03-slides.pdf">
available</a>.</p>

<hr />
<h3><a name="contributing">Contributing</a></h3>

<p>Checkout the <code>tree-ssa-20020619-branch</code> branch
following the instructions found in the <a
href="../../cvs.html">CVS documentation</a>.</p>

<p>Daily snapshots of the branch are also <a
href="http://people.redhat.com/dnovillo/pub/snapshot/">
available</a>.  These snapshots are known to bootstrap on
<code>i686-pc-linux-gnu</code>.</p>

<p>When posting to the development lists, please mark messages and patches with
<code>[tree-ssa]</code> in the subject.  As this is a branch, and not
the mainline, the usual maintainer rules do not apply.  This branch is
maintained by <a href="mailto:dnovillo@redhat.com">Diego Novillo
&lt;dnovillo@redhat.com&gt;</a>.  Approval from the usual maintainers will be
needed when submitting patches from the branch onto the mainline.</p>

<p>Current contributors to this project include 
<a href="mailto:dberlin@dberlin.org">Daniel Berlin</a>,
<a href="mailto:steven@gcc.gnu.org">Steven Bosscher</a>,
<a href="mailto:fche@redhat.com">Frank Eigler</a>,
<a href="mailto:bje@redhat.com">Ben Elliston</a>,
<a href="mailto:rth@redhat.com">Richard Henderson</a>,
<a href="mailto:graydon@redhat.com">Graydon Hoare</a>,
<a href="mailto:aldyh@redhat.com">Aldy Hernandez</a>,
<a href="mailto:aj@suse.de">Andreas Jaeger</a>,
<a href="mailto:law@redhat.com">Jeff Law</a>,
<a href="mailto:amacleod@redhat.com">Andrew MacLeod</a>,
<a href="mailto:jason@redhat.com">Jason Merrill</a>,
<a href="mailto:dnovillo@redhat.com">Diego Novillo</a>,
<a href="mailto:s.pop@laposte.net">Sebastian Pop</a>,
<a href="mailto:graham.stott@btinternet.com">Graham Stott</a>,
<a href="mailto:jsturm@one-point.com">Jeff Sturm</a> and 
<a href="mailto:aph@redhat.com">Andrew Haley</a>.</p>

<hr />
<h3><a name="stability">Branch stability</a></h3>

<p>While this is an experimental branch and people are encouraged to
add new features to it, default bootstraps and regression tests for
the front ends using the tree-ssa framework <em>must always work</em>
before a patch is allowed in the branch.  If you want to contribute
a new feature that is still not complete, you should:</p>

<ol>
<li>Add a new <code>-f</code> flag to enable your code.</li>
<li>Document the new <code>-f</code> flag in doc/invoke.texi.</li>
<li>Configure and bootstrap the compiler with all the default front ends
    enabled.</li>
<li>Run <code>make check</code> with no new regressions.</li>
</ol>

<p>Patches that break default bootstraps will be removed (if a
fix is not immediately obvious).</p>

<p>Also, for new analyses and transformations, please include a
reference to the paper and/or book where you are getting the
algorithm from.  If it's your own research work, include a
Technical Report, Thesis or Paper reference for it.</p>

<p>There are regular mainline merges about 2 or 3 times a month.  The
latest merge tag is always added to GCC's version string.  A merge may
be postponed if there is major breakage in mainline.</p>

<p>Work from the branch will be incorporated into mainline only
when we can prove improvements in code quality and/or compile
times.  We should be able to either replace or simplify some of
the existing transformations currently done on RTL.</p>


<hr />
<h2><a name="gimple">GENERIC and GIMPLE</a></h2>

<p>While GCC trees contain sufficient information for
implementing SSA, there are two major problems that make this
difficult:</p>

<ul>
<li>There is no single tree representation in GCC.  Each front end
    defines its own trees.  This means that we would have to
    duplicate all this code for each front end.</li>

<li>Trees are arbitrarily complex.  This is a problem for
    optimizations that want to examine them.  They need to
    take into account many different variations.</li>
</ul>

<p>To address the first problem, we have created a common tree
representation called GENERIC that is meant to be able to represent all the
constructs needed by the different front ends while removing all the
language dependencies.  The design of GENERIC was discussed on the GCC
lists.  One of the main threads of discussion started with <a
href="http://gcc.gnu.org/ml/gcc/2002-07/msg00890.html">http://gcc.gnu.org/ml/gcc/2002-07/msg00890.html</a>.
A description of the current design can be found at
<a
href="http://gcc.gnu.org/ml/gcc/2002-08/msg01397.html">http://gcc.gnu.org/ml/gcc/2002-08/msg01397.html</a>.</p>

<p>To address the complexity problem we have implemented a new simplified
intermediate representation based on GENERIC. The IR, called GIMPLE, is a
very simple C-like three-address language that looks pretty straightforward
to analyze and keeps all the high-level attributes of data types.  GIMPLE
is derived from the SIMPLE representation proposed by the McCAT project out
of <a href="http://www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html">McGill
University</a> [<a href="#hendren.ea-92">2</a>].</p>

<p>The data structures are the same trees used by GCC, but we impose
rules on how the trees can be combined.  For instance, the
initial GENERIC representation for the expression:</p>

<pre>
a = b + c - d;
</pre>

<p>generates a single tree for the whole assignment statement.
The GIMPLE version of that expression generates 2 different
trees:</p>

<pre>
t1 = b + c;
a = t1 - d;
</pre>

<p>So, when examining expressions we can now assume that a
<code>PLUS</code> operation will always have exactly two operands that are
variables.  This also exposes other opportunities like finding common
expressions to eliminate (although it might also lead to code bloating, so
we need to be careful).  This new pass was discussed at length on the GCC
lists, starting with <a href="http://gcc.gnu.org/ml/gcc/2002-01/msg00082.html">http://gcc.gnu.org/ml/gcc/2002-01/msg00082.html</a>.</p>

<p>The conversion from GENERIC into GIMPLE trees is implemented in
<code>gimplify.c</code>.  Additionally, each front end may have a set of
language-specific helpers.  For instance, the C/Objective-C front ends contain the helper
functions in <code>c-simplify.c</code>, the C++ front end has its own in
<code>cp/cp-simplify.c</code>.  Predicates to determine whether a tree is
in GIMPLE form are defined in <code>tree-simple.[ch]</code>.</p>

<hr />
<h2><a name="ssa">SSA implementation</a></h2>

<p>Having trees in GIMPLE form enables language-independent analysis
and transformation passes.  Currently, we are implementing an SSA pass
based on the algorithms described by Cytron <em>et. al.</em>
[<a href="#cytron-91">1</a>].</p>

<p>The graph below describes the process:</p>

<p><img src="tree-opt.png" alt=""/></p>

<p>The front ends described in the graph are just an example.  In
general, any front end that can emit functions-as-trees can be
converted to emit GENERIC trees.</p>

<p>Conversion to SSA form is a three step process driven from
<code>tree-optimize.c</code>:</p>

<ol>
<li>Convert the function into GIMPLE form.  Implemented in
<code>gimplify.c</code> and <code>c-simplify.c</code>.</li>
<li>Find variable references in the code.  Implemented in
<code>tree-dfa.c</code>.</li>
<li>Build a control-flow graph (CFG).  Implemented in <code>tree-cfg.c</code>.
This implementation uses the same <code>basic_block</code> structure used by
the RTL optimizers.  This allows us to share most of the existing CFG
code.</li>
<li>Rewrite the tree in SSA form.  Implemented in <code>tree-ssa.c</code>.</li>
</ol>

<p>The partial call graph below describes the main entry points of the
conversion process for the C front end:</p>

<p><img src="call-graph.png" alt=""/></p>

<hr />
<h2><a name="unparse">Unparsing C trees</a></h2>

<p>The file <code>tree-pretty-print.c</code> implements several debugging
functions that given a GENERIC tree node, they print a C representation of
the tree.  The output is not meant to be compilable, but it is of great
help when debugging transformations done by the transformation passes.</p>

<hr />
<h2><a name="tb">Tree Browser</a></h2>
For debugging, browsing, discovering, and playing with trees you can
use the <a href="tree-browser.html">Tree Browser</a> directly from gdb.

<hr />
<h2><a name="status">Implementation Status</a></h2>

<p>This is a short list of the work that has already been finished or
is ongoing.</p>

<h3>Lowering of trees</h3>
<p>Lowering from the language specific tree representations for C and C++
to GENERIC has been implemented.  A more or less language-independent
pass to lower from GENERIC to GIMPLE has also been implemented.</p>

<h3>Into/out of SSA tree rewriting</h3>
<p>The CFG builder has been in place for a while now,
and most of the work that is done on it is tuning and speeding it
up where  possible.  Most of the DFA infrastructure is in place.
Type-based alias analysis has been implemented, but it needs some
work to be fast enough.  An initial implementation of Andersen
Points-to analysis is also available.  Rewriting the tree into SSA
form is finished.  Writing out of SSA form can now handle variables
with overlapping live ranges.  This means that most of the basic
infrastructure is in place.</p>

<h3>SSA Optimizations</h3>
<p>Four optimization passes have been implemented to date:</p>

<ul>
<li>Copy propagation[<a href="#morgan-98">3</a>]</li>
<li>CCP (sparse Conditional Constant Propagation)[<a href="#wegman.ea-91">4</a>]</li>
<li>DCE (Dead Code Elimination)[<a href="#morgan-98">3</a>]</li>
<li>PRE (Partial Redundancy Elimination)[<a href="#chow.ea-97">5</a>]
    with strength reduction</li>
<li>Dominator-based optimizations such as constant propagation and
    redundancy elimination using value numbering.
</ul>

<p>All passes are enabled by default at <code>-O1</code> and better.  The
dominator-based optimizations are enabled when writing into SSA form.</p>

<h3>Testing framework</h3>
<p>Work on a framework for validation of the optimization passes has only
just started.  All analysis and optimization passes in the tree-ssa
framework have the ability to dump an annotated intermediate representation.
Support for scanning these tree dumps has been implemented for the
existing DejaGNU testing framework.</p>

<hr />
<h2><a name="todo">TODO list</a></h2>

<p>This is a loosely organized list of unimplemented features,
possible improvemend, and planned analyses and optimizations.
Suggestions for other passes and volunteers to help finish the
different passes are welcome.</p>

<h3>Infrastructure</h3>

<dl>
<dt><em>Speed up the new infrastructure</em></dt>
<dd>There are still many things that we can do faster.  The compile time
    performance of GCC should improve, not degrade.  A lot of work is
    going on in this area.</dd>
<dt><em>Find and fix integration deficiencies</em></dt>
<dd>We have to integrate all the different passes to make one run
    after the other efficiently.  The integration work done so far has
    uncovered many bugs and inefficiencies in the way we build and
    maintain DFA/SSA information, and as more passes are implemented,
    we will probably find some more deficiencies that need to be
    addressed.</dd>
<dt><em>Add parse tree to GENERIC translation passes to front ends</em></dt>
<dd>From the front ends that generate function-as-trees, only the C, Objective-C
    and C++ front ends have a genericize pass.  
    <a href="mailto:jsturm@one-point.com">Jeff Sturm</a> and 
    <a href="mailto:aph@redhat.com">Andrew Haley</a> are working on
    Java.</dd>
<dt><em>Tune RTL expanders to the subset of trees used by GIMPLE</em></dt>
<dd>This is best illustrated with an example.  In GIMPLE all loops are
    LOOP_EXPRs, a kind of tree node that was not produced by the C
    front end.  A simple patch reduced the number of INSNs for a loop
    header from 16 to 12.  It is very likely that other improvements
    like this are possible.</dd>
<dt><em>Analyse interactions between the tree and RTL optimizers</em></dt>
<dd>In the current implementation, no low-level (RTL) optimizations
    have been disabled yet, while the new infrastructure is already
    enabled.  So, there now is a new stage in the compile pipeline
    but nothing has been taken out yet.
    In theory, the tree optimizers should make some of the
    optimizations we try to do on RTL redundant for the front ends
    that already use the tree-ssa infrastructure.  But how exactly these
    two optimization infrastructures interact is not well understood
    yet.</dd>
<dt><em>Extend the testing framework</em></dt>
<dd>More analysis is required for a complete testing framework.  The
    framework will have to be updated to allow it to verify things like
    correct/optimal code motions.</dd>
<dt><em>Add test cases and consistency checks</em></dt>
<dd>Test cases that prove the correctness and efficiency of the
    optimization passes are especially welcome.</dd>
</dl>

<h3>Analyses</h3>

<dl>
<dt><em>SSA information for arrays</em></dt>
<dd>The existing implementation treats arrays as an opaque object.  A
    definition to an array location is treated as a definition for the
    whole array.</dd>
<dt><em>Search of loop induction variables</em></dt>
<dd>This could be implemented using Michael Wolfe's algorithm <a
    href="http://citeseer.nj.nec.com/gerlek95beyond.html">Beyond Induction
    Variables</a>.  This algorithm is implemented in the <a
    href="ftp://ftp.cse.ogi.edu/pub/mwolfe/nascent.tar.gz">Nascent
    Compiler</a>.</dd>
<dt><em>Pointer analysis (aliasing)</em></dt>
<dd>Dan Berlin is working on Andersen Points-to analysis.
    Unfortunately we cannot implement Steengaard analysis due to
    patent issues.</dd>
<dt><em>Dependence graph</em></dt>
<dd>This pass is almost implemented in <code>dependence.c</code> but it's not
    used.  We can adapt this work by keeping the dependence tester, but get
    the information about array subscripts and loops from the GIMPLE
    representation.</dd>
</dl>

<h3>Basic scalar transformations</h3>

<dl>
<dt><em>GVN (Global Value Numbering)</em></dt>
<dd>Value numbering is used to detect equivalent expressions to eliminate
    redundancies. It assigns symbolic values to expressions such that if
    two expression have the same symbolic value, they compute the same
    value.</dd>
<dt><em>VRP (Value Range Propagation)[<a href="#patterson-95">6</a>]</em></dt>
<dd>This optimization tracks the weighted value ranges of variables through
    a program, much like constant propagation. These value ranges may be
    either numeric or symbolic in nature. A paper describing the algorithm,
    as well as some applications and experimental results, is available at <a
    href="http://www.pattosoft.com.au/jason/Papers/ValueRangeProp/">
    http://www.pattosoft.com.au/jason/Papers/ValueRangeProp/</a>.</dd>
</dl>


<h3>Control transformations</h3>

<dl>
<dt><em>Normalization of array access functions</em></dt>
<dd>This pass should gather the information decomposed by
    gimplification into well formed access functions.  A further
    simplification should simplify these functions in order to get
    functions of loop indices.  This form is needed in dependence
    tests.  The implementation of this normalization is very similar
    to the search of loop induction variables by following use-defs
    chains and reconstructing the corresponding tree.  Arithmetic
    simplification of expressions can be performed since we work on
    integers.</dd>
<dt><em>Loop canonicalization</em></dt>
<dd>This pass should construct Fortran like loops: a single induction
    variable by loop, the iteration begins at zero, and a step of one.
    If a loop has more than one induction variables, then it is
    possible to choose one of them, and express other variables in
    function of the first one.</dd>
<dt><em>Temporal locality of data references</em></dt>
<dd>This pass builds a geometrical representation of the order in
    which data sets are accessed.  It transforms loop iterations in
    order to keep data references in caches.  The algorithm is
    described in these
    <a href="http://icps.u-strasbg.fr/pco/locality.htm">papers</a> and
    implemented in a source-to-source
    <a href="http://icps.u-strasbg.fr/cgi-bin/temporal/temporal.cgi">
    translator</a>
    for Fortran.</dd>
</dl>


<hr />
<h2>References</h2>

<dl>
<dt><a name="cytron.ea-91">[1]</a></dt>
<dd>R.&nbsp;Cytron, J.&nbsp;Ferrante, B.&nbsp;Rosen, M.&nbsp;Wegman, and K.&nbsp;Zadeck.
Efficiently Computing Static Single Assignment Form and the Control Dependence Graph.
<em>ACM Transactions on Programming Languages and Systems</em>, 13(4): 451-490, October 1991.</dd>

<dt><a name="hendren.ea-92">[2]</a></dt>
<dd>L.&nbsp;Hendren, C.&nbsp;Donawa, M.&nbsp;Emami, G.&nbsp;Gao, Justiani, and B.&nbsp;Sridharan.
Designing the McCAT compiler based on a family of structured intermediate representations.
In <em>Proceedings of the 5th International Workshop on Languages
 and Compilers for Parallel Computing</em>, pages 406-420. Lecture Notes in
 Computer Science, no. 457, Springer-Verlag, August 1992.</dd>

<dt><a name="morgan-98">[3]</a></dt>
<dd>Robert&nbsp;Morgan.
<em>Building an Optimizing Compiler</em>, Butterworth-Heinemann, 1998.</dd>

<dt><a name="wegman.ea-91">[4]</a></dt>
<dd>Mark&nbsp;N.&nbsp;Wegman and F.&nbsp;Kenneth&nbsp;Zadeck.
Constant Propagation with Conditional Branches.
<em>ACM Transactions on Programming Languages and Systems</em>, 13(2): 181-210, April 1991.</dd>

<dt><a name="chow.ea-97">[5]</a></dt>
<dd>Robbert&nbsp;Kennedy, Sun&nbsp;Chan, Shin-Ming&nbsp;Liu, Raymond&nbsp;Lo, Peng&nbsp;Tu, and Fred&nbsp;Chow.
Partial Redundancy Elimination in SSA Form.
<em>ACM Transactions on Programming Languages and Systems</em>, 21(3): 627-676, 1999.</dd>

<dt><a name="patterson-95">[6]</a></dt>
<dd>Jason&nbsp;R.&nbsp;C.&nbsp;Patterson.
Accurate Static Branch Prediction by Value Range Propagation.
<em>Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation</em>, pages 67-78, June 1995.</dd>

</dl>

</body>
</html>
