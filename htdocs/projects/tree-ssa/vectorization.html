<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta name="generator" content=
    "HTML Tidy for Linux/x86 (vers 1st July 2003), see www.w3.org" />
    <meta http-equiv="Content-Type" content="text/html" />

    <title>Auto-vectorization in GCC</title>
</head>

<body>
    <h1 align="center">Auto-vectorization in GCC:<br />
    A preliminary high level plan of implementation</h1>

    <p>This document outlines a high level plan for the
    implementation of auto-vectorization in the <a href=
    "./">tree-ssa branch</a> of GCC. The main goals of this
    document are to:</p>

    <ul>
        <li>
            <h3>Facilitate contributing to the different
            vectorization-related components.</h3>

            <p>Vectorization consists of many independent
            components. While some basic infrastructure will be
            required by all vectorization "clients", there are many
            directions by which this basic infrastructure can be
            enhanced. The decision on which directions to pursue
            first is in many cases guided by the specific
            properties of a given target architecture and target
            application domain. Therefore, it is important to keep
            developers informed about the implementation status of
            these different directions, and allow them to push
            those directions that are more important for their
            targets (but possibly too far down the vectorizer's
            todo list).</p>
        </li>

        <li>
            <h3>Increase synchronization and minimize work
            duplication.</h3>

            <p>Vectorization consists of, or can benefit from,
            components that are used by other compiler
            optimizations; some of these components are already
            under development. The hope is that exposing the list
            of components that the vectorizer may need to interact
            with, would help to increase the synchronization
            between the vectorizer and other components and assist
            in minimizing work duplication.</p>
        </li>

        <li>
            <h3>Expose this work.</h3>

            <p>Allow early exposure of this work, in order to be
            able to get feedback. All tree-ssa developers are
            encouraged to comment on the infrastructure that is
            available (or is being or will be developed) in the
            tree-ssa and its implications on the items listed
            here.</p>
        </li>
    </ul>

    <p>This document tries to serve the above goals by,</p>

    <ol>
        <li>providing a list all the issues that vectorization may
        need to handle,</li>

        <li>breaking the implementation into independent tasks as
        much as possible, and</li>

        <li>proposing a gradual implementation that consists of a
        very limited vectorizer as a first step, which will be
        gradually extend in different directions.</li>
    </ol>

    <p>Related discussion threads: <a href=
    "http://gcc.gnu.org/ml/gcc/2003-07/msg01309.html">http://gcc.gnu.org/ml/gcc/2003-07/msg01309.html.</a><br />

    This web page is managed by <a href=
    "mailto:dorit@il.ibm.com">Dorit Naishlos &lt;dorit at il dot
    ibm dot com&gt;</a>.</p>

    <h2>General Vectorization Scheme</h2>

    <p>The table below outlines the high level vectorization scheme
    along with a proposal for an implementation scheme, as
    follows:</p>

    <ul>
        <li>
            <p>The first column ("vectorization driver") lists the
            tasks that the vectorizer must consist of. It briefly
            describes the expected functionality of each task.</p>
        </li>

        <li>
            <p>The second column ("basic-vectorizer") describes a
            proposal for a basic vectorizer that provides minimal
            support for each of these tasks, listing the
            restrictions that will be imposed by the basic
            vectorizer on candidate loops. Loops that are
            considered vectorizable by the basic-vectorizer are of
            the form: <tt>for(i=0; i&lt;N; i++) {a[i] = b[i] +
            c[i]; }.</tt> The "basic vectorizer" is implemented
            by&nbsp; Dorit Naishlos.</p>
        </li>

        <li>
            <p>The third column ("enhancements") lists possible
            directions for extending the capabilities of the basic
            vectorizer. Some of these enhancements are aimed at
            improving the quality of the vector code that is being
            generated. Other enhancements aim at broadening the
            range of computations that are amenable for
            vectorization. Other focus on improved robustness.
            Following the table is a complete and detailed list of
            these enhancements. Next to each item which is already
            being addressed, there should be the name of the
            relevant contact person.</p>
        </li>
    </ul>

    <table width="98%" border="1">
        <tbody>
            <tr valign="top">
                <td width="33%"><b>vectorization driver</b></td>

                <td width="33%"><b>basic vectorizer</b></td>

                <td width="33%"><b>enhancements</b></td>
            </tr>

            <tr valign="top">
                <td>
                    <tt>analyze_loop_CFG(loop)</tt>

                    <p>Checks the <a href="#loopCFG">control flow
                    properties of the loop</a> (number of
                    basic-blocks it consists of, nesting, single
                    entry/exit, etc.), in order to determine
                    whether the control flow of the loop falls
                    within the range of loop forms that are
                    supported by this vectorizer.</p>
                </td>

                <td>
                    <ul>
                        <li>inner-most (single nest) loops.</li>

                        <li>single basic block loops; i.e., no
                        if-then-else constructs, etc. (in practice
                        this means loops that consist of exactly
                        two basic blocks - header+latch).</li>

                        <li>other restrictions (single
                        successor/predecessor, a pre-header
                        block).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>use <a href="#IdiomRecognition">idiom
                        recognition</a> to collapse
                        <tt>if-then-else</tt> constructs into a
                        straight line code.</li>

                        <li>handle <a href="#cond">conditional
                        execution</a></li>

                        <li>the above needs to be aware of <a href=
                        "#Machine">target specific vector
                        capabilities</a>.</li>

                        <li>extend the <a href="#LoopForms">range
                        of loop forms</a> that can be vectorized,
                        with respect to their CFG
                        characteristics.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_loop_index_and_bound(loop)</tt></p>

                    <p>Analyzes the loop termination condition to
                    determine the loop bound and properties of the
                    loop index (its bounds and step). The
                    functionality of this utility should be largely
                    provided by the information computed by the
                    <a href="#InductionVariable">Induction Variable
                    Analyzer</a>.</p>
                </td>

                <td>
                    <ul>
                        <li>handle simple normalized loops (loop
                        index is a trivial IV with step 1, etc.),
                        with a simple termination condition.</li>

                        <li>loop-bound known at compile time.</li>

                        <li><tt>loop-bound &gt;= vector_size</tt>
                        and <tt>loop-bound % vector_size =
                        0</tt>.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>relax the restrictions on the <a href=
                        "#LoopForms">loop bound</a> and <a href=
                        "#AccessPattern">loop index</a> imposed by
                        the basic vectorizer.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p><tt>analyze_loop_stmts(loop-stmts)</tt></p>

                    <p>Scan the loop statements and check whether
                    there are any statements that prohibit
                    vectorization (function calls, statements that
                    don't have a mapping to a built-in vector
                    function, etc.)</p>
                </td>

                <td>
                    <ul>
                        <li>simple operations for which there's a
                        1-1 mapping between the scalar and vector
                        operations.</li>

                        <li>no support for scalar expansion,
                        induction variables, reduction
                        operations...</li>

                        <li>no mixture of data types (all
                        statements operate on the same data
                        types).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>handle <a href="#computations">scalar
                        expansion</a>.</li>

                        <li>handle computations with <a href=
                        "#computations">mixed data types</a>.</li>

                        <li>Support operations that can't be
                        expressed using existing (scalar)
                        tree-codes; this requires <a href=
                        "#Machine">developing&nbsp; a mechanism to
                        expose to the compiler that such operations
                        are supportable</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_access_pattern(loop-mem-refs)</tt></p>

                    <p>Analyze the memory references in the loop,
                    and <a href="#AccessPattern">classify them
                    according to the access pattern</a> that they
                    exhibit.</p>
                </td>

                <td>
                    <ul>
                        <li>support only memory accesses which are
                        array references (no pointers...).</li>

                        <li>support only consecutive (unit stride)
                        access pattern.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>extend the access pattern analyzer to
                        handle pointer references</li>

                        <li>improve the <a href=
                        "#PointerAliasing">memory aliasing</a>
                        capabilities.</li>

                        <li>handle non consecutive access patterns
                        <a href="#Machine">if supported by the
                        target</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_alignment(loop-mem-refs)</tt></p>

                    <p>Analyze the alignment of the memory
                    references in the loop. For each memory
                    reference, record its misalignment amount, if
                    it can be resolved at compile time.</p>
                </td>

                <td>
                    <ul>
                        <li>misalignment amount for all memory
                        references is known at compile time.</li>

                        <li>misalignment is zero for all references
                        (all references are aligned).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li><a href="#Alignment">handle unaligned
                        accesses</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_loop_carried_dependences(loop)</tt></p>

                    <p>Build the loop dependence graph (for scalar
                    and array references); Detect Strongly
                    Connected Components (SCCs) in the graph
                    (statements that are involved in a dependence
                    cycle); Perform a topological sort on the
                    reduced graph (in which each SCC is represented
                    by a single node); Only singleton nodes w/o
                    self dependencies can be vectorized. If other
                    (compound) nodes (which represent SCCs) are
                    present, loop transformations are required.</p>
                </td>

                <td>
                    <ul>
                        <li>handle only loops that do not contain
                        any SCCs (i.e., no dependence cycles).</li>

                        <li>the only scalar loop-carried
                        dependencies allowed are of IVs which are
                        used in array references or for the loop
                        index (i.e., reduction is not
                        supported).</li>

                        <li>use simplest dependence tests.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>use more <a href="#Dependence">advanced
                        dependence tests</a>.</li>

                        <li>try to <a href="#Dependence">break
                        cycles in the dependence graph</a> of the
                        loop by performing <a href=
                        "#LoopTransform">loop transformations</a>
                        (or <a href="#IdiomRecognition">detecting
                        reduction</a>).</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>estimate_vectorization_profitability(loop)</tt></p>

                    <p>At this point, it has been determined that
                    the loop is vectorizable. It remains to decide
                    whether it is indeed profitable to vectorize
                    it.</p>
                </td>

                <td>
                    <ul>
                        <li>vectorize all loops with loop_bound
                        &gt;= MIN_LIMIT (?).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>develop a <a href="#Cost">cost
                        model</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p><tt>vectorize_loop(loop)</tt></p>

                    <p>Replace the scalar statements with the
                    corresponding vector statements (which could be
                    calls to builtin functions); Also change the
                    loop bound accordingly.</p>
                </td>

                <td>
                    <ul>
                        <li>use a <a href=
                        "#Machine">scalar-to-vector
                        mapping</a>.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li><a href="#OtherOptimizations.">misc.
                        optimizations</a>.</li>

                        <li><a href="#OtherIssues">misc. issues</a>
                        to consider.</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h2>List of Vectorization Related Tasks</h2>

    <p>The following is a list of independent directions by which
    the basic vectorizer can be enhanced. It should be possible for
    different people to work on different items on this list. Some
    of these items are already under development, or (partially)
    supported.</p>

    <ol>
        <li>
            <a name="loopCFG" id="loopCFG"></a>

            <h3>Loop detection and loop CFG analysis</h3>

            <p>Detect loops, and record some basic control flow
            information about them (contained basic blocks, loop
            pre-header, exit and entry, etc.).</p>

            <p><b>Status:</b> Loop detection and control flow
            analysis is already supported (<tt>cfgloop.c</tt>,
            <tt>cfgloopanal.c</tt>).</p>
        </li>

        <li>
            <a name="Machine" id="Machine"></a>

            <h3>Modeling the target machine vector capabilities to
            the <tt>tree</tt>-level.</h3>

            <p>Expose the required target specific information to
            the <tt>tree</tt> level. This includes providing a
            mapping from scalar operations to the corresponding
            vector support, which will answer the following
            questions:</p>

            <ol>
                <li>Does vector support for this operation
                exist?</li>

                <li>At what cost?</li>

                <li>How to express the vector operation at the
                <tt>tree-</tt>level?</li>
            </ol>

            <p>The general SIMD support in GCC already provides
            some initial support; For simple operations which can
            be expressed using existing (scalar)
            <tt>tree-codes</tt> (<tt>PLUS_EXPR, MULT_EXPR,</tt>
            etc.) the existing infra-structure can provide answers
            for questions 1 and 2 above, however, the
            <tt>tree-</tt>level currently does not have an idea
            about the cost that this transformation actually
            entails. A first basic implementation will support only
            simple operations that fall into the above category. As
            the capabilities of the vectorizer are extended, it
            will be required to inform the vectorizer of the
            advanced capabilities available in the architecture
            (for example, support for operations on complex
            numbers, reduction, etc.). Such operations cannot be
            expressed using existing tree-codes. Possible
            solutions: introduce new tree-codes (and corresponding
            optabs); introduce new builtins that are exposed to the
            compiler; use target hooks to handle these cases (the
            hook could return a call to a machine specific builtin
            function). Another related design question that needs
            to be addressed here is how much information to expose
            to the tree-level (is it sufficient to indicate that
            conditional vector addition is supported, or do we want
            the vectorizer to actually generate the required
            masking/predication/select operations depending on the
            target? similarly for alignment, multiplication of
            integers, etc.).</p>

            <p><b>Status:</b> Open for discussion. Contact: Dorit
            Naishlos; Martin Brain.<br />
            Related discussion: <a href=
            "http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html">
            http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html</a></p>
        </li>

        <li>
            <a name="mapping" id="mapping"></a>

            <h3>Enhance the Builtins Support</h3>

            <p>Currently the tree optimizers do not know the
            semantics of target specific builtin functions, so they
            do not attempt to optimize them (or to SSA the
            variables passed as arguments to these functions).
            Since the vectorizer will probably end up generating
            calls to target specific builtin functions, this
            situation needs to be improved, i.e. - the semantics of
            these builtins needs to somehow be exposed to the
            compiler.</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <a name="Cost" id="Cost"></a>

            <h3>Cost Model</h3>

            <p>There is an overhead associated with vectorization
            -- moving data in to/out of vector registers
            before/after the vectorized loop, aligning of data
            accesses, etc. It is required to incorporate a cost
            model into the machine description in order to allow
            the vectorizer to evaluate whether it is worth while to
            vectorize a given loop. One can also consider using run
            time tests to decide which version of the loop to
            execute (scalar or vectorized).</p>

            <p><b>Status:</b> Open for discussion. Contact: Martin
            Brain.<br />
            Related discussion: <a href=
            "http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html">
            http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html</a></p>
        </li>

        <li>
            <a name="InductionVariable" id="InductionVariable"></a>

            <h3>Induction Variable Analysis</h3>

            <p>Used by the vectorizer to detect loop bound, analyze
            access patterns and analyze data dependencies between
            array references. One option is that the dependence
            tests would be designed deal with array references that
            are expressed in terms of a linear function of the
            iteration counter (in this case, vectorization will
            also benefit from optimizations like induction variable
            substitution and replacement of auxiliary IVs with
            linear functions of the loop index). A dependence
            tester that is based on IVs represented in this form
            would analyze each subscript of each array reference,
            and apply the appropriate dependence test (SIV, ZIV,
            MIV etc., see <a href="#Dependence">dependence
            testing</a>). Alternatively, an induction variable
            evolution analyzer could provide a different
            implementation to the dependence tester. This is the
            solution that is currently used, based on the Induction
            Variable evolution analysis developed by Sebastian
            Pop.</p>

            <p><b>Status:</b> Using the IV evolution analyzer
            developed by Sebastian Pop.</p>
        </li>

        <li>
            <a name="Dependence" id="Dependence"></a>

            <h3>Dependence Testing</h3>

            <p>Following the classic dependence-based approach for
            vectorization as described in <a href=
            "#kenedy-book">[1]</a>, apply dependence tests to pairs
            of array references in each loop nest, and analyze the
            resulting dependence graph. We will start from a
            dependence analyzer that relies on the array references
            being expressed in terms of a linear function of the
            loop index, apply the simplest dependence tests to all
            pairs of memory read/write and write/write, and
            gradually extend its capabilities. The scheme below
            follows the algorithm described in <a href=
            "#tseng">[2]:</a></p>

            <ul>
                <li>Partition the array subscripts into separable
                sets (subscripts which index does not occur in
                other subscripts).</li>

                <li>Apply the simplest tests for separable
                subscripts (strong SIV (single index variable)
                tests).</li>

                <li>Incorporate more advanced dependence tests;
                first, tests for separable subscripts - e.g., weak
                SIV tests, MIV (Multiple Index Variable) tests,
                followed by tests for coupled subscripts, possibly
                up to integer linear programming like
                Fourier-Motzkin elimination.</li>

                <li>Compute dependence distance, and prune
                dependencies with distance &gt; vector_size.</li>

                <li>Try to handle cycles in the dependence graph of
                the loop (by performing loop distribution,
                etc.).</li>

                <li>Generalize the dependence tester to nested
                loops.</li>
            </ul>

            <p><b>Status:</b> Some preliminary trivial tests are
            implemented to prove independence.</p>
        </li>

        <li>
            <a name="AccessPattern" id="AccessPattern"></a>

            <h3>Access Pattern Analysis</h3>

            <p>The memory architecture usually allows only
            restricted accesses to data in memory; one of the
            restrictions is that the accessed data must be
            consecutive in memory. Any other accesses (strided for
            example) require to perform special permutation of the
            data in order to pack the data elements in the right
            order into a vector register. Support for different
            access patterns consists of the following stages:</p>

            <ul>
                <li>Classify the access pattern of each array
                reference.</li>

                <li>Trivially handle consecutive (unit stride)
                access patterns (a[i]).</li>

                <li>Handle strided access patterns (a[2*i]). The
                stride 2 access pattern appears in computations on
                complex numbers, where the real and imaginary parts
                are interleaved in the input/output array.</li>

                <li>Handle other types of access patterns?</li>

                <li>Support pointer arithmetic.</li>
            </ul>

            <p>In order to facilitate a scheme that trivially
            replaces each operation with its equivalent SIMD
            instruction, a preprocessing pass may need to take
            place in order to convert the scalar operations into a
            proper (scalar) form. For example, the following code
            sequence is generated in order to represent the
            expression <tt>'a[2*i+1] = b[i]</tt>':</p>

            <ol>
                <li><tt>T.1 = i * 2;</tt></li>

                <li><tt>T.2 = T.1 + 1;</tt></li>

                <li><tt>a[T.2] = b[i];</tt></li>
            </ol>

            <p>These operations (1 and 2 in the example) determine
            the data permutation that will be performed, however,
            they do not need to be directly vectorized. It maybe
            required to mark such code to indicate that no vector
            code needs to be generated for it; instead, we may want
            to consider collapsing this code into the relevant
            array reference, similarly to forward substitution (but
            this would probably mean breaking the GIMPLE
            conventions?).</p>

            <p><b>Status:</b> Currently, the access function is
            determined using the <a href=
            "#InductionVariable">evolution analyzer</a>. Statements
            that are only used for address computations will bw
            detected and handled accordingly. Contact: Dorit
            Naishlos.</p>
        </li>

        <li>
            <a name="computations" id="computations"></a>

            <h3>Extend the range of supportable operations</h3>

            <p>At first, the only computations that will be
            vectorized are those for which the vectorization
            process consists of trivially replacing each scalar
            operation in the loop with its vector counterpart. This
            includes simple loads, stores and arithmetic operations
            that operate on the same data type. Some computations
            require extra code to be generated in order to
            vectorize. These include:</p>

            <ul>
                <li>computations with mixed types; these require
                proper promotion/demotion between vectors of
                different sizes.</li>

                <li>computations that involve loop invariants
                (<tt>a[i] = N</tt>) and require scalar
                expansion.</li>

                <li>computations that involve induction variables
                (<tt>a[i] = i</tt>), require scalar expansion, and
                proper initialization and update code.</li>
            </ul>

            <p><b>Status:</b> Depending on the design decisions
            with respect to the <a href="#Machine">machine
            modeling</a>, some of these issues maybe hidden in the
            machine description, alleviating the vectorizer from
            the need to generate the special extra code. Contact:
            Dorit Naishlos.</p>
        </li>

        <li>
            <a name="Alignment" id="Alignment"></a>

            <h3>Alignment</h3>

            <p>The memory architecture usually allows only
            restricted accesses to data in memory. One of the
            restrictions is that data accesses need to be properly
            aligned on a certain boundary. Even if the architecture
            supports unaligned accesses, these are usually much
            more costly than aligned accesses. The work on
            alignment consists of several stages:</p>

            <ul>
                <li>Compute the misalignment properties of each
                memory access.</li>

                <li>Handling of aligned memory accesses only (do
                not attempt to vectorize loops that contain
                unaligned accesses).</li>

                <li>If it is impossible to determine at compile
                time whether the memory access is aligned, <a href=
                "#versioning">create two versions of the loop and
                use a runtime test</a> to decide which version to
                execute: the original scalar version (if the data
                access is not aligned), or the vectorized version
                (if the access is aligned).</li>

                <li>Develop optimizations that increase the
                alignment of data accesses (static loop peeling,
                dynamic loop peeling, etc.).</li>

                <li>Vectorize unaligned accesses. There are
                different ways to do that, depending on whether the
                target supports unaligned accesses, and also
                depending on what we want to implement at the tree
                level, and what we want to leave for the RTL level
                to handle. For example, one could generate the
                required code to support a miss-aligned memory
                access (for miss-aligned loads, generate an
                additional load and the required merging code).
                Alternatively, the tree level could just generate a
                "VEC_UNALIGNED_LOAD" statement, that will be
                translated later in the RTL level into the
                appropriate RTL sequence that handles the unaligned
                load (in a target dependent way). This means
                however that optimizations that try to reduce the
                merging overhead cannot take place at the tree
                level, where it is probably easier to do than at
                the RTL level.</li>
            </ul>

            <p><b>Status:</b> Some of this functionality can be
            ported from the rtlopt branch. Contact: Steven
            Bosscher.</p>
        </li>

        <li>
            <a name="IdiomRecognition" id="IdiomRecognition"></a>

            <h3>Idiom Recognition</h3>

            <p>It is often the case that complicated computations
            can be reduced into a simpler, straight-line sequence
            of operations. These operations may not be directly
            supported in a scalar form, but are supported by the
            target in a vector form. Such cases include:</p>

            <ul>
                <li>Reduction operations:

                    <ul>
                        <li>Detect different kinds of reduction
                        (summation, min/max, min/max with index,
                        etc.); once detected, these idioms may be
                        replaced with a virtual scalar operation
                        (to facilitate straight forward vector code
                        generation).</li>

                        <li>Vectorizing the reduction requires
                        generating epilog code after the loop.
                        First, generate a scalar code sequence to
                        compute the epilog. Later, try to make use
                        of target dependent mechanisms to compute
                        the epilog of the reduction more
                        efficiently.</li>
                    </ul>
                </li>

                <li>Special patterns that are supported by the
                architecture. <a href="#cond">This may involve
                collapsing multi-block constructs (such as
                <tt>if-then-else</tt>)</a> into a single
                vectorizable operation. For example, in the
                following code sequence (taken from the SPECint
                benchmark gzip) the conditional expression can be
                collapsed into a "subtract and saturate" operation
                (see <a href=
                "http://gcc.gnu.org/ml/gcc/2003-07/msg01355.html">
                    http://gcc.gnu.org/ml/gcc/2003-07/msg01355.html</a>):

                    <p><tt>&nbsp;for (n = 0; n &lt; HASH_SIZE; n++)
                    {</tt><br />
                    <tt>&nbsp; m = head[n];</tt><br />
                    <tt>&nbsp; head[n] = (Pos)(m &gt;= 32768 ?
                    m-32768 : 0);</tt><br />
                    <tt>&nbsp;}</tt></p>
                </li>

                <li>Detect saturation idioms, and map them to the
                appropriate vector operation.</li>
            </ul>

            <p><b>Status:</b> Contact: Dorit Naishlos.</p>
        </li>

        <li>
            <a name="cond" id="cond"></a>

            <h3>Conditional Execution</h3>

            <p>The general principle we are trying to follow is to
            keep the actual code transformation part of the
            vectorizer as simple as possible: a simple scan of
            straight-line code, and a one-to-one replacement of
            each scalar operation with the equivalent vector
            operation. To support this scheme in the presence of
            conditional execution, we'll need to flatten the loop
            body by collapsing if-then-else into a conditional
            (scalar) operation (something like transforming -
            '<tt>if (x) {c = PLUS (a,b)}</tt>' into
            '<tt>PLUS_COND(a,b,x)</tt>'. These will later be
            replaced with a conditional vector operation using
            whatever support is available in the target (masking,
            predication or select operation). Flattening the loop
            body this way will greatly simplify the vectorizer.
            Some of the issues to think about here: (a) how to
            represent these conditional operations, (b) to what
            extent does the tree vectorizer need to be aware of the
            specific target support that is available for
            conditional vector execution (mask/predicate/select),
            and (c) how to allow a simple way to reverse this
            transformation if the loop doesn't end up getting
            vectorized.</p>

            <p><b>Status:</b> Contact: Devang Patel.</p>
        </li>

        <li>
            <a name="LoopForms" id="LoopForms"></a>

            <h3>Handle Advanced Loop Forms</h3>

            <ol>
                <li>Support general loop bound (unknown, or doesn't
                divide by the vector size).</li>

                <li>Support more complex forms of loop termination
                condition and loop index update.</li>

                <li>Support outer-loop vectorization (unroll and
                jam).</li>

                <li>Relax other restrictions on the loop form.</li>
            </ol>

            <p><b>Status:</b> Future work.</p>
        </li>

        <li>
            <a name="PointerAliasing" id="PointerAliasing"></a>

            <h3>Handle Pointer Aliasing</h3>

            <ol>
                <li>Develop anti-aliasing analysis.</li>

                <li>Generate run-time tests for cases where memory
                anti-aliasing cannot be resolved at compile
                time.</li>

                <li>Support user hints?</li>
            </ol>

            <p><b>Status:</b> Some aliasing infrastructure is
            available. Andersen points-to analysis also
            available.</p>
        </li>

        <li>
            <h3>Aliasing and Virtual def-use Chains</h3>

            <p>&nbsp;Address the item from the <a href=
            "http://gcc.gnu.org/projects/tree-ssa/#todo">tree-ssa
            todo list</a> -&nbsp;"SSA information for arrays : The
            existing implementation treats arrays as an opaque
            object. A definition to an array location is treated as
            a definition for the whole array"</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <h3>Array addressing Represented as Pointer
            Arithmetic</h3>

            <p>Address the issue mentioned in <a href=
            "http://gcc.gnu.org/ml/gcc/2003-07/msg02013.html">http://gcc.gnu.org/ml/gcc/2003-07/msg02013.html</a>,
            which turns out to be a front end issue.</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <a name="versioning" id="versioning"></a>

            <h3>Loop versioning</h3>

            <p>Provide utilities that allow performing the
            following transformation: Given a condition and a loop,
            create -'if (condition) { loop_copy1 } else {
            loop_copy2 }', where loop_copy1 is the loop transformed
            in one way, and loop_copy2 is the loop transformed in
            another way (or unchanged). 'condition' may be a run
            time test for things that were not resolved by static
            analysis (overlapping ranges (anti-aliasing),
            alignment, etc.).</p>

            <p><b>Status:</b> Contact: Devang Patel.</p>
        </li>

        <li>
            <a name="LoopTransform" id="LoopTransform"></a>

            <h3>Loop Transformations to Increase Vectorizability of
            Loops</h3>

            <p>These include:</p>

            <ul>
                <li>loop interchange, and other unimodular
                transformations.</li>

                <li>scalar expansion.</li>

                <li>loop distribution.</li>

                <li>collapsing tightly nested loops to a single
                loop.</li>

                <li>loop unswitching.</li>
            </ul>

            <p><b>Status:</b> Some of this functionality can be
            ported from the rtlopt branch. Daniel Berlin is working
            on loop interchange.</p>
        </li>

        <li>
            <a name="OtherOptimizations." id=
            "OtherOptimizations."></a>

            <h3>Other Optimizations</h3>

            <ol>
                <li>Exploit data reuse (a la "Compiler-Controlled
                Caching in Superword Register Files for Multimedia
                Extension Architectures" by Shin, Chame and Hall).
                Mostly relies on unroll &amp; jam having been
                applied.</li>

                <li>Vectorize loops that can't be vectorized using
                the classic vectorizer (until the proper loop
                transformations are developed) by applying SLP
                vectorization (a la "Exploiting Superword Level
                Parallelism with Multimedia Instruction Sets" by
                Amarasinghe and Larsen). This scheme can
                potentially more easily vectorize partially
                vectorizable loops, or loops that are already
                unrolled in the source code. It is possible to
                implement SLP vectorization either in the tree
                level or at the RTL level as a complementary
                approach to classic loop vectorization.</li>
            </ol>

            <p><b>Status:</b> Future work.</p>
        </li>

        <li>
            <a name="OtherIssues" id="OtherIssues"></a>

            <h3>Other Issues to consider</h3>

            <ol>
                <li>Using user hints for different purposes
                (aliasing, alignment, profitability of vectorizing
                a loop, etc.).</li>

                <li>Decide which of the items listed above should
                take place in the GIMPLE tree level, and which in
                the RTL level. For example, anything that could
                affect the decision whether to vectorize a loop,
                should take place at the tree level (in order to
                avoid having to undo transformations); also, many
                of the things that can take place at the RTL level
                maybe simpler to implement at the tree level.
                However, this would mean that a lot of machine
                dependent stuff will have to be done at the tree
                level.</li>
            </ol>

            <p><b>Status:</b> Open for discussion.</p>
        </li>
    </ol>

    <h2>(Incomplete) Reference list</h2>

    <ol>
        <li><a name="kenedy-book" id="kenedy-book"></a>"Optimizing
        Compilers for Modern Architectures - A dependence based
        approach", Randy Allen &amp; Ken Kennedy, Morgan Kaufmann
        Publishers, San Francisco, San Diego, New York (2001).</li>

        <li><a name="tseng" id="tseng"></a>"Practical Dependence
        Testing", Gina Goff, Ken Kennedy, Chau-Wen Tseng, CRPC+TR
        90103, November 1990.</li>
    </ol>
</body>
</html>
