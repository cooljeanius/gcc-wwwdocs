<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta name="generator" content=
    <meta http-equiv="Content-Type" content="text/html" />

    <title>Auto-vectorization in GCC</title>
</head>

<body>
    <h1>Auto-vectorization in GCC<br /></h1>

    <p>The goal of this project is to develop a loop vectorizer in
    GCC, based on the <a href="./">tree-ssa</a> framework. This
    work is taking place in the <a href=
    "lno.html">lno-branch</a>.</p>

    <h2>Table of Contents</h2>

    <ul>
        <li><a href="#using">Using the Vectorizer</a></li>

        <li><a href="#vectorizab">Vectorizable Loops</a></li>

        <li><a href="#unvectoriz">Unvectorizable Loops</a></li>

        <li><a href="#status">Status</a></li>

        <li><a href="#related">Related Links</a></li>

        <li><a href="#vec_todo">In The Works</a></li>

        <li><a href="#high-level">High-Level Plan of
        Implementation</a></li>

        <li><a href="#list">ToDo List</a></li>
    </ul>

    <h2><a name="using" id="using">Using the Vectorizer</a></h2>

    <p>Vectorization is enabled by the flag <code>-ftree-vectorize</code>. To
    allow vectorization on powerpc platforms also use <code>-maltivec</code>. On
    i?86 and x86_64 platforms use <code>-msse/-msse2</code>. The vectorizer test
    cases demonstrate the currrent vectorization capabilities;
    these can be found under
    gcc/gcc/testsuite/gcc.dg/tree-ssa-vect/. Information on which
    loops were or were not vectorized and why, can be obtained
    using the flag <code>-fdump-tree-vect-stats</code>. For example, this is the
    output that the vectorizer generates for test case
    tree-ssa-vect-1.c:</p>
    <pre>
loop at tree-ssa-vect-1.c:35: not vectorized: unsupported scalar cycle.
loop at tree-ssa-vect-1.c:45: not vectorized: multi-dimensional array.
loop at tree-ssa-vect-1.c:53: LOOP VECTORIZED.
loop at tree-ssa-vect-1.c:60: LOOP VECTORIZED.
loop at tree-ssa-vect-1.c:67: not vectorized: complicated access pattern.
loop at tree-ssa-vect-1.c:75: LOOP VECTORIZED.
loop at tree-ssa-vect-1.c:86: not vectorized: mixed data-types
loop at tree-ssa-vect-1.c:95: not vectorized: dependence between refs to same array: a
vectorized 3 loops in function.
</pre>

    <h2><a name="vectorizab" id="vectorizab">Vectorizable
    Loops</a></h2>

    <p>Examples of loops that can currently be vectorized by lno-branch
    (unless indicated otherwise). "feature" indicates the vectorization
    capabilities demonstrated by the example.</p>

<strong><a name="example1" id="example1">example1:</a></strong>
<pre>
int a[256], b[256], c[256];
foo () {
  for (i=0; i&lt;256; i++){
    a[i] = b[i] + c[i];
  }
}
</pre>
<strong><a name="example2" id="example2">example2</a>:</strong>
<pre>
int a[256], b[256], c[256];
foo (int n, int x) {

   /* feature: support for unknown loop bound  */
   /* feature: support for loop invariants  */
   for (i=0; i&lt;n; i++)
      b[i] = x;
   }

   /* feature: general loop exit condition  */
   /* feature: support for bitwise operations  */
   while (n--){
      a[i] = b[i]&amp;c[i]; i++;
   }
}
</pre>

<strong><a name="example3" id="example3">example3</a>:</strong>
<pre>
typedef int aint __attribute__ ((__aligned__(16)));
foo (int n, aint * __restricted__ p, aint * __restricted q) {

   /* feature: support for pointer accesses.  */
   while (n--){
      *p++ = *q++;
   }
}
</pre>

<strong><a name="example4" id=
"example4">example4</a></strong> (on apple-ppc-branch only):
<pre>
typedef int aint __attribute__ ((__aligned__(16)));
int a[256], b[256], c[256];
foo (int n, aint * __restricted__ p, aint * __restricted__ q) {

   /* features: support for pointer accesses and constants  */
   while (n--){
      *p++ = *q++ + 5;
   }

   /* feature: support for read accesses with a compile time known misalignment  */
   for (i=0; i&lt;n; i++){
      a[i] = b[i+1] + c[i+3];
   }

   /* feature: support for if-conversion  */
   for (i=0; i&lt;n; i++){
      j = a[i];
      b[i] = (j &gt; MAX ? MAX : 0);
   }
}
</pre>

<strong><a name="example51" id="example51">example5</a></strong>:
<pre>
for (i = 0; i &lt; N; i++)
  {
    /* feature: struct access  */
    s.ca[i] = 5;
  }
</pre>

<a name="example61" id=
"example61"><strong>example6</strong> (gfortran):</a>
<pre>
DIMENSION A(1000000), B(1000000), C(1000000)
READ*, X, Y
A = LOG(X); B = LOG(Y); C = A + B
PRINT*, C(500000)
END
</pre>

<strong><a name="example5" id=
"example5">example7</a></strong> (on apple-ppc-branch only):
<pre>
int a[256], b[256];
foo (int x) {

   /* feature: support for read accesses with an unknown misalignment  */
   for (i=0; i&lt;N; i++){
      a[i] = b[i+x];
   }
}
</pre>

<strong><a name="example6" id=
"example6">example8</a></strong> (on apple-ppc-branch only):
<pre>
typedef unsigned char auchar __attribute__ ((__aligned__(16)));
foo (auchar * __restricted__ srcA,
     auchar * __restricted__ srcB,
     auchar * __restricted__ dest, unsigned char alpha){
  unsigned char not_alpha = 255 - alpha;

  /* feature: pattern recognition  */
  for (i = 0; i &lt; N; i++){
     unsigned short a1 = srcA[i] * alpha;
     unsigned short a2 = srcB[i] * not_alpha;
     unsigned char b1 = a1 &gt;&gt; 8;
     unsigned char b2 = a2 &gt;&gt; 8;
     dest[i] = b1 + b2;
  }
}
</pre>

    <h2><a name="unvectoriz" id="unvectoriz">Unvectorizable
    Loops</a></h2>

    <p>Examples of loops that currently cannot be vectorized:</p>

<strong>example1</strong>: uncountable loop:
<pre>
while (*p != NULL) {
  *q++ = *p++;
}
</pre>

<strong>example2</strong>: reduction, induction:
<pre>
diff = 0;
for (i = 0; i &lt; N; i++) {
  diff += (a[i] - b[i]);
}

for (i = 0; i &lt; N; i++) {
  a[i] = i;
}
</pre>

<strong>example3</strong>: strided access - the data elements that can be
operated upon in parallel are not consecutive - they are accessed with a
stride > 1 (in the example, the stride is 2):
<pre>
for (i = 0; i &lt; N/2; i++){
  a[i] = b[2*i+1] * c[2*i+1] - b[2*i] * c[2*i];
  d[i] = b[2*i] * c[2*i+1] + b[2*i+1] * c[2*i];
}
</pre>

<strong>example4</strong>: data-types of different sizes - currently only
a single vector-size per target is supported; it can accommodate 
vector-size/element-size elements (e.g, 4 ints, 8 shorts, 16 chars for a 
vector of size 16 bytes). A combination of data-types of different sizes in 
the same loop requires special handling which is not yet supported):
<pre>
short *sa, *sb, *sc;
int *ia, *ib, *ic;
for (i = 0; i &lt; N; i++) {
  ia[i] = ib[i] + ic[i];
  sa[i] = sb[i] + sc[i];
}

for (i = 0; i &lt; N; i++) {
  ia[i] = (int) sb[i];
}
</pre>

    <h2><a name="status" id="status">Status</a></h2>

    <dl>
        <dt>The main development branch is the lno-branch. In some
        cases, a certain functionality is first implemented in
        apple-ppc-branch, as a preliminary step before committing
        it to lno-branch in a more generic form.</dt>
    </dl>

    <dl>
        <dt><strong>2004-07-20, lno-branch</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li>The loop bound (number of iterations) can be
                unknown.</li>

                <li><strong>New</strong>: Supported memory accesses
                are one-dimensional arrays, <strong>which base can
                be a struct field,</strong> and which alignment can
                be forced (not extern arrays), and aligned pointers
                that are annotated as <code>__restricted__</code>.</li>

                <li>All memory accesses are consecutive (stride=1)
                and aligned.</li>

                <li>Supportable operations include plus/minus/mult,
                as well as bitwise operations -
                and/or/xor/1's-complement, according to available
                vector support in the target platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions (a[i]
                = i).</li>

                <li>Constants and invariants are supported (<code>a[i] =
                5</code>, <code>a[i] = x</code>).</li>

                <li><strong>New: first gfortran program
                vectorized.</strong></li>
            </ol>

            <p>Examples of newly vectorizable loops: <a href=
            "#example51">loop</a>, <a href=
            "#example61">loop</a></p>

            <p>New test-cases:</p>

            <ul>
                <li>tree-ssa-vect-31.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li>tree-ssa-vect-32.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li>tree-ssa-vect-33.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li>tree-ssa-vect-34.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li>tree-ssa-vect-35.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li>tree-ssa-vect-36.c: 1 of 1 loops vectorized
                (struct access)</li>

                <li><strong>total loops vectorized: 37 of 85 loops
                vectorized.</strong></li>
            </ul>
        </dd>
    </dl>

    <dl>
        <dt><strong>2004-06-25, apple-ppc-branch</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li>The loop bound (number of iterations) can be
                unknown.</li>

                <li>Supported memory accesses are one-dimensional
                arrays, and pointers. If more than one memory
                access is present in the loop, any pointers that
                are used in the loop have to be annotated as
                <code>__restricted__</code>.</li>

                <li>Store (memory-write) accesses have to be
                aligned.</li>

                <li><strong>New:</strong> Loads (memory-reads) can
                be unaligned <strong>by an unknown amount (e.g.
                access <code>a[i+x]</code>, where the value of x is
                unknown).</strong> <strong>Misalignment support for
                loads was also made more efficient.</strong></li>

                <li>All memory accesses are consecutive
                (stride=1).</li>

                <li>Supportable operations include plus/minus/mult,
                as well as bitwise operations -
                and/or/xor/1's-complement, according to available
                vector support in the target platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li>Some forms of if-then-else patterns can be
                vectorized.</li>

                <li><strong>New: Infrastructure for idiom
                recognition has been added. The first computation idiom
                that is recognized and vectorized is a
                multiplication of unsigned chars, whose (unsigned
                short) product is converted back to unsigned char
                (a similar computation comes up in pixel blending;
                we support a simplified version that does not
                require operating on different data
                types).</strong></li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions
		(<code>a[i] = i</code>).</li>

                <li>Constants and invariants are supported (<code>a[i] =
                5</code>, <code>a[i] = x</code>). <strong>New: Support for invariants
                was made more efficient.</strong></li>
            </ol>

            <p>Examples of newly vectorizable loops: <a href=
            "#example5">loop,</a> <a href="#example6">loop</a></p>
        </dd>
    </dl>

    <dl>
        <dt><strong>2004-06-23, lno-branch</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li>The loop bound (number of iterations) can be
                unknown.</li>

                <li>Supported memory accesses are one-dimensional
                arrays, which alignment can be forced (not extern
                arrays).</li>

                <li><strong>New: Memory accesses can also be
                pointer based. If more than one memory access is
                present in the loop, any pointers that are used in
                the loop have to be annotated as <code>__restricted__</code>.
                The pointers have to point to an aligned
                address.</strong></li>

                <li>All memory accesses are consecutive (stride=1)
                and aligned.</li>

                <li>Supportable operations include plus/minus/mult,
                as well as bitwise operations -
                and/or/xor/1's-complement, according to available
                vector support in the target platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions
		(<code>a[i] = i</code>).</li>

                <li>Constants and invariants are supported (<code>a[i] =
                5</code>, <code>a[i] = x</code>).</li>
            </ol>

            <p>Examples of newly vectorizable loops: <a href=
            "#example3">loop</a></p>

            <p>New test-cases:</p>

            <ul>
                <li>tree-ssa-vect-26.c: 0 of 1 loops vectorized
                (store with a compile-time known misalignment)</li>

                <li>tree-ssa-vect-27.c: 0 of 1 loops vectorized
                (load with a compile-time known misalignment)</li>

                <li>tree-ssa-vect-28.c: 0 of 1 loops vectorized
                (store with an unknown misalignment)</li>

                <li>tree-ssa-vect-29.c: 0 of 1 loops vectorized
                (load with an unknown misalignment)</li>

                <li>tree-ssa-vect-30.c: 1 of 1 loops vectorized
                (unknown loop bound)</li>

                <li>tree-ssa-vect-40.c: 1 of 1 loops vectorized
                (pointers; aligned and restricted).</li>

                <li>tree-ssa-vect-41.c: 0 of 1 loops vectorized
                (pointers; aligned).</li>

                <li>tree-ssa-vect-42.c: 1 of 1 loops vectorized
                (pointers; aligned and restricted).</li>

                <li>tree-ssa-vect-43.c: 1 of 1 loops vectorized
                (pointers; aligned).</li>

                <li>tree-ssa-vect-44.c: 0 of 1 loops vectorized
                (pointers; misaligned and restricted).</li>

                <li>tree-ssa-vect-45.c: 0 of 1 loops vectorized
                (pointers; misaligned).</li>

                <li>tree-ssa-vect-46.c: 0 of 1 loops vectorized
                (pointers; aligned and restricted, unknown loop
                bound).</li>

                <li>tree-ssa-vect-47.c: 0 of 1 loops vectorized
                (pointers; aligned, unknown loop bound).</li>

                <li>tree-ssa-vect-48.c: 0 of 1 loops vectorized
                (pointers; misaligned and restricted).</li>

                <li>tree-ssa-vect-49.c: 0 of 1 loops vectorized
                (pointers; amisligned).</li>

                <li>tree-ssa-vect-50.c: 0 of 1 loops vectorized
                (pointers; misaligned and restricted, unknown loop
                bound).</li>

                <li>tree-ssa-vect-51.c: 0 of 1 loops vectorized
                (pointers; misaligned, unknown loop bound).</li>

                <li>tree-ssa-vect-52.c: 0 of 1 loops vectorized
                (pointers; misaligned and restricted, unknown loop
                bound).</li>

                <li>tree-ssa-vect-53.c: 0 of 1 loops vectorized
                (pointers; misaligned, unknown loop bound).</li>

                <li>tree-ssa-vect-54.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount and
                restricted).</li>

                <li>tree-ssa-vect-55.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount).</li>

                <li>tree-ssa-vect-56.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount and
                restricted).</li>

                <li>tree-ssa-vect-57.c: 0 of 1 loops vectorized
                (pointers;misaligned by a known amount).</li>

                <li>tree-ssa-vect-58.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount and
                restricted, unknown loop bound).</li>

                <li>tree-ssa-vect-59.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount, unknown
                loop bound).</li>

                <li>tree-ssa-vect-60.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amountand
                restricted, unknown loop bound).</li>

                <li>tree-ssa-vect-61.c: 0 of 1 loops vectorized
                (pointers; misaligned by a known amount, unknown
                loop bound).</li>

                <li><strong>total loops vectorized</strong>: 31 of
                79 loops vectorized.</li>
            </ul>
        </dd>
    </dl>

    <dl>
        <dt><strong>2004-06-17, apple-ppc-branch</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li>The loop bound (number of iterations) can be
                unknown.</li>

                <li>Memory accesses are one dimensional-arrays,
                which alignment can be forced (not extern
                arrays).</li>

                <li><strong>New: Memory accesses can also be
                pointer based. If more than one memory access is
                present in the loop, any pointers that are used in
                the loop have to be annotated as <code>__restricted__</code>.
                (new experimental feature)</strong></li>

                <li><strong>New: Loads (memory reads) can be
                unaligned by a known amount (e.g. access <code>a[i+1]</code>,
                where array <code>a</code> is aligned and <code>i</code>
		starts from 0)</strong>. Stores (memory writes) still have to
                be aligned.</li>

                <li>All memory accesses are consecutive
                (stride=1).</li>

                <li>Supportable operations include plus/minus/mult,
                as well as bitwise operations -
                and/or/xor/1's-complement, according to available
                vector support in the target platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li><strong>New: Some forms of if-then-else patterns
                can be vectorized. (new experimental
                feature)</strong>.</li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions
		(<code>a[i] = i</code>).</li>

                <li>Constants and invariants are supported (<code>a[i] =
                5</code>, <code>a[i] = x</code>).</li>
            </ol>

            <p>Examples of newly vectorizable loops: <a href=
            "#example4">loop</a></p>
        </dd>
    </dl>

    <dl>
        <dt><strong>2004-06-04, lno-branch (and
        apple-ppc-branch)</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li><strong>New: No restrictions on the form of the
                loop index and the loop exit
                condition.</strong></li>

                <li><strong>New: The loop bound (number of
                iterations) can be unknown</strong>. Currently
                known loop-bounds still need to be divisible by the
                vectorization factor.</li>

                <li>All memory accesses are one dimensional-arrays,
                which alignment can be forced (not extern
                arrays).</li>

                <li>All array accesses are consecutive and aligned;
                i,e. all the array references are of the form
                <code>a[i]</code>, where <code>i</code> is updated from 0 to
		N in steps of 1.</li>

                <li><strong>New:</strong> Supportable operations
                include plus/minus/mult, <strong>as well as bitwise
                operations - and/or/xor/1's-complement</strong>,
                according to available vector support in the target
                platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions 
		(<code>a[i] = i</code>).</li>

                <li><strong>New: Constants and invariants are
                supported (<code>a[i] = 5</code>, <code>a[i] = x</code>)</strong>.</li>
            </ol>

            <p>Examples of newly vectorizable loops: <a href=
            "#example2">loop</a></p>

            <p>New test-cases:</p>

            <ul>
                <li>tree-ssa-vect-5.c: 2 of 2 loops vectorized
                (general exit condition and loop index)</li>

                <li>tree-ssa-vect-6.c: 2 of 2 loops vectorized
                (general exit condition and loop index)</li>

                <li>tree-ssa-vect-7.c: 2 of 2 loops vectorized
                (constnats)</li>

                <li>tree-ssa-vect-8.c: 1 of 1 loops vectorized
                (unknown loop bound)</li>

                <li>tree-ssa-vect-9.c: 0 of 1 loops vectorized
                (type casting)</li>

                <li>tree-ssa-vect-10.c: 0 of 1 loops vectorized
                (strided access)</li>

                <li>tree-ssa-vect-11.c: 0 of 1 loops vectorized
                (integer multiplication)</li>

                <li>tree-ssa-vect-12.c: 0 of 1 loops vectorized
                (multiple data types)</li>

                <li>tree-ssa-vect-13.c: 0 of 1 loops vectorized
                (if-then-else)</li>

                <li>tree-ssa-vect-14.c: 0 of 1 loops vectorized
                (induction)</li>

                <li>tree-ssa-vect-15.c: 0 of 1 loops vectorized
                (reverse access)</li>

                <li>tree-ssa-vect-16.c: 0 of 1 loops vectorized
                (reduction)</li>

                <li>tree-ssa-vect-17.c: 3 of 3 loops vectorized
                (bitwise and)</li>

                <li>tree-ssa-vect-18.c: 3 of 3 loops vectorized
                (bitwise or)</li>

                <li>tree-ssa-vect-19.c: 3 of 3 loops vectorized
                (bitwise xor)</li>

                <li>tree-ssa-vect-20.c: 3 of 3 loops vectorized
                (bitwise one's complement)</li>

                <li>tree-ssa-vect-21.c: 0 of 3 loops vectorized
                (logical not)</li>

                <li>tree-ssa-vect-22.c: 0 of 3 loops vectorized
                (negate)</li>

                <li>tree-ssa-vect-23.c: 0 of 3 loops vectorized
                (logical and)</li>

                <li>tree-ssa-vect-24.c: 0 of 3 loops vectorized
                (logical or)</li>

                <li>tree-ssa-vect-25.c: 2 of 2 loops vectorized
                (invariants)</li>

                <li><strong>total loops vectorized</strong>: 27 of
                52 loops vectorized</li>
            </ul>
        </dd>
    </dl>

    <dl>
        <dt><strong>2004-01-01, lno-branch</strong></dt>

        <dd>
            Description of vectorizable loops:

            <ol>
                <li>Inner most loops, that consist of a single
                basic block (i.e, straight-line code, no
                if-then-else).</li>

                <li>The loop has to be countable - i.e, the number
                of iterations can be evaluated before the loop
                starts to execute.</li>

                <li>Known (constant) loop bound, divisible by the
                vectorization factor.</li>

                <li>The loop index <code>i</code> is updated from 0 to N in
                steps of 1, and the loop exit condition is of the
                form <code>i&lt;N</code>.</li>

                <li>All memory accesses are one dimensional-arrays,
                which alignment can be forced (not extern
                arrays).</li>

                <li>All array accesses are consecutive (stride=1)
                and aligned.</li>

                <li>Supportable operations include plus/minus/mult,
                according to available vector support in the target
                platform.</li>

                <li>All operations operate on data types of the
                same size.</li>

                <li>No reductions (<code>sum += a[i]</code>) or inductions
		(<code>a[i] = i</code>).</li>

                <li>No Constants or invariants in the loop (<code>a[i] =
                5</code>).</li>
            </ol>

            <p>Examples of vectorizable loops: <a href=
            "#example1">loop</a></p>

            <p>New test-cases:</p>

            <ul>
                <li>tree-ssa-vect-1.c: 3 of 8 loops vectorized</li>

                <li>tree-ssa-vect-2.c: 1 of 1 loops vectorized</li>

                <li>tree-ssa-vect-3.c: 1 of 1 loops vectorized</li>

                <li>tree-ssa-vect-4.c: 1 of 1 loops vectorized</li>

                <li><strong>total loops vectorized</strong>: 6 of
                11 loops vectorized</li>
            </ul>
        </dd>
    </dl>

    <h2><a name="related" id="related">Related Links</a></h2>

    <p>Related discussion threads: <a href=
    "http://gcc.gnu.org/ml/gcc/2003-07/msg01309.html">http://gcc.gnu.org/ml/gcc/2003-07/msg01309.html.</a></p>

    <p>GCC summit paper: <a href=
    "http://people.redhat.com/lockhart/.gcc04/MasterGCC-2side.pdf">http://people.redhat.com/lockhart/.gcc04/MasterGCC-2side.pdf</a></p>

    <p>This web page is managed by <a href=
    "mailto:dorit@il.ibm.com">Dorit Naishlos &lt;dorit at il dot
    ibm dot com&gt;</a>.</p>

    <h2><a name="vec_todo" id="vec_todo">In The Works</a></h2>

    <p>Current contributors to this project include Olga
    Golovanevsky, Devang Patel, Ayal Zaks and Dorit Naishlos.
    Currently in the works:</p>

    <ol>
        <li>Merge the vectorizer from lno-branch to mainline</li>

        <li>Port new functionality from apple-ppc-branch to
        lno-branch</li>

        <li>Loop peeling to force alignment of accesses in the
        loop.</li>

        <li>Loop versioning, to create a version of the loop in
        which all accesses are aligned.</li>

        <li>Support for reduction and induction</li>
    </ol>

    <h2><a name="high-level" id="high-level">High-Level Plan of
    Implementation</a></h2>

    <p>The table below outlines the high level vectorization scheme
    along with a proposal for an implementation scheme, as
    follows:</p>

    <ul>
        <li>
            <p>The first column ("vectorization driver") lists the
            tasks that the vectorizer must consist of. It briefly
            describes the expected functionality of each task.</p>
        </li>

        <li>
            <p>The second column ("basic-vectorizer") describes a
            proposal for a basic vectorizer that provides minimal
            support for each of these tasks, listing the
            restrictions that will be imposed by the basic
            vectorizer on candidate loops. Loops that are
            considered vectorizable by the basic-vectorizer are of
            the form: <tt>for(i=0; i&lt;N; i++) {a[i] = b[i] +
            c[i]; }.</tt> The "basic vectorizer" is implemented by
            Dorit Naishlos.</p>
        </li>

        <li>
            <p>The third column ("enhancements") lists possible
            directions for extending the capabilities of the basic
            vectorizer. Some of these enhancements are aimed at
            improving the quality of the vector code that is being
            generated. Other enhancements aim at broadening the
            range of computations that are amenable for
            vectorization. Other focus on improved robustness.
            Following the table is a complete and detailed list of
            these enhancements. Next to each item which is already
            being addressed, there should be the name of the
            relevant contact person.</p>
        </li>
    </ul>

    <table width="98%" border="1">
        <tbody>
            <tr valign="top">
                <td width="33%"><b>vectorization driver</b></td>

                <td width="33%"><b>basic vectorizer</b></td>

                <td width="33%"><b>enhancements</b></td>
            </tr>

            <tr valign="top">
                <td>
                    <tt>analyze_loop_CFG(loop)</tt>

                    <p>Checks the <a href="#loopCFG">control flow
                    properties of the loop</a> (number of
                    basic-blocks it consists of, nesting, single
                    entry/exit, etc.), in order to determine
                    whether the control flow of the loop falls
                    within the range of loop forms that are
                    supported by this vectorizer.</p>
                </td>

                <td>
                    <ul>
                        <li>inner-most (single nest) loops.</li>

                        <li>single basic block loops; i.e., no
                        if-then-else constructs, etc. (in practice
                        this means loops that consist of exactly
                        two basic blocks - header+latch).</li>

                        <li>other restrictions (single
                        successor/predecessor, a pre-header
                        block).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>use <a href="#IdiomRecognition">idiom
                        recognition</a> to collapse
                        <tt>if-then-else</tt> constructs into a
                        straight line code.</li>

                        <li>handle <a href="#cond">conditional
                        execution</a></li>

                        <li>the above needs to be aware of <a href=
                        "#Machine">target specific vector
                        capabilities</a>.</li>

                        <li>extend the <a href="#LoopForms">range
                        of loop forms</a> that can be vectorized,
                        with respect to their CFG
                        characteristics.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_loop_index_and_bound(loop)</tt></p>

                    <p>Analyzes the loop termination condition to
                    determine the loop bound and properties of the
                    loop index (its bounds and step). The
                    functionality of this utility should be largely
                    provided by the information computed by the
                    <a href="#InductionVariable">Induction Variable
                    Analyzer</a>.</p>
                </td>

                <td>
                    <ul>
                        <li>handle simple normalized loops (loop
                        index is a trivial IV with step 1, etc.),
                        with a simple termination condition.</li>

                        <li>loop-bound known at compile time.</li>

                        <li><tt>loop-bound &gt;= vector_size</tt>
                        and <tt>loop-bound % vector_size =
                        0</tt>.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>relax the restrictions on the <a href=
                        "#LoopForms">loop bound</a> and <a href=
                        "#AccessPattern">loop index</a> imposed by
                        the basic vectorizer.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p><tt>analyze_loop_stmts(loop-stmts)</tt></p>

                    <p>Scan the loop statements and check whether
                    there are any statements that prohibit
                    vectorization (function calls, statements that
                    don't have a mapping to a built-in vector
                    function, etc.)</p>
                </td>

                <td>
                    <ul>
                        <li>simple operations for which there's a
                        1-1 mapping between the scalar and vector
                        operations.</li>

                        <li>no support for scalar expansion,
                        induction variables, reduction
                        operations...</li>

                        <li>no mixture of data types (all
                        statements operate on the same data
                        types).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>handle <a href="#computations">scalar
                        expansion</a>.</li>

                        <li>handle computations with <a href=
                        "#computations">mixed data types</a>.</li>

                        <li>Support operations that can't be
                        expressed using existing (scalar)
                        tree-codes; this requires <a href=
                        "#Machine">developing  a mechanism to
                        expose to the compiler that such operations
                        are supportable</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_access_pattern(loop-mem-refs)</tt></p>

                    <p>Analyze the memory references in the loop,
                    and <a href="#AccessPattern">classify them
                    according to the access pattern</a> that they
                    exhibit.</p>
                </td>

                <td>
                    <ul>
                        <li>support only memory accesses which are
                        array references (no pointers...).</li>

                        <li>support only consecutive (unit stride)
                        access pattern.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>extend the access pattern analyzer to
                        handle pointer references</li>

                        <li>improve the <a href=
                        "#PointerAliasing">memory aliasing</a>
                        capabilities.</li>

                        <li>handle non consecutive access patterns
                        <a href="#Machine">if supported by the
                        target</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_alignment(loop-mem-refs)</tt></p>

                    <p>Analyze the alignment of the memory
                    references in the loop. For each memory
                    reference, record its misalignment amount, if
                    it can be resolved at compile time.</p>
                </td>

                <td>
                    <ul>
                        <li>misalignment amount for all memory
                        references is known at compile time.</li>

                        <li>misalignment is zero for all references
                        (all references are aligned).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li><a href="#Alignment">handle unaligned
                        accesses</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>analyze_loop_carried_dependences(loop)</tt></p>

                    <p>Build the loop dependence graph (for scalar
                    and array references); Detect Strongly
                    Connected Components (SCCs) in the graph
                    (statements that are involved in a dependence
                    cycle); Perform a topological sort on the
                    reduced graph (in which each SCC is represented
                    by a single node); Only singleton nodes w/o
                    self dependencies can be vectorized. If other
                    (compound) nodes (which represent SCCs) are
                    present, loop transformations are required.</p>
                </td>

                <td>
                    <ul>
                        <li>handle only loops that do not contain
                        any SCCs (i.e., no dependence cycles).</li>

                        <li>the only scalar loop-carried
                        dependencies allowed are of IVs which are
                        used in array references or for the loop
                        index (i.e., reduction is not
                        supported).</li>

                        <li>use simplest dependence tests.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>use more <a href="#Dependence">advanced
                        dependence tests</a>.</li>

                        <li>try to <a href="#Dependence">break
                        cycles in the dependence graph</a> of the
                        loop by performing <a href=
                        "#LoopTransform">loop transformations</a>
                        (or <a href="#IdiomRecognition">detecting
                        reduction</a>).</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p>
                    <tt>estimate_vectorization_profitability(loop)</tt></p>

                    <p>At this point, it has been determined that
                    the loop is vectorizable. It remains to decide
                    whether it is indeed profitable to vectorize
                    it.</p>
                </td>

                <td>
                    <ul>
                        <li>vectorize all loops with loop_bound
                        &gt;= MIN_LIMIT (?).</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li>develop a <a href="#Cost">cost
                        model</a>.</li>
                    </ul>
                </td>
            </tr>

            <tr valign="top">
                <td>
                    <p><tt>vectorize_loop(loop)</tt></p>

                    <p>Replace the scalar statements with the
                    corresponding vector statements (which could be
                    calls to builtin functions); Also change the
                    loop bound accordingly.</p>
                </td>

                <td>
                    <ul>
                        <li>use a <a href=
                        "#Machine">scalar-to-vector
                        mapping</a>.</li>
                    </ul>
                </td>

                <td>
                    <ul>
                        <li><a href="#OtherOptimizations.">misc.
                        optimizations</a>.</li>

                        <li><a href="#OtherIssues">misc. issues</a>
                        to consider.</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h2><a name="List" id="List">List of Vectorization Related
    Tasks (Todo List)</a></h2>

    <p>The following is a list of independent directions by which
    the basic vectorizer can be enhanced. It should be possible for
    different people to work on different items on this list. Some
    of these items are already under development, or (partially)
    supported.</p>

    <ol>
        <li>
            <a name="loopCFG" id="loopCFG"></a>

            <h3>Loop detection and loop CFG analysis</h3>

            <p>Detect loops, and record some basic control flow
            information about them (contained basic blocks, loop
            pre-header, exit and entry, etc.).</p>

            <p><b>Status:</b> Loop detection and control flow
            analysis is already supported (<tt>cfgloop.c</tt>,
            <tt>cfgloopanal.c</tt>).</p>
        </li>

        <li>
            <a name="Machine" id="Machine"></a>

            <h3>Modeling the target machine vector capabilities to
            the <tt>tree</tt>-level.</h3>

            <p>Expose the required target specific information to
            the <tt>tree</tt> level. This includes providing a
            mapping from scalar operations to the corresponding
            vector support, which will answer the following
            questions:</p>

            <ol>
                <li>Does vector support for this operation
                exist?</li>

                <li>At what cost?</li>

                <li>How to express the vector operation at the
                <tt>tree-</tt>level?</li>
            </ol>

            <p>The general SIMD support in GCC already provides
            some initial support; For simple operations which can
            be expressed using existing (scalar)
            <tt>tree-codes</tt> (<tt>PLUS_EXPR, MULT_EXPR,</tt>
            etc.) the existing infra-structure can provide answers
            for questions 1 and 2 above, however, the
            <tt>tree-</tt>level currently does not have an idea
            about the cost that this transformation actually
            entails. A first basic implementation will support only
            simple operations that fall into the above category. As
            the capabilities of the vectorizer are extended, it
            will be required to inform the vectorizer of the
            advanced capabilities available in the architecture
            (for example, support for operations on complex
            numbers, reduction, etc.). Such operations cannot be
            expressed using existing tree-codes. Possible
            solutions: introduce new tree-codes (and corresponding
            optabs); introduce new builtins that are exposed to the
            compiler; use target hooks to handle these cases (the
            hook could return a call to a machine specific builtin
            function). Another related design question that needs
            to be addressed here is how much information to expose
            to the tree-level (is it sufficient to indicate that
            conditional vector addition is supported, or do we want
            the vectorizer to actually generate the required
            masking/predication/select operations depending on the
            target? similarly for alignment, multiplication of
            integers, etc.).</p>

            <p><b>Status:</b> Open for discussion. Contact: Dorit
            Naishlos.<br />
            Related discussion: <a href=
            "http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html">
            http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html</a></p>
        </li>

        <li>
            <a name="mapping" id="mapping"></a>

            <h3>Enhance the Builtins Support</h3>

            <p>Currently the tree optimizers do not know the
            semantics of target specific builtin functions, so they
            do not attempt to optimize them (or to SSA the
            variables passed as arguments to these functions).
            Since the vectorizer will probably end up generating
            calls to target specific builtin functions, this
            situation needs to be improved, i.e. - the semantics of
            these builtins needs to somehow be exposed to the
            compiler.</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <a name="Cost" id="Cost"></a>

            <h3>Cost Model</h3>

            <p>There is an overhead associated with vectorization
            -- moving data in to/out of vector registers
            before/after the vectorized loop, aligning of data
            accesses, etc. It is required to incorporate a cost
            model into the machine description in order to allow
            the vectorizer to evaluate whether it is worth while to
            vectorize a given loop. One can also consider using run
            time tests to decide which version of the loop to
            execute (scalar or vectorized).</p>

            <p><b>Status:</b> Open for discussion. Contact:Dorit
            Naishlos.<br />
            Related discussion: <a href=
            "http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html">
            http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00469.html</a></p>
        </li>

        <li>
            <a name="InductionVariable" id="InductionVariable"></a>

            <h3>Induction Variable Analysis</h3>

            <p>Used by the vectorizer to detect loop bound, analyze
            access patterns and analyze data dependencies between
            array references. One option is that the dependence
            tests would be designed deal with array references that
            are expressed in terms of a linear function of the
            iteration counter (in this case, vectorization will
            also benefit from optimizations like induction variable
            substitution and replacement of auxiliary IVs with
            linear functions of the loop index). A dependence
            tester that is based on IVs represented in this form
            would analyze each subscript of each array reference,
            and apply the appropriate dependence test (SIV, ZIV,
            MIV etc., see <a href="#Dependence">dependence
            testing</a>). Alternatively, an induction variable
            evolution analyzer could provide a different
            implementation to the dependence tester. This is the
            solution that is currently used, based on the Induction
            Variable evolution analysis developed by Sebastian
            Pop.</p>

            <p><b>Status:</b> Using the IV evolution analyzer
            developed by Sebastian Pop.</p>
        </li>

        <li>
            <a name="Dependence" id="Dependence"></a>

            <h3>Dependence Testing</h3>

            <p>Following the classic dependence-based approach for
            vectorization as described in <a href=
            "#kenedy-book">[1]</a>, apply dependence tests to pairs
            of array references in each loop nest, and analyze the
            resulting dependence graph. We will start from a
            dependence analyzer that relies on the array references
            being expressed in terms of a linear function of the
            loop index, apply the simplest dependence tests to all
            pairs of memory read/write and write/write, and
            gradually extend its capabilities. The scheme below
            follows the algorithm described in <a href=
            "#tseng">[2]:</a></p>

            <ul>
                <li>Partition the array subscripts into separable
                sets (subscripts which index does not occur in
                other subscripts).</li>

                <li>Apply the simplest tests for separable
                subscripts (strong SIV (single index variable)
                tests).</li>

                <li>Incorporate more advanced dependence tests;
                first, tests for separable subscripts - e.g., weak
                SIV tests, MIV (Multiple Index Variable) tests,
                followed by tests for coupled subscripts, possibly
                up to integer linear programming like
                Fourier-Motzkin elimination.</li>

                <li>Compute dependence distance, and prune
                dependencies with distance &gt; vector_size.</li>

                <li>Try to handle cycles in the dependence graph of
                the loop (by performing loop distribution,
                etc.).</li>

                <li>Generalize the dependence tester to nested
                loops.</li>
            </ul>

            <p><b>Status:</b> Some preliminary trivial tests are
            implemented to prove independence.</p>
        </li>

        <li>
            <a name="AccessPattern" id="AccessPattern"></a>

            <h3>Access Pattern Analysis</h3>

            <p>The memory architecture usually allows only
            restricted accesses to data in memory; one of the
            restrictions is that the accessed data must be
            consecutive in memory. Any other accesses (strided for
            example) require to perform special permutation of the
            data in order to pack the data elements in the right
            order into a vector register. Support for different
            access patterns consists of the following stages:</p>

            <ul>
                <li>Classify the access pattern of each array
                reference.</li>

                <li>Trivially handle consecutive (unit stride)
                access patterns (a[i]).</li>

                <li>Handle strided access patterns (a[2*i]). The
                stride 2 access pattern appears in computations on
                complex numbers, where the real and imaginary parts
                are interleaved in the input/output array.</li>

                <li>Handle other types of access patterns?</li>

                <li>Support pointer arithmetic.</li>
            </ul>

            <p>In order to facilitate a scheme that trivially
            replaces each operation with its equivalent SIMD
            instruction, a preprocessing pass may need to take
            place in order to convert the scalar operations into a
            proper (scalar) form. For example, the following code
            sequence is generated in order to represent the
            expression <tt>'a[2*i+1] = b[i]</tt>':</p>

            <ol>
                <li><tt>T.1 = i * 2;</tt></li>

                <li><tt>T.2 = T.1 + 1;</tt></li>

                <li><tt>a[T.2] = b[i];</tt></li>
            </ol>

            <p>These operations (1 and 2 in the example) determine
            the data permutation that will be performed, however,
            they do not need to be directly vectorized. It maybe
            required to mark such code to indicate that no vector
            code needs to be generated for it; instead, we may want
            to consider collapsing this code into the relevant
            array reference, similarly to forward substitution (but
            this would probably mean breaking the GIMPLE
            conventions?).</p>

            <p><b>Status:</b> Currently, the access function is
            determined using the <a href=
            "#InductionVariable">evolution analyzer</a>. Statements
            that are only used for address computations will be
            detected and handled accordingly. Contact: Dorit
            Naishlos.</p>
        </li>

        <li>
            <a name="computations" id="computations"></a>

            <h3>Extend the range of supportable operations</h3>

            <p>At first, the only computations that will be
            vectorized are those for which the vectorization
            process consists of trivially replacing each scalar
            operation in the loop with its vector counterpart. This
            includes simple loads, stores and arithmetic operations
            that operate on the same data type. Some computations
            require extra code to be generated in order to
            vectorize. These include:</p>

            <ul>
                <li>computations with mixed types; these require
                proper promotion/demotion between vectors of
                different sizes.</li>

                <li>computations that involve loop invariants
                (<tt>a[i] = N</tt>) and require scalar
                expansion.</li>

                <li>computations that involve induction variables
                (<tt>a[i] = i</tt>), require scalar expansion, and
                proper initialization and update code.</li>
            </ul>

            <p><b>Status:</b> Depending on the design decisions
            with respect to the <a href="#Machine">machine
            modeling</a>, some of these issues maybe hidden in the
            machine description, alleviating the vectorizer from
            the need to generate the special extra code. Contact:
            Dorit Naishlos.</p>
        </li>

        <li>
            <a name="Alignment" id="Alignment"></a>

            <h3>Alignment</h3>

            <p>The memory architecture usually allows only
            restricted accesses to data in memory. One of the
            restrictions is that data accesses need to be properly
            aligned on a certain boundary. Even if the architecture
            supports unaligned accesses, these are usually much
            more costly than aligned accesses. The work on
            alignment consists of several stages:</p>

            <ul>
                <li>Compute the misalignment properties of each
                memory access.</li>

                <li>Handling of aligned memory accesses only (do
                not attempt to vectorize loops that contain
                unaligned accesses).</li>

                <li>If it is impossible to determine at compile
                time whether the memory access is aligned, <a href=
                "#versioning">create two versions of the loop and
                use a runtime test</a> to decide which version to
                execute: the original scalar version (if the data
                access is not aligned), or the vectorized version
                (if the access is aligned).</li>

                <li>Develop optimizations that increase the
                alignment of data accesses (static loop peeling,
                dynamic loop peeling, etc.).</li>

                <li>Vectorize unaligned accesses. There are
                different ways to do that, depending on whether the
                target supports unaligned accesses, and also
                depending on what we want to implement at the tree
                level, and what we want to leave for the RTL level
                to handle. For example, one could generate the
                required code to support a miss-aligned memory
                access (for miss-aligned loads, generate an
                additional load and the required merging code).
                Alternatively, the tree level could just generate a
                "VEC_UNALIGNED_LOAD" statement, that will be
                translated later in the RTL level into the
                appropriate RTL sequence that handles the unaligned
                load (in a target dependent way). This means
                however that optimizations that try to reduce the
                merging overhead cannot take place at the tree
                level, where it is probably easier to do than at
                the RTL level.</li>
            </ul>

            <p><b>Status:</b> Preliminary implementation of some of
            this functionality is in apple-ppc-branch. Peeling and
            versioning for alignment are in the works. Contact:
            Dorit Naishlos, Olga Golovanevsky.</p>
        </li>

        <li>
            <a name="IdiomRecognition" id="IdiomRecognition"></a>

            <h3>Idiom Recognition</h3>

            <p>It is often the case that complicated computations
            can be reduced into a simpler, straight-line sequence
            of operations. These operations may not be directly
            supported in a scalar form, but are supported by the
            target in a vector form. Such cases include:</p>

            <ul>
                <li>Reduction operations:

                    <ul>
                        <li>Detect different kinds of reduction
                        (summation, min/max, min/max with index,
                        etc.); once detected, these idioms may be
                        replaced with a virtual scalar operation
                        (to facilitate straight forward vector code
                        generation).</li>

                        <li>Vectorizing the reduction requires
                        generating epilog code after the loop.
                        First, generate a scalar code sequence to
                        compute the epilog. Later, try to make use
                        of target dependent mechanisms to compute
                        the epilog of the reduction more
                        efficiently.</li>
                    </ul>
                </li>

                <li>Special patterns that are supported by the
                architecture. <a href="#cond">This may involve
                collapsing multi-block constructs (such as
                <tt>if-then-else</tt>)</a> into a single
                vectorizable operation. For example, in the
                following code sequence (taken from the SPECint
                benchmark gzip) the conditional expression can be
                collapsed into a "subtract and saturate" operation
                (see <a href=
                "http://gcc.gnu.org/ml/gcc/2003-07/msg01355.html">
                    http://gcc.gnu.org/ml/gcc/2003-07/msg01355.html</a>):
                    <pre>
for (n = 0; n &lt; HASH_SIZE; n++)
  {
    m = head[n];
    head[n] = (Pos)(m >= 32768 ? m-32768 : 0);
  }
                    </pre>
                </li>

                <li>Detect saturation idioms, and map them to the
                appropriate vector operation.</li>
            </ul>

            <p><b>Status:</b> Contact: Dorit Naishlos.</p>
        </li>

        <li>
            <a name="cond" id="cond"></a>

            <h3>Conditional Execution</h3>

            <p>The general principle we are trying to follow is to
            keep the actual code transformation part of the
            vectorizer as simple as possible: a simple scan of
            straight-line code, and a one-to-one replacement of
            each scalar operation with the equivalent vector
            operation. To support this scheme in the presence of
            conditional execution, we'll need to flatten the loop
            body by collapsing if-then-else into a conditional
            (scalar) operation (something like transforming -
            '<tt>if (x) {c = PLUS (a,b)}</tt>' into
            '<tt>PLUS_COND(a,b,x)</tt>'. These will later be
            replaced with a conditional vector operation using
            whatever support is available in the target (masking,
            predication or select operation). Flattening the loop
            body this way will greatly simplify the vectorizer.
            Some of the issues to think about here: (a) how to
            represent these conditional operations, (b) to what
            extent does the tree vectorizer need to be aware of the
            specific target support that is available for
            conditional vector execution (mask/predicate/select),
            and (c) how to allow a simple way to reverse this
            transformation if the loop doesn't end up getting
            vectorized.</p>

            <p><b>Status:</b> Contact: Devang Patel.</p>
        </li>

        <li>
            <a name="LoopForms" id="LoopForms"></a>

            <h3>Handle Advanced Loop Forms</h3>

            <ol>
                <li>Support general loop bound (unknown, or doesn't
                divide by the vector size). [done; contact: Olga
                Golovanevsky]</li>

                <li>Support more complex forms of loop termination
                condition and loop index update. [done]</li>

                <li>Support outer-loop vectorization (unroll and
                jam).</li>

                <li>Relax other restrictions on the loop form.</li>
            </ol>

            <p><b>Status:</b> Future work.</p>
        </li>

        <li>
            <a name="PointerAliasing" id="PointerAliasing"></a>

            <h3>Handle Pointer Aliasing</h3>

            <ol>
                <li>Develop anti-aliasing analysis.</li>

                <li>Generate run-time tests for cases where memory
                anti-aliasing cannot be resolved at compile
                time.</li>

                <li>Support user hints?</li>
            </ol>

            <p><b>Status:</b> Some aliasing infrastructure is
            available. Andersen points-to analysis also
            available.</p>
        </li>

        <li>
            <h3>Aliasing and Virtual def-use Chains</h3>

            <p> Address the item from the <a href=
            "index.html#todo">tree-ssa
            todo list</a> - "SSA information for arrays : The
            existing implementation treats arrays as an opaque
            object. A definition to an array location is treated as
            a definition for the whole array"</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <h3>Array addressing Represented as Pointer
            Arithmetic</h3>

            <p>Address the issue mentioned in <a href=
            "http://gcc.gnu.org/ml/gcc/2003-07/msg02013.html">http://gcc.gnu.org/ml/gcc/2003-07/msg02013.html</a>,
            which turns out to be a front end issue.</p>

            <p><b>Status:</b> Open for discussion.</p>
        </li>

        <li>
            <a name="versioning" id="versioning"></a>

            <h3>Loop versioning</h3>

            <p>Provide utilities that allow performing the
            following transformation: Given a condition and a loop,
            create -'if (condition) { loop_copy1 } else {
            loop_copy2 }', where loop_copy1 is the loop transformed
            in one way, and loop_copy2 is the loop transformed in
            another way (or unchanged). 'condition' may be a run
            time test for things that were not resolved by static
            analysis (overlapping ranges (anti-aliasing),
            alignment, etc.).</p>

            <p><b>Status:</b> Contact: Devang Patel.</p>
        </li>

        <li>
            <a name="LoopTransform" id="LoopTransform"></a>

            <h3>Loop Transformations to Increase Vectorizability of
            Loops</h3>

            <p>These include:</p>

            <ul>
                <li>loop interchange, and other unimodular
                transformations.</li>

                <li>scalar expansion.</li>

                <li>loop distribution.</li>

                <li>collapsing tightly nested loops to a single
                loop.</li>

                <li>loop unswitching.</li>
            </ul>

            <p><b>Status:</b>Linear loop transformations are
            implemented by Daniel Berlin.</p>
        </li>

        <li>
            <a name="OtherOptimizations." id=
            "OtherOptimizations."></a>

            <h3>Other Optimizations</h3>

            <ol>
                <li>Exploit data reuse (a la "Compiler-Controlled
                Caching in Superword Register Files for Multimedia
                Extension Architectures" by Shin, Chame and Hall).
                Mostly relies on unroll &amp; jam having been
                applied.</li>

                <li>Vectorize loops that can't be vectorized using
                the classic vectorizer (until the proper loop
                transformations are developed) by applying SLP
                vectorization (a la "Exploiting Superword Level
                Parallelism with Multimedia Instruction Sets" by
                Amarasinghe and Larsen). This scheme can
                potentially more easily vectorize partially
                vectorizable loops, or loops that are already
                unrolled in the source code. It is possible to
                implement SLP vectorization either in the tree
                level or at the RTL level as a complementary
                approach to classic loop vectorization.</li>
            </ol>

            <p><b>Status:</b> Future work.</p>
        </li>

        <li>
            <a name="OtherIssues" id="OtherIssues"></a>

            <h3>Other Issues to consider</h3>

            <ol>
                <li>Using user hints for different purposes
                (aliasing, alignment, profitability of vectorizing
                a loop, etc.).</li>

                <li>Decide which of the items listed above should
                take place in the GIMPLE tree level, and which in
                the RTL level. For example, anything that could
                affect the decision whether to vectorize a loop,
                should take place at the tree level (in order to
                avoid having to undo transformations); also, many
                of the things that can take place at the RTL level
                maybe simpler to implement at the tree level.
                However, this would mean that a lot of machine
                dependent stuff will have to be done at the tree
                level.</li>
            </ol>

            <p><b>Status:</b> Open for discussion.</p>
        </li>
    </ol>

    <h2>(Incomplete) Reference list</h2>

    <ol>
        <li><a name="kenedy-book" id="kenedy-book"></a>"Optimizing
        Compilers for Modern Architectures - A dependence based
        approach", Randy Allen &amp; Ken Kennedy, Morgan Kaufmann
        Publishers, San Francisco, San Diego, New York (2001).</li>

        <li><a name="tseng" id="tseng"></a>"Practical Dependence
        Testing", Gina Goff, Ken Kennedy, Chau-Wen Tseng, CRPC+TR
        90103, November 1990.</li>
    </ol>
</body>
</html>
