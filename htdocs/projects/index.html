<html>

<head>
<title>GCC Projects</title>
</head>

<body>

<!-- table of contents start -->
<h1><a name="toc">Table of Contents</a></h1>
<ul>
<li><a href="#fix_bugs_in_bts">Fix bugs in our bug tracking system</a></li>
<li><a href="#beginner_gcc_hackers">Projects for beginner GCC hackers</a></li>
<li><a href="#gcc_web_pages">Projects for the GCC web pages</a></li>
<li><a href="#documentation_projects">Projects for improving the GCC documentation</a></li>
<li><a href="#development_branches">Development Branches</a></li>
<li><a href="#optimizer_inadequacies">Optimizer inadequacies</a></li>
<li><a href="#c_preprocessor">Projects for the C preprocessor</a></li>
<li><a href="#c_front_end">Projects for improving the C front end</a></li>
<li><a href="#improve_the_installation_procedure">Improve the installation procedure</a></li>
<li><a href="#simpler_porting">Simpler porting</a></li>
<li><a href="#other_languages">Other languages</a></li>
<li><a href="#generalize_the_machine_model">Generalize the machine model</a></li>
<li><a href="#the_old_problems_file">The old PROBLEMS file</a></li>
</ul>
<!-- table of contents end -->


<h1>GCC Projects</h1>

<p>Remember to <a href="../contributewhy.html">keep other developers
informed</a> of any substantial projects you intend to work on.</p>

<h2><a name="fix_bugs_in_bts">Fix bugs in our bug tracking system</a></h2>
<p>You can investigate bugs in our <a href="http://gcc.gnu.org/bugzilla/">bug
tracking system</a> and attempt to fix them or see whether they still are
present in current GCC.</p>

<h2><a name="beginner_gcc_hackers">Projects for beginner GCC hackers</a></h2>
<p>If you are new to GCC, start with our <a
href="beginner.html">projects for beginners</a>.</p>

<h2><a name="gcc_web_pages">Projects for the GCC web pages</a></h2>
<p>There is a separate projects list for the <a href="web.html">web
pages</a>.</p>

<h2><a name="documentation_projects">Projects for improving the GCC documentation</a></h2>
<p>There is a separate projects list for <a
href="documentation.html">projects for improving the GCC documentation</a>.</p>

<h2><a name="development_branches">Development Branches</a></h2>
<p>There are several <a href="../cvs.html#devbranches">development branches</a>
pursuing various goals.</p>

<h2><a name="optimizer_inadequacies">Optimizer inadequacies</a></h2>
<p>We also have a page detailing <a href="optimize.html">optimizer
inadequacies</a>, if you'd prefer to think about it in terms of problems
instead of features.</p>

<h2><a name="c_preprocessor">Projects for the C preprocessor</a></h2>
<p>There is a separate project list for the <a
href="cpplib.html">C preprocessor</a>.</p>

<h2><a name="c_front_end">Projects for the C front end</a></h2>
<p>There is a separate projects page for the <a
href="c-frontend.html">C front end</a>.</p>

<h2><a name="improve_the_installation_procedure">Improve the installation procedure</a></h2>

<ul>
  <li>See <a href="http://gcc.gnu.org/ml/gcc/2000-11/msg00556.html">a
  message from Zack Weinberg</a>, and follow-ups to it, for some
  discussion of some of these ideas.</li>

  <li>Move the installation from incomprehensible shell scripts in the
  Makefiles to more comprehensible shell scripts outside the Makefiles.</li>

  <li>When installing as root, make the installed headers in
  <code>$(libsubdir)</code> be owned by root rather than the user who
  did the build.</li>

  <li>Be consistent about what programs get links such as
  <code>i686-pc-linux-gnu-gcc</code> and
  <code>i686-pc-linux-gnu-gcc-3.4.1</code>.  Any program embedding
  architecture or version dependencies may need such links.</li>

  <li>Add a configure option <code>--enable-cc-links</code> or similar
  which causes links to the compiler driver or shell scripts to be
  installed under names <code>cc</code> (the traditional Unix compiler
  name and a legacy utility in Unix98, accepting an unspecified C
  language variant), <code>c89</code> (POSIX; a script running <code>gcc
  -std=c89 -pedantic</code>) and <code>c99</code> (the Austin Group
  revision of POSIX; a script running <code>gcc -std=c99
  -pedantic</code>) for systems such as GNU/Linux where GCC is the
  system compiler.</li>

  <li>Fix the issues discussed in <a
  href="http://gcc.gnu.org/PR346">PR other/346</a>.</li>
</ul>

<hr />
<h2><a name="simpler_porting">Simpler porting</a></h2>

<p>Right now, describing the target machine's instructions is done
cleanly, but describing its addressing mode is done with several
ad-hoc macro definitions.  Porting would be much easier if there were
an RTL description for addressing modes like that for instructions.
Tools analogous to genflags and genrecog would generate macros from
this description.</p>

<p>There would be one pattern in the address-description file for each
kind of addressing, and this pattern would have:</p>

<ul>
  <li>the RTL expression for the address</li>
  <li>C code to verify its validity (since that may depend on
      the exact data).</li>
  <li>C code to print the address in assembly language.</li>
  <li>C code to convert the address into a valid one, if it is not valid.
      (This would replace LEGITIMIZE_ADDRESS).</li>
  <li>Register constraints for all indeterminates that appear
      in the RTL expression.</li>
</ul>

<h2><a name="other_languages">Other languages</a></h2>

<p>We currently have front ends for Ada, C, C++, Objective C, 
Fortran, and Java.  A Pascal front end exists but has not yet
been integrated.</p>

<p>Cobol and Modula-2 front ends might be useful, and are being worked
on.</p>

<h2><a name="generalize_the_machine_model">Generalize the machine model</a></h2>

<p>Some new compiler features may be needed to do a good job on
machines where static data needs to be addressed using base registers.</p>

<p>Some machines have two stacks in different areas of memory, one
used for scalars and another for large objects.  The compiler does not
now have a way to understand this.</p>

<p>The scheduler does not do very well on recent RISC machines.  Haifa
helps but not enough.</p>

<hr />

<h2><a name="the_old_problems_file">The old PROBLEMS file</a></h2>

<p>The following used to be in a file <code>PROBLEMS</code> in the GCC
 distribution.  Probably much of it is no longer relevant as of GCC 3.0
(the file hadn't changed since GCC 2.0), but some might be.  Someone
should go through it, identifying what is and isn't relevant, adding
anything applicable to current GCC (and describing a bug) to our
<a href="../bugs.html">bug-tracking system</a> and sending patches to
gcc-patches to remove such analysed entries from the list.</p>

<ol>
  <li value="110">Possible special combination pattern: If the two
  operands to a comparison die there and both come from insns that are
  identical except for replacing one operand with the other, throw away
  those insns.  Ok if insns being discarded are known 1 to 1.  An andl
  #1 after a seq is 1 to 1, but how should compiler know that?</li>

  <li value="117">Any number of slow zero-extensions in one loop, that
  have their clr insns moved out of the loop, can share one register if
  their original life spans are disjoint.  But it may be hard to be sure
  of this since the life span data that regscan produces may be hard to
  interpret validly or may be incorrect after cse.</li>

  <li value="118">In cse, when a bfext insn refers to a register, if the
  field corresponds to a halfword or a byte and the register is
  equivalent to a memory location, it would be possible to detect this
  and replace it with a simple memory reference.</li>
</ol>

</body>
</html>
