<html>

<head>
<title>GCC Projects</title>
</head>

<body><!-- table of contents start -->
<h1><a name="toc">Table of Contents</a></h1>
<ul>
<li><a href="#fix_bugs_in_bts">Fix bugs in our bug tracking system</a></li>
<li><a href="#beginner_gcc_hackers">Projects for beginner GCC hackers</a></li>
<li><a href="#c_preprocessor">Projects for the C preprocessor</a></li>
<li><a href="#gcc_web_pages">Projects for the GCC web pages</a></li>
<li><a href="#documentation_projects">Projects for improving the GCC documentation</a></li>
<li><a href="#development_branches">Development Branches</a></li>
<li><a href="#data_prefetch">Data prefetch support</a></li>
<li><a href="#optimizer_inadequacies">Optimizer inadequacies</a></li>
<li><a href="#ia64_projects">Projects to improve performance on IA-64</a></li>
<li><a href="#c99_support">Changes to support C99 standard</a></li>
<li><a href="#miscellaneous_ideas">Miscellaneous ideas:</a>
<ul>
<li><a href="#improve_wconversion">Improve <code>-Wconversion</code></a></li>
<li><a href="#implement_various_builtin_functions_for_isoc99">Implement various builtin functions for ISO C99's 
<code>&lt;tgmath.h&gt;</code></a></li>
</ul></li>
<li><a href="#better_builtin_string_functions">Better builtin string functions</a>
<ul>
<li><a href="#string_operation_insns">String operation instructions</a></li>
<li><a href="#optimize_strcmp">Optimize <code>strcmp</code></a></li>
<li><a href="#optimize_strncpy">Optimize <code>strncpy</code></a></li>
<li><a href="#optimize_strcat">Optimize <code>strcat</code></a></li>
<li><a href="#optimize_strspn">Optimize <code>strspn</code>,
<code>strcspn</code> and <code>strpbrk</code></a></li>
</ul></li>
<li><a href="#format_checking">Format (<code>printf</code>, <code>scanf</code> and
<code>strftime</code>) checking:</a></li>
<li><a href="#improve_the_installation_procedure">Improve the installation procedure</a></li>
<li><a href="#the_old_projects_file">The old PROJECTS file</a>
<ul>
<li><a href="#putting_constants_in_special_sections">Putting constants in special sections.</a></li>
<li><a href="#un_cse">Un-cse.</a></li>
<li><a href="#clean_up_how_cse_works">Clean up how cse works.</a></li>
<li><a href="#loop_optimization">Loop optimization.</a></li>
<li><a href="#using_constraints_on_values">Using constraints on values.</a></li>
<li><a href="#change_the_type_of_a_variable">Change the type of a variable.</a></li>
<li><a href="#better_handling_for_very_sparse_switches">Better handling for very sparse switches.</a></li>
<li><a href="#order_of_subexpressions">Order of subexpressions.</a></li>
<li><a href="#distributive_law">Distributive law.</a></li>
</ul></li>
<li><a href="#simpler_porting">Simpler porting</a></li>
<li><a href="#other_languages">Other languages</a></li>
<li><a href="#generalize_the_machine_model">Generalize the machine model</a></li>
<li><a href="#more_warnings">More warnings</a></li>
<li><a href="#the_old_problems_file">The old PROBLEMS file</a></li>
</ul>
<!-- table of contents end -->


<h1>GCC Projects</h1>

<p>Remember to <a href="../contributewhy.html">keep other developers
informed</a> of any substantial projects you intend to work on.</p>

<h2><a name="fix_bugs_in_bts">Fix bugs in our bug tracking system</a></h2>
<p>You can investigate bugs in our <a href="http://gcc.gnu.org/bugzilla/">bug
tracking system</a> and attempt to fix them or see whether they still are
present in current GCC.</p>

<h2><a name="beginner_gcc_hackers">Projects for beginner GCC hackers</a></h2>
<p>If you are new to GCC, start with our <a
href="beginner.html">projects for beginners</a>.</p>

<h2><a name="c_preprocessor">Projects for the C preprocessor</a></h2>
<p>There is a separate project list for the <a
href="cpplib.html">C preprocessor</a>.</p>

<h2><a name="gcc_web_pages">Projects for the GCC web pages</a></h2>
<p>There is a separate projects list for the <a href="web.html">web
pages</a>.</p>

<h2><a name="documentation_projects">Projects for improving the GCC documentation</a></h2>
<p>There is a separate projects list for <a
href="documentation.html">projects for improving the GCC documentation</a>.</p>

<h2><a name="development_branches">Development Branches</a></h2>
<p>There are several <a href="../cvs.html#devbranches">development branches</a>
pursuing various goals.</p>

<h2><a name="data_prefetch">Data prefetch support</a></h2>
<p>A separate page describes <a href="prefetch.html">
data prefetch support and optimizations</a> that are in development
in the main branch.</p>
  
<h2><a name="optimizer_inadequacies">Optimizer inadequacies</a></h2>
<p>We also have a page detailing <a href="optimize.html">optimizer
inadequacies</a>, if you'd prefer to think about it in terms of problems
instead of features.</p>

<h2><a name="ia64_projects">Projects to improve performance on IA-64</a></h2>
<p>There is a separate project list for
<a href="ia64.html">IA-64 performance improvements</a>.</p>

<h2><a name="c99_support">Changes to support C99 standard</a></h2>

<p>The new version of the C standard (ISO/IEC 9899:1999) requires a
number of library changes; these have to be provided by the C library,
and not by gcc.  In addition, there are also changes to the language
proper, and some compiler support is needed for the new library
features.  An <a href="../c99status.html">overview</a> of the C99
implementation status is available.</p>

<h2><a name="miscellaneous_ideas">Miscellaneous ideas:</a></h2>

<p>The following are some miscellaneous ideas for GCC projects to work
on.</p>

<h3><a name="improve_wconversion">Improve <code>-Wconversion</code></a></h3>
<p>Improve <code>-Wconversion</code> so that it can be used for
security auditing as well as for its original intended purpose of
helping with converting old code to ISO C.</p>

<h3><a name="implement_various_builtin_functions_for_isoc99">Implement various builtin functions for ISO C99's 
<code>&lt;tgmath.h&gt;</code></a></h3> 
<p>Design and implement builtin functions that assist in implementing
the ISO C99 <code>&lt;tgmath.h&gt;</code> macros.  These builtins
could be along the general lines of the macros used in glibc 2.2 (for
example, the implementation of <code>&lt;tgmath.h&gt;</code> might use
<code>__builtin_tgmath_unary_real_only (value, log2f, log2,
log2l)</code> to implement the <code>log2</code> macro), but should be
designed so that, if the Annex G imaginary types are implemented in
GCC, glibc does not need to change again to allow for them.  This
means additional functions, beyond those corresponding to the macros
in glibc, are needed to handle the trigonometric functions which G.7
specifies have real or imaginary result type for imaginary arguments,
but which have complex result type for complex arguments.  The design
for these builtins should be discussed with the gcc and libc-alpha
lists.</p>

<h2><a name="better_builtin_string_functions">Better builtin string functions</a></h2>

<p>Although GCC implements numerous optimizations of the standard C
library's string, math and I/O functions, there are still plenty more
transformations that could be implemented.</p>

<ul>
  <li>glibc has inline assembler versions of various string functions; GCC
  has some, but not necessarily the same ones on the same architectures.
  Additional <code>optab</code> entries, like the ones for <code>ffs</code>
  and <code>strlen</code>, could be provided for several more functions
  including <code>memset</code>, <code>strchr</code>, <code>strcpy</code>
  and <code>strrchr</code>.</li>

  <li>GCC could optimize <code>strcmp</code> (and <code>memcmp</code>)
  where one string is constant to compare successive bytes to known
  constant ones inline.  For lengths longer than about 4, the inline
  comparisons could test the prefix before calling the library function
  (or inline a suitable instruction) for the remainder of the strings.</li>

  <li>glibc optimizes <code>strncpy</code> from a string constant, where
  the maximum length is constant and greater than the length of the
  string constant including the terminating null character, by using
  an optimization not implemented in GCC.  Its makes use of its own
  <code>__mempcpy</code> function to copy and return the address after
  the data copied, to pass into <code>memset</code>.  This could be
  implemented if GCC provided a <code>__builtin_mempcpy</code> function.</li>

  <li>Similarly, GCC could transform a call to <code>strcat</code> into
  a call to <code>strchr</code> followed by a <code>strcpy</code> or
  <code>memcpy</code>.</li>

  <li>glibc optimizes <code>strcspn</code>, <code>strcspn</code> and
  <code>strpbrk</code> where the string of characters that need to be
  matched is constant and of length not greater than three.</li>
</ul>

<p>The GNU libc also currently contains macros to optimize calls to
some string functions with constant arguments and those that can be
implemented by processor specific instructions.  These transformations
are better performed in GCC, both to reduce the overhead of macro
expansion and to take advantage of the functions attributes, for
example to avoid a second call to a pure function altogether.  The
use of these macros tend to cause huge blowup in the size of preprocessed
source if nested; for example, each nested call to <code>strcpy</code>
expands the source 20-fold, with four nested calls having an expansion
ten megabytes in size.  GCC then consumes a huge amount of memory
compiling such expressions.  The remaining optimizations need to be
implemented in GCC and then disabled in glibc, with benefits to other
systems as well, and the potential to use information GCC has about
alignment.</p>

<p>All the string functions act as if they access individual
characters, so care may need to be taken that no
<code>-fstrict-aliasing</code> problems occur when internal uses of
other types are generated.  Also, the arguments to the string function
must be evaluated exactly once each (if they have any side effects),
even though the call to the string function might be optimized away.</p>

<p>Care must be taken that any optimizations in GCC are
standards-conforming in terms of not possibly accessing beyond the
arrays involved (possibly within a function call created in the
optimization); whereas the glibc macros know the glibc implementation
and how much memory it might access, GCC optimizations can't.</p>

<p>There are some further optimizations in glibc not covered here,
that either optimize calls to non-ISO C functions or call glibc
internal functions in the expansion of the macro.</p>

<p>Many of these optimizations should not be applied if
<code>-Os</code> is specified.</p>


<h2><a name="format_checking">Format (<code>printf</code>,
<code>scanf</code> and <code>strftime</code>) checking:</a></h2>

<ul>
  <li>Make re-entrant: eliminate global state used for <code>$</code>
  format checking.</li>

  <li><code>strftime</code>: warnings for use of <code>0</code>,
  <code>-</code> or <code>_</code> flags without width on formats where
  inappropriate.  Similar warnings where use of one format feature is
  useless unless another one is also used also apply for
  <code>printf</code> formats (<code>0</code> and <code>-</code> flags
  when no width is specified and so there is no padding) and for
  <code>strfmon</code> formats.</li>

  <li>Integer <code>printf</code> formats: warn for integer constant
  argument out of range of unpromoted type (including signed/unsigned
  where it doesn't fit in range).</li>

  <li>Fix detection of whether format strings are narrow or wide on
  targets where <code>wchar_t</code> is <code>char</code>.  This may
  require changes elsewhere in the compiler to mark string constants
  with this information.</li>

  <li>Include an option to warn for format extensions that have been
  obsoleted by standard C99 features.</li>

  <li>Meaning of "quad" and <code>%q</code>: anything more accurate than
  <code>long long</code>?  See messages <a
  href="http://gcc.gnu.org/ml/gcc-bugs/1999-02n/msg00164.html">1</a> and
  <a href="http://gcc.gnu.org/ml/gcc-bugs/2000-08/msg00272.html">2</a>
  about this to gcc-bugs.  (Note that <code>%q</code> is now largely
  obsolete given the new C99 formats and macros.)</li>

  <li>Wide string format support.  See a <a
  href="http://gcc.gnu.org/ml/gcc/2000-12/msg00170.html">message
  soliciting views on the user interface to this</a> and send any views
  on this to the <code>gcc</code> mailing list.</li>

  <li>Clean up how <code>format.exp</code> handles
  <code>TORTURE_OPTIONS</code>, by making changes elsewhere in the test
  harness so that <code>TORTURE_OPTIONS</code> is initialized for each
  <code>dg-init</code> rather than just once and so needing saving and
  restoring.</li>

  <li>When a <code>format</code> or <code>format_arg</code> attribute is
  applied to a function with a non-prototype declaration, and the
  function is later redeclared with a prototype or defined, the
  attribute should be checked again to see if it makes sense given the
  argument types of the function.  Similarly, these checks should be
  made if the original attribute is on an old-style function
  definition.</li>

  <li>Implement more checks related to <code>__attribute__((__nonnull__))</code>,
  such as for functions such as <code>execle</code> that require
  <code>NULL</code>-terminated argument lists.</li>

  <li>Possible security warnings under <code>-Wformat-security</code>:

  <ul>
    <li>Warn for <code>sprintf</code> into fixed length buffer if the
    output can't be proved not to overrun.  Similarly for
    <code>scanf</code> <code>%s</code> and <code>%[...]</code> without
    width to fixed length buffer (or possibly to any buffer); or
    <code>%s</code>, <code>%[...]</code> and <code>%c</code> with width
    to too short a buffer, including <code>%lc</code>, <code>%ls</code>
    and <code>%l[...]</code>.</li>
  </ul>

  </li>

  <li>(Maybe eventually:) Extensible format checking: allow programs
  such as OS kernels and parts of GCC to tell GCC about additional
  format conversion characters recognised by their format
  functions.</li>

  <li><code>fopen</code>, <code>freopen</code>: warning for the
  incorrect format of the mode parameter, see <a 
  href="http://gcc.gnu.org/ml/gcc-bugs/2001-12/msg00649.html">PR
  c/5127</a>.  Some ideas for how to implement such a warning
  were discussed <a 
  href="http://gcc.gnu.org/ml/gcc-bugs/2001-12/msg00651.html">here</a>.
  </li>
</ul>


<h2><a name="improve_the_installation_procedure">Improve the installation procedure</a></h2>

<ul>
  <li>See <a href="http://gcc.gnu.org/ml/gcc/2000-11/msg00556.html">a
  message from Zack Weinberg</a>, and follow-ups to it, for some
  discussion of some of these ideas.</li>

  <li>Move the installation from incomprehensible shell scripts in the
  Makefiles to more comprehensible shell scripts outside the Makefiles.</li>

  <li>When installing as root, make the installed headers in
  <code>$(libsubdir)</code> be owned by root rather than the user who
  did the build.</li>

  <li>Be consistent about what programs get links such as
  <code>i686-pc-linux-gnu-gcc</code> and
  <code>i686-pc-linux-gnu-gcc-3.4.1</code>.  Any program embedding
  architecture or version dependencies may need such links.</li>

  <li>Add a configure option <code>--enable-cc-links</code> or similar
  which causes links to the compiler driver or shell scripts to be
  installed under names <code>cc</code> (the traditional Unix compiler
  name and a legacy utility in Unix98, accepting an unspecified C
  language variant), <code>c89</code> (POSIX; a script running <code>gcc
  -std=c89 -pedantic</code>) and <code>c99</code> (the Austin Group
  revision of POSIX; a script running <code>gcc -std=c99
  -pedantic</code>) for systems such as GNU/Linux where GCC is the
  system compiler.</li>

  <li>Fix the issues discussed in <a
  href="http://gcc.gnu.org/PR346">PR other/346</a>.</li>
</ul>

<hr />

<h2><a name="the_old_projects_file">The old PROJECTS file</a></h2>

<p>Stuff I know has been done has been deleted.
Stuff in progress has a contact name associated with it.</p>

<p>Better optimization.</p>


<h3><a name="putting_constants_in_special_sections">Putting constants in special sections.</a></h3>

<p>If a function has been placed in a special
section via attributes, we may want to put its static data and string
constants in a special section too.  But which one?  (Being able to
specify a section for string constants would be useful for the Linux
kernel.)</p>

<h3><a name="un_cse">Un-cse.</a></h3>

<p>Perhaps we should have an un-cse step right after cse, which tries to
replace a reg with its value if the value can be substituted for the
reg everywhere, if that looks like an improvement.  Which is if the
reg is used only a few times.  Use rtx_cost to determine if the
change is really an improvement.</p>

<h3><a name="clean_up_how_cse_works">Clean up how cse works.</a></h3>

<p>The scheme is that each value has just one hash entry.  The
first_same_value and next_same_value chains are no longer needed.</p>

<p>For arithmetic, each hash table elt has the following slots:</p>
<ul>
  <li>Operation.  This is an rtx code.</li>
  <li>Mode.</li>
  <li>Operands 0, 1 and 2.  These point to other hash table elements.</li>
</ul>

<p>So, if we want to enter <code>(plus:SI (reg:SI 30) (const_int
104))</code>, we first enter <code>(const_int 104)</code> and find the
entry that <code>(reg:SI 30)</code> now points to.  Then we put these
elts into operands 0 and 1 of a new elt.  We put PLUS and
SI into the new elt.</p>

<p>Registers and mem refs would never be entered into the table as
such.  However, the values they contain would be entered.  There would
be a table indexed by regno which points at the hash entry for the
value in that reg.</p>

<p>The hash entry index now plays the role of a qty number.  We still
need qty_first_reg, reg_next_eqv, etc. to record which regs share a
particular qty.</p>

<p>When a reg is used whose contents are unknown, we need to create a
hash table entry whose contents say "unknown", as a place holder for
whatever the reg contains.  If that reg is added to something, then
the hash entry for the sum will refer to the "unknown" entry.  Use
UNKNOWN for the rtx code in this entry.  This replaces make_new_qty.</p>

<p>For a constant, a unique hash entry would be made based on the
value of the constant.</p>

<p>What about MEM?  Each time a memory address is referenced, we need
a qty (a hash table elt) to represent what is in it.  (Just as for a
register.)  If this isn't known, create one, just as for a reg whose
contents are unknown.</p>

<p>We need a way to find all mem refs that still contain a certain
value.  Do this with a chain of hash elts (for memory addresses) that
point to locations that hold the value.  The hash elt for the value
itself should point to the start of the chain.  It would be good for
the hash elt for an address to point to the hash elt for the contents
of that address (but this ptr can be null if the contents have never
been entered).</p>

<p>With this data structure, nothing need ever be invalidated except
the lists of which regs or mems hold a particular value.  It is easy
to see if there is a reg or mem that is equiv to a particular value.
If the value is constant, it is always explicitly constant.</p>

<h3><a name="loop_optimization">Loop optimization</a></h3>

<p>Strength reduction and iteration variable elimination could be
smarter.  They should know how to decide which iteration variables are
not worth making explicit because they can be computed as part of an
address calculation.  Based on this information, they should decide
when it is desirable to eliminate one iteration variable and create
another in its place.</p>

<p>It should be possible to compute what the value of an iteration
variable will be at the end of the loop, and eliminate the variable
within the loop by computing that value at the loop end.</p>

<h3><a name="using_constraints_on_values">Using constraints on values</a></h3>

<p>Many operations could be simplified based on knowledge of the
minimum and maximum possible values of a register at any particular
time.  These limits could come from the data types in the tree, via
rtl generation, or they can be deduced from operations that are
performed.  For example, the result of an <code>and</code> operation
one of whose operands is 7 must be in the range 0 to 7.  Compare
instructions also tell something about the possible values of the
operand, in the code beyond the test.</p>

<p>Value constraints can be used to determine the results of a further
comparison.  They can also indicate that certain <code>and</code>
operations are redundant.  Constraints might permit a decrement and
branch instruction that checks zeroness to be used when the user has
specified to exit if negative.</p>

<h3><a name="change_the_type_of_a_variable">Change the type of a variable</a></h3>

<p>Sometimes a variable is declared as <code>int</code>, it is
assigned only once from a value of type <code>char</code>, and then it
is used only by comparison against constants.  On many machines,
better code would result if the variable had type <code>char</code>.
If the compiler could detect this case, it could change the
declaration of the variable and change all the places that use it.</p>

<h3><a name="better_handling_for_very_sparse_switches">Better handling for very sparse switches</a></h3>

<p>There may be cases where it would be better to compile a switch
statement to use a fixed hash table rather than the current
combination of jump tables and binary search.</p>

<h3><a name="order_of_subexpressions">Order of subexpressions</a></h3>

<p>It might be possible to make better code by paying attention to the
order in which to generate code for subexpressions of an expression.</p>

<h3><a name="distributive_law">Distributive law</a></h3>

<p>The C expression <code>*(X + 4 * (Y + C))</code> compiles better on
certain machines if rewritten as <code>*(X + 4*C + 4*Y)</code> because
of known addressing modes.  It may be tricky to determine when, and
for which machines, to use each alternative.</p>

<p>Some work has been done on this, in combine.c.</p>

<h2><a name="simpler_porting">Simpler porting</a></h2>

<p>Right now, describing the target machine's instructions is done
cleanly, but describing its addressing mode is done with several
ad-hoc macro definitions.  Porting would be much easier if there were
an RTL description for addressing modes like that for instructions.
Tools analogous to genflags and genrecog would generate macros from
this description.</p>

<p>There would be one pattern in the address-description file for each
kind of addressing, and this pattern would have:</p>

<ul>
  <li>the RTL expression for the address</li>
  <li>C code to verify its validity (since that may depend on
      the exact data).</li>
  <li>C code to print the address in assembly language.</li>
  <li>C code to convert the address into a valid one, if it is not valid.
      (This would replace LEGITIMIZE_ADDRESS).</li>
  <li>Register constraints for all indeterminates that appear
      in the RTL expression.</li>
</ul>

<h2><a name="other_languages">Other languages</a></h2>

<p>We currently have front ends for Ada, C, C++, Objective C, 
Fortran, and Java.  A Pascal front end exists but has not yet
been integrated.</p>

<p>Cobol and Modula-2 front ends might be useful, and are being worked
on.</p>

<h2><a name="generalize_the_machine_model">Generalize the machine model</a></h2>

<p>Some new compiler features may be needed to do a good job on
machines where static data needs to be addressed using base registers.</p>

<p>Some machines have two stacks in different areas of memory, one
used for scalars and another for large objects.  The compiler does not
now have a way to understand this.</p>

<p>The scheduler does not do very well on recent RISC machines.  Haifa
helps but not enough.</p>

<h2><a name="more_warnings">More warnings</a></h2>

<p>Warn about statements that are undefined because the order of
evaluation of increment operators makes a big difference.  Here is an
example:</p>
<pre>
*foo++ = hack (*foo);
</pre>

<p><code>-Wsequence-point</code> does some of this, but not that
particular case.</p>

<hr />

<h2><a name="the_old_problems_file">The old PROBLEMS file</a></h2>

<p>The following used to be in a file <code>PROBLEMS</code> in the GCC
 distribution.  Probably much of it is no longer relevant as of GCC 3.0
(the file hadn't changed since GCC 2.0), but some might be.  Someone
should go through it, identifying what is and isn't relevant, adding
anything applicable to current GCC (and describing a bug) to our
<a href="../bugs.html">bug-tracking system</a> and sending patches to
gcc-patches to remove such analysed entries from the list.</p>

<ol>
  <li value="10">
  <pre>
        movl a3@,a0
        movl a3@(16),a1
        clrb a0@(a1:l)
  </pre>
  <p>is generated and may be worse than</p>
  <pre>
        movl a3@,a0
        addl a3@(16),a0
        clrb a0@
  </pre>
  <p>If ordering of operands is improved, many more such cases will be
  generated from typical array accesses.</p></li>

  <li value="63">Potential problem in <code>cc_status.value2</code>, if it
  ever activates itself after a two-address subtraction (which currently
  cannot happen).  It is supposed to compare the current value of the
  destination but eliminating it would use the results of the
  subtraction, equivalent to comparing the previous value of the
  destination.</li>

  <li value="85">pea can force a value to be reloaded into an areg which
  can make it worse than separate adding and pushing.  This can only
  happen for adding something within addql range and it only loses if
  the qty becomes dead at that point so it can be added to with no
  copying.</li>

  <li value="108">Can speed up flow analysis by making a table saying
  which register is set and which registers are used by each instruction
  that only sets one register and only uses two.  This way avoid the
  tree walk for such instructions (most instructions).</li>

  <li value="109">It is desirable to avoid converting INDEX to SImode if a
  narrower mode suffices, as HImode does on the 68000.  How can this be
  done?</li>

  <li value="110">Possible special combination pattern: If the two
  operands to a comparison die there and both come from insns that are
  identical except for replacing one operand with the other, throw away
  those insns.  Ok if insns being discarded are known 1 to 1.  An andl
  #1 after a seq is 1 to 1, but how should compiler know that?</li>

  <li value="117">Any number of slow zero-extensions in one loop, that
  have their clr insns moved out of the loop, can share one register if
  their original life spans are disjoint.  But it may be hard to be sure
  of this since the life span data that regscan produces may be hard to
  interpret validly or may be incorrect after cse.</li>

  <li value="118">In cse, when a bfext insn refers to a register, if the
  field corresponds to a halfword or a byte and the register is
  equivalent to a memory location, it would be possible to detect this
  and replace it with a simple memory reference.</li>

  <li value="122">When <code>insn-output.c</code> turns a bit-test into a
  sign-test, it should see whether the condition code is already set up
  with that sign.</li>
</ol>

</body>
</html>
