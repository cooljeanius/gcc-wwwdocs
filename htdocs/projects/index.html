<html>

<head>
<title>GCC Projects</title>
</head>

<body><!-- table of contents start -->
<h1><a name="toc">Table of Contents</a></h1>
<ul>
<li><a href="#fix_bugs_in_the_gnats_database">Fix bugs in the GNATS database</a>
<li><a href="#projects_for_beginner_gcc_hackers">Projects for beginner GCC hackers</a>
<li><a href="#projects_for_the_c_preprocessor">Projects for the C preprocessor</a>
<li><a href="#projects_for_the_gcc_web_pages">Projects for the GCC web pages</a>
<li><a href="#work_in_progress">Work in progress</a>
<ul>
<li><a href="#bounds_checking_with_bounded_pointers">Bounds Checking with Bounded Pointers</a>
<li><a href="#new_register_allocator">New register allocator</a>
<li><a href="#ssa_for_trees">SSA for trees</a>
<li><a href="#cfgbranch">CFG branch</a>
<li><a href="#value_range_propagation_pass">Value range propagation pass</a>
<li><a href="#automaton_based_pipeline_hazard_recognizer">Automaton based pipeline hazard recognizer</a>
<li><a href="#ast_optimizer">Tree optimization passes</a>
<li><a href="#data_prefetch">Data prefetch support</a>
</ul>
<li><a href="#optimizer_inadequacies">Optimizer inadequacies</a>
<li><a href="#ia64 projects">Projects to improve performance on IA-64</a>
<li><a href="#changes_to_support_c99_standard">Changes to support C99 standard</a>
<li><a href="#improve_the_haifa_scheduler">Improve the Haifa scheduler</a>
<li><a href="#improvements_to_gcse_and_pre">Improvements to global cse and partial redundancy elimination:</a>
<li><a href="#miscellaneous_ideas">Miscellaneous ideas:</a>
<ul>
<li><a href="#chill_should_use_gc">Chill should use garbage collection</a>
<li><a href="#improve_wconversion">Improve <code>-Wconversion</code></a>
<li><a href="#implement_various_builtin_functions_for_isoc99">Implement various builtin functions for ISO C99's 
<code>&lt;tgmath.h&gt;</code></a>
<li><a href="#fully_document_the_interface_of_front_ends_to_gcc">Fully document the interface of front ends to GCC</a>
</ul>
<li><a href="#better_builtin_string_functions">Better builtin string functions</a>
<ul>
<li><a href="#optimize_memset">Optimize <code>memset</code></a>
<li><a href="#optimize_strcpy">Optimize <code>strcpy</code></a>
<li><a href="#optimize_strncpy">Optimize <code>strncpy</code></a>
<li><a href="#optimize_strncat">Optimize <code>strncat</code></a>
<li><a href="#optimize_strcmp">Optimize <code>strcmp</code></a>
<li><a href="#optimize_strncmp">Optimize <code>strncmp</code></a>
<li><a href="#optimize_strcspn">Optimize <code>strcspn</code></a>
<li><a href="#optimize_strspn">Optimize <code>strspn</code></a>
<li><a href="#optimize_strpbrk">Optimize <code>strpbrk</code></a>
</ul>
<li><a href="#format_checking">Format (<code>printf</code>, <code>scanf</code> and
<code>strftime</code>) checking:</a>
<li><a href="#improve_the_installation_procedure">Improve the installation procedure</a>
<li><a href="#the_old_projects_file">The old PROJECTS file</a>
<ul>
<li><a href="#putting_constants_in_special_sections">Putting constants in special sections.</a>
<li><a href="#optimize_a_sequence_of_if_statements_whose_conditions_are">Optimize a sequence of if statements whose conditions are
exclusive.</a>
<li><a href="#un_cse">Un-cse.</a>
<li><a href="#clean_up_how_cse_works">Clean up how cse works.</a>
<li><a href="#support_more_general_tail_recursion_among_different_functions">Support more general tail-recursion among different functions.</a>
<li><a href="#keep_global_variables_in_registers">Keep global variables in registers.</a>
<li><a href="#live_range_splitting">Live-range splitting.</a>
<li><a href="#detect_dead_stores_into_memory">Detect dead stores into memory?</a>
<li><a href="#loop_optimization">Loop optimization.</a>
<li><a href="#using_constraints_on_values">Using constraints on values.</a>
<li><a href="#change_the_type_of_a_variable">Change the type of a variable.</a>
<li><a href="#better_handling_for_very_sparse_switches">Better handling for very sparse switches.</a>
<li><a href="#order_of_subexpressions">Order of subexpressions.</a>
<li><a href="#more_code_motion">More code motion.</a>
<li><a href="#trace_scheduling">Trace scheduling.</a>
<li><a href="#distributive_law">Distributive law.</a>
<li><a href="#restructuring_conditionals">Restructuring conditionals</a>
<li><a href="#how_to_call_this">??? How to call this???</a>
</ul>
<li><a href="#simpler_porting">Simpler porting</a>
<li><a href="#other_languages">Other languages</a>
<li><a href="#more_extensions">More extensions</a>
<li><a href="#generalize_the_machine_model">Generalize the machine model</a>
<li><a href="#more_warnings">More warnings</a>
<li><a href="#better_documentation_of_how_gcc_works_and_how_to_port_it">Better documentation of how GCC works and how to port it</a>
<li><a href="#the_old_problems_file">The old PROBLEMS file</a>
</ul>
<!-- table of contents end -->


<h1 align=center>GCC Projects</h1>

<h2><a name="fix_bugs_in_the_gnats_database">Fix bugs in the GNATS database</a></h2>
<p>You can investigate bugs in our <a href="../gnats.html">GNATS
database</a> and attempt to fix them or see whether they still are
present in current GCC.

<h2><a name="projects_for_beginner_gcc_hackers">Projects for beginner GCC hackers</a></h2>
<p>If you are new to GCC, start with our <a
href="beginner.html">projects for beginners</a>.

<h2><a name="projects_for_the_c_preprocessor">Projects for the C preprocessor</a></h2>
<p>There is a separate project list for the <a
href="cpplib.html">C preprocessor</a>.

<h2><a name="projects_for_the_gcc_web_pages">Projects for the GCC web pages</a></h2>
<p>There is a separate projects list for the <a href="web.html">web
pages</a>.</p>

<h2><a name="work_in_progress">Work in progress</a></h2>
<p>Different projects that are in progress.</p>

<h3><a name="bounds_checking_with_bounded_pointers">Bounds Checking with Bounded Pointers</a></h3>
<p>There is a separate page for <a
href="bp/main.html">Bounds Checking with Bounded Pointers</a>.</p>

<h3><a name="new_register_allocator">New register allocator</a></h3>
<p>Daniel Berlin and Michael Matz are working on an implementation of
a graph-coloring register allocator. A branch is created in CVS with
the tag <code>new-regalloc-branch</code>. It is known to bootstrap
under x86-linux and ppc-linux.</p>

<h3><a name="ssa_for_trees">SSA for trees</a></h3>
<p>Diego Novillo is working on implementing 
<a href="ast-optimizer.html#ssa_for_trees">SSA analysis for trees</a>.</p>

<h3><a name="cfgbranch">CFG branch</a></h3>
<p>The <a href="cfg.html">cfg branch</a> is created to develop and
test infrastructure for easier writing of new optimizations.  Some new
passes (such as superblock formation, loop peeling, web construction,
branch combining etc.)  are being implemented there.</p>


<h3><a name="value_range_propagation_pass">Value range propagation pass</a></h3>
<p>John Wehle (john@feith.com) implemented a <a
href="http://gcc.gnu.org/ml/gcc-patches/2000-07/msg00968.html">value
range propagation pass</a> which isn't yet in GCC.</p>

<h3><a name="automaton_based_pipeline_hazard_recognizer">Automaton based pipeline hazard recognizer</a></h3> 
<p>Vladimir Makarov has implemented an 
<a href="http://gcc.gnu.org/ml/gcc-patches/2001-06/msg00951.html">
automaton based pipeline hazard recognizer</a>. It enables better
instruction scheduling and it provides the base for a future sofware
pipelining implementation.</p>

<h3><a name="ast_optimizer">Tree optimization passes</a></h3>
A separate page describes <a href="ast-optimizer.html">abstract
syntax tree optimization passes</a> that are being worked on.</p>

<h3><a name="data_prefetch">Data prefetch support</a></h3>
<p>A separate page describes <a href="prefetch.html">
data prefetch support and optimizations</a> that are in development
in the main branch.</p>
  
<h2><a name="optimizer_inadequacies">Optimizer inadequacies</a></h2>
<p>We also have a page detailing <a href="optimize.html">optimizer
inadequacies</a>, if you'd prefer to think about it in terms of problems
instead of features.</p>

<h2><a name="ia64 projects">Projects to improve performance on IA-64</a></h2>
<p>There is a separate project list for
<a href="ia64.html">IA-64 performance improvements</a>.</p>

<h2><a name="changes_to_support_c99_standard">Changes to support C99 standard</a></h2>

<p>The new version of the C standard (ISO/IEC 9899:1999) requires a
number of library changes; these have to be provided by the C library,
and not by gcc.  In addition, there are also changes to the language
proper, and some compiler support is needed for the new library
features.  An <a href="../c99status.html">overview</a> of the C99
implementation status is available.</p>

<h2><a name="improve_the_haifa_scheduler">Improve the Haifa scheduler</a></h2> (haifa-sched.c, loop.[ch],
unroll.c, genattrtab.c): (contact <a
href="mailto:law@cygnus.com">law@cygnus.com</a> before starting any
serious haifa work)

<ul>
  <li>Fix/add comments throughout the code.  Many of the comments are
  from the old scheduler and are out of date and misleading.  Many new
  hunks of code don't have sufficient comments and documentation.
  Those which do have comments need to be rewritten to use complete
  sentences and proper formatting.

  <li>Someone needs make one (or more) passes over the scheduler as a
  whole to just clean it up.  Try to move the machine dependent bits
  into the target files where they belong, avoid re-creating functions
  where or near equivalents already exist (e.g. is_conditional_branch
  and friends), etc., etc.

  <li>Document the new scheduling options.  Remove those options which
  are not really useful (like reverse scheduling for example).  In
  general the haifa scheduler adds <b>way</b> too many options.  I'm
  definitely of the opinion that gcc already has too many
  <code>-f</code>options, and haifa doesn't help that situation.

  <li>Testing and benchmarking.  We've converted a few ports to using
  the Haifa scheduler (hppa, sparc, ppc, alpha).  We need to continue
  testing and benchmarking the new scheduler on additional targets.

  <li>We need to have some kind of docs for how to best describe a
  machine to the haifa scheduler to get good performance.  Some
  existing ports have been tuned to deal with the old scheduler --
  they may need to be tuned to generate good schedules with haifa.
</ul>

<h2><a name="improvements_to_gcse_and_pre">Improvements to global cse and partial redundancy elimination:</a></h2>

<p>The current implementation of global cse uses partial redundancy
elimination via lazy code motion (lcm).

<p>lcm also provides the underlying framework for several additional
optimizations such as shrink wrapping, spill code motion, dead store
elimination, and generic load/store motion (all the other examples are
subcases of load/store motion).

<p>It can probably also be used to improve the reg-stack pass of the
compiler.

<p>Contact <a href="mailto:law@cygnus.com">law@cygnus.com</a> if
you're interested in working on lazy code motion.</p>

<h2><a name="miscellaneous_ideas">Miscellaneous ideas:</a></h2>

<p>The following are some miscellaneous ideas for GCC projects to work
on.</p>

<h3><a name="chill_should_use_gc">Chill should use garbage collection</a></h3>
<p>Convert the Chill front end to use garbage collection instead of
obstacks, so it can work again with current GCC.</p>

<h3><a name="improve_wconversion">Improve <code>-Wconversion</code></a></h3>
<p>Improve <code>-Wconversion</code> so that it can be used for
security auditing as well as for its original intended purpose of
helping with converting old code to ISO C.  See a
<a href="http://www2.merton.ox.ac.uk/~security/security-audit-200012/0028.html">message
to the security-audit list</a> discussing this.  The design for such
an improved option or collection of options should be discussed with
the gcc and security-audit lists.</p>

<h3><a name="implement_various_builtin_functions_for_isoc99">Implement various builtin functions for ISO C99's 
<code>&lt;tgmath.h&gt;</code></a></h3> 
<p>Design and implement builtin functions that assist in implementing
the ISO C99 <code>&lt;tgmath.h&gt;</code> macros.  These builtins
could be along the general lines of the macros used in glibc 2.2 (for
example, the implementation of <code>&lt;tgmath.h&gt;</code> might use
<code>__builtin_tgmath_unary_real_only (value, log2f, log2,
log2l)</code> to implement the <code>log2</code> macro), but should be
designed so that, if the Annex G imaginary types are implemented in
GCC, glibc does not need to change again to allow for them.  This
means additional functions, beyond those corresponding to the macros
in glibc, are needed to handle the trigonometric functions which G.7
specifies have real or imaginary result type for imaginary arguments,
but which have complex result type for complex arguments.  The design
for these builtins should be discussed with the gcc and libc-alpha
lists.</p>

<h3><a name="fully_document_the_interface_of_front_ends_to_gcc">Fully document the interface of front ends to GCC</a></h3>
<p>Fully document the interface of front ends to GCC (that is, the
<code>tree</code> interfaces, and the various functions, hooks, etc.,
that a front end must or may provide).  <code>gcc/c-tree.texi</code>
includes some of this information; <code>gcc/LANGUAGES</code> contains
incomplete information about changes that have been made to this
interface.</p>

<h2><a name="better_builtin_string_functions">Better builtin string functions</a></h2>

<p>GNU libc includes some macros to optimize calls to some string
functions with constant arguments.  These macros tend to cause huge
blowup in the size of preprocessed source if nested; for example, each
nested call to <code>strcpy</code> expands the source 20-fold, with
four nested calls having an expansion ten megabytes in size.  GCC then
consumes a huge amount of memory compiling such expressions.  Many of
the optimizations to ISO C string functions could be implemented in
GCC and then disabled in glibc, with benefits to other systems as
well, and the potential to use information GCC has about
alignment.</p>

<p>All the string functions act as if they access individual
characters, so care may need to be taken that no
<code>-fstrict-aliasing</code> problems occur when internal uses of
other types are generated.  Also, the arguments to the string function
must be evaluated exactly once each (if they have any side effects),
even though the call to the string function might be optimized away.</p>

<p>Care must be taken that any optimizations in GCC are
standards-conforming in terms of not possibly accessing beyond the
arrays involved (possibly within a function call created in the
optimization); whereas the glibc macros know the glibc implementation
and how much memory it might access, GCC optimizations can't.  When
<code>-fcheck-memory-usage</code> is used, calls to the checking
functions from Checker may need to be emitted; see the existing
builtin string functions in GCC for examples.</p>

<p>There are some further optimizations in glibc not covered here,
that either optimize calls to non-ISO C functions or call glibc
internal functions in the expansion of the macro.</p>

<p>glibc also has inline assembler versions of various string
functions; GCC has some, but not necessarily the same ones on the same
architectures.</p>

<p>Many of these optimizations should not be applied if
<code>-Os</code> is specified.</p>

<h3><a name="optimize_memset">Optimize <code>memset</code></a></h3>
<p>GCC optimizes <code>memset</code> only when the value and length
involved have no side effects, and the value is a constant zero.  On
architectures allowing unaligned accesses, glibc also optimizes if the
length is constant and does not exceed 16; the value to which memory
is set need not be constant.  In such a case, GCC should convert the
value (constant or not) to <code>unsigned char</code>, maybe using
<code>save_expr</code> to protect against multiple evaluation, and
compute and store the values <code>c * 0x01</code>, <code>c *
0x0101</code>, and so on (whichever are needed for the given length),
to store as single words then as part of a word.  Where the
architecture does not support unaligned accesses, GCC may still be
able to optimize if the destination is known to be suitably aligned.
For example, no alignment is needed for a set of one byte; a set of
zero bytes should be eliminated in all cases; if two bytes are to be
set, two byte alignment may suffice; and so on.</p>

<h3><a name="optimize_strcpy">Optimize <code>strcpy</code></a></h3>
<p>GCC converts <code>strcpy</code> from a string constant into a
<code>memcpy</code> with the known length of that string constant.  In
turn, <code>emit_block_move</code> may expand that <code>memcpy</code>
inline.  glibc includes optimizations to load the constant contents of
the string directly rather than via a memory copy, when no more than 8
bytes need copying.  <code>emit_block_move</code> could be taught to
find the contents of the string constant and include the appropriate
integers directly in the assembler output for the copy.</p>

<h3><a name="optimize_strncpy">Optimize <code>strncpy</code></a></h3>
<p>Similarly, glibc optimizes <code>strncpy</code> from a string
constant.  Where the maximum length to be copied is not more than the
length of the string constant including the terminating null
character, GCC could (but does not) optimize as a
<code>memcpy</code>.  Where the maximum length to be copied is
greater, trailing null characters must be added to make up the length;
here glibc can use a micro-optimization not available to GCC, its
<code>__mempcpy</code> function to copy and return the address after
the data copied, to pass into <code>memset</code>.  This is only used
when as inline assembler <code>__mempcpy</code> is available.</p>

<h3><a name="optimize_strncat">Optimize <code>strncat</code></a></h3>
<p>glibc optimizes <code>strncat</code> with constant source and
maximum length.  If the maximum length exceeds the length of the
source string, it is optimized to <code>strcat</code>; GCC could do
this (including when the maximum length equals the length of the
source string).  Otherwise, on architectures where glibc has an
inline assembler <code>strchr</code> and it is used, glibc converts
the <code>strncat</code> to a <code>memcpy</code>, but fails to add
the terminating null character.</p>

<h3><a name="optimize_strcmp">Optimize <code>strcmp</code></a></h3>
<p>glibc has various complicated optimizations for
<code>strcmp</code>.  The following in GCC would completely cover
them: comparisons of constant strings should be done at compile time;
comparisons where one string is constant and of length less than 4
should be inlined to compare successive bytes to the known constant
ones (further optimization to compare more than one byte at once is in
general unsafe as it might access too much memory).  Certain of these
cases could also be inlined for <code>memcmp</code>.</p>

<h3><a name="optimize_strncmp">Optimize <code>strncmp</code></a></h3>
<p>glibc optimizes <code>strncmp</code>, where one string is constant
and strictly shorter than the maximum number of characters to be
compared, by replacing it with <code>strcmp</code> (which may then be
further optimized).  This may not be safe for GCC except in the cases
where it handles <code>strcmp</code> internally as above, since
<code>strcmp</code> may require both strings to be null-terminated
whereas <code>strncmp</code> doesn't.</p>

<h3><a name="optimize_strcspn">Optimize <code>strcspn</code></a></h3>
<p>glibc optimizes <code>strcspn</code> where the string of excluded
characters is constant and of length not greater than three.  GCC
could readily optimize the specific case where the length is zero,
converting it to <code>strlen</code>.</p>

<h3><a name="optimize_strspn">Optimize <code>strspn</code></a></h3>
<p>Similarly, glibc optimizes <code>strspn</code> where not more than
three characters are involved.  Where there are zero characters
acceptable in the initial segment, GCC could optimize to the integer
constant 0.</p>

<h3><a name="optimize_strpbrk">Optimize <code>strpbrk</code></a></h3>
<p>glibc also has similar optimizations for <code>strpbrk</code>.
The cases of finding the first occurrence of zero characters (return a
null pointer) or one character (convert to <code>strchr</code>) could
readily be optimized by GCC.</p>


<h2><a name="format_checking">Format (<code>printf</code>, <code>scanf</code> and
<code>strftime</code>) checking:</a></h2>

<p>Contact <a href="mailto:jsm28@cam.ac.uk">jsm28@cam.ac.uk</a> before
doing any substantial format checking work.</p>

<ul>

<li>Make re-entrant: eliminate global state used for <code>$</code>
format checking.</li>

<li><code>strftime</code>: warnings for use of <code>0</code>,
<code>-</code> or <code>_</code> flags without width on formats where
inappropriate.  Similar warnings where use of one format feature is
useless unless another one is also used also apply for
<code>printf</code> formats (<code>0</code> and <code>-</code> flags
when no width is specified and so there is no padding) and for
<code>strfmon</code> formats.</li>

<li>Integer <code>printf</code> formats: warn for integer constant
argument out of range of unpromoted type (including signed/unsigned
where it doesn't fit in range).</li>

<li>For bounded pointers: check that all levels of pointers in the
list of format argument have the correct boundedness
qualification.</li>

<li>Fix detection of whether format strings are narrow or wide on
targets where <code>wchar_t</code> is <code>char</code>.  This may
require changes elsewhere in the compiler to mark string constants
with this information.</li>

<li>Improve how types of format arguments (both expected types and
actual argument types) are named in diagnostics; see <a href="http://gcc.gnu.org/cgi-bin/gnatsweb.pl?cmd=view&amp;pr=1027&amp;database=gcc">PR
c/1027</a>.</li>

<li>Include an option to warn for format extensions that have been
obsoleted by standard C99 features.</li>

<li>Meaning of "quad" and <code>%q</code>: anything more accurate than
<code>long long</code>?  See messages <a
href="http://gcc.gnu.org/ml/gcc-bugs/1999-02n/msg00164.html">1</a> and
<a href="http://gcc.gnu.org/ml/gcc-bugs/2000-08/msg00272.html">2</a>
about this to gcc-bugs.  (Note that <code>%q</code> is now largely
obsolete given the new C99 formats and macros.)</li>

<li>Wide string format support.  See a <a
href="http://gcc.gnu.org/ml/gcc/2000-12/msg00170.html">message
soliciting views on the user interface to this</a> and send any views
on this to the <code>gcc</code> mailing list.</li>

<li>Clean up how <code>format.exp</code> handles
<code>TORTURE_OPTIONS</code>, by making changes elsewhere in the test
harness so that <code>TORTURE_OPTIONS</code> is initialized for each
<code>dg-init</code> rather than just once and so needing saving and
restoring.</li>

<li>When a <code>format</code> or <code>format_arg</code> attribute is
applied to a function with a non-prototype declaration, and the
function is later redeclared with a prototype or defined, the
attribute should be checked again to see if it makes sense given the
argument types of the function.  Similarly, these checks should be
made if the original attribute is on an old-style function
definition.</li>

<li>Get Marc Espie's <code>__attribute__((__nonnull__))</code> patch
in (he may be working on a cleaner version that applies to current
sources).  See messages <a
href="http://gcc.gnu.org/ml/gcc-patches/2000-01/msg00360.html">1</a>,
<a
href="http://gcc.gnu.org/ml/gcc-patches/2000-02/msg00211.html">2</a>
and <a
href="http://gcc.gnu.org/ml/gcc-patches/2000-02/msg00829.html">3</a>
to gcc-patches.  Once this is done, further related checks could be
done, such as for functions such as <code>execle</code> that require
<code>NULL</code>-terminated argument lists.</li>

<li>Possible security warnings under <code>-Wformat-security</code>:

  <ul>

  <li>Warn for <code>sprintf</code> into fixed length buffer if the
  output can't be proved not to overrun.  Similarly for
  <code>scanf</code> <code>%s</code> and <code>%[...]</code> without
  width to fixed length buffer (or possibly to any buffer); or
  <code>%s</code>, <code>%[...]</code> and <code>%c</code> with width
  to too short a buffer, including <code>%lc</code>, <code>%ls</code>
  and <code>%l[...]</code>.</li>

  </ul>

</li>

<li>(Maybe eventually:) Extensible format checking: allow programs
such as OS kernels and parts of GCC to tell GCC about additional
format conversion characters recognised by their format
functions.</li>

</ul>

<h2><a name="improve_the_installation_procedure">Improve the installation procedure</a></h2>

<p>Contact <a href="mailto:zackw@stanford.edu">zackw@stanford.edu</a>
before working on improvements to installation.</p>

<ul>

<li>See <a href="http://gcc.gnu.org/ml/gcc/2000-11/msg00556.html">a
message from Zack Weinberg</a>, and follow-ups to it, for some
discussion of some of these ideas.</li>

<li>Move the installation from incomprehensible shell scripts in the
Makefiles to more comprehensible shell scripts outside the Makefiles.</li>

<li>When installing as root, make the installed headers in
<code>$(libsubdir)</code> be owned by root rather than the user who
did the build.</li>

<li>Support Automake-style <code>DESTDIR</code>: if
<code>DESTDIR</code> is specified to <code>make install</code>,
everything should be installed under the directory specified, from
where it will get moved to the eventual installation location
specified at configure time by methods not under the control of
<code>make install</code> (for example, the installation of a binary
package).  That is, <code>configure --prefix=/usr</code> followed by
building, then installing with <code>make install
DESTDIR=/some/where</code>, would install under
<code>/some/where/usr</code>, but this would work more generally where
setting <code>prefix</code> at install time (the best solution at
present) would not, if other configure options such as
<code>--bindir</code> had been used.</li>

<li>Install driver programs under names such as <code>gcc-3.0</code>,
to discourage the use of <code>-V</code> by making it easier to keep
old driver programs around.  Also, be consistent about what programs
get links such as <code>i686-pc-linux-gnu-gcc</code>.  Possibly
<code>gccbug</code> needs this treatment as well as driver programs,
since it embeds architecture and version information.  (Maybe, after
this is done <code>-V</code> could be deprecated.)</li>

<li>Add a configure option <code>--enable-cc-links</code> or similar
which causes links to the compiler driver or shell scripts to be
installed under names <code>cc</code> (the traditional Unix compiler
name and a legacy utility in Unix98, accepting an unspecified C
language variant), <code>c89</code> (POSIX; a script running <code>gcc
-std=c89 -pedantic</code>) and <code>c99</code> (the Austin Group
revision of POSIX; a script running <code>gcc -std=c99
-pedantic</code>) for systems such as GNU/Linux where GCC is the
system compiler.</li>

<li>Fix the issues discussed in <a
href="http://gcc.gnu.org/cgi-bin/gnatsweb.pl?cmd=view&pr=346&database=gcc">PR
other/346</a>.</li>

</ul>

<hr>

<h2><a name="the_old_projects_file">The old PROJECTS file</a></h2>

<p>Stuff I know has been done has been deleted.
Stuff in progress has a contact name associated with it.</p>

<p>Better optimization.


<h3><a name="putting_constants_in_special_sections">Putting constants in special sections.</a></h3>

<p>If a function has been placed in a special
section via attributes, we may want to put its static data and string
constants in a special section too.  But which one?  (Being able to
specify a section for string constants would be useful for the Linux
kernel.)</p>

<h3><a name="optimize_a_sequence_of_if_statements_whose_conditions_are">Optimize a sequence of if statements whose conditions are
exclusive.</a></h3>

<p>It is possible to optimize

<pre>
if (x == 1) ...;
if (x == 2) ...;
if (x == 3) ...;
</pre>
into
<pre>
if (x == 1) ...;
else if (x == 2) ...;
else if (x == 3) ...;
</pre>
provided that x is not altered by the contents of the if statements.</p>

<p>It's not certain whether this is worth doing.  Perhaps programmers
nearly always write the else's themselves, leaving few opportunities
to improve anything.</p>

<h3><a name="un_cse">Un-cse.</a></h3>

<p>Perhaps we should have an un-cse step right after cse, which tries to
replace a reg with its value if the value can be substituted for the
reg everywhere, if that looks like an improvement.  Which is if the
reg is used only a few times.  Use rtx_cost to determine if the
change is really an improvement.</p>

<h3><a name="clean_up_how_cse_works">Clean up how cse works.</a></h3>

<p>The scheme is that each value has just one hash entry.  The
first_same_value and next_same_value chains are no longer needed.</p>

<p>For arithmetic, each hash table elt has the following slots:
<ul>
	<li>Operation.  This is an rtx code.
	<li>Mode.
	<li>Operands 0, 1 and 2.  These point to other hash table elements.
</ul></p>

<p>So, if we want to enter <code>(plus:SI (reg:SI 30) (const_int
104))</code>, we first enter <code>(const_int 104)</code> and find the
entry that <code>(reg:SI 30)</code> now points to.  Then we put these
elts into operands 0 and 1 of a new elt.  We put PLUS and
SI into the new elt.</p>

<p>Registers and mem refs would never be entered into the table as
such.  However, the values they contain would be entered.  There would
be a table indexed by regno which points at the hash entry for the
value in that reg.</p>

<p>The hash entry index now plays the role of a qty number.  We still
need qty_first_reg, reg_next_eqv, etc. to record which regs share a
particular qty.</p>

<p>When a reg is used whose contents are unknown, we need to create a
hash table entry whose contents say "unknown", as a place holder for
whatever the reg contains.  If that reg is added to something, then
the hash entry for the sum will refer to the "unknown" entry.  Use
UNKNOWN for the rtx code in this entry.  This replaces make_new_qty.</p>

<p>For a constant, a unique hash entry would be made based on the
value of the constant.</p>

<p>What about MEM?  Each time a memory address is referenced, we need
a qty (a hash table elt) to represent what is in it.  (Just as for a
register.)  If this isn't known, create one, just as for a reg whose
contents are unknown.</p>

<p>We need a way to find all mem refs that still contain a certain
value.  Do this with a chain of hash elts (for memory addresses) that
point to locations that hold the value.  The hash elt for the value
itself should point to the start of the chain.  It would be good for
the hash elt for an address to point to the hash elt for the contents
of that address (but this ptr can be null if the contents have never
been entered).</p>

<p>With this data structure, nothing need ever be invalidated except
the lists of which regs or mems hold a particular value.  It is easy
to see if there is a reg or mem that is equiv to a particular value.
If the value is constant, it is always explicitly constant.</p>

<h3><a name="support_more_general_tail_recursion_among_different_functions">Support more general tail-recursion among different functions</a></h3>

<p>This might be possible under certain circumstances, such as when
the argument lists of the functions have the same lengths.  Perhaps it
could be done with a special declaration.</p>

<p>You would need to verify in the calling function that it does not
use the addresses of any local variables (?) and does not use setjmp.</p>

<p><code>-foptimize-sibling-calls</code> does at least some of this.</p>

<p>Put short statics vars at low addresses and use short addressing mode?</p>

<p>Useful on the 68000/68020 and perhaps on the 32000 series, provided
one has a linker that works with the feature.  This is said to make a
15% speedup on the 68000.</p>

<h3><a name="keep_global_variables_in_registers">Keep global variables in registers</a></h3>

<p>Here is a scheme for doing this.  A global variable, or a local variable
whose address is taken, can be kept in a register for an entire function
if it does not use non-constant memory addresses and (for globals only)
does not call other functions.  If the entire function does not meet
this criterion, a loop may.</p>

<p>The VAR_DECL for such a variable would have to have two RTL
expressions: the true home in memory, and the pseudo-register used
temporarily.  It is necessary to emit insns to copy the memory
location into the pseudo-register at the beginning of the function or
loop, and perhaps back out at the end.  These insns should have
REG_EQUIV notes so that, if the pseudo-register does not get a hard
register, it is spilled into the memory location which exists in any
case.</p>

<p>The easiest way to set up these insns is to modify the routine
put_var_into_stack so that it does not apply to the entire function
(sparing any loops which contain nothing dangerous) and to call it at
the end of the function regardless of where in the function the
address of a local variable is taken.  It would be called
unconditionally at the end of the function for all relevant global
variables.</p>

<p>For debugger output, the thing to do is to invent a new binding
level around the appropriate loop and define the variable name as a
register variable with that scope.</p>

<h3><a name="live_range_splitting">Live-range splitting</a></h3>

<p>Currently a variable is allocated a hard register either for the
full extent of its use or not at all.  Sometimes it would be good to
allocate a variable a hard register for just part of a function; for
example, through a particular loop where the variable is mostly used,
or outside of a particular loop where the variable is not used.  (The
latter is nice because it might let the variable be in a register most
of the time even though the loop needs all the registers.)

Contact <a href="mailto:meissner@cygnus.com">meissner@cygnus.com</a>
before starting any work on live range splitting.</p>

<h3><a name="detect_dead_stores_into_memory">Detect dead stores into memory?</a></h3>

<p>A store into memory is dead if it is followed by another store into
the same location; and, in between, there is no reference to anything
that might be that location (including no reference to a variable
address).</p>

<p>This can be modeled as a partial redundancy elimination/lazy code
motion problem.  Contact <a
href="mailto:law@cygnus.com">law@cygnus.com</a> before working on dead
store elimination optimizations.</p>

<h3><a name="loop_optimization">Loop optimization</a></h3>

<p>Strength reduction and iteration variable elimination could be
smarter.  They should know how to decide which iteration variables are
not worth making explicit because they can be computed as part of an
address calculation.  Based on this information, they should decide
when it is desirable to eliminate one iteration variable and create
another in its place.</p>

<p>It should be possible to compute what the value of an iteration
variable will be at the end of the loop, and eliminate the variable
within the loop by computing that value at the loop end.</p>

<p>When a loop has a simple increment that adds 1, instead of jumping
in after the increment, decrement the loop count and jump to the
increment.  This allows aob insns to be used.</p>

<h3><a name="using_constraints_on_values">Using constraints on values</a></h3>

<p>Many operations could be simplified based on knowledge of the
minimum and maximum possible values of a register at any particular
time.  These limits could come from the data types in the tree, via
rtl generation, or they can be deduced from operations that are
performed.  For example, the result of an <code>and</code> operation
one of whose operands is 7 must be in the range 0 to 7.  Compare
instructions also tell something about the possible values of the
operand, in the code beyond the test.</p>

<p>Value constraints can be used to determine the results of a further
comparison.  They can also indicate that certain <code>and</code>
operations are redundant.  Constraints might permit a decrement and
branch instruction that checks zeroness to be used when the user has
specified to exit if negative.</p>

<p>John Wehle (john@feith.com) implemented a <a
href="http://gcc.gnu.org/ml/gcc-patches/2000-07/msg00968.html">value
range propagation pass</a> which isn't yet in GCC.</p>

<h3><a name="change_the_type_of_a_variable">Change the type of a variable</a></h3>

<p>Sometimes a variable is declared as <code>int</code>, it is
assigned only once from a value of type <code>char</code>, and then it
is used only by comparison against constants.  On many machines,
better code would result if the variable had type <code>char</code>.
If the compiler could detect this case, it could change the
declaration of the variable and change all the places that use it.</p>

<h3><a name="better_handling_for_very_sparse_switches">Better handling for very sparse switches</a></h3>

<p>There may be cases where it would be better to compile a switch
statement to use a fixed hash table rather than the current
combination of jump tables and binary search.</p>

<h3><a name="order_of_subexpressions">Order of subexpressions</a></h3>

<p>It might be possible to make better code by paying attention to the
order in which to generate code for subexpressions of an expression.</p>

<h3><a name="more_code_motion">More code motion</a></h3>

<p>Consider hoisting common code up past conditional branches or tablejumps.</p>

<p>Contact <a href="mailto:law@cygnus.com">law@cygnus.com</a> before
working on code hoisting.</p>

<h3><a name="trace_scheduling">Trace scheduling</a></h3>

<p>This technique is said to be able to figure out which way a jump
will usually go, and rearrange the code to make that path the
faster one.</p>

<h3><a name="distributive_law">Distributive law</a></h3>

<p>The C expression <code>*(X + 4 * (Y + C))</code> compiles better on
certain machines if rewritten as <code>*(X + 4*C + 4*Y)</code> because
of known addressing modes.  It may be tricky to determine when, and
for which machines, to use each alternative.</p>

<p>Some work has been done on this, in combine.c.</p>

<h3><a name="restructuring_conditionals">Restructuring conditionals</a></h3>
<p>Can optimize by changing <code>if (x) y; else z;</code> into
<code>z; if (x) y;</code> if z and x do not interfere and z has no
effects not undone by y.  This is desirable if z is faster than
jumping.</p>

<h3><a name="how_to_call_this">??? How to call this???</a></h3>
<p>For a two-insn loop on the 68020, such as
<pre>
foo:	movb	a2@+,a3@+
	jne	foo
</pre>
it is better to insert <code>dbeq d0,foo</code> before the jne.
<code>d0</code> can be a junk register.  The challenge is to fit this
into a portable framework: when can you detect this situation and
still be able to allocate a junk register?</p>


<h2><a name="simpler_porting">Simpler porting</a></h2>

<p>Right now, describing the target machine's instructions is done
cleanly, but describing its addressing mode is done with several
ad-hoc macro definitions.  Porting would be much easier if there were
an RTL description for addressing modes like that for instructions.
Tools analogous to genflags and genrecog would generate macros from
this description.</p>

<p>There would be one pattern in the address-description file for each
kind of addressing, and this pattern would have:

<ul>
  <li>the RTL expression for the address
  <li>C code to verify its validity (since that may depend on
      the exact data).
  <li>C code to print the address in assembly language.
  <li>C code to convert the address into a valid one, if it is not valid.
      (This would replace LEGITIMIZE_ADDRESS).
  <li>Register constraints for all indeterminates that appear
      in the RTL expression.
</ul></p>

<h2><a name="other_languages">Other languages</a></h2>

<p>We currently have front ends for C, C++, Objective C, CHILL,
Fortran, and Java.  Pascal and Ada front ends exist but have not yet
been integrated.</p>

<p>Cobol and Modula-2 front ends might be useful, and are being worked
on.</p>

<p>Pascal, Modula-2 and Ada require the implementation of functions
within functions.  Some of the mechanisms for this already exist.</p>

<h2><a name="more_extensions">More extensions</a></h2>

<ul>
<li>Generated unique labels.  Have some way of generating distinct
labels for use in extended asm statements.  I don't know what a good
syntax would be.

<li>A way of defining a structure containing a union, in which the
choice of union alternative is controlled by a previous structure
component.

<li>Here is a possible syntax for this.
<pre>
struct foo {
  enum { INT, DOUBLE } code;
  auto union { case INT: int i; case DOUBLE: double d;} value : code;
};
</pre>

<li>Allow constructor expressions as lvalues, like this:
<pre>
(struct foo) {a, b, c} = foo();
</pre>
This would call foo, which returns a structure, and then store the
several components of the structure into the variables a, b, and c.
</ul>

<h2><a name="generalize_the_machine_model">Generalize the machine model</a></h2>

<p>Some new compiler features may be needed to do a good job on
machines where static data needs to be addressed using base registers.</p>

<p>Some machines have two stacks in different areas of memory, one
used for scalars and another for large objects.  The compiler does not
now have a way to understand this.</p>

<p>The scheduler does not do very well on recent RISC machines.  Haifa
helps but not enough.</p>

<h2><a name="more_warnings">More warnings</a></h2>

<p>Warn about statements that are undefined because the order of
evaluation of increment operators makes a big difference.  Here is an
example:
<pre>
*foo++ = hack (*foo);
</pre>
</p>
<p><code>-Wsequence-point</code> does some of this, but not that
particular case.</p>

<h2><a name="better_documentation_of_how_gcc_works_and_how_to_port_it">Better documentation of how GCC works and how to port it</a></h2>

<p>Here is an outline proposed by Allan Adler.

<p>
<ol type="I">
<li>   Overview of this document
<li>   The machines on which GCC is implemented
  <ol type="A">
  <li> Prose description of those characteristics of target machines and
       their operating systems which are pertinent to the implementation
       of GCC.
      <ol type="i">
	<li> target machine characteristics
	<li> comparison of this system of machine characteristics with
	    other systems of machine specification currently in use
      </ol>
  <li> Tables of the characteristics of the target machines on which
       GCC is implemented.
  <li> A priori restrictions on the values of characteristics of target
       machines, with special reference to those parts of the source code
       which entail those restrictions
      <ol type="i">
	<li> restrictions on individual characteristics
        <li> restrictions involving relations between various characteristics
      </ol>
  <li> The use of GCC as a cross-compiler
      <ol type="i">
	<li> cross-compilation to existing machines
	<li> cross-compilation to non-existent machines
      </ol>
  <li> Assumptions which are made regarding the target machine
      <ol type="i">
	<li>  assumptions regarding the architecture of the target machine
	<li> assumptions regarding the operating system of the target machine
	<li> assumptions regarding software resident on the target machine
	<li> where in the source code these assumptions are in effect
	made.
      </ol>
  </ol>
<li>   A systematic approach to writing the files tm.h and xm.h
  <ol type="A">
  <li> Macros which require special care or skill
  <li> Examples, with special reference to the underlying reasoning
  </ol>
<li>   A systematic approach to writing the machine description file
  <ol type="A">
  <li> Minimal viable sets of insn descriptions
  <li> Examples, with special reference to the underlying reasoning
  </ol>
<li>   Uses of the file aux-output.c
<li>   Specification of what constitutes correct performance of an
       implementation of GCC
  <ol type="A">
  <li> The components of GCC
  <li> The itinerary of a C program through GCC
  <li> A system of benchmark programs
  <li> What your RTL and assembler should look like with these benchmarks
  <li> Fine tuning for speed and size of compiled code
  </ol>
<li>   A systematic procedure for debugging an implementation of GCC
  <ol type="A">
  <li> Use of GDB
      <ol type="i">
	<li> the macros in the file .gdbinit for GCC
	<li> obstacles to the use of GDB
	  <ol type="a">
	    <li> functions implemented as macros can't be called in
	    GDB
	  </ol>
      </ol>
  <li> Debugging without GDB
      <ol type="i">
	<li> How to turn off the normal operation of GCC and access specific
	   parts of GCC
      </ol>
  <li> Debugging tools
  <li> Debugging the parser
      <ol type="i">
	<li> how machine macros and insn definitions affect the parser
      </ol>
  <li> Debugging the recognizer
      <ol type="i">
	<li> how machine macros and insn definitions affect the
	recognizer
      </ol>
  <li>
  <li> ... ditto for other components ...
  <li>
  </ol>
<li>  Data types used by GCC, with special reference to restrictions not
      specified in the formal definition of the data type
<li>  References to the literature for the algorithms used in GCC
</ol>

<hr>

<h2><a name="the_old_problems_file">The old PROBLEMS file</a></h2>

<p>The following used to be in a file <code>PROBLEMS</code> in the GCC
distribution.  Probably much of it is no longer relevant as of GCC 3.0
(the file hadn't changed since GCC 2.0), but some might be.  Someone
should go through it, identifying what is and isn't relevant, adding
anything applicable to current GCC (and describing a bug) to GNATS and
sending patches to gcc-patches to remove from the list entries that no
longer apply or have been entered in GNATS.</p>

<ol>

<li value=3>When <code>find_reloads</code> is used to count number of
spills needed it does not take into account the fact that a reload may
turn out to be a dummy.

<p>I'm not sure this really happens any more.  Doesn't it find all the
dummies on both passes?</p></li>

<li value=10>
<pre>
        movl a3@,a0
        movl a3@(16),a1
        clrb a0@(a1:l)
</pre>
<p>is generated and may be worse than</p>
<pre>
        movl a3@,a0
        addl a3@(16),a0
        clrb a0@
</pre>
<p>If ordering of operands is improved, many more such cases will be
generated from typical array accesses.</p></li>

<li value=38>Hack <code>expand_mult</code> so that if there is no
same-modes multiply it will use a widening multiply and then truncate
rather than calling the library.</li>

<li value=39>Hack expanding of division to notice cases for long -&gt;
short division.</li>

<li value=40>Represent divide insns as (DIV:SI ...) followed by a
separate lowpart extract.  Represent remainder insns as DIV:SI
followed by a separate highpart extract.  Then cse can work on the
DIV:SI part.  Problem is, this may not be desirable on machines where
computing the quotient alone does not necessarily give a
remainder--such as the 68020 for long operands.</li>

<li value=52>Reloading can look at how <code>reload_contents</code>
got set up.  If it was copied from a register, just reload from that
register.  Otherwise, perhaps can change the previous insn to move the
data via the reload reg, thus avoiding one memory ref.</li>

<li value=63>Potential problem in <code>cc_status.value2</code>, if it
ever activates itself after a two-address subtraction (which currently
cannot happen).  It is supposed to compare the current value of the
destination but eliminating it would use the results of the
subtraction, equivalent to comparing the previous value of the
destination.</li>

<li value=65>Should loops that neither start nor end with a break be
rearranged to end with the last break?</li>

<li value=69>Define the floating point converting arithmetic
instructions for the 68881.</li>

<li value=74>Combine loop opt with cse opt in one pass.  Do cse on
each loop, then loop opt on that loop, and go from innermost loops
outward.  Make loop invariants available for cse at end of loop.</li>

<li value=85>pea can force a value to be reloaded into an areg which
can make it worse than separate adding and pushing.  This can only
happen for adding something within addql range and it only loses if
the qty becomes dead at that point so it can be added to with no
copying.</li>

<li value=93>If a pseudo doesn't get a hard reg everywhere, can it get
one during a loop?</li>

<li value=96>Can do SImode bitfield insns without reloading, but must
alter the operands in special ways.</li>

<li value=99>final could check loop-entry branches to see if they
screw up deletion of a test instruction.  If they do, can put another
test instruction before the branch and make it conditional and
redirect it.</li>

<li value=106>Aliasing may be impossible if data types of refs differ
and data type of containing objects also differ.  (But check this wrt
unions.)  This may now be covered by <code>-fstrict-aliasing</code>.</li>

<li value=108>Can speed up flow analysis by making a table saying
which register is set and which registers are used by each instruction
that only sets one register and only uses two.  This way avoid the
tree walk for such instructions (most instructions).</li>

<li value=109>It is desirable to avoid converting INDEX to SImode if a
narrower mode suffices, as HImode does on the 68000.  How can this be
done?</li>

<li value=110>Possible special combination pattern: If the two
operands to a comparison die there and both come from insns that are
identical except for replacing one operand with the other, throw away
those insns.  Ok if insns being discarded are known 1 to 1.  An andl
#1 after a seq is 1 to 1, but how should compiler know that?</li>

<li value=112>Can convert float to unsigned int by subtracting a
constant, converting to signed int, and changing the sign bit.</li>

<li value=117>Any number of slow zero-extensions in one loop, that
have their clr insns moved out of the loop, can share one register if
their original life spans are disjoint.  But it may be hard to be sure
of this since the life span data that regscan produces may be hard to
interpret validly or may be incorrect after cse.</li>

<li value=118>In cse, when a bfext insn refers to a register, if the
field corresponds to a halfword or a byte and the register is
equivalent to a memory location, it would be possible to detect this
and replace it with a simple memory reference.</li>

<li value=121>Insns that store two values cannot be moved out of
loops.  The code in <code>scan_loop</code> doesn't even try to deal
with them.</li>

<li value=122>When <code>insn-output.c</code> turns a bit-test into a
sign-test, it should see whether the cc is already set up with that
sign.</li>

<li value=123>When a conditional expression is used as a function arg,
it would be faster (and in some cases shorter) to push each
alternative rather than compute in a register and push that.  This
would require being able to specify "push this" as a target for
<code>expand_expr</code>.</li>

<li value=124>On the 386, bad code results from <code>foo (bar
())</code> when <code>bar</code> returns a double, because the pseudo
used fails to get preferenced into an fp reg because of the
distinction between regs 8 and 9.</li>

</ol>

</body>
</html>
