<html>
<head>
<title>CLI Back-End and Front-End</title>
</head>

<body>
<h1>CLI Back-End and Front-End</h1>

<h2>Table of Contents</h2>

<ul>
<li><a href="#news">Latest news</a></li>
<li><a href="#intro">Introduction</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#internals">The CLI back-end</a></li>
<li><a href="#frontend">The CLI front-end</a></li>
<li><a href="#readings">Readings</a></li>
</ul>

<h2><a name="news">Latest News</a></h2>

<dl>
<dt>2007-07-10</dt>
<dd><p>Added CLI front-end</p></dd>
</dl>

<dl>
<dt>2007-05-14</dt>
<dd><p>Roberto Costa steps down as a maintainer, replaced by
Andrea Ornstein and Erven Rohou.</p></dd>
</dl>

<dl>
<dt>2007-01-09</dt>
<dd><p>Added documentation about the back-end internal structure.</p></dd>
</dl>

<dl>
<dt>2006-09-07</dt>
<dd><p>Creation of st/cli branch.</p></dd>
</dl>

<h2><a name="intro">Introduction</a></h2>
<p>
CLI is a framework that defines a platform independent format for
executables and a run-time environment for the execution of applications.
The framework has been been standardized by the European Computer
Manufacturers Association
(<a href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a>)
and by the International Organization for Standardization (ISO/IEC 23271:2006).
CLI executables are encoded in the Common Intermediate Language (CIL),
a stack-based bytecode language.
CLI framework is designed to support several programming languages
with different abstraction levels, from object-oriented managed languages
to low-level languages with no managed execution at all.
</p>
<p>
The purpose of this project is to develop a GCC back-end that produces
CLI-compliant binaries.
The initial focus is on C language (more precisely, C99);
C++ is likely to be considered in the future, as well as any
other language for which there is an interest for a CLI back-end.
</p>
<p>To explore the potential of .NET as a deployment file format, in
collaboration
with <a href="http://www.hipeac.net/node/823">HiPEAC</a>, we
developped also a CIL front-end (always using GCC).
</p>

<p>
The original maintainer of the branch is
<a href="mailto:robsettantasei@gmail.com">Roberto Costa</a>.
Since May 2007, the current maintainers are
<a href="mailto:andrea.ornstein@st.com">Andrea Ornstein</a> and
<a href="mailto:erven.rohou@st.com">Erven Rohou</a>.
</p>
<p>
The implementation currently resides in the st/cli branch.
</p>

<h2><a name="contributing">Contributing</a></h2>

<p>Check out <code>st/cli</code> branch following the instructions found in the
<a href="../svn.html">SVN documentation</a>.</p>

<p>Being this a branch, the usual maintainer rules do not apply.
The branch is being maintained by
<a href="mailto:andrea.ornstein@st.com">Andrea Ornstein</a> and
<a href="mailto:erven.rohou@st.com">Erven Rohou</a>. Checking-in into
the branch is free, provided that the action was coordinated with the
branch maintainer and that the usual contribution and testing rules
are followed.  The branch is still in heavy development and check ins
into the mainline are not planned yet.
</p>

<h2><a name="internals">The CLI back-end</a></h2>
<p>
Unlike a typical GCC back-end, CLI back-end stops the compilation flow
at the end of the middle-end passes and, without going through any RTL
pass, it emits CIL bytecode from GIMPLE representation.
As a matter of fact, RTL is not a convenient representation to emit
CLI code, while GIMPLE is much more suited for this purpose.
</p>
<p>
CIL bytecode is much more high-level than a processor machine code.
For instance, there is no such a concept of registers or of frame
stack; instructions operate on an unbound set of local variables
(which closely match the concept of local variables) and on elements
on top of an evaluation stack.
In addition, CIL bytecode is strongly typed and it requires high-level
data type information that is not preserved across RTL.
</p>

<h3><a name="mmodel">Target machine model</a></h3>
<p>
Like existing GCC back-ends, CLI is truly seen as a target machine
and, as such, it follows GCC policy about the organization of the
back-end specific files.
</p>
<p>
Unfortunately, it is not feasible to define a single CLI target
machine. The reason is that, in dealing with languages with
unmanaged datas like C and C++, the size of pointers of the target
machine must be known at compile time.
Therefore, separate 32-bit and 64-bit CLI targets are defined,
namely <code>cil32</code> and <code>cil64</code>.
CLI binaries compiled for <code>cil32</code> are not guaranteed to
work on 64-bit machines and vice-versa.
Current work is focusing on <code>cil32</code>
target, but the differences between the two are minimal.
</p>
<p>
Being <code>cil32</code> the target machine, the machine model
description is located in files <code>config/cil32/cil32.*</code>.
This is an overview of such a description:
</p>
<ul>
  <li>The size of pointers is set to 32 (this is <code>cil32</code>
  target, it would similarly set to 64 for <code>cil64</code>).
  Natural modes for computations go up to 64 bits.</li>

  <li>Alignment rules specify that natural alignment is always
  followed (more precisely, in the absence of <code>packed</code>
  attribute).</li>

  <li>Properties exclusively needed by RTL passes are skipped.
  This is a mere consequence of the fact that CLI back-end starts
  from GIMPLE and it does not go through RTL at all.</li>

  <li>Though CLI back-end does not reach RTL passes, there is a
  minimum set of RTL-related description that must be present anyway.
  For instance, a few instruction selection patterns are mandatory,
  while others are used by some heuristics for cost estimation;
  there must be a definition of the register sets and a few peculiar
  registers have to be defined...
  As a rule of thumb, the machine model contains the simplest
  description for these properties, even if this makes little sense
  for CLI target.</li>
</ul>

<h3><a name="simp">CIL simplification pass</a></h3>
<p>
Though most GIMPLE tree codes closely match what is representable
in CIL, some simply do not.
Those codes could still be expressed in CIL bytecodes by a
CIL-emission pass; however, it would be much more difficult and
complicated to perform the required transformations at CIL
emission time (i.e.: those that involve generating new local temporary
variables, modifications in the control-flow graph or in types...),
than directly on GIMPLE expressions.
</p>
<p>
Pass <code>simpcil</code> (file
<code>config/cil32/tree-simp-cil.c</code>) is in charge of performing
such transformations.
The input is any code in GIMPLE form; the outcome is still valid
GIMPLE, it just contains only constructs for which CIL emission is
straightforward.
Such a constrained GIMPLE format is referred as "CIL simplified"
GIMPLE throughout this documentation.
</p>
<p>
The pass is currently performed just once, after leaving SSA form and
immediately before the CIL emission.
This is not a constraint; the only requirement is that the
CIL emission is immediately preceded by a run of <code>simpcil</code>.
<code>simpcil</code> pass is designed to be idempotent and it is perfectly
fine to insert additional previous runs in the compilation flow.
Given its current position in the list of passes,
<code>simpcil</code> does not yet support SSA form (though planned).
</p>
<p>
This is a non-exhaustive list of <code>simpcil</code> transformations:
</p>
<ul>
  <li>Removal of <code>RESULT_DECL</code> nodes.
  CIL doesn't treat the value
  returned by a function in any special way: if it has to be
  temporarily stored, this must happen in a local.
  A new local variable is generated and each <code>RESULT_DECL</code>
  node is transformed into a <code>VAR_DECL</code> of that variable.</li>

  <li>Expansion of <code>LROTATE_EXPR</code> and
  <code>RROTATE_EXPR</code> nodes.
  In CIL there no are opcodes for rotation and they have
  to be emulated through shifts and bit operations.
  A previous expansion may generate better code (i.e.:
  it may fold constants) or trigger further optimizations.</li>

  <li>Expansion of <code>ABS_EXPR</code> nodes (in case of
  <code>-mexpand-abs</code> option), of <code>MAX_EXPR</code> and
  <code>MIN_EXPR</code> nodes (in case of <code>-mexpand-minmax</code>
  option) and of <code>COND_EXPR</code> nodes used as expressions
  (not statements).
  The expansion requires changes to the control-flow graph.</li>

  <li>Expansion of <code>LTGT_EXPR</code>, <code>UNEQ_EXPR</code>,
  <code>UNLE_EXPR</code> and <code>UNGE_EXPR</code> nodes.
  CIL instruction set has some support for comparisons,
  but it is not orthogonal. Whenever a comparison is difficult to be
  translated in CIL, it is expanded.</li>

  <li>Expansion of <code>SWITCH_EXPR</code>, when it is not profitable
  to have a switch table (heuristic decision is based on case density).
  CIL emission pass always emits a <code>SWITCH_EXPR</code> to a
  CIL switch opcode. When a low case density makes compare trees
  preferable, the <code>SWITCH_EXPR</code> is expanded; otherwise the
  <code>SWITCH_EXPR</code> is not modified.
  The expansion requires changes to the control-flow graph.</li>

  <li>Expansion of <code>COMPONENT_REF</code> nodes operating on
  bit-fields and of <code>BIT_FIELD_REF</code> nodes.
  CIL has no direct support for bit-field access; hence,
  equivalent code that extracts the bit pattern and applies the
  appropriate bit mask is generated.
  Memory access is performed by using <code>INDIRECT_REF</code> nodes.
  Beware that such nodes on the left-hand side of an
  assignment also requires a load from memory; from the memory
  access point of view, the operation cannot be made atomic.</li>

  <li>Expansion of <code>TARGET_MEM_REF nodes</code>.
  Emission of such nodes is not difficult;
  however, a previous expansion may trigger further optimizations
  (since there is no similar construct in CIL bytecodes).</li>

  <li>Expansion of <code>ARRAY_REF</code> nodes with non-zero indexes
  into <code>ARRAY_REF</code> with zero indexes.
  CIL emission of such nodes is not difficult;
  however, a previous expansion may generate better code (i.e.:
  it may fold constants) or trigger further optimizations
  (CIL arrays cannot be used for C-style arrays).
  Remark that such a simplification must keep <code>ARRAY_REF</code>s,
  they cannot be replaced by <code>INDIRECT_REF</code> nodes in order
  not to break strict aliasing.</li>

  <li>Expansion of <code>CONSTRUCTOR</code> nodes used as right-hand
  sides of <code>INIT_EXPR</code> and <code>MODIFY_EXPR</code> nodes.
  Such <code>CONSTRUCTOR</code> nodes must be implemented in CIL
  bytecode through a sequence of finer grain initializations.
  Hence, initializer statements containing <code>CONSTRUCTOR</code> nodes
  are expanded into an equivalent list of initializer statements,
  with no more <code>CONSTRUCTOR</code> nodes.</li>

  <li>Rename of inlined variables to unique names.
  Emitted variables keep the original name.
  In case of variables declared within inlined functions,
  renaming them is needed to avoid clashes.</li>

  <li>Globalization of function static variables.
  CIL locals can be used for function non-static variables;
  there is no CIL feature to do the same with function static
  variables. Therefore, those variables have their scope changed
  (they become global), and their name as well, to avoid clashes.</li>

  <li>Expansion of initializers of local variables.
  In order to simplify the emission pass, the initialization of local
  variables (for those that have it) is expanded into the body
  of the entry basic block of the function.</li>
</ul>

<h3><a name="emission">CIL emission pass</a></h3>
<p>
Pass <code>cil</code> (file <code>config/cil32/gen-cil.c</code>)
receives a CIL-simplified GIMPLE form as input and it produces
a CLI assembly file as output.
It is the final pass of the compilation flow.
</p>
<p>
Before the proper emission, <code>cil</code> currently merges GIMPLE
expressions in the attempt to eliminate local variables.
The elimination of such variables has positive effects on the
generated code, both on performance and code size (each of such an
useless local variable ends up in an avoidable pair of
<code>stloc</code> and <code>ldloc</code> CIL opcodes).
The resulting code is no longer in valid GIMPLE form; this is fine
because the code stays in this form only within the pass.
This is conceptually (perhaps not only conceptually) similar to what
done by the <code>out-of-ssa</code> pass; <code>out-of-ssa</code> may
even be more powerful in doing this, since it operates in SSA form.
It may be interesting to move <code>simpcil</code> pass before
<code>out-of-ssa</code> and to avoid any variable elimination in
<code>cil</code>.
To be evaluated.
</p>
<p>Here is an overview of how <code>cil</code> pass handles some of
GIMPLE constructs. Many of them are omitted, for which the emission is
straightforward.
</p>
<ul>
  <li>GIMPLE functions are emitted as CIL static methods of
  <code>&lt;Module&gt;</code>.</li>

  <li>Local-scope <code>VAR_DECL</code> nodes are emitted as CIL
  locals, global-scope <code>VAR_DECL</code> nodes as static fields of
  <code>&lt;Module&gt;</code>.</li>

  <li><code>INTEGER_TYPE</code>s and <code>REAL_TYPE</code>s are
  translated into their obvious equivalent CIL scalar types.
  <code>BOOLEAN_TYPE</code>s are translated as CIL
  <code>int8</code>.
  <code>POINTER_TYPE</code>s are translated as CIL <code>native
  int</code>.</li>

  <li>Data structures of type <code>RECORD_TYPE</code>,
  <code>UNION_TYPE</code>, <code>ARRAY_TYPE</code> and
  <code>ENUMERAL_TYPE</code> are emitted as valuetypes with explicit
  layout.
  Remark that GIMPLE <code>ARRAY_TYPE</code> nodes cannot be emitted
  as CIL arrays (which are managed arrays, a specific kind of objects).
  Explicit layout is necessary because layout of structures and unions
  is already done when code is in GIMPLE form; CIL declarations have to
  match the size of such data structures.</li>

  <li>Expressions with <code>INDIRECT_REF</code> and
  <code>ARRAY_REF</code> nodes are emitted as indirect memory
  accesses.
  Remark that CIL-simplified GIMPLE only allows <code>ARRAY_REF</code>
  nodes with zero offset.</li>

  <li>Expressions with <code>COMPONENT_REF</code>
  nodes are emitted as field accesses.</li>
</ul>

<h2><a name="frontend">The CLI front-end</a></h2>

<p>The objective of the project was to create a new GCC frontend able
to take a .NET executable as input, and produce optimized native code
as output.</p>
<p>This frontend, called <i>gcccil</i>, would allow us to
achieve two goals:</p>

<ul>
  <li><p>The new frontend would provide a validation of a complete
  static compilation path from C to native code using CIL as
  intermediate format. This would allow using CIL as a distribution
  format for executables. In this model, the CIL image could be
  shipped to customers instead of a native executable and each
  customer could recompile said image for the native platform that he
  prefers using GCC.</p></li>

  <li><p>The frontend would provide a way of producing native
  executables from CIL images, analogous to how the <i>GNU Compiler
  for Java</i> (<a href="http://gcc.gnu.org/java/">GCJ</a>) provides a
  way to produce native executables from Java classes.</p></li>
</ul>

<p><i>Gcccil</i> targets primarily assemblies produced by the GCC CIL
back-end since this is more convenient for achieving the first of the
goals mentioned above.</p>

<h3>Implemented functionality</h3>

<p>Since the time available for the project was limited, it was not
possible to produce a complete implementation of the
standard. However, the subset implemented is enough to correctly
compile some medium sized CIL programs produced by the GCC CIL
back-end.  Basically, everything required to compile assemblies
produced by GCC CIL back-end has been implemented and tested.</p>

<p>In particular, the following features have been implemented:</p>
<ul>
  <li><p>most base instructions (most of chapter 3 and some opcodes
  from chapter 4, partition II of ECMA-335),</p></li>
  <li><p>calls to static methods (direct and indirect),</p></li>
  <li><p>most CIL types (integers, reals, enums, structs, classes) can
  be parsed and used,</p></li>
  <li><p>structs with explicit layout and size,</p></li>
  <li><p>constant initializers,</p></li>
  <li><p>limited platform invoke (pInvoke) support,</p></li>
  <li><p>and other minor things like the volatile prefix, localloc,
  etc.</p></li>
</ul>

<h3>Missing functionality</h3>

<p>On the other hand, almost every feature which is not required to
compile assemblies produced by GCC CIL back-end has not been
implemented yet.</p>
<p> This includes:</p>
<ul>
  <li><p>object model related functionality (including strings and
  arrays),</p></li>
  <li><p>exceptions,</p></li>
  <li><p>garbage collection,</p></li>
  <li><p>reflection and support for .NET 2.0 generics.</p></li>
</ul>

<p>The main obstacle impeding the implementation of these features is
the lack of a runtime library (similar to <i>libgcj</i>) which is
necessary to implement virtual machine services like garbage
collection and reflection. Also, the standard class library (CORLIB)
needs to be ported for this environment.</p>

<h3>Implementation overview</h3>

<p><i>Gcccil</i> does not implement its own CLR metadata parser.
Instead, it uses <a href="http://www.mono-project.com/">Mono</a> to
"parse" the input assembly. That is, Mono is used to load the assembly
and parse the metadata and types. The frontend only has to parse the
actual CIL code of each method. Mono provides a comprehensive API to
allow this.</p>

<p>Once <i>gcccil</i> has loaded the assembly (or assemblies) to be
compiled, it builds GCC types for the all the types declared or
referenced in the assembly. For this, the assemblies declaring the
referenced types may need to be loaded too.</p>

<p>CIL basic types (int32, intptr, float...) are translated to their
obvious GCC equivalent. To translate classes and value types, the
GCC_RECORD_TYPE tree node is used. There is some support for class
inheritance, although it cannot be tested yet.</p>

<p>Generating types with explicit layout and size requires some
additional effort. There is already one language supported by GCC
which supports types with explicit layout (ADA), however CIL allows
the definition of some types which are not directly translatable using
the current GCC infrastructure. In particular, CIL allows to define
types with "holes". That is, types of a given size that don't have
fields defined for part of their storage (or that don't have fields at
all). However, the contents of that storage can be accessed using
pointer arithmetic and must be preserved. GCC4NET produces these kind
of types very frequently. Some optimization passes of GCC don't expect
these types, so a different representation has to be used in these
cases.</p>

<p>Once the types have been parsed, <i>gcccil</i> parses the CIL code
stream for the methods defined in the assembly in order to build GCC
GENERIC trees for them. Translating from CIL opcodes to GENERIC trees
should be straightforward once the types are built since CIL opcodes
are simple instructions that almost always have a direct translation
to GENERIC. The hardest part is using the correct type conversions to
get the correct CIL semantics in presence of all the optimizations of
GCC.</p>

<p><i>Gcccil</i> cannot compile some methods if they use some
unsupported feature. In those cases, those methods can be skipped,
allowing the user to provide a native implementation if necessary.</p>

<h2><a name="readings">Readings</a></h2>

<dl>
<dt><a name="1">[1]</a></dt>

<dd>
ECMA, <a href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">
<i>Common Language Infrastructure (CLI)</i></a>, 4th edition, June 2006.
</dd>

<dt><a name="2">[2]</a></dt>

<dd>
John Gough, <i>Compiling for the .NET Common Language Runtime (CLR)</i>,
Prentice Hall, ISBN 0-13-062296-6.
</dd>

<dt><a name="3">[3]</a></dt>

<dd>
Serge Liden, <i>Inside Microsoft .NET IL Assembler</i>, Microsoft Press,
ISBN 073561547.
</dd>
</dl>


</body>
</html>
