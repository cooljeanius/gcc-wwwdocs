<html>

<head>
<title>Status of Supported Architectures from Maintainers' Point of View</title>
</head>

<body>
<h1>Status of Supported Architectures from Maintainers' Point of View</h1>

<p>The table below shows various characteristics for all architectures
supported by GCC.  It can be used to determine an appropriate variety
of targets on which to test patches, and is also used by GCC
maintainers to track criteria that are considered when determining
which targets to obsolete.</p>
  
<p>Each characteristic has a unique letter.  Characteristics
describing fundamental properties of the architecture or target use
uppercase letters, and characteristics describing properties of the
GCC port to that architecture use lowercase letters.  The appearance
of a letter means that the architecture has that characteristic, a
blank means it does not, and a question mark means the author didn't
know whether the architecture had the characteristic or not.  For
criteria used to determine whether an architecture should be
obsoleted, the appearance of a letter is the less common case and the
lack of a letter is the common case.</p>
  
<p>Architectures are identified by the names of their subdirectories
in gcc/config, not by the CPU fields that config.guess reports.</p>

<pre>
Architecture characteristic key
-----------------------------------------------------------------------
H       A hardware implementation does not exist.
M       A hardware implementation is not currently being manufactured.
S       A Free simulator does not exist.
L       Integer registers are narrower than 32 bits.
Q       Integer registers are at least 64 bits wide.
N       Memory is not byte addressable, and/or bytes are not eight bits.
F       Floating point arithmetic is not included in the instruction set
I       Architecture does not use IEEE format floating point numbers
C       Architecture does not have a single condition code register.
B       Architecture has delay slots.
D       Architecture has a stack that grows upward.

l       Port cannot use ILP32 mode integer arithmetic.
q       Port can use LP64 mode integer arithmetic.
r       Port can switch between ILP32 and LP64 at runtime.
        (Not necessarily supported by all subtargets.)
c       Port uses cc0.
p       Port uses define_peephole (as opposed to define_peephole2).
b       Port uses '"* ..."' notation for output template code.
f       Port does not define prologue and/or epilogue RTL expanders.
g       Port does not define TARGET_ASM_FUNCTION_(PRO|EPI)LOGUE.
m       Port does not use define_constants.
d       Port does not use DFA scheduler descriptions.
i       Port generates multiple inheritance thunks using
        TARGET_ASM_OUTPUT_MI(_VCALL)_THUNK.
a       Port uses LRA (by default, i.e. unless overridden by a switch).
t       All insns either produce exactly one assembly instruction, or
        trigger a define_split.
e       &lt;arch&gt;-elf is not a supported target.
s       &lt;arch&gt;-elf is the correct target to use with the simulator
        in /cvs/src.
</pre>

<pre>
           |      Characteristics
Target     | HMSLQNFICBD lqrcpbfgmdiates
-----------+----------------------------
aarch64    |     Q        q   b g  ia  s
alpha      |  ?? Q   C    q     g  i  e
arc        |          B       b g  i
arm        |                  b    ia  s
avr        |    L  FI    l  cp  g d
bfin       |       F            g  i
c6x        |   S     CB         g  i
cr16       |    L  F C          g d    s
cris       |       F  B     c   g di   s
epiphany   |         C          g  i   s
fr30       | ??    FI B      pb gmd    s
frv        | ??       B       b    i   s
h8300      |       FI B     c   g d    s
i386       |   ? Q        q   b    ia
ia64       |   ? Q   C    qr  b    i
iq2000     | ???   FICB       b g    t
lm32       |       F            g
m32c       |    L  FI    l    b g d    s
m32r       |       FI         b        s
m68k       |   ?            cpb    i
mcore      |  ?    FI        pb gm     s
mep        |       F C        b g    t s
microblaze |         CB            i   s
mips       |     Q   CB   qr       ia  s
mmix       | HM  Q   C    q       di  e
mn10300    | ??             c   g  i   s
moxie      |       F            g d  t s
msp430     |    L  FI    l    b g d    s
nds32      |       F C             ia  s
nios2      |   S     C
nvptx      |   S Q   C    q     g     e
pa         |   ? Q   CBD  qr  b  m i  e
pdp11      |    L   IC    qrc b   d   e
rl78       |    L  F     l      g d    s
rs6000     |     Q   C    qr pb    i
rx         |                           s
s390       |   ? Q        qr    g  ia e
sh         |     Q   CB   qr p     i
sparc      |     Q   CB   qr  b    i
spu        |   ? Q  *C          g  i
stormy16   | ???L  FIC D l    b  mdi
tilegx     |   S Q   C    q     g  i  e
tilepro    |   S   F C          g  i  e
v850       | ??    FI       c   gm     s
vax        |  M?    I       c b   di  e
visium     |          B         g      s
xtensa     |         C
</pre>

<p>For AVR simulator, see <a
href="https://gcc.gnu.org/ml/gcc/2003-10/msg00027.html">
https://gcc.gnu.org/ml/gcc/2003-10/msg00027.html</a>.</p>
<p>For ARC simulator, see <a
href="https://github.com/foss-for-synopsys-dwc-arc-processors/binutils-gdb.git">
https://github.com/foss-for-synopsys-dwc-arc-processors/binutils-gdb.git</a>.</p>

<p>* SPU's float is special; it has the same format as IEEE float but has
an extended range and no infinity or NaNs. SPU's float will not produce
denormal or negative zeros; both are treated as positive zero.  On the
other hand, SPU's double is IEEE floating point.</p>

</body>
</html>
