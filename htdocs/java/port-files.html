<html>

<head>
<title>How to port the libjava file handling code</title>
</head>

<body>
<h1>How to port the libjava file handling code</h1>

<h2>Introduction</h2>

<p>The classes in <tt>java.io</tt> ultimately require some connection to
the underlying operating system's notion of files.  This document
attempts to describe how to port the native file-handling layer.</p>

<p>There are basically two parts to the porting.  First, the
<tt>FileDescriptor</tt> class is used to represent an open file.  It
has native methods to open, close, read, write, etc.  Second, the
<tt>File</tt> class can be used to manipulate the file system via
methods such as mkdir, rename, etc.</p>


<h2>Porting <tt>FileDescriptor</tt></h2>

<p>The current implementation of <tt>FileDescriptor</tt> assumes a
POSIX-like system.  For instance, the current representation of the
native state is a single <tt>int</tt>, the POSIX file descriptor.</p>

Here are the semantics of the various functions you must write to port
this class:
<dl>
<dt>boolean valid ()</dt>
<dd>Should return <tt>true</tt> if this object is valid, and
<tt>false</tt> otherwise.
</dd>

<dt>void sync ()</dt>
<dd>Synchronize the file descriptor.  On error, throw a
<tt>SyncFailedException</tt>.
</dd>

<dt>int open (String path, int flags)</dt>
<dd>Open a file and return the native file descriptor.  Should throw
exception on error.  <tt>flags</tt> is either <tt>READ</tt>,
<tt>WRITE</tt>, <tt>READ | WRITE</tt>, or <tt>WRITE | APPEND</tt> and
is used to specify the mode in which the file should be opened.
</dd>

<dt>void write (int byte)</dt>
<dd>Write a single byte (low-order bits of <tt>byte</tt>) to the
file.  Throw exception on error.
</dd>

<dt>void write (byte[] bytes, int offset, int length)</dt>
<dd>Write several bytes to the file.  If <tt>bytes</tt> is null, throw
<tt>NullPointerException</tt>.  Should check offset and length as
well, and throw <tt>ArrayIndexOutOfBoundsException</tt> on error.
Also should throw exception if write fails.
</dd>

<dt>void close ()</dt>
<dd>Close the file.  Throw exception on error.
</dd>

<dt>int seek (long pos, int whence)</dt>
<dd>Seek to a new position in the file.  <tt>whence</tt> is either
<tt>SET</tt> (set the new position absolutely) or <tt>CUR</tt> (set
the new position relative to the current position.  If the call would
set the position past the end of the file, should throw
<tt>EOFException</tt>  Should throw exception on error.  Return value
is the new position.
</dd>

<dt>long length ()</dt>
<dd>Returns the size of the file in bytes.  Throws exception on error.
</dd>

<dt>long getFilePointer ()</dt>
<dd>Returns current location in file of file pointer.  Throws
exception on error.
</dd>

<dt>int read ()</dt>
<dd>Read a single byte from the file.  On EOF, return -1.  On error,
throw exception.
</dd>

<dt>int read (byte[] buffer, int offset, int count)</dt>
<dd>First, check buffer, offset, and count, just like <tt>write</tt>.
Then read as many bytes are as available into buffer (at location
offset), up to count bytes.  If EOF hit before any bytes read, return
-1.  On error, throw exception.  Otherwise, return number of bytes
read.  This method should never return 0; instead it should block
until at least one byte is read.
</dd>

<dt>int available ()</dt>
<dd>Return number of bytes that could be read without blocking.  On
error, throw exception.
</dd>
</dl>


<h2>Porting <tt>File</tt></h2>

The File class represents a file name, and also provides the interface
to manipulating the file system.  It is this latter functionality we
are primarily concerned with.  Here are the methods involved:

<dl>
<dt>boolean access (String canonical, int query)</dt>
<dd>Determine if access to the file is permitted.  <tt>canonical</tt>
is the file name to use.  <tt>query</tt> is <tt>READ</tt> to see if
read access is permitted, <tt>WRITE</tt> to see if write access is
permitted, and <tt>EXISTS</tt> to see if the file exists.  canonical
might be null, in which case the answer should be false.
</dd>

<dt>boolean stat (String canonical, int query)</dt>
<dd>Like <tt>access</tt>, but used to query file type.  In this case,
<tt>query</tt> is either <tt>DIRECTORY</tt> to see if the name
represents a directory, or <tt>ISFILE</tt> to see if the name
represents a file (which is basically anything that is not a
directory).
</dd>

<dt>long attr (String canonical, int query)</dt>
<dd>Like <tt>stat</tt>, but returns non-boolean information about the
file.  If <tt>query</tt> is <tt>MODIFIED</tt>, return the last
modified time (in milliseconds since the Epoch).  If it is
<tt>LENGTH</tt>, return the file's length.  Return 0 on error.
</dd>

<dt>String getCanonicalPath ()</dt>
<dd>Return the canonical form of <tt>this.path</tt>.  Throw exception
on error.  See the JCL book for information on path canonicalization.
</dd>

<dt>boolean isAbsolute ()</dt>
<dd>Return true if <tt>this.path</tt> represents an absolute path for
the underlying filesystem.  The current implementation knows about
both POSIX and Windows filesystems, so probably should not need much
porting.
</dd>

<dt>String[] performList (jstring canon, FilenameFilter filter)</dt>
<dd>If the string is null, just return.  Otherwise, if it names a
directory, this should return an array of all the files in the
directory.  The directories ``.'' and ``..''  should be omitted.  If
the path is not a directory, this method should return null.
</dd>

<dt>boolean performMkdir ()</dt>
<dd>This function should make a directory named by <tt>path</tt>.
Returns true on success.
</dd>

<dt>boolean performRenameTo (File dest)</dt>
<dd>This function should rename the current file to <tt>dest</tt>.
Returns true on success.
</dd>

<dt>boolean performDelete (String canonical)</dt>
<dd>Should try to delete the path specified by <tt>canonical</tt>.
This might be either a file or a directory.  Should return true on
success.
</dd>
</dl>

</body>
</html>
