--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/Runtime.java	2004-04-18 02:22:18.000000000 -0600
+++ java/lang/Runtime.java	2003-07-21 02:18:02.000000000 -0600
@@ -52,7 +52,7 @@
  *
  * @author John Keiser
  * @author Eric Blake <ebb9@email.byu.edu>
- * @author Jeroen Frijters
+ * @status still missing 1.4 functionality
  */
 // No idea why this class isn't final, since you can't build a subclass!
 public class Runtime
@@ -95,9 +95,8 @@
    *  System.loadLibrary calls Runtime.getRuntime, triggering initialization
    *   Runtime.<clinit> calls Properties.<init>, triggering initialization
    *    Dictionary, Hashtable, and Properties have no dependencies
-   *   Runtime.<clinit> calls VMRuntime.insertSystemProperties, triggering
-   *      initialization of VMRuntime; the VM must make sure that there are
-   *      not any harmful dependencies
+   *   Runtime.<clinit> calls insertSystemProperties; the VM must make sure
+   *      that there are not any harmful dependencies
    *   Runtime.<clinit> calls Runtime.<init>
    *    Runtime.<init> calls StringTokenizer.<init>, triggering initialization
    *     StringTokenizer has no dependencies
@@ -109,7 +108,7 @@
   static Properties defaultProperties = new Properties();
   static
   {
-    VMRuntime.insertSystemProperties(defaultProperties);
+    insertSystemProperties(defaultProperties);
   }
 
   /**
@@ -127,6 +126,9 @@
    */
   private Set shutdownHooks;
 
+  /** True if we should finalize on exit.  */
+  private boolean finalizeOnExit;
+
   /**
    * The one and only runtime instance. This must appear after the default
    * properties have been initialized by the VM.
@@ -140,20 +142,13 @@
   {
     if (current != null)
       throw new InternalError("Attempt to recreate Runtime");
-    // Using defaultProperties directly avoids a security check, as well
-    // as bootstrap issues (since System is not initialized yet).
-    String path = defaultProperties.getProperty("java.library.path", ".");
-    String pathSep = defaultProperties.getProperty("path.separator", ":");
-    String fileSep = defaultProperties.getProperty("file.separator", "/");
-    StringTokenizer t = new StringTokenizer(path, pathSep);
-    libpath = new String[t.countTokens()];
-    for (int i = 0; i < libpath.length; i++)
-      {
-        String prefix = t.nextToken();
-        if (! prefix.endsWith(fileSep))
-          prefix += fileSep;
-        libpath[i] = prefix;
-      }
+
+    // We don't use libpath in the libgcj implementation.  We still
+    // set it to something to allow the various synchronizations to
+    // work.
+    libpath = new String[0];
+
+    init ();
   }
 
   /**
@@ -175,13 +170,13 @@
    *
    * <p>First, all shutdown hooks are run, in unspecified order, and
    * concurrently. Next, if finalization on exit has been enabled, all pending
-   * finalizers are run. Finally, the system calls <code>halt</code>.</p>
+   * finalizers are run. Finally, the system calls <code>halt</code>.
    *
    * <p>If this is run a second time after shutdown has already started, there
    * are two actions. If shutdown hooks are still executing, it blocks
    * indefinitely. Otherwise, if the status is nonzero it halts immediately;
    * if it is zero, it blocks indefinitely. This is typically called by
-   * <code>System.exit</code>.</p>
+   * <code>System.exit</code>.
    *
    * @param status the status to exit with
    * @throws SecurityException if permission is denied
@@ -195,53 +190,6 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(status);
-
-    if (runShutdownHooks())
-      halt(status);
-
-    // Someone else already called runShutdownHooks().
-    // Make sure we are not/no longer in the shutdownHooks set.
-    // And wait till the thread that is calling runShutdownHooks() finishes.
-    synchronized (libpath)
-      {
-        if (shutdownHooks != null)
-          {
-            shutdownHooks.remove(Thread.currentThread());
-	    // Shutdown hooks are still running, so we clear status to
-	    // make sure we don't halt.
-	    status = 0;
-          }
-      }
-
-    // If exit() is called again after the shutdown hooks have run, but
-    // while finalization for exit is going on and the status is non-zero
-    // we halt immediately.
-    if (status != 0)
-      halt(status);
-
-    while (true)
-      try
-        {
-          exitSequence.join();
-        }
-      catch (InterruptedException e)
-        {
-          // Ignore, we've suspended indefinitely to let all shutdown
-          // hooks complete, and to let any non-zero exits through, because
-          // this is a duplicate call to exit(0).
-        }
-  }
-
-  /**
-   * On first invocation, run all the shutdown hooks and return true.
-   * Any subsequent invocations will simply return false.
-   * Note that it is package accessible so that VMRuntime can call it
-   * when VM exit is not triggered by a call to Runtime.exit().
-   * 
-   * @return was the current thread the first one to call this method?
-   */
-  boolean runShutdownHooks()
-  {
     boolean first = false;
     synchronized (libpath) // Synch on libpath, not this, to avoid deadlock.
       {
@@ -301,11 +249,34 @@
                 shutdownHooks = null;
               }
           }
-	// Run finalization on all finalizable objects (even if they are
-	// still reachable).
-        VMRuntime.runFinalizationForExit();
+        // XXX Right now, it is the VM that knows whether runFinalizersOnExit
+        // is true; so the VM must look at exitSequence to decide whether
+        // this should be run on every object.
+        runFinalization();
       }
-    return first;
+    else
+      synchronized (libpath)
+        {
+          if (shutdownHooks != null)
+            {
+              shutdownHooks.remove(Thread.currentThread());
+              status = 0; // Change status to enter indefinite wait.
+            }
+        }
+    
+    if (first || status > 0)
+      halt(status);
+    while (true)
+      try
+        {
+          exitSequence.join();
+        }
+      catch (InterruptedException e)
+        {
+          // Ignore, we've suspended indefinitely to let all shutdown
+          // hooks complete, and to let any non-zero exits through, because
+          // this is a duplicate call to exit(0).
+        }
   }
 
   /**
@@ -314,23 +285,23 @@
    * <code>System.exit</code> was invoked), or when the user terminates
    * the virtual machine (such as by typing ^C, or logging off). There is
    * a security check to add hooks,
-   * <code>RuntimePermission("shutdownHooks")</code>.
+   * <code>RuntimePermission("shutdownHooks")<code>.
    *
    * <p>The hook must be an initialized, but unstarted Thread. The threads
    * are run concurrently, and started in an arbitrary order; and user
    * threads or daemons may still be running. Once shutdown hooks have
    * started, they must all complete, or else you must use <code>halt</code>,
    * to actually finish the shutdown sequence. Attempts to modify hooks
-   * after shutdown has started result in IllegalStateExceptions.</p>
+   * after shutdown has started result in IllegalStateExceptions.
    *
    * <p>It is imperative that you code shutdown hooks defensively, as you
    * do not want to deadlock, and have no idea what other hooks will be
    * running concurrently. It is also a good idea to finish quickly, as the
-   * virtual machine really wants to shut down!</p>
+   * virtual machine really wants to shut down!
    *
    * <p>There are no guarantees that such hooks will run, as there are ways
    * to forcibly kill a process. But in such a drastic case, shutdown hooks
-   * would do little for you in the first place.</p>
+   * would do little for you in the first place.
    *
    * @param hook an initialized, unstarted Thread
    * @throws IllegalArgumentException if the hook is already registered or run
@@ -363,7 +334,7 @@
   /**
    * De-register a shutdown hook. As when you registered it, there is a
    * security check to remove hooks,
-   * <code>RuntimePermission("shutdownHooks")</code>.
+   * <code>RuntimePermission("shutdownHooks")<code>.
    *
    * @param hook the hook to remove
    * @return true if the hook was successfully removed, false if it was not
@@ -408,7 +379,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(status);
-    VMRuntime.exit(status);
+    exitInternal(status);
   }
 
   /**
@@ -432,12 +403,12 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(0);
-    VMRuntime.runFinalizersOnExit(finalizeOnExit);
+    current.finalizeOnExit = finalizeOnExit;
   }
 
   /**
    * Create a new subprocess with the specified command line. Calls
-   * <code>exec(cmdline, null, null)</code>. A security check is performed,
+   * <code>exec(cmdline, null, null)<code>. A security check is performed,
    * <code>checkExec</code>.
    *
    * @param cmdline the command to call
@@ -562,7 +533,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExec(cmd[0]);
-    return VMRuntime.exec(cmd, env, dir);
+    return execInternal(cmd, env, dir);
   }
 
   /**
@@ -572,20 +543,14 @@
    *
    * @return the number of processors available, at least 1
    */
-  public int availableProcessors()
-  {
-    return VMRuntime.availableProcessors();
-  }
+  public native int availableProcessors();
 
   /**
    * Find out how much memory is still free for allocating Objects on the heap.
    *
    * @return the number of bytes of free memory for more Objects
    */
-  public long freeMemory()
-  {
-    return VMRuntime.freeMemory();
-  }
+  public native long freeMemory();
 
   /**
    * Find out how much memory total is available on the heap for allocating
@@ -593,10 +558,7 @@
    *
    * @return the total number of bytes of memory for Objects
    */
-  public long totalMemory()
-  {
-    return VMRuntime.totalMemory();
-  }
+  public native long totalMemory();
 
   /**
    * Returns the maximum amount of memory the virtual machine can attempt to
@@ -606,10 +568,7 @@
    * @return the maximum number of bytes the virtual machine will attempt
    *         to allocate
    */
-  public long maxMemory()
-  {
-    return VMRuntime.maxMemory();
-  }
+  public native long maxMemory();
 
   /**
    * Run the garbage collector. This method is more of a suggestion than
@@ -617,10 +576,7 @@
    * have "done its best" by the time it returns. Notice that garbage
    * collection takes place even without calling this method.
    */
-  public void gc()
-  {
-    VMRuntime.gc();
-  }
+  public native void gc();
 
   /**
    * Run finalization on all Objects that are waiting to be finalized. Again,
@@ -629,10 +585,7 @@
    *
    * @see #finalize()
    */
-  public void runFinalization()
-  {
-    VMRuntime.runFinalization();
-  }
+  public native void runFinalization();
 
   /**
    * Tell the VM to trace every bytecode instruction that executes (print out
@@ -641,10 +594,7 @@
    *
    * @param on whether to turn instruction tracing on
    */
-  public void traceInstructions(boolean on)
-  {
-    VMRuntime.traceInstructions(on);
-  }
+  public native void traceInstructions(boolean on);
 
   /**
    * Tell the VM to trace every method call that executes (print out a trace
@@ -653,10 +603,7 @@
    *
    * @param on whether to turn method tracing on
    */
-  public void traceMethodCalls(boolean on)
-  {
-    VMRuntime.traceMethodCalls(on);
-  }
+  public native void traceMethodCalls(boolean on);
 
   /**
    * Load a native library using the system-dependent filename. This is similar
@@ -673,8 +620,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkLink(filename);
-    if (VMRuntime.nativeLoad(filename) == 0)
-      throw new UnsatisfiedLinkError("Could not load library " + filename);
+    _load(filename, false);
   }
 
   /**
@@ -689,39 +635,20 @@
    * <code>System.mapLibraryName(libname)</code>. There may be a security
    * check, of <code>checkLink</code>.
    *
-   * @param libname the library to load
-   *
+   * @param filename the file to load
    * @throws SecurityException if permission is denied
    * @throws UnsatisfiedLinkError if the library is not found
-   *
    * @see System#mapLibraryName(String)
    * @see ClassLoader#findLibrary(String)
    */
   public void loadLibrary(String libname)
   {
-    String filename;
-    ClassLoader cl = VMSecurityManager.currentClassLoader();
-    if (cl != null)
-      {
-        filename = cl.findLibrary(libname);
-        if (filename != null)
-          {
-            load(filename);
-            return;
-          }
-      }
-    filename = System.mapLibraryName(libname);
-    for (int i = 0; i < libpath.length; i++)
-      try
-        {
-          load(libpath[i] + filename);
-          return;
-        }
-      catch (UnsatisfiedLinkError e)
-        {
-          // Try next path element.
-        }
-    throw new UnsatisfiedLinkError("Could not find library " + libname + ".");
+    // This is different from the Classpath implementation, but I
+    // believe it is more correct.
+    SecurityManager sm = securityManager; // Be thread-safe!
+    if (sm != null)
+      sm.checkLink(libname);
+    _load(libname, true);
   }
 
   /**
@@ -732,7 +659,6 @@
    * @return the localized stream
    * @deprecated <code>InputStreamReader</code> is the preferred way to read
    *             local encodings
-   * @XXX This implementation does not localize, yet.
    */
   public InputStream getLocalizedInputStream(InputStream in)
   {
@@ -747,10 +673,107 @@
    * @return the localized stream
    * @deprecated <code>OutputStreamWriter</code> is the preferred way to write
    *             local encodings
-   * @XXX This implementation does not localize, yet.
    */
   public OutputStream getLocalizedOutputStream(OutputStream out)
   {
     return out;
   }
+
+  /**
+   * Native method that actually shuts down the virtual machine.
+   *
+   * @param status the status to end the process with
+   */
+  native void exitInternal(int status);
+
+  /**
+   * Load a file. If it has already been loaded, do nothing. The name has
+   * already been mapped to a true filename.
+   *
+   * @param filename the file to load
+   * @param do_search True if we should search the load path for the file
+   */
+  native void _load(String filename, boolean do_search);
+
+  /**
+   *This is a helper function for the ClassLoader which can load
+   * compiled libraries.  Returns true if library (which is just the
+   * base name -- path searching is done by this function) was loaded,
+   * false otherwise.
+   */
+  native boolean loadLibraryInternal(String libname);
+
+  /**
+   * A helper for the constructor which does some internal native
+   * initialization.
+   */
+  private native void init ();
+
+  /**
+   * Map a system-independent "short name" to the full file name, and append
+   * it to the path.
+   * XXX This method is being replaced by System.mapLibraryName.
+   *
+   * @param pathname the path
+   * @param libname the short version of the library name
+   * @return the full filename
+   */
+  static native String nativeGetLibname(String pathname, String libname);
+
+  /**
+   * Execute a process. The command line has already been tokenized, and
+   * the environment should contain name=value mappings. If directory is null,
+   * use the current working directory; otherwise start the process in that
+   * directory.
+   *
+   * @param cmd the non-null command tokens
+   * @param env the non-null environment setup
+   * @param dir the directory to use, may be null
+   * @return the newly created process
+   * @throws NullPointerException if cmd or env have null elements
+   */
+  native Process execInternal(String[] cmd, String[] env, File dir);
+
+  /**
+   * Get the system properties. This is done here, instead of in System,
+   * because of the bootstrap sequence. Note that the native code should
+   * not try to use the Java I/O classes yet, as they rely on the properties
+   * already existing. The only safe method to use to insert these default
+   * system properties is {@link Properties#setProperty(String, String)}.
+   *
+   * <p>These properties MUST include:
+   * <dl>
+   * <dt>java.version         <dd>Java version number
+   * <dt>java.vendor          <dd>Java vendor specific string
+   * <dt>java.vendor.url      <dd>Java vendor URL
+   * <dt>java.home            <dd>Java installation directory
+   * <dt>java.vm.specification.version <dd>VM Spec version
+   * <dt>java.vm.specification.vendor  <dd>VM Spec vendor
+   * <dt>java.vm.specification.name    <dd>VM Spec name
+   * <dt>java.vm.version      <dd>VM implementation version
+   * <dt>java.vm.vendor       <dd>VM implementation vendor
+   * <dt>java.vm.name         <dd>VM implementation name
+   * <dt>java.specification.version    <dd>Java Runtime Environment version
+   * <dt>java.specification.vendor     <dd>Java Runtime Environment vendor
+   * <dt>java.specification.name       <dd>Java Runtime Environment name
+   * <dt>java.class.version   <dd>Java class version number
+   * <dt>java.class.path      <dd>Java classpath
+   * <dt>java.library.path    <dd>Path for finding Java libraries
+   * <dt>java.io.tmpdir       <dd>Default temp file path
+   * <dt>java.compiler        <dd>Name of JIT to use
+   * <dt>java.ext.dirs        <dd>Java extension path
+   * <dt>os.name              <dd>Operating System Name
+   * <dt>os.arch              <dd>Operating System Architecture
+   * <dt>os.version           <dd>Operating System Version
+   * <dt>file.separator       <dd>File separator ("/" on Unix)
+   * <dt>path.separator       <dd>Path separator (":" on Unix)
+   * <dt>line.separator       <dd>Line separator ("\n" on Unix)
+   * <dt>user.name            <dd>User account name
+   * <dt>user.home            <dd>User home directory
+   * <dt>user.dir             <dd>User's current working directory
+   * </dl>
+   *
+   * @param p the Properties object to insert the system properties into
+   */
+  static native void insertSystemProperties(Properties p);
 } // class Runtime
