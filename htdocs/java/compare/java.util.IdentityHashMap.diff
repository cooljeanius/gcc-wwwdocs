--- /home/tromey/gnu/classpath/classpath/java/util/IdentityHashMap.java	Tue Apr 30 17:58:37 2002
+++ java/util/IdentityHashMap.java	Tue Apr  2 15:20:51 2002
@@ -162,9 +162,9 @@
     // Need at least two slots, or hash() will break.
     if (max < 2)
       max = 2;
-    table = new Object[max << 1];
+    table = new Object[2 * max];
     Arrays.fill(table, emptyslot);
-    threshold = (max >> 2) * 3;
+    threshold = max / 4 * 3;
   }
 
   /**
@@ -176,7 +176,7 @@
    */
   public IdentityHashMap(Map m)
   {
-    this(Math.max(m.size() << 1, DEFAULT_CAPACITY));
+    this(Math.max(m.size() * 2, DEFAULT_CAPACITY));
     putAll(m);
   }
 
@@ -341,14 +341,12 @@
   }
 
   /**
-   * Return the value in this Map associated with the supplied key, or
-   * <code>null</code> if the key maps to nothing.
-   *
-   * <p>NOTE: Since the value could also be null, you must use
-   * containsKey to see if this key actually maps to something.
-   * Unlike normal maps, this tests for the key with <code>entry ==
-   * key</code> instead of <code>entry == null ? key == null :
-   * entry.equals(key)</code>.
+   * Return the value in this Map associated with the supplied key,
+   * or <pre>null</pre> if the key maps to nothing.  NOTE: Since the value
+   * could also be null, you must use containsKey to see if this key
+   * actually maps to something.  Unlike normal maps, this tests for the key
+   * with <code>entry == key</code> instead of
+   * <code>entry == null ? key == null : entry.equals(key)</code>.
    *
    * @param key the key for which to fetch an associated value
    * @return what the key maps to, if present
@@ -489,10 +487,10 @@
         Object[] old = table;
         // This isn't necessarily prime, but it is an odd number of key/value
         // slots, which has a higher probability of fewer collisions.
-        table = new Object[old.length << 1 + 2];
+        table = new Object[old.length * 2 + 2];
         Arrays.fill(table, emptyslot);
         size = 0;
-        threshold = (table.length >>> 3) * 3;
+        threshold = (table.length / 2) / 4 * 3;
 
         for (int i = old.length - 2; i >= 0; i -= 2)
           {
@@ -533,15 +531,13 @@
   }
 
   /**
-   * Removes from the HashMap and returns the value which is mapped by
-   * the supplied key. If the key maps to nothing, then the HashMap
-   * remains unchanged, and <code>null</code> is returned.
-   *
-   * NOTE: Since the value could also be null, you must use
-   * containsKey to see if you are actually removing a mapping.
-   * Unlike normal maps, this tests for the key with <code>entry ==
-   * key</code> instead of <code>entry == null ? key == null :
-   * entry.equals(key)</code>.
+   * Removes from the HashMap and returns the value which is mapped by the
+   * supplied key. If the key maps to nothing, then the HashMap remains
+   * unchanged, and <pre>null</pre> is returned. NOTE: Since the value
+   * could also be null, you must use containsKey to see if you are
+   * actually removing a mapping.  Unlike normal maps, this tests for the
+   * key with <code>entry == key</code> instead of
+   * <code>entry == null ? key == null : entry.equals(key)</code>.
    *
    * @param key the key used to locate the value to remove
    * @return whatever the key mapped to, if present
@@ -646,7 +642,7 @@
     // By requiring at least 2 key/value slots, and rehashing at 75%
     // capacity, we guarantee that there will always be either an emptyslot
     // or a tombstone somewhere in the table.
-    int h = Math.abs(System.identityHashCode(key) % (table.length >> 1)) << 1;
+    int h = 2 * Math.abs(System.identityHashCode(key) % (table.length / 2));
     int del = -1;
     int save = h;
 
@@ -739,8 +735,7 @@
 
     /**
      * Removes from the backing Map the last element which was fetched
-     * with the <code>next()</code> method.
-     *
+     * with the <pre>next()</pre> method.
      * @throws ConcurrentModificationException if the Map was modified
      * @throws IllegalStateException if called when there is no last element
      */
@@ -899,7 +894,7 @@
     s.defaultReadObject();
 
     int num = s.readInt();
-    table = new Object[Math.max(num << 1, DEFAULT_CAPACITY) << 1];
+    table = new Object[2 * Math.max(num * 2, DEFAULT_CAPACITY)];
     // Read key/value pairs.
     while (--num >= 0)
       put(s.readObject(), s.readObject());
