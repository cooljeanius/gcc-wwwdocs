--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/Thread.java	2004-02-04 02:21:34.000000000 -0700
+++ java/lang/Thread.java	2004-02-06 02:18:31.000000000 -0700
@@ -38,6 +38,8 @@
 
 package java.lang;
 
+import gnu.gcj.RawData;
+
 /* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
  * "The Java Language Specification", ISBN 0-201-63451-1
  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.
@@ -96,39 +98,32 @@
   /** The maximum priority for a Thread. */
   public static final int MAX_PRIORITY = 10;
 
-  /** The underlying VM thread, only set when the thread is actually running.
-   */
-  volatile VMThread vmThread;
-
   /**
    * The group this thread belongs to. This is set to null by
    * ThreadGroup.removeThread when the thread dies.
    */
-  volatile ThreadGroup group;
-
-  /** The object to run(), null if this is the target. */
-  final Runnable toRun;
+  ThreadGroup group;
 
   /** The thread name, non-null. */
-  volatile String name;
+  String name;
 
-  /** Whether the thread is a daemon. */
-  volatile boolean daemon;
+  /** The object to run(), null if this is the target. */
+  private Runnable runnable;
 
   /** The thread priority, 1 to 10. */
-  volatile int priority;
+  private int priority;
 
-  /** Native thread stack size. 0 = use default */
-  private long stacksize;
+  private boolean daemon_flag;
+  boolean interrupt_flag;
+  private boolean alive_flag;
+  private boolean startable_flag;
+  private ClassLoader context_class_loader;
 
-  /** Was the thread stopped before it was started? */
-  Throwable stillborn;
+  // This describes the top-most interpreter frame for this thread.
+  RawData interp_frame;
 
-  /** The context classloader for this Thread. */
-  private ClassLoader contextClassLoader;
-
-  /** The next thread number to use. */
-  private static int numAnonymousThreadsCreated = 0;
+  // Our native data - points to an instance of struct natThread.
+  private Object data;
 
   /**
    * Allocates a new <code>Thread</code> object. This constructor has
@@ -179,79 +174,36 @@
    */
   public Thread()
   {
-    this(null, (Runnable) null);
+    this(null, null, gen_name());
   }
 
   /**
-   * Allocate a new Thread object, as if by
-   * <code>Thread(null, toRun, <i>fake name</i>)</code>, where the fake name
-   * is "Thread-" + <i>unique integer</i>.
-   *
-   * @param toRun the Runnable object to execute
-   * @see #Thread(ThreadGroup, Runnable, String)
-   */
-  public Thread(Runnable toRun)
-  {
-    this(null, toRun);
-  }
-  
-  /**
-   * Allocate a new Thread object, as if by
-   * <code>Thread(group, toRun, <i>fake name</i>)</code>, where the fake name
-   * is "Thread-" + <i>unique integer</i>.
+   * Allocates a new <code>Thread</code> object. This constructor has
+   * the same effect as <code>Thread(null, target,</code>
+   * <i>gname</i><code>)</code>, where <i>gname</i> is
+   * a newly generated name. Automatically generated names are of the
+   * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
    *
-   * @param group the group to put the Thread into
-   * @param target the Runnable object to execute
-   * @throws SecurityException if this thread cannot access <code>group</code>
-   * @throws IllegalThreadStateException if group is destroyed
-   * @see #Thread(ThreadGroup, Runnable, String)
+   * @param target the object whose <code>run</code> method is called.
+   * @see java.lang.Thread#Thread(java.lang.ThreadGroup,
+   *                              java.lang.Runnable, java.lang.String)
    */
-  public Thread(ThreadGroup group, Runnable toRun)
+  public Thread(Runnable target)
   {
-    this(group, toRun, "Thread-" + ++numAnonymousThreadsCreated, 0);
+    this(null, target, gen_name());
   }
 
   /**
-   * Allocate a new Thread object, as if by
-   * <code>Thread(null, null, name)</code>.
+   * Allocates a new <code>Thread</code> object. This constructor has
+   * the same effect as <code>Thread(null, null, name)</code>.
    *
-   * @param name the name for the Thread
-   * @throws NullPointerException if name is null
-   * @see #Thread(ThreadGroup, Runnable, String)
+   * @param   name   the name of the new thread.
+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,
+   *          java.lang.Runnable, java.lang.String)
    */
   public Thread(String name)
   {
-    this(null, null, name, 0);
-  }
-
-  /**
-   * Allocate a new Thread object, as if by
-   * <code>Thread(group, null, name)</code>.
-   *
-   * @param group the group to put the Thread into
-   * @param name the name for the Thread
-   * @throws NullPointerException if name is null
-   * @throws SecurityException if this thread cannot access <code>group</code>
-   * @throws IllegalThreadStateException if group is destroyed
-   * @see #Thread(ThreadGroup, Runnable, String)
-   */
-  public Thread(ThreadGroup group, String name)
-  {
-    this(group, null, name, 0);
-  }
-
-  /**
-   * Allocate a new Thread object, as if by
-   * <code>Thread(group, null, name)</code>.
-   *
-   * @param toRun the Runnable object to execute
-   * @param name the name for the Thread
-   * @throws NullPointerException if name is null
-   * @see #Thread(ThreadGroup, Runnable, String)
-   */
-  public Thread(Runnable toRun, String name)
-  {
-    this(null, toRun, name, 0);
+    this(null, null, name);
   }
 
   /**
@@ -283,9 +235,9 @@
    * @see SecurityManager#checkAccess(ThreadGroup)
    * @see ThreadGroup#checkAccess()
    */
-  public Thread(ThreadGroup group, Runnable toRun, String name)
+  public Thread(ThreadGroup group, Runnable target, String name)
   {
-    this(group, toRun, name, 0);
+    this(currentThread(), group, target, name);
   }
 
   /**
@@ -308,55 +260,107 @@
    * @throws IllegalThreadStateException if group is destroyed
    * @since 1.4
    */
-  public Thread(ThreadGroup group, Runnable toRun, String name, long size)
+  public Thread(ThreadGroup group, Runnable target, String name, long size)
   {
-    // Bypass System.getSecurityManager, for bootstrap efficiency.
-    SecurityManager sm = Runtime.securityManager;
-    Thread current = currentThread();
-    if (group == null)
-      {
-	if (sm != null)
-	    group = sm.getThreadGroup();
-	if (group == null)
-	    group = current.group;
-      }
-    else if (sm != null)
-	sm.checkAccess(group);
+    // Just ignore stackSize for now.
+    this(currentThread(), group, target, name);
+  }
 
-    this.group = group;
-    // Use toString hack to detect null.
-    this.name = name.toString();
-    this.toRun = toRun;
-    this.stacksize = size;
-
-    priority = current.priority;
-    daemon = current.daemon;
-    contextClassLoader = current.contextClassLoader;
+  /**
+   * Allocates a new <code>Thread</code> object. This constructor has
+   * the same effect as <code>Thread(group, target,</code>
+   * <i>gname</i><code>)</code>, where <i>gname</i> is
+   * a newly generated name. Automatically generated names are of the
+   * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
+   *
+   * @param      group    the thread group.
+   * @param      target   the object whose <code>run</code> method is called.
+   * @exception  SecurityException  if the current thread cannot create a
+   *             thread in the specified thread group.
+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,
+   *             java.lang.Runnable, java.lang.String)
+   */
+  public Thread(ThreadGroup group, Runnable target)
+  {
+    this(group, target, gen_name());
+  }
 
-    group.addThread(this);
-    InheritableThreadLocal.newChildThread(this);
+  /**
+   * Allocates a new <code>Thread</code> object. This constructor has
+   * the same effect as <code>Thread(group, null, name)</code>
+   *
+   * @param      group   the thread group.
+   * @param      name    the name of the new thread.
+   * @exception  SecurityException  if the current thread cannot create a
+   *               thread in the specified thread group.
+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,
+   *          java.lang.Runnable, java.lang.String)
+   */
+  public Thread(ThreadGroup group, String name)
+  {
+    this(group, null, name);
   }
 
   /**
-   * Used by the VM to create thread objects for threads started outside
-   * of Java. Note: caller is responsible for adding the thread to
-   * a group and InheritableThreadLocal.
+   * Allocates a new <code>Thread</code> object. This constructor has
+   * the same effect as <code>Thread(null, target, name)</code>.
    *
-   * @param vmThread the native thread
-   * @param name the thread name or null to use the default naming scheme
-   * @param priority current priority
-   * @param daemon is the thread a background thread?
+   * @param   target   the object whose <code>run</code> method is called.
+   * @param   name     the name of the new thread.
+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,
+   *          java.lang.Runnable, java.lang.String)
    */
-  Thread(VMThread vmThread, String name, int priority, boolean daemon)
+  public Thread(Runnable target, String name)
   {
-    this.vmThread = vmThread;
-    this.toRun = null;
-    if (name == null)
-	name = "Thread-" + ++numAnonymousThreadsCreated;
-    this.name = name;
-    this.priority = priority;
-    this.daemon = daemon;
-    this.contextClassLoader = ClassLoader.getSystemClassLoader();
+    this(null, target, name);
+  }
+
+  private Thread (Thread current, ThreadGroup g, Runnable r, String n)
+  {
+    // The Class Libraries book says ``threadName cannot be null''.  I
+    // take this to mean NullPointerException.
+    if (n == null)
+      throw new NullPointerException ();
+      
+    if (g == null)
+      {
+	// If CURRENT is null, then we are bootstrapping the first thread. 
+	// Use ThreadGroup.root, the main threadgroup.
+	if (current == null)
+	  group = ThreadGroup.root;
+	else
+	  group = current.getThreadGroup();
+      }
+    else
+      group = g;
+      
+    data = null;
+    interrupt_flag = false;
+    alive_flag = false;
+    startable_flag = true;
+
+    if (current != null)
+      {
+	group.checkAccess();
+
+	daemon_flag = current.isDaemon();
+        int gmax = group.getMaxPriority();
+	int pri = current.getPriority();
+	priority = (gmax < pri ? gmax : pri);
+	context_class_loader = current.context_class_loader;
+	InheritableThreadLocal.newChildThread(this);
+      }
+    else
+      {
+	daemon_flag = false;
+	priority = NORM_PRIORITY;
+      }
+
+    name = n;
+    group.addThread(this);
+    runnable = r;
+
+    initialize_native ();
   }
 
   /**
@@ -369,7 +373,7 @@
    */
   public static int activeCount()
   {
-    return currentThread().group.activeCount();
+    return currentThread().getThreadGroup().activeCount();
   }
 
   /**
@@ -381,8 +385,7 @@
    */
   public final void checkAccess()
   {
-    // Bypass System.getSecurityManager, for bootstrap efficiency.
-    SecurityManager sm = Runtime.securityManager;
+    SecurityManager sm = System.getSecurityManager();
     if (sm != null)
       sm.checkAccess(this);
   }
@@ -395,35 +398,20 @@
    * @throws IllegalThreadStateException if this Thread is not suspended
    * @deprecated pointless, since suspend is deprecated
    */
-  public int countStackFrames()
-  {
-    VMThread t = vmThread;
-    if (t == null || group == null)
-	throw new IllegalThreadStateException();
-
-    return t.countStackFrames();
-  }
+  public native int countStackFrames();
 
   /**
-   * Get the currently executing Thread. In the situation that the
-   * currently running thread was created by native code and doesn't
-   * have an associated Thread object yet, a new Thread object is
-   * constructed and associated with the native thread.
+   * Get the currently executing Thread.
    *
    * @return the currently executing Thread
    */
-  public static Thread currentThread()
-  {
-    return VMThread.currentThread();
-  }
+  public static native Thread currentThread();
 
   /**
    * Originally intended to destroy this thread, this method was never
    * implemented by Sun, and is hence a no-op.
    */
-  public void destroy()
-  {
-  }
+  public native void destroy();
   
   /**
    * Print a stack trace of the current thread to stderr using the same
@@ -433,7 +421,7 @@
    */
   public static void dumpStack()
   {
-    new Throwable().printStackTrace();
+    (new Exception("Stack trace")).printStackTrace();
   }
 
   /**
@@ -454,7 +442,7 @@
   {
     return currentThread().group.enumerate(array);
   }
-
+  
   /**
    * Get this Thread's name.
    *
@@ -462,8 +450,7 @@
    */
   public final String getName()
   {
-    VMThread t = vmThread;
-    return t == null ? name : t.getName();
+    return name;
   }
 
   /**
@@ -471,10 +458,9 @@
    *
    * @return the Thread's priority
    */
-  public final synchronized int getPriority()
+  public final int getPriority()
   {
-    VMThread t = vmThread;
-    return t == null ? priority : t.getPriority();
+    return priority;
   }
 
   /**
@@ -489,18 +475,14 @@
   }
 
   /**
-   * Checks whether the current thread holds the monitor on a given object.
-   * This allows you to do <code>assert Thread.holdsLock(obj)</code>.
+   * Return true if this Thread holds the object's lock, false otherwise.
    *
-   * @param obj the object to check
+   * @param obj the object to test lock ownership on.
    * @return true if the current thread is currently synchronized on obj
-   * @throws NullPointerException if obj is null
+   * @throws NullPointerException if obj is null.
    * @since 1.4
    */
-  public static boolean holdsLock(Object obj)
-  {
-    return VMThread.holdsLock(obj);
-  }
+  public static native boolean holdsLock(Object obj);
 
   /**
    * Interrupt this Thread. First, there is a security check,
@@ -524,13 +506,7 @@
    *
    * @throws SecurityException if you cannot modify this Thread
    */
-  public synchronized void interrupt()
-  {
-    checkAccess();
-    VMThread t = vmThread;
-    if (t != null)
-	t.interrupt();
-  }
+  public native void interrupt();
 
   /**
    * Determine whether the current Thread has been interrupted, and clear
@@ -541,7 +517,7 @@
    */
   public static boolean interrupted()
   {
-    return VMThread.interrupted();
+    return currentThread().isInterrupted(true);
   }
 
   /**
@@ -553,8 +529,7 @@
    */
   public boolean isInterrupted()
   {
-    VMThread t = vmThread;
-    return t != null && t.isInterrupted();
+    return interrupt_flag;
   }
 
   /**
@@ -565,7 +540,7 @@
    */
   public final boolean isAlive()
   {
-    return vmThread != null && group != null;
+    return alive_flag;
   }
 
   /**
@@ -576,8 +551,7 @@
    */
   public final boolean isDaemon()
   {
-    VMThread t = vmThread;
-    return t == null ? daemon : t.isDaemon();
+    return daemon_flag;
   }
 
   /**
@@ -617,35 +591,43 @@
    * @throws InterruptedException if the Thread is interrupted; it's
    *         <i>interrupted status</i> will be cleared
    * @throws IllegalArgumentException if ns is invalid
+   * @XXX A ThreadListener would be nice, to make this efficient.
    */
-  public final void join(long ms, int ns) throws InterruptedException
-  {
-    if(ms < 0 || ns < 0 || ns > 999999)
-	throw new IllegalArgumentException();
-
-    VMThread t = vmThread;
-    if(t != null)
-        t.join(ms, ns);
-  }
+  public final native void join(long ms, int ns)
+    throws InterruptedException;
 
   /**
-   * Resume this Thread.  If the thread is not suspended, this method does
-   * nothing. To mirror suspend(), there may be a security check:
-   * <code>checkAccess</code>.
+   * Resume a suspended thread.
    *
    * @throws SecurityException if you cannot resume the Thread
    * @see #checkAccess()
    * @see #suspend()
    * @deprecated pointless, since suspend is deprecated
    */
-  public final synchronized void resume()
+  public final native void resume();
+
+  private final native void finish_();
+
+  /**
+   * Determine whether the given Thread has been interrupted, but leave
+   * the <i>interrupted status</i> alone in the process.
+   *
+   * @return whether the current Thread has been interrupted
+   * @see #interrupted()
+   */
+  private boolean isInterrupted(boolean clear_flag)
   {
-    checkAccess();
-    VMThread t = vmThread;
-    if (t != null)
-	t.resume();
+    boolean r = interrupt_flag;
+    if (clear_flag && r)
+      {
+	// Only clear the flag if we saw it as set. Otherwise this could 
+	// potentially cause us to miss an interrupt in a race condition, 
+	// because this method is not synchronized.
+	interrupt_flag = false;
+      }
+    return r;
   }
-
+  
   /**
    * The method of Thread that will be run if there is no Runnable object
    * associated with the Thread. Thread's implementation does nothing at all.
@@ -655,14 +637,14 @@
    */
   public void run()
   {
-    if (toRun != null)
-      toRun.run();
+    if (runnable != null)
+      runnable.run();
   }
 
   /**
    * Set the daemon status of this Thread.  If this is a daemon Thread, then
    * the VM may exit even if it is still running.  This may only be called
-   * while the Thread is not running. There may be a security check,
+   * before the Thread starts running. There may be a security check,
    * <code>checkAccess</code>.
    *
    * @param daemon whether this should be a daemon thread or not
@@ -671,12 +653,12 @@
    * @see #isDaemon()
    * @see #checkAccess()
    */
-  public final synchronized void setDaemon(boolean daemon)
+  public final void setDaemon(boolean status)
   {
-    if (vmThread != null)
-      throw new IllegalThreadStateException();
     checkAccess();
-    this.daemon = daemon;
+    if (!startable_flag)
+      throw new IllegalThreadStateException();
+    daemon_flag = status;
   }
 
   /**
@@ -693,14 +675,30 @@
    * @see setContextClassLoader(ClassLoader)
    * @since 1.2
    */
-  public ClassLoader getContextClassLoader()
+  public synchronized ClassLoader getContextClassLoader()
   {
-    // Bypass System.getSecurityManager, for bootstrap efficiency.
-    SecurityManager sm = Runtime.securityManager;
-    if (sm != null)
-      // XXX Don't check this if the caller's class loader is an ancestor.
-      sm.checkPermission(new RuntimePermission("getClassLoader"));
-    return contextClassLoader;
+    if (context_class_loader == null)
+      context_class_loader = ClassLoader.getSystemClassLoader();
+
+    SecurityManager sm = System.getSecurityManager();
+    // FIXME: we can't currently find the caller's class loader.
+    ClassLoader callers = null;
+    if (sm != null && callers != null)
+      {
+	// See if the caller's class loader is the same as or an
+	// ancestor of this thread's class loader.
+	while (callers != null && callers != context_class_loader)
+	  {
+	    // FIXME: should use some internal version of getParent
+	    // that avoids security checks.
+	    callers = callers.getParent();
+	  }
+
+	if (callers != context_class_loader)
+	  sm.checkPermission(new RuntimePermission("getClassLoader"));
+      }
+
+    return context_class_loader;
   }
 
   /**
@@ -715,12 +713,12 @@
    * @see getContextClassLoader()
    * @since 1.2
    */
-  public void setContextClassLoader(ClassLoader classloader)
+  public synchronized void setContextClassLoader(ClassLoader classloader)
   {
     SecurityManager sm = System.getSecurityManager();
     if (sm != null)
       sm.checkPermission(new RuntimePermission("setContextClassLoader"));
-    this.contextClassLoader = classloader;
+    context_class_loader = classloader;
   }
 
   /**
@@ -731,30 +729,21 @@
    * @throws NullPointerException if name is null
    * @throws SecurityException if you cannot modify this Thread
    */
-  public final synchronized void setName(String name)
+  public final void setName(String name)
   {
     checkAccess();
     // The Class Libraries book says ``threadName cannot be null''.  I
     // take this to mean NullPointerException.
     if (name == null)
       throw new NullPointerException();
-    VMThread t = vmThread;
-    if (t != null)
-	t.setName(name);
-    else
-	this.name = name;
+    this.name = name;
   }
 
   /**
-   * Yield to another thread. The Thread will not lose any locks it holds
-   * during this time. There are no guarantees which thread will be
-   * next to run, and it could even be this one, but most VMs will choose
-   * the highest priority thread that has been waiting longest.
+   * Causes the currently executing thread object to temporarily pause
+   * and allow other threads to execute.
    */
-  public static void yield()
-  {
-    VMThread.yield();
-  }
+  public static native void yield();
 
   /**
    * Suspend the current Thread's execution for the specified amount of
@@ -793,10 +782,8 @@
    * @see #notify()
    * @see #wait(long, int)
    */
-  public static void sleep(long ms, int ns) throws InterruptedException
-  {
-    VMThread.sleep(ms, ns);
-  }
+  public static native void sleep(long timeout, int nanos)
+    throws InterruptedException;
 
   /**
    * Start this Thread, calling the run() method of the Runnable this Thread
@@ -808,14 +795,8 @@
    * @throws IllegalThreadStateException if the thread has already started
    * @see #run()
    */
-  public synchronized void start()
-  {
-    if (vmThread != null || group == null)
-	throw new IllegalThreadStateException();
+  public native void start();
 
-    VMThread.create(this, stacksize);
-  }
-  
   /**
    * Cause this Thread to stop abnormally because of the throw of a ThreadDeath
    * error. If you stop a Thread that has not yet started, it will stop
@@ -841,16 +822,17 @@
    */
   public final void stop()
   {
-    stop(new ThreadDeath());
+    // Argument doesn't matter, because this is no longer
+    // supported.
+    stop(null);
   }
 
   /**
    * Cause this Thread to stop abnormally and throw the specified exception.
-   * If you stop a Thread that has not yet started, the stop is ignored
-   * (contrary to what the JDK documentation says).
-   * <b>WARNING</b>This bypasses Java security, and can throw a checked
-   * exception which the call stack is unprepared to handle. Do not abuse 
-   * this power.
+   * If you stop a Thread that has not yet started, it will stop immediately
+   * when it is actually started. <b>WARNING</b>This bypasses Java security,
+   * and can throw a checked exception which the call stack is unprepared to
+   * handle. Do not abuse this power.
    *
    * <p>This is inherently unsafe, as it can interrupt synchronized blocks and
    * leave data in bad states.  Hence, there is a security check:
@@ -872,24 +854,7 @@
    * @see SecurityManager#checkPermission(Permission)
    * @deprecated unsafe operation, try not to use
    */
-  public final synchronized void stop(Throwable t)
-  {
-    if (t == null)
-      throw new NullPointerException();
-    // Bypass System.getSecurityManager, for bootstrap efficiency.
-    SecurityManager sm = Runtime.securityManager;
-    if (sm != null)
-      {
-        sm.checkAccess(this);
-        if (this != currentThread())
-          sm.checkPermission(new RuntimePermission("stopThread"));
-      }
-    VMThread vt = vmThread;
-    if (vt != null)
-	vt.stop(t);
-    else
-	stillborn = t;
-  }
+  public final native void stop(Throwable e);
 
   /**
    * Suspend this Thread.  It will not come back, ever, unless it is resumed.
@@ -903,13 +868,7 @@
    * @see #resume()
    * @deprecated unsafe operation, try not to use
    */
-  public final synchronized void suspend()
-  {
-    checkAccess();
-    VMThread t = vmThread;
-    if (t != null)
-	t.suspend();
-  }
+  public final native void suspend();
 
   /**
    * Set this Thread's priority. There may be a security check,
@@ -926,19 +885,7 @@
    * @see #MIN_PRIORITY
    * @see #MAX_PRIORITY
    */
-  public final synchronized void setPriority(int priority)
-  {
-    checkAccess();
-    if (priority < MIN_PRIORITY || priority > MAX_PRIORITY)
-      throw new IllegalArgumentException("Invalid thread priority value "
-                                         + priority + ".");
-    priority = Math.min(priority, group.getMaxPriority());
-    VMThread t = vmThread;
-    if (t != null)
-	t.setPriority(priority);
-    else
-	this.priority = priority;
-  }
+  public final native void setPriority(int newPriority);
 
   /**
    * Returns a string representation of this thread, including the
@@ -952,12 +899,7 @@
 	    + (group == null ? "" : group.getName()) + "]");
   }
 
-  /**
-   * Clean up code, called by VMThread when thread dies.
-   */
-  synchronized void die()
-  {
-    group.removeThread(this);
-    vmThread = null;
-  }
+  private final native void initialize_native();
+
+  private final native static String gen_name();
 }
