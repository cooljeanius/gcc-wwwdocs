--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/BufferedInputStream.java	2004-03-09 02:21:53.000000000 -0700
+++ java/io/BufferedInputStream.java	2002-01-22 16:01:32.000000000 -0700
@@ -103,19 +103,6 @@
   protected int marklimit = 0;
 
   /**
-   * This is the maximum size we have to allocate for the mark buffer.
-   * This number may be huge (Integer.MAX_VALUE). The class will continue
-   * to allocate new chunks (specified by <code>CHUNKSIZE</code>) until the
-   * the size specified by this field is achieved.
-   */
-  private int marktarget = 0;
-
-  /**
-   * This is the number of bytes to allocate to reach marktarget.
-   */
-  static final private int CHUNKSIZE = 1024;
-
-  /**
    * This method initializes a new <code>BufferedInputStream</code> that will
    * read from the specified subordinate stream with a default buffer size
    * of 2048 bytes
@@ -196,9 +183,7 @@
    */
   public synchronized void mark(int readlimit)
   {
-    marktarget = marklimit = readlimit;
-    if (marklimit > CHUNKSIZE)
-	marklimit = CHUNKSIZE;
+    marklimit = readlimit;
     markpos = pos;
   }
 
@@ -231,7 +216,7 @@
     if (pos >= count && !refill())
       return -1;	// EOF
 
-    if (markpos >= 0 && pos - markpos > marktarget)
+    if (markpos >= 0 && pos - markpos > marklimit)
       markpos = -1;
 
     return ((int) buf[pos++]) & 0xFF;
@@ -270,7 +255,7 @@
     System.arraycopy(buf, pos, b, off, remain);
     pos += remain;
 
-    if (markpos >= 0 && pos - markpos > marktarget)
+    if (markpos >= 0 && pos - markpos > marklimit)
       markpos = -1;
 
     return remain;
@@ -324,7 +309,7 @@
 	pos += numread;
 	n -= numread;
 
-        if (markpos >= 0 && pos - markpos > marktarget)
+        if (markpos >= 0 && pos - markpos > marklimit)
           markpos = -1;
       }
 
@@ -352,16 +337,13 @@
 	pos -= markpos;
 	markpos = 0;
       }
-    else if (marktarget >= buf.length && marklimit < marktarget)	// BTW, markpos == 0
+    else if (marklimit >= buf.length)	// BTW, markpos == 0
       {
 	// Need to grow the buffer now to have room for marklimit bytes.
 	// Note that the new buffer is one greater than marklimit.
 	// This is so that there will be one byte past marklimit to be read
 	// before having to call refill again, thus allowing marklimit to be
 	// invalidated.  That way refill doesn't have to check marklimit.
-	marklimit += CHUNKSIZE;
-	if (marklimit >= marktarget)
-	  marklimit = marktarget;
 	byte[] newbuf = new byte[marklimit + 1];
 	System.arraycopy(buf, 0, newbuf, 0, count);
 	buf = newbuf;
