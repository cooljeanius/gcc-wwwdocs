--- /home/tromey/gnu/egcs/classpath/classpath/java/lang/Float.java	Sat Mar  2 12:13:11 2002
+++ java/lang/Float.java	Tue Jun  4 16:33:56 2002
@@ -1,4 +1,4 @@
-/* Float.java -- object wrapper for float
+/* java.lang.Float
    Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -40,6 +40,12 @@
 
 import gnu.classpath.Configuration;
 
+/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
+ * "The Java Language Specification", ISBN 0-201-63451-1
+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status:  Believed complete and correct.
+ */
+
 /**
  * Instances of class <code>Float</code> represent primitive
  * <code>float</code> values.
@@ -49,18 +55,11 @@
  *
  * @author Paul Fisher
  * @author Andrew Haley <aph@cygnus.com>
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.0
- * @status updated to 1.4
+ * @since JDK 1.0
  */
 public final class Float extends Number implements Comparable
 {
   /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = -2671257302660747028L;
-
-  /**
    * The maximum positive value a <code>double</code> may represent
    * is 3.4028235e+38f.
    */
@@ -75,50 +74,46 @@
   /**
    * The value of a float representation -1.0/0.0, negative infinity.
    */
-  public static final float NEGATIVE_INFINITY = -1.0f / 0.0f;
+  public static final float NEGATIVE_INFINITY = -1.0f/0.0f;
 
   /**
    * The value of a float representation 1.0/0.0, positive infinity.
    */
-  public static final float POSITIVE_INFINITY = 1.0f / 0.0f;
+  public static final float POSITIVE_INFINITY = 1.0f/0.0f;
 
   /**
    * All IEEE 754 values of NaN have the same value in Java.
    */
-  public static final float NaN = 0.0f / 0.0f;
+  public static final float NaN = 0.0f/0.0f;
 
   /**
-   * The primitive type <code>float</code> is represented by this
+   * The primitive type <code>float</code> is represented by this 
    * <code>Class</code> object.
-   * @since 1.1
    */
   public static final Class TYPE = VMClassLoader.getPrimitiveClass('F');
 
   /**
    * The immutable value of this Float.
-   *
-   * @serial the wrapped float
    */
   private final float value;
 
-  /**
-   * Load native routines necessary for this class.
-   */
+  private static final long serialVersionUID = -2671257302660747028L;
+
   static
   {
     if (Configuration.INIT_LOAD_LIBRARY)
       {
-        System.loadLibrary("javalang");
+	System.loadLibrary ("javalang");
       }
   }
 
   /**
-   * Create a <code>Float</code> from the primitive <code>float</code>
+   * Create a <code>float</code> from the primitive <code>Float</code>
    * specified.
    *
-   * @param value the <code>float</code> argument
+   * @param value the <code>Float</code> argument
    */
-  public Float(float value)
+  public Float (float value)
   {
     this.value = value;
   }
@@ -129,395 +124,379 @@
    *
    * @param value the <code>double</code> argument
    */
-  public Float(double value)
+  public Float (double value)
   {
-    this.value = (float) value;
+    this.value = (float)value;
   }
 
   /**
    * Create a <code>Float</code> from the specified <code>String</code>.
+   *
    * This method calls <code>Float.parseFloat()</code>.
    *
+   * @exception NumberFormatException when the <code>String</code> cannot
+   *            be parsed into a <code>Float</code>.
    * @param s the <code>String</code> to convert
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>float</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @see #parseFloat(String)
-   */
-  public Float(String s)
-  {
-    value = parseFloat(s);
-  }
-
-  /**
-   * Convert the <code>float</code> to a <code>String</code>.
-   * Floating-point string representation is fairly complex: here is a
-   * rundown of the possible values.  "<code>[-]</code>" indicates that a
-   * negative sign will be printed if the value (or exponent) is negative.
-   * "<code>&lt;number&gt;</code>" means a string of digits ('0' to '9').
-   * "<code>&lt;digit&gt;</code>" means a single digit ('0' to '9').<br>
-   *
-   * <table border=1>
-   * <tr><th>Value of Float</th><th>String Representation</th></tr>
-   * <tr><td>[+-] 0</td> <td><code>[-]0.0</code></td></tr>
-   * <tr><td>Between [+-] 10<sup>-3</sup> and 10<sup>7</sup>, exclusive</td>
-   *     <td><code>[-]number.number</code></td></tr>
-   * <tr><td>Other numeric value</td>
-   *     <td><code>[-]&lt;digit&gt;.&lt;number&gt;
-   *          E[-]&lt;number&gt;</code></td></tr>
-   * <tr><td>[+-] infinity</td> <td><code>[-]Infinity</code></td></tr>
-   * <tr><td>NaN</td> <td><code>NaN</code></td></tr>
-   * </table>
-   *
-   * Yes, negative zero <em>is</em> a possible value.  Note that there is
-   * <em>always</em> a <code>.</code> and at least one digit printed after
-   * it: even if the number is 3, it will be printed as <code>3.0</code>.
-   * After the ".", all digits will be printed except trailing zeros. The
-   * result is rounded to the shortest decimal number which will parse back
-   * to the same float.
-   *
-   * <p>To create other output formats, use {@link java.text.NumberFormat}.
-   *
-   * @XXX specify where we are not in accord with the spec.
-   *
-   * @param f the <code>float</code> to convert
-   * @return the <code>String</code> representing the <code>float</code>
+   * @see #parseFloat(java.lang.String)
    */
-  public static String toString(float f)
+  public Float (String s) throws NumberFormatException
   {
-    return Double.toString(f, true);
+    this.value = parseFloat (s);
   }
 
   /**
-   * Creates a new <code>Float</code> object using the <code>String</code>.
-   *
-   * @param s the <code>String</code> to convert
-   * @return the new <code>Float</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>float</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @see #parseFloat(String)
-   */
-  public static Float valueOf(String s)
-  {
-    return new Float(parseFloat(s));
-  }
-
-  /**
-   * Parse the specified <code>String</code> as a <code>float</code>. The
-   * extended BNF grammar is as follows:<br>
-   * <pre>
-   * <em>DecodableString</em>:
-   *      ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> )
-   *    | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> )
-   *    | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em>
-   *              [ <code>f</code> | <code>F</code> | <code>d</code>
-   *                | <code>D</code>] )
-   * <em>FloatingPoint</em>:
-   *      ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ]
-   *              [ <em>Exponent</em> ] )
-   *    | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] )
-   * <em>Exponent</em>:
-   *      ( ( <code>e</code> | <code>E</code> )
-   *              [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ )
-   * <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em>
-   * </pre>
-   *
-   * <p>NaN and infinity are special cases, to allow parsing of the output
-   * of toString.  Otherwise, the result is determined by calculating
-   * <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding
-   * to the nearest float. Remember that many numbers cannot be precisely
-   * represented in floating point. In case of overflow, infinity is used,
-   * and in case of underflow, signed zero is used. Unlike Integer.parseInt,
-   * this does not accept Unicode digits outside the ASCII range.
-   *
-   * <p>If an unexpected character is found in the <code>String</code>, a
-   * <code>NumberFormatException</code> will be thrown.  Leading and trailing
-   * 'whitespace' is ignored via <code>String.trim()</code>, but spaces
-   * internal to the actual number are not allowed.
-   *
-   * <p>To parse numbers according to another format, consider using
-   * {@link java.text.NumberFormat}.
+   * Parse the specified <code>String</code> as a <code>float</code>.
+   *
+   * The number is really read as <em>n * 10<sup>exponent</sup></em>.  The
+   * first number is <em>n</em>, and if there is an "<code>E</code>"
+   * ("<code>e</code>" is also acceptable), then the integer after that is
+   * the exponent.
+   * <P>
+   * Here are the possible forms the number can take:
+   * <BR>
+   * <TABLE BORDER=1>
+   *     <TR><TH>Form</TH><TH>Examples</TH></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]</CODE></TD><TD>345., -10, 12</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;</CODE></TD><TD>40.2, 80.00, -12.30</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]E[+-]&lt;number&gt;</CODE></TD><TD>80E12, -12e+7, 4.E-123</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;E[+-]&lt;number&gt;</CODE></TD><TD>6.02e-22, -40.2E+6, 12.3e9</TD></TR>
+   * </TABLE>
+   *
+   * "<code>[+-]</code>" means either a plus or minus sign may go there, or
+   * neither, in which case + is assumed.
+   * <BR>
+   * "<code>[.]</code>" means a dot may be placed here, but is optional.
+   * <BR>
+   * "<code>&lt;number&gt;</code>" means a string of digits (0-9), basically
+   * an integer.  "<code>&lt;number&gt;.&lt;number&gt;</code>" is basically
+   * a real number, a floating-point value.
+   * <P>
+   * Remember that a <code>float</code> has a limited range.  If the
+   * number you specify is greater than <code>Float.MAX_VALUE</code> or less
+   * than <code>-Float.MAX_VALUE</code>, it will be set at
+   * <code>Float.POSITIVE_INFINITY</code> or
+   * <code>Float.NEGATIVE_INFINITY</code>, respectively.
+   * <P>
+   *
+   * Note also that <code>float</code> does not have perfect precision.  Many
+   * numbers cannot be precisely represented.  The number you specify
+   * will be rounded to the nearest representable value.
+   * <code>Float.MIN_VALUE</code> is the margin of error for <code>float</code>
+   * values.
+   * <P>
+   * If an unexpected character is found in the <code>String</code>, a
+   * <code>NumberFormatException</code> will be thrown.  Spaces are not
+   * allowed and will cause this exception to be thrown.
    *
    * @XXX specify where/how we are not in accord with the spec.
    *
    * @param str the <code>String</code> to convert
-   * @return the <code>float</code> value of <code>s</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>float</code>
-   * @throws NullPointerException if <code>s</code> is null
+   * @return the value of the <code>String</code> as a <code>float</code>.
+   * @exception NumberFormatException when the string cannot be parsed to a
+   *            <code>float</code>.
+   * @since JDK 1.2
    * @see #MIN_VALUE
    * @see #MAX_VALUE
    * @see #POSITIVE_INFINITY
    * @see #NEGATIVE_INFINITY
-   * @since 1.2
    */
-  public static float parseFloat(String s)
+  public static float parseFloat (String s) throws NumberFormatException
   {
-    // XXX Rounding parseDouble() causes some errors greater than 1 ulp from
-    // the infinitely precise decimal.
-    return (float) Double.parseDouble(s);
+    // The spec says that parseFloat() should work like
+    // Double.valueOf().  This is equivalent, in our implementation,
+    // but more efficient.
+    return (float) Double.parseDouble (s);
   }
 
   /**
-   * Return <code>true</code> if the <code>float</code> has the same
-   * value as <code>NaN</code>, otherwise return <code>false</code>.
+   * Convert the <code>float</code> value of this <code>Float</code>
+   * to a <code>String</code>.  This method calls
+   * <code>Float.toString(float)</code> to do its dirty work.
    *
-   * @param v the <code>float</code> to compare
-   * @return whether the argument is <code>NaN</code>
+   * @return the <code>String</code> representation of this <code>Float</code>.
+   * @see #toString(float)
    */
-  public static boolean isNaN(float v)
+  public String toString ()
   {
-    // This works since NaN != NaN is the only reflexive inequality
-    // comparison which returns true.
-    return v != v;
+    return toString (value);
   }
 
   /**
-   * Return <code>true</code> if the <code>float</code> has a value
-   * equal to either <code>NEGATIVE_INFINITY</code> or
-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
+   * If the <code>Object</code> is not <code>null</code>, is an
+   * <code>instanceof</code> <code>Float</code>, and represents
+   * the same primitive <code>float</code> value return 
+   * <code>true</code>.  Otherwise <code>false</code> is returned.
+   * <p>
+   * Note that there are two differences between <code>==</code> and
+   * <code>equals()</code>. <code>0.0f == -0.0f</code> returns <code>true</code>
+   * but <code>new Float(0.0f).equals(new Float(-0.0f))</code> returns
+   * <code>false</code>. And <code>Float.NaN == Float.NaN</code> returns
+   * <code>false</code>, but
+   * <code>new Float(Float.NaN).equals(new Float(Float.NaN))</code> returns
+   * <code>true</code>.
    *
-   * @param v the <code>float</code> to compare
-   * @return whether the argument is (-/+) infinity
+   * @param obj the object to compare to
+   * @return whether the objects are semantically equal.
    */
-  public static boolean isInfinite(float v)
+  public boolean equals (Object obj)
   {
-    return v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY;
+    if (!(obj instanceof Float))
+      return false;
+
+    float f = ((Float) obj).value;
+
+    // GCJ LOCAL: this implementation is probably faster than
+    // Classpath's, especially once we inline floatToIntBits.
+    return floatToIntBits (value) == floatToIntBits (f);
+    // END GCJ LOCAL
   }
 
   /**
-   * Return <code>true</code> if the value of this <code>Float</code>
-   * is the same as <code>NaN</code>, otherwise return <code>false</code>.
-   *
-   * @return whether this <code>Float</code> is <code>NaN</code>
+   * Return a hashcode representing this Object.
+   * <code>Float</code>'s hash code is calculated by calling the
+   * <code>floatToIntBits()</code> function.
+   * @return this Object's hash code.
+   * @see java.lang.Float.floatToIntBits(float)
    */
-  public boolean isNaN()
+  public int hashCode ()
   {
-    return isNaN(value);
+    return floatToIntBits (value);
   }
 
   /**
-   * Return <code>true</code> if the value of this <code>Float</code>
-   * is the same as <code>NEGATIVE_INFINITY</code> or
-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
-   *
-   * @return whether this <code>Float</code> is (-/+) infinity
+   * Return the value of this <code>Double</code> when cast to an 
+   * <code>int</code>.
    */
-  public boolean isInfinite()
+  public int intValue ()
   {
-    return isInfinite(value);
+    return (int) value;
   }
 
   /**
-   * Convert the <code>float</code> value of this <code>Float</code>
-   * to a <code>String</code>.  This method calls
-   * <code>Float.toString(float)</code> to do its dirty work.
-   *
-   * @return the <code>String</code> representation
-   * @see #toString(float)
+   * Return the value of this <code>Double</code> when cast to a
+   * <code>long</code>.
    */
-  public String toString()
+  public long longValue ()
   {
-    return toString(value);
+    return (long) value;
   }
 
   /**
-   * Return the value of this <code>Float</code> as a <code>byte</code>.
-   *
-   * @return the byte value
-   * @since 1.1
+   * Return the value of this <code>Double</code> when cast to a
+   * <code>float</code>.
    */
-  public byte byteValue()
+  public float floatValue ()
   {
-    return (byte) value;
+    return (float) value;
   }
 
   /**
-   * Return the value of this <code>Float</code> as a <code>short</code>.
-   *
-   * @return the short value
-   * @since 1.1
+   * Return the primitive <code>double</code> value represented by this
+   * <code>Double</code>.
    */
-  public short shortValue()
+  public double doubleValue ()
   {
-    return (short) value;
+    return (double) value;
   }
 
   /**
-   * Return the value of this <code>Integer</code> as an <code>int</code>.
+   * Convert the <code>float</code> to a <code>String</code>.
+   * <P>
+   *
+   * Floating-point string representation is fairly complex: here is a
+   * rundown of the possible values.  "<CODE>[-]</CODE>" indicates that a
+   * negative sign will be printed if the value (or exponent) is negative.
+   * "<CODE>&lt;number&gt;</CODE>" means a string of digits (0-9).
+   * "<CODE>&lt;digit&gt;</CODE>" means a single digit (0-9).
+   * <P>
+   *
+   * <TABLE BORDER=1>
+   * <TR><TH>Value of Float</TH><TH>String Representation</TH></TR>
+   * <TR>
+   *     <TD>[+-] 0</TD>
+   *     <TD>[<CODE>-</CODE>]<CODE>0.0</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>Between [+-] 10<SUP>-3</SUP> and 10<SUP>7</SUP></TD>
+   *     <TD><CODE>[-]number.number</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>Other numeric value</TD>
+   *     <TD><CODE>[-]&lt;digit&gt;.&lt;number&gt;E[-]&lt;number&gt;</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>[+-] infinity</TD>
+   *     <TD><CODE>[-]Infinity</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>NaN</TD>
+   *     <TD><CODE>NaN</CODE></TD>
+   * </TR>
+   * </TABLE>
+   *
+   * Yes, negative zero <EM>is</EM> a possible value.  Note that there is
+   * <EM>always</EM> a <CODE>.</CODE> and at least one digit printed after
+   * it: even if the number is 3, it will be printed as <CODE>3.0</CODE>.
+   * After the ".", all digits will be printed except trailing zeros.  No
+   * truncation or rounding is done by this function.
    *
-   * @return the int value
+   * @XXX specify where we are not in accord with the spec.
+   *
+   * @param f the <code>float</code> to convert
+   * @return the <code>String</code> representing the <code>float</code>.
    */
-  public int intValue()
+  public static String toString (float f)
   {
-    return (int) value;
+    return Double.toString ((double) f, true);
   }
 
   /**
-   * Return the value of this <code>Integer</code> as a <code>long</code>.
+   * Return the result of calling <code>new Float(java.lang.String)</code>.
    *
-   * @return the long value
+   * @param s the <code>String</code> to convert to a <code>Float</code>.
+   * @return a new <code>Float</code> representing the <code>String</code>'s
+   *         numeric value.
+   *
+   * @exception NumberFormatException thrown if <code>String</code> cannot
+   * be parsed as a <code>double</code>.
+   * @see #Float(java.lang.String)
+   * @see #parseFloat(java.lang.String)
    */
-  public long longValue()
+  public static Float valueOf (String s) throws NumberFormatException
   {
-    return (long) value;
+    return new Float (s);
   }
 
   /**
-   * Return the value of this <code>Float</code>.
-   *
-   * @return the float value
+   * Return <code>true</code> if the value of this <code>Float</code>
+   * is the same as <code>NaN</code>, otherwise return <code>false</code>.
+   * @return whether this <code>Float</code> is <code>NaN</code>.
    */
-  public float floatValue()
+  public boolean isNaN ()
   {
-    return value;
+    return isNaN (value);
   }
 
   /**
-   * Return the value of this <code>Float</code> as a <code>double</code>
+   * Return <code>true</code> if the <code>float</code> has the same
+   * value as <code>NaN</code>, otherwise return <code>false</code>.
    *
-   * @return the double value
+   * @param v the <code>float</code> to compare
+   * @return whether the argument is <code>NaN</code>.
    */
-  public double doubleValue()
+  public static boolean isNaN (float v)
   {
-    return value;
+    // This works since NaN != NaN is the only reflexive inequality
+    // comparison which returns true.
+    return v != v;
   }
 
   /**
-   * Return a hashcode representing this Object. <code>Float</code>'s hash
-   * code is calculated by calling <code>floatToIntBits(floatValue())</code>.
+   * Return <code>true</code> if the value of this <code>Float</code>
+   * is the same as <code>NEGATIVE_INFINITY</code> or 
+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
    *
-   * @return this Object's hash code
-   * @see #floatToIntBits(float)
+   * @return whether this <code>Float</code> is (-/+) infinity.
    */
-  public int hashCode()
+  public boolean isInfinite ()
   {
-    return floatToIntBits(value);
+    return isInfinite (value);
   }
 
   /**
-   * Returns <code>true</code> if <code>obj</code> is an instance of
-   * <code>Float</code> and represents the same float value. Unlike comparing
-   * two floats with <code>==</code>, this treats two instances of
-   * <code>Float.NaN</code> as equal, but treats <code>0.0</code> and
-   * <code>-0.0</code> as unequal.
-   *
-   * <p>Note that <code>f1.equals(f2)<code> is identical to
-   * <code>floatToIntBits(f1.floatValue()) ==
-   *    floatToIntBits(f2.floatValue())<code>.
+   * Return <code>true</code> if the <code>float</code> has a value 
+   * equal to either <code>NEGATIVE_INFINITY</code> or 
+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
    *
-   * @param obj the object to compare
-   * @return whether the objects are semantically equal
+   * @param v the <code>float</code> to compare
+   * @return whether the argument is (-/+) infinity.
    */
-  public boolean equals(Object obj)
+  public static boolean isInfinite (float v)
   {
-    if (! (obj instanceof Float))
-      return false;
-
-    float f = ((Float) obj).value;
-
-    // Avoid call to native method. However, some implementations, like gcj,
-    // are better off using floatToIntBits(value) == floatToIntBits(f).
-    // Check common case first, then check NaN and 0.
-    if (value == f)
-      return (value != 0) || (1 / value == 1 / f);
-    return isNaN(value) && isNaN(f);
+    return (v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY);
   }
 
   /**
-   * Convert the float to the IEEE 754 floating-point "single format" bit
-   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23
-   * (masked by 0x7f800000) represent the exponent, and bits 22-0
-   * (masked by 0x007fffff) are the mantissa. This function collapses all
-   * versions of NaN to 0x7fc00000. The result of this function can be used
-   * as the argument to <code>Float.intBitsToFloat(int)</code> to obtain the
+   * Return the int bits of the specified <code>float</code>.
+   * The result of this function can be used as the argument to
+   * <code>Float.intBitsToFloat(long)</code> to obtain the
    * original <code>float</code> value.
    *
    * @param value the <code>float</code> to convert
-   * @return the bits of the <code>float</code>
-   * @see #intBitsToFloat(int)
+   * @return the bits of the <code>float</code>.
    */
-  public static native int floatToIntBits(float value);
+  public static native int floatToIntBits (float value);
 
   /**
-   * Convert the float to the IEEE 754 floating-point "single format" bit
-   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23
-   * (masked by 0x7f800000) represent the exponent, and bits 22-0
-   * (masked by 0x007fffff) are the mantissa. This function leaves NaN alone,
-   * rather than collapsing to a canonical value. The result of this function
-   * can be used as the argument to <code>Float.intBitsToFloat(int)</code> to
-   * obtain the original <code>float</code> value.
+   * Return the int bits of the specified <code>float</code>.
+   * The result of this function can be used as the argument to
+   * <code>Float.intBitsToFloat(long)</code> to obtain the
+   * original <code>float</code> value.  The difference between
+   * this function and <code>floatToIntBits</code> is that this
+   * function does not collapse NaN values.
    *
    * @param value the <code>float</code> to convert
-   * @return the bits of the <code>float</code>
-   * @see #intBitsToFloat(int)
+   * @return the bits of the <code>float</code>.
    */
-  public static native int floatToRawIntBits(float value);
+  public static native int floatToRawIntBits (float value);
 
   /**
-   * Convert the argument in IEEE 754 floating-point "single format" bit
-   * layout to the corresponding float. Bit 31 (the most significant) is the
-   * sign bit, bits 30-23 (masked by 0x7f800000) represent the exponent, and
-   * bits 22-0 (masked by 0x007fffff) are the mantissa. This function leaves
-   * NaN alone, so that you can recover the bit pattern with
-   * <code>Float.floatToRawIntBits(float)</code>.
+   * Return the <code>float</code> represented by the long
+   * bits specified.
    *
-   * @param bits the bits to convert
-   * @return the <code>float</code> represented by the bits
-   * @see #floatToIntBits(float)
-   * @see #floatToRawIntBits(float)
+   * @param bits the long bits representing a <code>double</code>
+   * @return the <code>float</code> represented by the bits.
    */
-  public static native float intBitsToFloat(int bits);
+  public static native float intBitsToFloat (int bits);
 
   /**
-   * Compare two Floats numerically by comparing their <code>float</code>
-   * values. The result is positive if the first is greater, negative if the
-   * second is greater, and 0 if the two are equal. However, this special
-   * cases NaN and signed zero as follows: NaN is considered greater than
-   * all other floats, including <code>POSITIVE_INFINITY</code>, and positive
-   * zero is considered greater than negative zero.
+   * Returns 0 if the <code>float</code> value of the argument is 
+   * equal to the value of this <code>Float</code>.  Returns a number
+   * less than zero if the value of this <code>Float</code> is less 
+   * than the <code>Float</code> value of the argument, and returns a 
+   * number greater than zero if the value of this <code>Float</code> 
+   * is greater than the <code>float</code> value of the argument.
+   * <br>
+   * <code>Float.NaN</code> is greater than any number other than itself, 
+   * even <code>Float.POSITIVE_INFINITY</code>.
+   * <br>
+   * <code>0.0</code> is greater than <code>-0.0</code>.
    *
-   * @param f the Float to compare
-   * @return the comparison
-   * @since 1.2
-   */
-  public int compareTo(Float f)
-  {
-    return compare(value, f.value);
-  }
-
-  /**
-   * Behaves like <code>compareTo(Float)</code> unless the Object
-   * is not an <code>Float</code>.
+   * @param f the Float to compare to.
+   * @return  0 if the <code>Float</code>s are the same, &lt; 0 if this
+   *          <code>Float</code> is less than the <code>Float</code> in
+   *          in question, or &gt; 0 if it is greater.
    *
-   * @param o the object to compare
-   * @return the comparison
-   * @throws ClassCastException if the argument is not a <code>Float</code>
-   * @see #compareTo(Float)
-   * @see Comparable
    * @since 1.2
    */
-  public int compareTo(Object o)
+  public int compareTo (Float f)
   {
-    return compare(value, ((Float) o).value);
+    return compare (value, f.value);
   }
 
   /**
-   * Behaves like <code>new Float(x).compareTo(new Float(y))</code>; in
-   * other words this compares two floats, special casing NaN and zero,
-   * without the overhead of objects.
-   *
-   * @param x the first float to compare
-   * @param y the second float to compare
-   * @return the comparison
+   * Returns 0 if the first argument is equal to the second argument.
+   * Returns a number less than zero if the first argument is less than the
+   * second argument, and returns a number greater than zero if the first
+   * argument is greater than the second argument.
+   * <br>
+   * <code>Float.NaN</code> is greater than any number other than itself, 
+   * even <code>Float.POSITIVE_INFINITY</code>.
+   * <br>
+   * <code>0.0</code> is greater than <code>-0.0</code>.
+   *
+   * @param x the first float to compare.
+   * @param y the second float to compare.
+   * @return  0 if the arguments are the same, &lt; 0 if the
+   *          first argument is less than the second argument in
+   *          in question, or &gt; 0 if it is greater.
    * @since 1.4
    */
-  public static int compare(float x, float y)
+  public static int compare (float x, float y)
   {
-    if (isNaN(x))
-      return isNaN(y) ? 0 : 1;
-    if (isNaN(y))
+    if (isNaN (x))
+      return isNaN (y) ? 0 : 1;
+    if (isNaN (y))
       return -1;
     // recall that 0.0 == -0.0, so we convert to infinities and try again
     if (x == 0 && y == 0)
@@ -526,5 +505,24 @@
       return 0;
 
     return x > y ? 1 : -1;
+  }
+
+  /**
+   * Compares the specified <code>Object</code> to this <code>Float</code>
+   * if and only if the <code>Object</code> is an instanceof 
+   * <code>Float</code>.
+   * Otherwise it throws a <code>ClassCastException</code>
+   *
+   * @param o the Object to compare to.
+   * @return  0 if the <code>Float</code>s are the same, &lt; 0 if this
+   *          <code>Float</code> is less than the <code>Float</code> in
+   *          in question, or &gt; 0 if it is greater.
+   * @throws ClassCastException if the argument is not a <code>Float</code>
+   *
+   * @since 1.2
+   */
+  public int compareTo (Object o)
+  {
+    return compareTo ((Float) o);
   }
 }
