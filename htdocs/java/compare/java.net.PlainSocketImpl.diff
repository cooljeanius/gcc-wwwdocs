--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/PlainSocketImpl.java	Sun Mar 23 02:18:39 2003
+++ java/net/PlainSocketImpl.java	Sun Mar 23 02:18:02 2003
@@ -41,227 +41,217 @@
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import gnu.classpath.Configuration;
 
 /**
-  * Unless the application installs its own SocketImplFactory, this is the
-  * default socket implemetation that will be used.  It simply uses a
-  * combination of Java and native routines to implement standard BSD
-  * style sockets of family AF_INET and types SOCK_STREAM and SOCK_DGRAM
-  *
-  * @version 0.1
-  *
-  * @author Aaron M. Renn (arenn@urbanophile.com)
-  */
+ * The standard GCJ socket implementation.
+ * Written using on-line Java Platform 1.2 API Specification, as well
+ * as "The Java Class Libraries", 2nd edition (Addison-Wesley, 1998).
+ * Status:  Believed complete and correct.
+ *
+ * @author Per Bothner <bothner@cygnus.com>
+ * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>
+ */
 class PlainSocketImpl extends SocketImpl
 {
-  // Static initializer to load native library
-  static
-  {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-	System.loadLibrary("javanet");
-      }
-  }
+  // These fields are mirrored for use in native code to avoid cpp conflicts
+  // when the #defines in system header files are the same as the public fields.
+  static final int _Jv_TCP_NODELAY_ = SocketOptions.TCP_NODELAY,
+                   _Jv_SO_BINDADDR_ = SocketOptions.SO_BINDADDR,
+                   _Jv_SO_REUSEADDR_ = SocketOptions.SO_REUSEADDR,
+                   _Jv_SO_BROADCAST_ = SocketOptions.SO_BROADCAST,
+                   _Jv_SO_OOBINLINE_ = SocketOptions.SO_OOBINLINE,
+                   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,
+                   _Jv_IP_MULTICAST_IF2_ = SocketOptions.IP_MULTICAST_IF2,
+                   _Jv_IP_MULTICAST_LOOP_ = SocketOptions.IP_MULTICAST_LOOP,
+                   _Jv_IP_TOS_ = SocketOptions.IP_TOS,
+                   _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,
+                   _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,
+                   _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,
+                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF,
+                   _Jv_SO_KEEPALIVE_ = SocketOptions.SO_KEEPALIVE;
 
   /**
-   * This is the native file descriptor for this socket
+   * The OS file handle representing the socket.
+   * This is used for reads and writes to/from the socket and
+   * to close it.
+   *
+   * When the socket is closed this is reset to -1.
    */
-  protected int native_fd = -1;
+  int fnum = -1;
 
+  // This value is set/read by setOption/getOption.
+  int timeout = 0;
+  
+  // localAddress cache
+  InetAddress localAddress;
 
-  /**
-   * Default do nothing constructor
-   */
-  public PlainSocketImpl()
+  public native void setOption(int optID, Object value) throws SocketException;
+
+  public native Object getOption(int optID) throws SocketException;
+
+  public native void shutdownInput () throws IOException;
+
+  public native void shutdownOutput () throws IOException;
+
+  protected native void create (boolean stream)  throws IOException;
+
+  protected void connect (String host, int port) throws IOException
   {
+    connect (new InetSocketAddress (InetAddress.getByName(host), port), 0);
   }
 
-  /**
-   * Accepts a new connection on this socket and returns in in the 
-   * passed in SocketImpl.
-   *
-   * @param impl The SocketImpl object to accept this connection.
-   */
-  protected native synchronized void accept(SocketImpl impl)
-    throws IOException;
-
-  /**
-   * Returns the number of bytes that the caller can read from this socket
-   * without blocking. 
-   *
-   * @return The number of readable bytes before blocking
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native int available() throws IOException;
+  protected void connect (InetAddress host, int port) throws IOException
+  {
+    connect (new InetSocketAddress (host, port), 0);
+  }
 
-  /**
-   * Binds to the specified port on the specified addr.  Note that this addr
-   * must represent a local IP address.  **** How bind to INADDR_ANY? ****
-   *
-   * @param addr The address to bind to
-   * @param port The port number to bind to
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native synchronized void bind(InetAddress addr, int port)
+  protected native void connect (SocketAddress addr, int timeout)
     throws IOException;
 
-  /**
-   * Closes the socket.  This will cause any InputStream or OutputStream
-   * objects for this Socket to be closed as well.
-   * <p>
-   * Note that if the SO_LINGER option is set on this socket, then the
-   * operation could block.
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native void close () throws IOException;
+  protected native void bind (InetAddress host, int port) throws IOException;
 
-  /**
-   * Connects to the remote address and port specified as arguments.
-   *
-   * @param addr The remote address to connect to
-   * @param port The remote port to connect to
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native void connect(InetAddress addr, int port)
-    throws IOException;
+  protected native void listen (int backlog) throws IOException;
 
-  /**
-   * Connects to the remote hostname and port specified as arguments.
-   *
-   * @param hostname The remote hostname to connect to
-   * @param port The remote port to connect to
-   *
-   * @exception IOException If an error occurs
-   */
-  protected synchronized void connect(String hostname, int port)
-    throws IOException
+  private native void accept (PlainSocketImpl s) throws IOException;
+
+  protected void accept (SocketImpl s) throws IOException
   {
-    InetAddress addr = InetAddress.getByName(hostname);
-    connect(addr, port);
+    accept((PlainSocketImpl) s);
   }
 
-  /**
-   * Creates a new socket that is not bound to any local address/port and
-   * is not connected to any remote address/port.  This will be created as
-   * a stream socket if the stream parameter is true, or a datagram socket
-   * if the stream parameter is false.
-   *
-   * @param stream true for a stream socket, false for a datagram socket
-   */
-  protected native synchronized void create(boolean stream)
-    throws IOException;
+  protected native int available() throws IOException;
 
-  /**
-   * Starts listening for connections on a socket. The queuelen parameter
-   * is how many pending connections will queue up waiting to be serviced
-   * before being accept'ed.  If the queue of pending requests exceeds this
-   * number, additional connections will be refused.
-   *
-   * @param queuelen The length of the pending connection queue
-   * 
-   * @exception IOException If an error occurs
-   */
-  protected native synchronized void listen(int queuelen)
+  protected native void close () throws IOException;
+
+  protected native void sendUrgentData(int data)
     throws IOException;
 
-  /**
-   * Internal method used by SocketInputStream for reading data from
-   * the connection.  Reads up to len bytes of data into the buffer
-   * buf starting at offset bytes into the buffer.
-   *
-   * @return The actual number of bytes read or -1 if end of stream.
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native int read(byte[] buf, int offset, int len)
+  // Stream handling.
+
+  /** A cached copy of the in stream for reading from the socket.  */
+  private InputStream in;
+
+  /** A cached copy of the out stream for writing to the socket.  */
+  private OutputStream out;
+
+
+  // The native read methods.
+
+  private native int read() throws IOException;
+
+  private native int read(byte[] buffer, int offset, int count)
     throws IOException;
 
-  /**
-   * Internal method used by SocketOuputStream for writing data to
-   * the connection.  Writes up to len bytes of data from the buffer
-   * buf starting at offset bytes into the buffer.
-   *
-   * @exception IOException If an error occurs
-   */
-  protected native void write(byte[] buf, int offset, int len)
+
+  // The native write methods.
+
+  private native void write(int c) throws IOException;
+
+  private native void write(byte[] buffer, int offset, int count)
     throws IOException;
 
-  /**
-   * Sets the specified option on a socket to the passed in object.  For
-   * options that take an integer argument, the passed in object is an
-   * Integer.  The option_id parameter is one of the defined constants in
-   * this interface.
-   *
-   * @param option_id The identifier of the option
-   * @param val The value to set the option to
-   *
-   * @exception SocketException If an error occurs
-   */
-  public native void setOption(int option_id, Object val) 
-    throws SocketException;
+  protected void finalize() throws Throwable
+  {
+    synchronized (this)
+      {
+	if (fnum != -1)
+	  try
+	    {
+	      close();
+	    }
+	  catch (IOException ex)
+	    {
+	      // ignore
+	    }
+      }
+    super.finalize();
+  }
 
-  /**
-   * Returns the current setting of the specified option.  The Object returned
-   * will be an Integer for options that have integer values.  The option_id
-   * is one of the defined constants in this interface.
-   *
-   * @param option_id The option identifier
-   *
-   * @return The current value of the option
-   *
-   * @exception SocketException If an error occurs
+  /** @return the input stream attached to the socket.
    */
-  public native Object getOption(int option_id)
-    throws SocketException;
+  protected InputStream getInputStream() throws IOException
+  {
+    if (in == null)
+      in = new SocketInputStream();
+    return in;
+  }
 
-  /**
-   * Returns an InputStream object for reading from this socket.  This will
-   * be an instance of SocketInputStream.
-   *
-   * @return An input stream attached to the socket.
-   *
-   * @exception IOException If an error occurs
+  /** @return the output stream attached to the socket.
    */
-  protected synchronized InputStream getInputStream() throws IOException
+  protected OutputStream getOutputStream() throws IOException
   {
-    return(new SocketInputStream(this));
+    if (out == null)
+      out = new SocketOutputStream();
+    return out;
   }
 
   /**
-   * Returns an OutputStream object for writing to this socket.  This will
-   * be an instance of SocketOutputStream.
-   *
-   * @return An output stream attached to the socket.
+   * A stream which reads from the socket implementation.
    *
-   * @exception IOException If an error occurs
+   * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>
    */
-  protected synchronized OutputStream getOutputStream() throws IOException
+  class SocketInputStream
+    extends InputStream
   {
-    return(new SocketOutputStream(this));
-  }
+    SocketInputStream()
+    {
+    }
+    
+    public final void close() throws IOException
+    {
+      PlainSocketImpl.this.close();
+    }
 
-  public void connect(SocketAddress address, int timeout)
-  {
-    throw new InternalError ("PlainSocketImpl::connect not implemented");
-  }
+    public final int available() throws IOException
+    {
+      return PlainSocketImpl.this.available();
+    }
 
-  public void sendUrgentData(int data)
-  {
-    throw new InternalError ("PlainSocketImpl::sendUrgentData not implemented");
-  }
+    public final int read() throws IOException
+    {
+      return PlainSocketImpl.this.read();
+    }
 
-  public void shutdownInput()
-  {
-    throw new InternalError ("PlainSocketImpl::shutdownInput not implemented");
+    public final int read(byte[] buffer, int offset, int length)
+      throws IOException
+    {
+      return PlainSocketImpl.this.read(buffer, offset, length);
+    }
+
+    public final int read(byte[] buffer)
+      throws IOException
+    {
+      return PlainSocketImpl.this.read(buffer, 0, buffer.length);
+    }
   }
 
-  public void shutdownOutput()
+  /** A stream which writes to the socket implementation.
+   *
+   * @author Nic Ferrier  <nferrier@tapsellferrier.co.uk>
+   */
+  class SocketOutputStream
+    extends OutputStream
   {
-    throw new InternalError ("PlainSocketImpl::shutdownOutput not implemented");
+    public final void close() throws IOException
+    {
+      PlainSocketImpl.this.close();
+    }
+
+    public final void write(int c) throws IOException
+    {
+      PlainSocketImpl.this.write(c);
+    }
+
+    public final void write(byte[] buffer, int offset, int length)
+      throws IOException
+    {
+      PlainSocketImpl.this.write(buffer, offset, length);
+    }
+
+    public final void write(byte[] buffer)
+      throws IOException
+    {
+      PlainSocketImpl.this.write(buffer, 0, buffer.length);
+    }
   }
-} // class PlainSocketImpl
+}
