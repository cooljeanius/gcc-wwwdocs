--- /home/tromey/gnu/Nightly/classpath/classpath/java/math/BigDecimal.java	2003-07-19 02:19:40.000000000 -0600
+++ java/math/BigDecimal.java	2003-04-20 02:20:18.000000000 -0600
@@ -1,5 +1,5 @@
 /* java.math.BigDecimal -- Arbitrary precision decimals.
-   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -273,7 +273,7 @@
     // Ensure that pow gets a non-negative value.
     int valScale = val.scale;
     BigInteger valIntVal = val.intVal;
-    int power = newScale - (scale - val.scale);
+    int power = newScale + 1 - (scale - val.scale);
     if (power < 0)
       {
 	// Effectively increase the scale of val to avoid an
@@ -288,51 +288,47 @@
 //      System.out.println("int: " + parts[0]);
 //      System.out.println("rem: " + parts[1]);
 
-    BigInteger unrounded = parts[0];
-    if (parts[1].signum () == 0) // no remainder, no rounding necessary
-      return new BigDecimal (unrounded, newScale);
+    int roundDigit = parts[0].mod (BigInteger.valueOf (10)).intValue ();
+    BigInteger unrounded = parts[0].divide (BigInteger.valueOf (10));
 
-    if (roundingMode == ROUND_UNNECESSARY)
-      throw new ArithmeticException ("newScale is not large enough");
+    if (roundDigit == 0 && parts[1].signum () == 0) // no rounding necessary
+      return new BigDecimal (unrounded, newScale);
 
     int sign = unrounded.signum ();
 
-    if (roundingMode == ROUND_CEILING)
-      roundingMode = (sign == 1) ? ROUND_UP : ROUND_DOWN;
-    else if (roundingMode == ROUND_FLOOR)
-      roundingMode = (sign == 1) ? ROUND_DOWN : ROUND_UP;
-    else
+    switch (roundingMode)
       {
-	// half is -1 if remainder*2 < positive intValue (*power), 0 if equal,
-	// 1 if >. This implies that the remainder to round is less than,
-	// equal to, or greater than half way to the next digit.
-	BigInteger posRemainder = sign == -1 ? parts[1].negate() : parts[1];
-	int half = posRemainder.shiftLeft(1).compareTo(valIntVal);
-	
-	switch(roundingMode)
+      case ROUND_UNNECESSARY:
+	throw new ArithmeticException ("newScale is not large enough");
+      case ROUND_CEILING:
+	roundingMode = (sign == 1) ? ROUND_UP : ROUND_DOWN;
+	break;
+      case ROUND_FLOOR:
+	roundingMode = (sign == 1) ? ROUND_DOWN : ROUND_UP;
+	break;
+      case ROUND_HALF_UP:
+	roundingMode = (roundDigit >= 5) ? ROUND_UP : ROUND_DOWN;
+	break;
+      case ROUND_HALF_DOWN:
+	roundingMode = (roundDigit > 5) ? ROUND_UP : ROUND_DOWN;
+	break;
+      case ROUND_HALF_EVEN:
+	if (roundDigit < 5)
+	  roundingMode = ROUND_DOWN;
+	else
 	  {
-	  case ROUND_HALF_UP:
-	    roundingMode = (half == -1) ? ROUND_DOWN : ROUND_UP;
-	    break;
-	  case ROUND_HALF_DOWN:
-	    roundingMode = (half == 1) ? ROUND_UP : ROUND_DOWN;
-	    break;
-	  case ROUND_HALF_EVEN:
-	    if (half == -1)
-	      roundingMode = ROUND_DOWN;
-	    else if (half == 1)
-	      roundingMode = ROUND_UP;
-	    else if (unrounded.testBit(0)) // odd, then ROUND_HALF_UP
+	    int rightmost = 
+	      unrounded.mod (BigInteger.valueOf (10)).intValue ();
+	    if (rightmost % 2 == 1) // odd, then ROUND_HALF_UP
 	      roundingMode = ROUND_UP;
-	    else                           // even, ROUND_HALF_DOWN
-	      roundingMode = ROUND_DOWN;
-	    break;
+	    else // even, then ROUND_HALF_DOWN
+	      roundingMode = (roundDigit > 5) ? ROUND_UP : ROUND_DOWN;
 	  }
+	break;
       }
 
     if (roundingMode == ROUND_UP)
-      return new BigDecimal (unrounded.add (BigInteger.valueOf
-					    (sign != 0 ? sign : 1)), newScale);
+      return new BigDecimal (unrounded.add (BigInteger.valueOf (1)), newScale);
 
     // roundingMode == ROUND_DOWN
     return new BigDecimal (unrounded, newScale);
