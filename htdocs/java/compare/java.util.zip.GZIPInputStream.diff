--- /home/tromey/gnu/egcs/classpath/classpath/java/util/zip/GZIPInputStream.java	Fri Sep  7 06:44:14 2001
+++ java/util/zip/GZIPInputStream.java	Fri Nov 17 14:42:28 2000
@@ -1,14 +1,14 @@
-/* java.util.zip.GZIPInputStream
-   Copyright (C) 2001 Free Software Foundation, Inc.
+/* GZIPInputStream.java - Input filter for reading gzip file
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
 
-This file is part of Jazzlib.
+This file is part of GNU Classpath.
 
-Jazzlib is free software; you can redistribute it and/or modify
+GNU Classpath is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
-Jazzlib is distributed in the hope that it will be useful, but
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
@@ -28,274 +28,143 @@
 
 import java.io.InputStream;
 import java.io.IOException;
-import java.io.EOFException;
-
 
 /**
- * This filter stream is used to decompress a "GZIP" format stream. 
- * The "GZIP" format is described in RFC 1952.
- *
- * @author John Leuner
- * @since JDK 1.1
+ * @author Tom Tromey
+ * @date May 17, 1999
  */
 
-public class GZIPInputStream extends InflaterInputStream implements GZIPConstants {
-
-  //Variables
-
-  /** CRC-32 value for uncompressed data
-   */
-
-  protected CRC32 crc; 
-
-  /** Indicates end of stream */
-  
-  protected boolean eos;
+/* Written using on-line Java Platform 1.2 API Specification
+ * and JCL book.
+ * Believed complete and correct.
+ */
 
-  /**
-   * Creates a GZIPInputStream with the default buffer size
-   *
-   *
-   * @param in The stream to read compressed data from 
-   * (in GZIP format)
-   */
+public class GZIPInputStream extends InflaterInputStream
+{
+  public static final int GZIP_MAGIC = 0x8b1f;
 
-  public GZIPInputStream(InputStream in) throws IOException
+  public void close () throws IOException
   {
-    this(in, 4096);
+    // Nothing to do here.
+    super.close();
   }
 
-  /**
-   * Creates a GZIPInputStream with the specified buffer size
-   *
-   *
-   * @param in The stream to read compressed data from 
-   * (in GZIP format)
-   * @param size Size of the buffer to use 
-   */
-
-  public GZIPInputStream(InputStream in, int size) throws IOException
+  public GZIPInputStream (InputStream istream) throws IOException
   {
-    super(in, new Inflater(true), size);
-    crc = new CRC32();
+    this (istream, 512);
   }
 
-  /**
-   * Closes the input stream 
-   *
-   */
-  public void close() throws IOException
+  private final int eof_read () throws IOException
   {
-    super.close();
+    int r = in.read();
+    if (r == -1)
+      throw new ZipException ("gzip header corrupted");
+    return r & 0xff;
   }
 
-  /**
-   * Reads uncompressed data into an array of bytes 
-   *
-   *
-   * @param buf the buffer to read uncompressed data into
-   * @param offset the offset indicating where the data should be placed
-   * @param len the number of uncompressed bytes to be read
-   */
-
-  public int read(byte[] buf, int offset, int len) throws IOException
+  public GZIPInputStream (InputStream istream, int readsize)
+    throws IOException
   {
-    // We first have to slurp in the GZIP header, then we feed all the
-    // rest of the data to the superclass.
-    //
-    // As we do that we continually update the CRC32. Once the data is
-    // finished, we check the CRC32
-    //
-    // This means we don't need our own buffer, as everything is done
-    // in the superclass.
-    if (!readGZIPHeader)
-      readHeader();
+    super (istream, new Inflater (true), readsize);
 
-    if (eos)
-      return -1;
+    // NOTE: header reading code taken from zlib's gzio.c.
 
-    //    System.err.println("GZIPIS.read(byte[], off, len ... " + offset + " and len " + len);
-    //We don't have to read the header, so we just grab data from the superclass
-    int numRead = super.read(buf, offset, len);
-    if (numRead > 0)
-      crc.update(buf, offset, numRead);
-
-    if (inf.finished())
-      readFooter();
-    return numRead;
-  }
+    // Read the magic number.
+    int magic = eof_read () | (eof_read () << 8);
+    if (magic != GZIP_MAGIC)
+      throw new ZipException ("gzip header corrupted");
 
-  private void readHeader() throws IOException
-  {
-    /* 1. Check the two magic bytes */
-    CRC32 headCRC = new CRC32();
-    int magic = in.read();
-    if (magic < 0)
-      {
-	eos = true;
-	return;
-      }
-    headCRC.update(magic);
-    if (magic != (GZIP_MAGIC >> 8))
-      {
-	throw new IOException("Error in GZIP header, first byte doesn't match");
-      }
-    
-    magic = in.read();
-    if (magic != (GZIP_MAGIC & 0xff))
-      {
-	throw new IOException("Error in GZIP header,  second byte doesn't match");
-      }
-    headCRC.update(magic);
-    
-    /* 2. Check the compression type (must be 8) */
-    int CM = in.read();
-    if (CM != 8)
-      {
-	throw new IOException("Error in GZIP header, data not in deflate format");
-      }
-    headCRC.update(CM);
+    int method = eof_read ();
+    int flags = eof_read ();
+    // Test from zlib.
+    if (method != Z_DEFLATED || (flags & RESERVED) != 0)
+      throw new ZipException ("gzip header corrupted");
 
-    /* 3. Check the flags */
-    int flags = in.read();
-    if (flags < 0)
-      throw new EOFException("Early EOF in GZIP header");
-    headCRC.update(flags);
-    
-    /*    This flag byte is divided into individual bits as follows:
-	  
-	  bit 0   FTEXT
-	  bit 1   FHCRC
-	  bit 2   FEXTRA
-	  bit 3   FNAME
-	  bit 4   FCOMMENT
-	  bit 5   reserved
-	  bit 6   reserved
-	  bit 7   reserved
-    */
-    
-    /* 3.1 Check the reserved bits are zero */
-    
-    if ((flags & 0xd0) != 0)
-      {
-	throw new IOException("Reserved flag bits in GZIP header != 0");
-      }
-    
-    /* 4.-6. Skip the modification time, extra flags, and OS type */
-    for (int i=0; i< 6; i++)
+    // Discard time, xflags, OS code.
+    for (int i = 0; i < 6; ++i)
+      eof_read ();
+
+    // Skip the extra field.
+    if ((flags & EXTRA_FIELD) != 0)
       {
-	int readByte = in.read();
-	if (readByte < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	headCRC.update(readByte);
+	int len = eof_read () | (eof_read () << 8);
+	while (len-- != 0)
+	  eof_read ();
       }
-    
-    /* 7. Read extra field */
-    if ((flags & FEXTRA) != 0)
+
+    if ((flags & ORIG_NAME) != 0)
       {
-	/* Skip subfield id */
-	for (int i=0; i< 2; i++)
+	while (true)
 	  {
-	    int readByte = in.read();
-	    if (readByte < 0)
-	      throw new EOFException("Early EOF in GZIP header");
-	    headCRC.update(readByte);
+	    int c = eof_read ();
+	    if (c == 0)
+	      break;
 	  }
-	if (in.read() < 0 || in.read() < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	
-	int len1, len2, extraLen;
-	len1 = in.read();
-	len2 = in.read();
-	if ((len1 < 0) || (len2 < 0))
-	  throw new EOFException("Early EOF in GZIP header");
-	headCRC.update(len1);
-	headCRC.update(len2);
+      }
 
-	extraLen = (len1 << 8) | len2;
-	for (int i = 0; i < extraLen;i++)
+    if ((flags & COMMENT) != 0)
+      {
+	while (true)
 	  {
-	    int readByte = in.read();
-	    if (readByte < 0)
-	      throw new EOFException("Early EOF in GZIP header");
-	    headCRC.update(readByte);
+	    int c = eof_read ();
+	    if (c == 0)
+	      break;
 	  }
       }
-    
-    /* 8. Read file name */
-    if ((flags & FNAME) != 0)
-      {
-	int readByte;
-	while ( (readByte = in.read()) > 0)
-	  headCRC.update(readByte);
-	if (readByte < 0)
-	  throw new EOFException("Early EOF in GZIP file name");
-	headCRC.update(readByte);
-      }
 
-    /* 9. Read comment */
-    if ((flags & FCOMMENT) != 0)
-      {
-	int readByte;
-	while ( (readByte = in.read()) > 0)
-	  headCRC.update(readByte);
-
-	if (readByte < 0)
-	  throw new EOFException("Early EOF in GZIP comment");
-	headCRC.update(readByte);
-      }
-    
-    /* 10. Read header CRC */
-    if ((flags & FHCRC) != 0)
+    if ((flags & HEAD_CRC) != 0)
       {
-	int tempByte;
-	int crcval = in.read();
-	if (crcval < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	
-	tempByte = in.read();
-	if (tempByte < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	
-	crcval = (crcval << 8) | tempByte;
-	if (crcval != ((int) headCRC.getValue() & 0xffff))
-	  throw new IOException("Header CRC value mismatch");
+	// FIXME: consider checking CRC of the header.
+	eof_read ();
+	eof_read ();
       }
-    
-    readGZIPHeader = true;
-    //System.err.println("Read GZIP header");
+
+    crc = new CRC32 ();
   }
 
-  private void readFooter() throws IOException
+  public int read (byte[] buf, int off, int len) throws IOException
   {
-    byte[] footer = new byte[8];
-    int avail = inf.getRemaining();
-    if (avail > 8)
-      avail = 8;
-    System.arraycopy(buf, len - inf.getRemaining(), footer, 0, avail);
-    int needed = 8 - avail;
-    while (needed > 0)
+    if (eos)
+      return -1;
+    int r = super.read(buf, off, len);
+    if (r == -1)
       {
-	int count = in.read(footer, 8-needed, needed);
-	if (count <= 0)
-	  throw new EOFException("Early EOF in GZIP footer");
-	needed -= count; //Jewel Jan 16
-      }
-    int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8)
-      | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
-    if (crcval != (int) crc.getValue())
-      throw new IOException("GZIP crc sum mismatch, theirs \"" + Integer.toHexString(crcval) + "\" and ours \"" + Integer.toHexString( (int) crc.getValue()));
-    int total = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8)
-      | ((footer[6] & 0xff) << 16) | (footer[7] << 24);
-    if (total != inf.getTotalOut())
-      throw new IOException("Number of bytes mismatch");
-    /* XXX Should we support multiple members.
-     * Difficult, since there may be some bytes still in buf
-     */
-    eos = true;
+	eos = true;
+	int header_crc = read4 ();
+	if (crc.getValue() != header_crc)
+	  throw new ZipException ("corrupted gzip file");
+	// Read final `ISIZE' field.
+	// FIXME: should we check this length?
+	read4 ();
+	return -1;
+      }
+    crc.update(buf, off, r);
+    return r;
+  }
+
+  private final int read4 () throws IOException
+  {
+    int byte0 = in.read();
+    int byte1 = in.read();
+    int byte2 = in.read();
+    int byte3 = in.read();
+    if (byte3 < 0)
+      throw new ZipException (".zip archive ended prematurely");
+    return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)
+      + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);
   }
 
+  // Checksum used by this input stream.
+  protected CRC32 crc;
+
+  // Indicates whether end-of-stream has been reached.
+  protected boolean eos;
 
-  /* Have we read the GZIP header yet? */
-  private boolean readGZIPHeader;
+  // Some constants from zlib.
+  static final int Z_DEFLATED = 8;
+  static final int HEAD_CRC    = 0x02;
+  static final int EXTRA_FIELD = 0x04;
+  static final int ORIG_NAME   = 0x08;
+  static final int COMMENT     = 0x10;
+  static final int RESERVED    = 0xe0;
 }
