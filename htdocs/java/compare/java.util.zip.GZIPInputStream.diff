--- /home/tromey/gnu/Nightly/classpath/classpath/java/util/zip/GZIPInputStream.java	2004-02-04 02:21:39.000000000 -0700
+++ java/util/zip/GZIPInputStream.java	2002-12-10 19:20:36.000000000 -0700
@@ -1,5 +1,5 @@
 /* GZIPInputStream.java - Input filter for reading gzip file
-   Copyright (C) 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -39,320 +39,149 @@
 
 import java.io.InputStream;
 import java.io.IOException;
-import java.io.EOFException;
 
 /**
- * This filter stream is used to decompress a "GZIP" format stream. 
- * The "GZIP" format is described in RFC 1952.
- *
- * @author John Leuner
  * @author Tom Tromey
- * @since JDK 1.1
+ * @date May 17, 1999
  */
-public class GZIPInputStream
-  extends InflaterInputStream
+
+/* Written using on-line Java Platform 1.2 API Specification
+ * and JCL book.
+ * Believed complete and correct.
+ */
+
+public class GZIPInputStream extends InflaterInputStream
 {
-  /**
-   * The magic number found at the start of a GZIP stream.
-   */
-  public static final int GZIP_MAGIC = 0x1f8b;
-
-  /**
-   * The mask for bit 0 of the flag byte.
-   */
-  static final int FTEXT = 0x1;
-
-  /**
-   * The mask for bit 1 of the flag byte.
-   */
-  static final int FHCRC = 0x2;
-
-  /**
-   * The mask for bit 2 of the flag byte.
-   */
-  static final int FEXTRA = 0x4;
-
-  /**
-   * The mask for bit 3 of the flag byte.
-   */
-  static final int FNAME = 0x8;
-
-  /**
-   * The mask for bit 4 of the flag byte.
-   */
-  static final int FCOMMENT = 0x10;
-
-  /**
-   * The CRC-32 checksum value for uncompressed data.
-   */
-  protected CRC32 crc; 
-
-
-  /**
-   * Indicates whether or not the end of the stream has been reached.
-   */  
-  protected boolean eos;
+  public static final int GZIP_MAGIC = 0x8b1f;
 
-  /**
-   * Indicates whether or not the GZIP header has been read in.
-   */
-  private boolean readGZIPHeader;
-
-  /**
-   * Creates a GZIPInputStream with the default buffer size.
-   *
-   * @param in The stream to read compressed data from 
-   *           (in GZIP format).
-   *
-   * @throws IOException if an error occurs during an I/O operation.
-   */
-  public GZIPInputStream(InputStream in)
-    throws IOException
+  public void close () throws IOException
   {
-    this(in, 4096);
+    // Nothing to do here.
+    super.close();
   }
 
-  /**
-   * Creates a GZIPInputStream with the specified buffer size.
-   *
-   * @param in The stream to read compressed data from 
-   *           (in GZIP format).
-   * @param size The size of the buffer to use.
-   *
-   * @throws IOException if an error occurs during an I/O operation.
-   * @throws IllegalArgumentException if <code>size</code>
-   * is less than or equal to 0.
-   */
-  public GZIPInputStream(InputStream in, int size)
-    throws IOException
+  public GZIPInputStream (InputStream istream) throws IOException
   {
-    super(in, new Inflater(true), size);
-    crc = new CRC32();
+    this (istream, 512);
   }
 
-  /**
-   * Closes the input stream.
-   *
-   * @throws IOException if an error occurs during an I/O operation.
-   */
-  public void close()
-    throws IOException
+  private final int eof_read () throws IOException
   {
-    // Nothing to do here.
-    super.close();
+    int r = in.read();
+    if (r == -1)
+      throw new ZipException ("gzip header corrupted");
+    return r & 0xff;
   }
 
-  /**
-   * Reads in GZIP-compressed data and stores it in uncompressed form
-   * into an array of bytes.  The method will block until either
-   * enough input data becomes available or the compressed stream
-   * reaches its end.
-   *
-   * @param buf the buffer into which the uncompressed data will
-   *            be stored.
-   * @param offset the offset indicating where in <code>buf</code>
-   *               the uncompressed data should be placed.
-   * @param len the number of uncompressed bytes to be read.
-   */
-  public int read(byte[] buf, int offset, int len) throws IOException
+  public GZIPInputStream (InputStream istream, int readsize)
+    throws IOException
   {
-    // We first have to slurp in the GZIP header, then we feed all the
-    // rest of the data to the superclass.
-    //
-    // As we do that we continually update the CRC32. Once the data is
-    // finished, we check the CRC32.
-    //
-    // This means we don't need our own buffer, as everything is done
-    // in the superclass.
-    if (!readGZIPHeader)
-      readHeader();
+    super (istream, new Inflater (true), readsize);
 
-    if (eos)
-      return -1;
+    // NOTE: header reading code taken from zlib's gzio.c.
 
-    //  System.err.println("GZIPIS.read(byte[], off, len ... " + offset + " and len " + len);
+    // Read the magic number.
+    int magic = eof_read () | (eof_read () << 8);
+    if (magic != GZIP_MAGIC)
+      throw new ZipException ("gzip header corrupted");
+
+    int method = eof_read ();
+    int flags = eof_read ();
+    // Test from zlib.
+    if (method != Z_DEFLATED || (flags & RESERVED) != 0)
+      throw new ZipException ("gzip header corrupted");
+
+    // Discard time, xflags, OS code.
+    for (int i = 0; i < 6; ++i)
+      eof_read ();
 
-    /* We don't have to read the header,
-     * so we just grab data from the superclass.
-     */
-    int numRead = super.read(buf, offset, len);
-    if (numRead > 0)
-      crc.update(buf, offset, numRead);
-
-    if (inf.finished())
-      readFooter();
-    return numRead;
-  }
+    // Skip the extra field.
+    if ((flags & EXTRA_FIELD) != 0)
+      {
+	int len = eof_read () | (eof_read () << 8);
+	while (len-- != 0)
+	  eof_read ();
+      }
 
+    if ((flags & ORIG_NAME) != 0)
+      {
+	while (true)
+	  {
+	    int c = eof_read ();
+	    if (c == 0)
+	      break;
+	  }
+      }
 
-  /**
-   * Reads in the GZIP header.
-   */
-  private void readHeader() throws IOException
-  {
-    /* 1. Check the two magic bytes */
-    CRC32 headCRC = new CRC32();
-    int magic = in.read();
-    if (magic < 0)
-    {
-      eos = true;
-      return;
-    }
-    headCRC.update(magic);
-    if (magic != (GZIP_MAGIC >> 8))
-      throw new IOException("Error in GZIP header, first byte doesn't match");
-    
-    magic = in.read();
-    if (magic != (GZIP_MAGIC & 0xff))
-      throw new IOException("Error in GZIP header, second byte doesn't match");
-    headCRC.update(magic);
-    
-    /* 2. Check the compression type (must be 8) */
-    int CM = in.read();
-    if (CM != 8)
-      throw new IOException("Error in GZIP header, data not in deflate format");
-    headCRC.update(CM);
-
-    /* 3. Check the flags */
-    int flags = in.read();
-    if (flags < 0)
-      throw new EOFException("Early EOF in GZIP header");
-    headCRC.update(flags);
-    
-    /*    This flag byte is divided into individual bits as follows:
-	  
-	  bit 0   FTEXT
-	  bit 1   FHCRC
-	  bit 2   FEXTRA
-	  bit 3   FNAME
-	  bit 4   FCOMMENT
-	  bit 5   reserved
-	  bit 6   reserved
-	  bit 7   reserved
-    */
-    
-    /* 3.1 Check the reserved bits are zero */    
-    if ((flags & 0xd0) != 0)
-      throw new IOException("Reserved flag bits in GZIP header != 0");
-    
-    /* 4.-6. Skip the modification time, extra flags, and OS type */
-    for (int i=0; i< 6; i++)
-    {
-      int readByte = in.read();
-      if (readByte < 0)
-	throw new EOFException("Early EOF in GZIP header");
-      headCRC.update(readByte);
-    }
-    
-    /* 7. Read extra field */
-    if ((flags & FEXTRA) != 0)
-    {
-      /* Skip subfield id */
-      for (int i=0; i< 2; i++)
+    if ((flags & COMMENT) != 0)
       {
-        int readByte = in.read();
-	if (readByte < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	headCRC.update(readByte);
+	while (true)
+	  {
+	    int c = eof_read ();
+	    if (c == 0)
+	      break;
+	  }
       }
-      if (in.read() < 0 || in.read() < 0)
-	throw new EOFException("Early EOF in GZIP header");
-	
-      int len1, len2, extraLen;
-      len1 = in.read();
-      len2 = in.read();
-      if ((len1 < 0) || (len2 < 0))
-	throw new EOFException("Early EOF in GZIP header");
-      headCRC.update(len1);
-      headCRC.update(len2);
 
-      extraLen = (len1 << 8) | len2;
-      for (int i = 0; i < extraLen;i++)
+    if ((flags & HEAD_CRC) != 0)
       {
-	int readByte = in.read();
-	if (readByte < 0)
-	  throw new EOFException("Early EOF in GZIP header");
-	headCRC.update(readByte);
+	// FIXME: consider checking CRC of the header.
+	eof_read ();
+	eof_read ();
       }
-    }
-    
-    /* 8. Read file name */
-    if ((flags & FNAME) != 0)
-    {
-      int readByte;
-      while ( (readByte = in.read()) > 0)
-	headCRC.update(readByte);
-      if (readByte < 0)
-	throw new EOFException("Early EOF in GZIP file name");
-      headCRC.update(readByte);
-    }
-
-    /* 9. Read comment */
-    if ((flags & FCOMMENT) != 0)
-    {
-      int readByte;
-      while ( (readByte = in.read()) > 0)
-        headCRC.update(readByte);
-
-      if (readByte < 0)
-        throw new EOFException("Early EOF in GZIP comment");
-      headCRC.update(readByte);
-    }
-    
-    /* 10. Read header CRC */
-    if ((flags & FHCRC) != 0)
-    {
-      int tempByte;
-      int crcval = in.read();
-      if (crcval < 0)
-        throw new EOFException("Early EOF in GZIP header");
-	
-      tempByte = in.read();
-      if (tempByte < 0)
-        throw new EOFException("Early EOF in GZIP header");
-	
-      crcval = (crcval << 8) | tempByte;
-      if (crcval != ((int) headCRC.getValue() & 0xffff))
-        throw new IOException("Header CRC value mismatch");
-    }
-    
-    readGZIPHeader = true;
-    //System.err.println("Read GZIP header");
+
+    crc = new CRC32 ();
   }
 
+  public int read (byte[] buf, int off, int len) throws IOException
+  {
+    if (eos)
+      return -1;
+    int r = super.read(buf, off, len);
+    if (r == -1)
+      {
+	eos = true;
+
+	byte[] tmp = new byte[8];
+	// First copy remaining bytes from inflater input buffer.
+	int avail = inf.getRemaining ();
+	System.arraycopy (this.buf, this.len - avail, tmp, 0, avail);
+
+	// Now read remaining bytes from wrapped input stream.
+	for (int i = avail; i < 8; ++i)
+	  {
+	    tmp[i] = (byte) eof_read ();
+	  }
+
+	int header_crc = read4 (tmp, 0);
+	if (crc.getValue() != header_crc)
+	  throw new ZipException ("corrupted gzip file - crc mismatch");
+	int isize = read4 (tmp, 4);
+	if (inf.getTotalOut() != isize)
+	  throw new ZipException ("corrupted gzip file - size mismatch");
+	return -1;
+      }
+    crc.update(buf, off, r);
+    return r;
+  }
 
-  private void readFooter() throws IOException
+  private final int read4 (byte[] buf, int offset) throws IOException
   {
-    byte[] footer = new byte[8];
-    int avail = inf.getRemaining();
-    if (avail > 8)
-      avail = 8;
-    System.arraycopy(buf, len - inf.getRemaining(), footer, 0, avail);
-    int needed = 8 - avail;
-    while (needed > 0)
-    {
-      int count = in.read(footer, 8-needed, needed);
-      if (count <= 0)
-	throw new EOFException("Early EOF in GZIP footer");
-      needed -= count; //Jewel Jan 16
-    }
-
-    int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8)
-      | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
-    if (crcval != (int) crc.getValue())
-      throw new IOException("GZIP crc sum mismatch, theirs \""
-			    + Integer.toHexString(crcval)
-			    + "\" and ours \""
-			    + Integer.toHexString( (int) crc.getValue()));
-
-    int total = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8)
-      | ((footer[6] & 0xff) << 16) | (footer[7] << 24);
-    if (total != inf.getTotalOut())
-      throw new IOException("Number of bytes mismatch");
-
-    /* FIXME" XXX Should we support multiple members.
-     * Difficult, since there may be some bytes still in buf
-     */
-    eos = true;
+    return (((buf[offset + 3] & 0xFF) << 24) + ((buf[offset + 2] & 0xFF) << 16)
+	    + ((buf[offset + 1] & 0xFF) << 8) + (buf[offset] & 0xFF));
   }
+
+  // Checksum used by this input stream.
+  protected CRC32 crc;
+
+  // Indicates whether end-of-stream has been reached.
+  protected boolean eos;
+
+  // Some constants from zlib.
+  static final int Z_DEFLATED = 8;
+  static final int HEAD_CRC    = 0x02;
+  static final int EXTRA_FIELD = 0x04;
+  static final int ORIG_NAME   = 0x08;
+  static final int COMMENT     = 0x10;
+  static final int RESERVED    = 0xe0;
 }
