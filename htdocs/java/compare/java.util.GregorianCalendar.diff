--- /home/tromey/gnu/Nightly/classpath/classpath/java/util/GregorianCalendar.java	2004-11-09 02:37:55.000000000 -0700
+++ java/util/GregorianCalendar.java	2004-11-09 02:18:46.000000000 -0700
@@ -217,35 +217,22 @@
    */
   public GregorianCalendar(TimeZone zone, Locale locale)
   {
-    this(zone, locale, false);
-    setTimeInMillis(System.currentTimeMillis());
-  }
-
-  /**
-   * Common constructor that all constructors should call.
-   * @param zone a time zone.  
-   * @param locale a locale.  
-   * @param unused unused parameter to make the signature differ from
-   * the public constructor (TimeZone, Locale).
-   */
-  private GregorianCalendar(TimeZone zone, Locale locale, boolean unused)
-  {
     super(zone, locale);
     ResourceBundle rb = getBundle(locale);
     gregorianCutover = ((Date) rb.getObject("gregorianCutOver")).getTime();
+    setTimeInMillis(System.currentTimeMillis());
   }
 
   /**
    * Constructs a new GregorianCalendar representing midnight on the
    * given date with the default time zone and locale.
-   *
    * @param year corresponds to the YEAR time field.
    * @param month corresponds to the MONTH time field.
    * @param day corresponds to the DAY time field.
    */
   public GregorianCalendar(int year, int month, int day)
   {
-    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    super();
     set(year, month, day);
   }
 
@@ -261,7 +248,7 @@
    */
   public GregorianCalendar(int year, int month, int day, int hour, int minute)
   {
-    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    super();
     set(year, month, day, hour, minute);
   }
 
@@ -269,6 +256,7 @@
    * Constructs a new GregorianCalendar representing midnight on the
    * given date with the default time zone and locale.
    *
+   *
    * @param year corresponds to the YEAR time field.
    * @param month corresponds to the MONTH time field.
    * @param day corresponds to the DAY time field.
@@ -279,7 +267,7 @@
   public GregorianCalendar(int year, int month, int day,
 			   int hour, int minute, int second)
   {
-    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    super();
     set(year, month, day, hour, minute, second);
   }
 
@@ -515,21 +503,6 @@
   {
     int era = isSet[ERA] ? fields[ERA] : AD;
     int year = isSet[YEAR] ? fields[YEAR] : 1970;
-    if (isLenient() && isSet[MONTH])
-      {
-	int month = fields[MONTH];
-	year += month / 12;
-	month %= 12;
-	if (month < 0)
-	  {
-	    month += 12;
-	    year--;
-	  }
-	fields[MONTH] = month;
-	isSet[YEAR] = true;
-	fields[YEAR] = year;
-      }
-
     if (era == BC)
       year = 1 - year;
 
@@ -580,20 +553,19 @@
     int rawOffset = isSet[ZONE_OFFSET]
       ? fields[ZONE_OFFSET] : zone.getRawOffset();
 
-    int day = (int) (time / (24 * 60 * 60 * 1000L));
-    millisInDay = (int) (time % (24 * 60 * 60 * 1000L));
-    if (millisInDay < 0)
-      {
-	millisInDay += (24 * 60 * 60 * 1000);
-	day--;
-      }
-
-    int[] f = new int[FIELD_COUNT];
-    calculateDay(f, day, time - rawOffset >= gregorianCutover);
-    year = f[YEAR];
-    int month = f[MONTH];
-    day = f[DAY_OF_MONTH];
-    int weekday = f[DAY_OF_WEEK];
+    int dayOfYear = daysOfYear[0] + daysOfYear[1];
+    // This formula isn't right, so check for month as a quick fix.
+    // It doesn't compensate for leap years and puts day 30 in month 1
+    // instead of month 0.
+    int month = isSet[MONTH]
+	? fields[MONTH] : (dayOfYear * 5 + 3) / (31 + 30 + 31 + 30 + 31);
+    // This formula isn't right, so check for day as a quick fix.  It
+    // doesn't compensate for leap years, either.
+    int day = isSet[DAY_OF_MONTH] ? fields[DAY_OF_MONTH]
+	: (6 + (dayOfYear * 5 + 3) % (31 + 30 + 31 + 30 + 31)) / 5;
+    int weekday = ((int) (time / (24 * 60 * 60 * 1000L)) + THURSDAY) % 7;
+    if (weekday <= 0)
+      weekday += 7;
     int dstOffset = isSet[DST_OFFSET]
       ? fields[DST_OFFSET] : (zone.getOffset((year < 0) ? BC : AD,
 					     (year < 0) ? 1 - year : year,
@@ -639,15 +611,15 @@
    * @param year the year of the date.
    * @param dayOfYear the day of year of the date; 1 based.
    * @param gregorian <code>true</code>, if we should use the Gregorian rules.
-   * @return the days since the epoch, may be negative.  
+   * @return the days since the epoch, may be negative.
    */
-  private long getLinearDay(int year, int dayOfYear, boolean gregorian)
+  private int getLinearDay(int year, int dayOfYear, boolean gregorian)
   {
     // The 13 is the number of days, that were omitted in the Gregorian
     // Calender until the epoch.
     // We shift right by 2 instead of dividing by 4, to get correct
     // results for negative years (and this is even more efficient).
-    long julianDay = ((year * (365L * 4 + 1)) >> 2) + dayOfYear -
+    int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -
       ((1970 * (365 * 4 + 1)) / 4 + 1 - 13);
 
     if (gregorian)
@@ -677,23 +649,23 @@
    * @param day the linear day.  
    * @param gregorian true, if we should use Gregorian rules.
    */
-  private void calculateDay(int[] fields, long day, boolean gregorian)
+  private void calculateDay(int day, boolean gregorian)
   {
     // the epoch is a Thursday.
-    int weekday = (int)(day + THURSDAY) % 7;
+    int weekday = (day + THURSDAY) % 7;
     if (weekday <= 0)
       weekday += 7;
     fields[DAY_OF_WEEK] = weekday;
 
     // get a first approximation of the year.  This may be one 
     // year too big.
-    int year = 1970 + (int)(gregorian
+    int year = 1970 + (gregorian
 		       ? ((day - 100) * 400) / (365 * 400 + 100 - 4 + 1)
 		       : ((day - 100) * 4) / (365 * 4 + 1));
     if (day >= 0)
       year++;
 
-    long firstDayOfYear = getLinearDay(year, 1, gregorian);
+    int firstDayOfYear = getLinearDay(year, 1, gregorian);
 
     // Now look in which year day really lies.
     if (day < firstDayOfYear)
@@ -704,7 +676,7 @@
 
     day -= firstDayOfYear - 1;	// day of year,  one based.
 
-    fields[DAY_OF_YEAR] = (int)day;
+    fields[DAY_OF_YEAR] = day;
     if (year <= 0)
       {
 	fields[ERA] = BC;
@@ -719,13 +691,13 @@
     int leapday = isLeapYear(year, gregorian) ? 1 : 0;
     if (day <= 31 + 28 + leapday)
       {
-	fields[MONTH] = (int)day / 32; // 31->JANUARY, 32->FEBRUARY
-	fields[DAY_OF_MONTH] = (int)day - 31 * fields[MONTH];
+	fields[MONTH] = day / 32;	// 31->JANUARY, 32->FEBRUARY
+	fields[DAY_OF_MONTH] = day - 31 * fields[MONTH];
       }
     else
       {
 	// A few more magic formulas
-	int scaledDay = ((int)day - leapday) * 5 + 8;
+	int scaledDay = (day - leapday) * 5 + 8;
 	fields[MONTH] = scaledDay / (31 + 30 + 31 + 30 + 31);
 	fields[DAY_OF_MONTH] = (scaledDay % (31 + 30 + 31 + 30 + 31)) / 5 + 1;
       }
@@ -744,7 +716,7 @@
     fields[ZONE_OFFSET] = zone.getRawOffset();
     long localTime = time + fields[ZONE_OFFSET];
 
-    long day = localTime / (24 * 60 * 60 * 1000L);
+    int day = (int) (localTime / (24 * 60 * 60 * 1000L));
     int millisInDay = (int) (localTime % (24 * 60 * 60 * 1000L));
     if (millisInDay < 0)
       {
@@ -752,7 +724,7 @@
 	day--;
       }
 
-    calculateDay(fields, day, gregorian);
+    calculateDay(day, gregorian);
     fields[DST_OFFSET] =
       zone.getOffset(fields[ERA], fields[YEAR], fields[MONTH],
 		     fields[DAY_OF_MONTH], fields[DAY_OF_WEEK],
@@ -762,7 +734,7 @@
     if (millisInDay >= 24 * 60 * 60 * 1000)
       {
 	millisInDay -= 24 * 60 * 60 * 1000;
-	calculateDay(fields, ++day, gregorian);
+	calculateDay(++day, gregorian);
       }
 
     fields[DAY_OF_WEEK_IN_MONTH] = (fields[DAY_OF_MONTH] + 6) / 7;
