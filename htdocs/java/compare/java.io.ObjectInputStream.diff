--- /home/tromey/gnu/classpath/classpath/java/io/ObjectInputStream.java	Mon Mar 25 00:05:17 2002
+++ java/io/ObjectInputStream.java	Wed Jul 24 10:05:34 2002
@@ -38,9 +38,10 @@
 
 package java.io;
 
+import gnu.classpath.Configuration;
+
 import java.lang.reflect.Array;
 import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
 import java.util.Arrays;
 import java.util.Hashtable;
 import java.util.Vector;
@@ -51,7 +52,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.InvocationTargetException;
 
-import gnu.classpath.Configuration;
+
 
 public class ObjectInputStream extends InputStream
   implements ObjectInput, ObjectStreamConstants
@@ -73,6 +74,21 @@
   public ObjectInputStream (InputStream in)
     throws IOException, StreamCorruptedException
   {
+    if (Configuration.DEBUG)
+      {
+	String val = System.getProperty("gcj.dumpobjects");
+	if (dump == false && val != null && !val.equals(""))
+	  {
+	    dump = true;
+	    System.out.println ("Serialization debugging enabled");
+	  }
+	else if (dump == true && (val == null || val.equals("")))
+	  {
+	    dump = false;
+	    System.out.println ("Serialization debugging disabled");
+	  }
+      }
+
     this.resolveEnabled = false;
     this.isDeserializing = false;
     this.blockDataPosition = 0;
@@ -113,346 +129,283 @@
     Object ret_val;
     was_deserializing = this.isDeserializing;
 
-    boolean is_consumed = false;
-    boolean old_mode = setBlockDataMode (false);
+    if (! was_deserializing)
+      setBlockDataMode (false);
 
     this.isDeserializing = true;
 
     byte marker = this.realInputStream.readByte ();
     dumpElement ("MARKER: 0x" + Integer.toHexString(marker) + " ");
 
-    try
+    switch (marker)
+    {
+      case TC_BLOCKDATA:
+      case TC_BLOCKDATALONG:
+	if (marker == TC_BLOCKDATALONG) 
+	  dumpElementln ("BLOCKDATALONG");
+	else
+	  dumpElementln ("BLOCKDATA");
+	readNextBlock (marker);
+	throw new StreamCorruptedException ("Unexpected blockData");
+
+      case TC_NULL:
+	dumpElementln ("NULL");
+	ret_val = null;
+	break;
+
+      case TC_REFERENCE:
+      {
+	dumpElement ("REFERENCE ");
+	Integer oid = new Integer (this.realInputStream.readInt ());
+	dumpElementln (Integer.toHexString(oid.intValue()));
+	ret_val = ((ObjectIdentityWrapper)
+		   this.objectLookupTable.get (oid)).object;
+	break;
+      }
+
+      case TC_CLASS:
+      {
+	dumpElementln ("CLASS");
+	ObjectStreamClass osc = (ObjectStreamClass)readObject ();
+	Class clazz = osc.forClass ();
+	assignNewHandle (clazz);
+	ret_val = clazz;
+	break;
+      }
+
+      case TC_CLASSDESC:
+      {
+	dumpElement ("CLASSDESC NAME=");
+	String name = this.realInputStream.readUTF ();
+	dumpElement (name + "; UID=");
+	long uid = this.realInputStream.readLong ();
+	dumpElement (Long.toHexString(uid) + "; FLAGS=");
+	byte flags = this.realInputStream.readByte ();
+	dumpElement (Integer.toHexString(flags) + "; FIELD COUNT=");
+	short field_count = this.realInputStream.readShort ();
+	dumpElementln (Short.toString(field_count));
+	ObjectStreamField[] fields = new ObjectStreamField[field_count];
+
+	ObjectStreamClass osc = new ObjectStreamClass (name, uid,
+						       flags, fields);
+	assignNewHandle (osc);
+
+	for (int i=0; i < field_count; i++)
+	{
+	  dumpElement ("  TYPE CODE=");
+	  char type_code = (char)this.realInputStream.readByte ();
+	  dumpElement (type_code + "; FIELD NAME=");
+	  String field_name = this.realInputStream.readUTF ();
+	  dumpElementln (field_name);
+	  String class_name;
+
+	  if (type_code == 'L' || type_code == '[')
+	    class_name = (String)readObject ();
+	  else
+	    class_name = String.valueOf (type_code);
+
+	  fields[i] =
+	    new ObjectStreamField (field_name,
+				   TypeSignature.getClassForEncoding
+				   (class_name));
+	}
+
+	Class cl = resolveClass (osc);
+	osc.setClass (cl);
+	setBlockDataMode (false);
+
+	if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)
+	  throw new IOException ("Data annotated to class was not consumed.");
+	dumpElementln ("ENDBLOCKDATA ");
+
+	osc.setSuperclass ((ObjectStreamClass)readObject ());
+	ret_val = osc;
+	break;
+      }
+
+      case TC_STRING:
       {
-	switch (marker)
-	  {
-	  case TC_ENDBLOCKDATA: //wgs
-	    {
-	      ret_val = null;
-	      is_consumed = true;
-	      break;
-	    }
-	    
-	  case TC_BLOCKDATA:
-	  case TC_BLOCKDATALONG:
-	    {
-	      if (marker == TC_BLOCKDATALONG)
-		dumpElementln ("BLOCKDATALONG");
-	      else
-		dumpElementln ("BLOCKDATA");
-	      readNextBlock (marker);
-	      throw new StreamCorruptedException ("Unexpected blockData");
-	    }
-	    
-	  case TC_NULL:
-	    {
-	      dumpElementln ("NULL");
-	      ret_val = null;
-	      break;
-	    }
-	    
-	  case TC_REFERENCE:
-	    {
-	      dumpElement ("REFERENCE ");
-	      Integer oid = new Integer (this.realInputStream.readInt ());
-	      dumpElementln (Integer.toHexString(oid.intValue()));
-	      ret_val = ((ObjectIdentityWrapper)
-			 this.objectLookupTable.get (oid)).object;
-	      break;
-	    }
-	    
-	  case TC_CLASS:
-	    {
-	      dumpElementln ("CLASS");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class clazz = osc.forClass ();
-	      assignNewHandle (clazz);
-	      ret_val = clazz;
-	      break;
-	    }
-	    
-	  case TC_PROXYCLASSDESC:
-	    {
-	      dumpElementln ("PROXYCLASS");
-	      int n_intf = this.realInputStream.readInt();
-	      String[] intfs = new String[n_intf];
-	      for (int i = 0; i < n_intf; i++) 
-		{
-		  intfs[i] = this.realInputStream.readUTF();
-		  System.out.println(intfs[i]);
-		}
-	      
-	      boolean oldmode = setBlockDataMode (true);
-	      Class cl = resolveProxyClass(intfs);
-	      setBlockDataMode(oldmode);
-	      
-	      ObjectStreamClass osc = ObjectStreamClass.lookup(cl);
-	      assignNewHandle (osc);
-	      
-	      if (!is_consumed)
-		{
-		  byte b = this.realInputStream.readByte ();
-		  if (b != TC_ENDBLOCKDATA)
-		    throw new IOException ("Data annotated to class was not consumed." + b);
-		}
-	      else
-		is_consumed = false;
-	      ObjectStreamClass superosc = (ObjectStreamClass)readObject ();
-	      osc.setSuperclass (superosc);
-	      ret_val = osc;
-	      break;
-	    }
-	    
-	  case TC_CLASSDESC:
-	    {
-	      dumpElement ("CLASSDESC NAME=");
-	      String name = this.realInputStream.readUTF ();
-	      dumpElement (name + "; UID=");
-	      long uid = this.realInputStream.readLong ();
-	      dumpElement (Long.toHexString(uid) + "; FLAGS=");
-	      byte flags = this.realInputStream.readByte ();
-	      dumpElement (Integer.toHexString(flags) + "; FIELD COUNT=");
-	      short field_count = this.realInputStream.readShort ();
-	      dumpElementln (Short.toString(field_count));
-	      ObjectStreamField[] fields = new ObjectStreamField[field_count];
-	      ObjectStreamClass osc = new ObjectStreamClass (name, uid,
-							     flags, fields);
-	      assignNewHandle (osc);
-	      
-	      for (int i=0; i < field_count; i++)
-		{
-		  dumpElement ("  TYPE CODE=");
-		  char type_code = (char)this.realInputStream.readByte ();
-		  dumpElement (type_code + "; FIELD NAME=");
-		  String field_name = this.realInputStream.readUTF ();
-		  dumpElementln (field_name);
-		  String class_name;
-		  
-		  if (type_code == 'L' || type_code == '[')
-		    class_name = (String)readObject ();
-		  else
-		    class_name = String.valueOf (type_code);
-		  
-		  // There're many cases you can't get java.lang.Class from typename 
-		  // if your context
-		  // class loader can't load it, then use typename to construct the field
-		  fields[i] =
-		    new ObjectStreamField (field_name, class_name);
-		  //new ObjectStreamField (field_name, TypeSignature.getClassForEncoding(class_name));
-		}
-	      
-	      boolean oldmode = setBlockDataMode (true);
-	      osc.setClass (resolveClass (osc));
-	      setBlockDataMode (oldmode);
-	      
-	      if (!is_consumed)
-		{
-		  byte b = this.realInputStream.readByte ();
-		  if (b != TC_ENDBLOCKDATA)
-		    throw new IOException ("Data annotated to class was not consumed." + b);
-		}
-	      else
-		is_consumed = false;
-	      
-	      osc.setSuperclass ((ObjectStreamClass)readObject ());
-	      ret_val = osc;
-	      break;
-	    }
-	    
-	  case TC_STRING:
-	  case TC_LONGSTRING:
-	    {
-	      dumpElement ("STRING=");
-	      String s = this.realInputStream.readUTF ();
-	      dumpElementln (s);
-	      ret_val = processResolution (s, assignNewHandle (s));
-	      break;
-	    }
-	    
-	  case TC_ARRAY:
-	    {
-	      dumpElementln ("ARRAY");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class componenetType = osc.forClass ().getComponentType ();
-	      dumpElement ("ARRAY LENGTH=");
-	      int length = this.realInputStream.readInt ();
-	      dumpElementln (length + "; COMPONENT TYPE=" + componenetType);
-	      Object array = Array.newInstance (componenetType, length);
-	      int handle = assignNewHandle (array);
-	      readArrayElements (array, componenetType);
-	      for (int i=0, len=Array.getLength(array); i < len; i++)
-		dumpElementln ("  ELEMENT[" + i + "]=" + Array.get(array, i));
-	      ret_val = processResolution (array, handle);
-	      break;
-	    }
-	    
-	  case TC_OBJECT:
-	    {
-	      dumpElementln ("OBJECT");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class clazz = osc.forClass ();
-	      
-	      if (!Serializable.class.isAssignableFrom (clazz))
-		throw new NotSerializableException (clazz + " is not Serializable, and thus cannot be deserialized.");
-	      
-	      if (Externalizable.class.isAssignableFrom (clazz))
-		{
-		  Externalizable obj = null;
-		  
-		  try
-		    {
-		      obj = (Externalizable)clazz.newInstance ();
-		    }
-		  catch (InstantiationException e)
-		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created");
-		    }
-		  catch (IllegalAccessException e)
-		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created because class or zero-argument constructor is not accessible");
-		    }
-		  catch (NoSuchMethodError e)
-		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created because zero-argument constructor is not defined");
-		    }
-		  
-		  int handle = assignNewHandle (obj);
-		  
-		  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);
-		  
-		  boolean oldmode = this.readDataFromBlock;
-		  if (read_from_blocks)
-		    setBlockDataMode (true);
-		  
-		  obj.readExternal (this);
-		  
-		  if (read_from_blocks)
-		    setBlockDataMode (oldmode);
-		  
-		  ret_val = processResolution (obj, handle);
-		  break;
-		} // end if (Externalizable.class.isAssignableFrom (clazz))
-	      
-	      // find the first non-serializable, non-abstract
-	      // class in clazz's inheritance hierarchy
-	      Class first_nonserial = clazz.getSuperclass ();
-	      while (Serializable.class.isAssignableFrom (first_nonserial)
-		     || Modifier.isAbstract (first_nonserial.getModifiers ()))
-		first_nonserial = first_nonserial.getSuperclass ();
-	      
-	      //     DEBUGln ("Using " + first_nonserial
-	      //              + " as starting point for constructing " + clazz);
-	      
-	      Object obj = null;
-	      obj = newObject (clazz, first_nonserial);
-	      
-	      if (obj == null)
-		throw new ClassNotFoundException ("Instance of " + clazz +
-						  " could not be created");
-	      
-	      int handle = assignNewHandle (obj);
-	      this.currentObject = obj;
-	      ObjectStreamClass[] hierarchy =
-		ObjectStreamClass.getObjectStreamClasses (clazz);
-	      
-	      //     DEBUGln ("Got class hierarchy of depth " + hierarchy.length);
-	      
-	      boolean has_read;
-	      for (int i=0; i < hierarchy.length; i++)
-		{
-		  this.currentObjectStreamClass = hierarchy[i];
-		  
-		  dumpElementln ("Reading fields of "
-				 + this.currentObjectStreamClass.getName ());
-		  
-		  has_read = true;
-		  
-		  try
-		    {
-		      this.currentObjectStreamClass.forClass ().
-			getDeclaredMethod ("readObject", readObjectParams);
-		    }
-		  catch (NoSuchMethodException e)
-		    {
-		      has_read = false;
-		    }
-		  
-		  // XXX: should initialize fields in classes in the hierarchy
-		  // that aren't in the stream
-		  // should skip over classes in the stream that aren't in the
-		  // real classes hierarchy
-		  readFields (obj, this.currentObjectStreamClass.fields,
-			      has_read, this.currentObjectStreamClass);
-		  
-		  if (has_read)
-		    {
-		      dumpElement ("ENDBLOCKDATA? ");
-		      try
-			{
-			  // FIXME: XXX: This try block is to catch EOF which is
-			  // thrown for some objects.  That indicates a bug in the logic.
-			  if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)
-			    throw new IOException ("No end of block data seen for class with readObject (ObjectInputStream) method.");
-			  dumpElementln ("yes");
-			}
-		      catch (EOFException e)
-			{
-			  dumpElementln ("no, got EOFException");
-			}
-		      catch (IOException e)
-			{
-			  dumpElementln ("no, got IOException");
-			}
-		    }
-		}
-	      
-	      this.currentObject = null;
-	      this.currentObjectStreamClass = null;
-	      ret_val = processResolution (obj, handle);
-	      break;
-	    }
-	    
-	  case TC_RESET:
-	    dumpElementln ("RESET");
-	    clearHandles ();
-	    ret_val = readObject ();
-	    break;
-	    
-	  case TC_EXCEPTION:
-	    {
-	      dumpElement ("EXCEPTION=");
-	      Exception e = (Exception)readObject ();
-	      dumpElementln (e.toString());
-	      clearHandles ();
-	      //try{
-	      throw new WriteAbortedException ("Exception thrown during writing of stream", e);
-	      //}catch(IOException _){
-	      //    ret_val = null;
-	      //}
-	      //break;
-	    }
-	    
-	  default:
-	    throw new IOException ("Unknown marker on stream: " + marker);
-	  }
+	dumpElement ("STRING=");
+	String s = this.realInputStream.readUTF ();
+	dumpElementln (s);
+	ret_val = processResolution (s, assignNewHandle (s));
+	break;
       }
-    finally
+
+      case TC_ARRAY:
       {
-	setBlockDataMode (old_mode);
-	
-	this.isDeserializing = was_deserializing;
-	
-	if (! was_deserializing)
+	dumpElementln ("ARRAY");
+	ObjectStreamClass osc = (ObjectStreamClass)readObject ();
+	Class componentType = osc.forClass ().getComponentType ();
+	dumpElement ("ARRAY LENGTH=");
+	int length = this.realInputStream.readInt ();
+	dumpElementln (length + "; COMPONENT TYPE=" + componentType);
+	Object array = Array.newInstance (componentType, length);
+	int handle = assignNewHandle (array);
+	readArrayElements (array, componentType);
+	for (int i=0, len=Array.getLength(array); i < len; i++)
+	  dumpElementln ("  ELEMENT[" + i + "]=" + Array.get(array, i));
+	ret_val = processResolution (array, handle);
+	break;
+      }
+
+      case TC_OBJECT:
+      {
+	dumpElementln ("OBJECT");
+	ObjectStreamClass osc = (ObjectStreamClass)readObject ();
+	Class clazz = osc.forClass ();
+
+	if (!Serializable.class.isAssignableFrom (clazz))
+	  throw new NotSerializableException (clazz + " is not Serializable, and thus cannot be deserialized.");
+
+	if (Externalizable.class.isAssignableFrom (clazz))
+	{
+	  Externalizable obj = null;
+
+	  try
 	  {
-	    //setBlockDataMode (true);
-	    
-	    if (validators.size () > 0)
-	      invokeValidators ();
+	    obj = (Externalizable)clazz.newInstance ();
+	  }
+	  catch (InstantiationException e)
+	  {
+	    throw new ClassNotFoundException ("Instance of " + clazz
+					      + " could not be created");
+	  }
+	  catch (IllegalAccessException e)
+	  {
+	    throw new ClassNotFoundException ("Instance of " + clazz
+					      + " could not be created because class or zero-argument constructor is not accessible");
+	  }
+	  catch (NoSuchMethodError e)
+	  {
+	    throw new ClassNotFoundException ("Instance of " + clazz
+					      + " could not be created because zero-argument constructor is not defined");
+	  }
+
+	  int handle = assignNewHandle (obj);
+
+	  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);
+
+	  if (read_from_blocks)
+	    setBlockDataMode (true);
+
+	  obj.readExternal (this);
+
+	  if (read_from_blocks)
+	    setBlockDataMode (false);
+
+	  ret_val = processResolution (obj, handle);
+	  break;
+	} // end if (Externalizable.class.isAssignableFrom (clazz))
+
+	// find the first non-serializable, non-abstract
+	// class in clazz's inheritance hierarchy
+	Class first_nonserial = clazz.getSuperclass ();
+	while (Serializable.class.isAssignableFrom (first_nonserial)
+	       || Modifier.isAbstract (first_nonserial.getModifiers ()))
+	  first_nonserial = first_nonserial.getSuperclass ();
+
+//	DEBUGln ("Using " + first_nonserial
+//		 + " as starting point for constructing " + clazz);
+
+	Object obj = null;
+	obj = newObject (clazz, first_nonserial);
+
+	if (obj == null)
+	  throw new ClassNotFoundException ("Instance of " + clazz +
+					    " could not be created");
+
+	int handle = assignNewHandle (obj);
+	this.currentObject = obj;
+	ObjectStreamClass[] hierarchy =
+	  ObjectStreamClass.getObjectStreamClasses (clazz);
+
+//	DEBUGln ("Got class hierarchy of depth " + hierarchy.length);
+
+	boolean has_read;
+	for (int i=0; i < hierarchy.length; i++)
+	{
+	  this.currentObjectStreamClass = hierarchy[i];
+
+	  dumpElementln ("Reading fields of "
+		   + this.currentObjectStreamClass.getName ());
+
+	  has_read = true;
+
+	  try
+	  {
+	    this.currentObjectStreamClass.forClass ().
+	      getDeclaredMethod ("readObject", readObjectParams);
+	  }
+	  catch (NoSuchMethodException e)
+	  {
+	    has_read = false;
+	  }
+
+	  // XXX: should initialize fields in classes in the hierarchy
+	  // that aren't in the stream
+	  // should skip over classes in the stream that aren't in the
+	  // real classes hierarchy
+	  readFields (obj, this.currentObjectStreamClass.fields,
+		      has_read, this.currentObjectStreamClass);
+
+	  if (has_read)
+	  {
+	    dumpElement ("ENDBLOCKDATA? ");
+	    try
+	      {
+		// FIXME: XXX: This try block is to catch EOF which is
+		// thrown for some objects.  That indicates a bug in the logic.
+	        if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)
+		  throw new IOException ("No end of block data seen for class with readObject (ObjectInputStream) method.");
+	        dumpElementln ("yes");
+	      }
+	    catch (EOFException e)
+	      {
+	        dumpElementln ("no, got EOFException");
+	      }
+	    catch (IOException e)
+	      {
+	        dumpElementln ("no, got IOException");
+	      }
 	  }
+	}
+
+	this.currentObject = null;
+	this.currentObjectStreamClass = null;
+	ret_val = processResolution (obj, handle);
+	break;
       }
-    
+
+      case TC_RESET:
+	dumpElementln ("RESET");
+	clearHandles ();
+	ret_val = readObject ();
+	break;
+
+      case TC_EXCEPTION:
+      {
+	dumpElement ("EXCEPTION=");
+	Exception e = (Exception)readObject ();
+	dumpElementln (e.toString());
+	clearHandles ();
+	throw new WriteAbortedException ("Exception thrown during writing of stream", e);
+      }
+
+      default:
+	throw new IOException ("Unknown marker on stream");
+    }
+
+    this.isDeserializing = was_deserializing;
+
+    if (! was_deserializing)
+    {
+      setBlockDataMode (true);
+
+      if (validators.size () > 0)
+	invokeValidators ();
+    }
+
     return ret_val;
   }
 
@@ -485,11 +438,9 @@
     if (fieldsAlreadyRead)
       throw new NotActiveException ("defaultReadObject called but fields already read from stream (by defaultReadObject or readFields)");
 
-    boolean oldmode = setBlockDataMode(false);
     readFields (this.currentObject,
 		this.currentObjectStreamClass.fields,
 		false, this.currentObjectStreamClass);
-    setBlockDataMode(oldmode);
 
     fieldsAlreadyRead = true;
   }
@@ -547,53 +498,16 @@
   protected Class resolveClass (ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-//    DEBUGln ("Resolving " + osc);
-
     SecurityManager sm = System.getSecurityManager ();
 
-    if (sm == null)
-      sm = new SecurityManager () {};
-
+    // FIXME: currentClassLoader doesn't yet do anything useful. We need
+    // to call forName() with the classloader of the class which called 
+    // readObject(). See SecurityManager.getClassContext().
     ClassLoader cl = currentClassLoader (sm);
 
-    if (cl == null)
-    {
-//      DEBUGln ("No class loader found");
-      return Class.forName (osc.getName ());
-    }
-    else
-    {
-//      DEBUGln ("Using " + cl);
-      return cl.loadClass (osc.getName ());
-    }
+    return Class.forName (osc.getName (), true, cl);
   }
 
-  protected Class resolveProxyClass (String[] intfs)
-    throws IOException, ClassNotFoundException
-  {
-    SecurityManager sm = System.getSecurityManager ();
-    
-    if (sm == null)
-      sm = new SecurityManager () {};
-    
-    ClassLoader cl = currentClassLoader (sm);
-    
-    Class[] clss = new Class[intfs.length];
-    if(cl == null){
-      for (int i = 0; i < intfs.length; i++)
-	clss[i] = Class.forName(intfs[i]);
-      cl = ClassLoader.getSystemClassLoader();
-    }
-    else
-      for (int i = 0; i < intfs.length; i++)
-	clss[i] = cl.loadClass(intfs[i]);
-    try {
-      return Proxy.getProxyClass(cl, clss);
-    } catch (IllegalArgumentException e) {
-      throw new ClassNotFoundException(null, e);
-    }
-  }
-  
   /**
      Allows subclasses to resolve objects that are read from the
      stream with other objects to be returned in their place.  This
@@ -665,32 +579,22 @@
     {
       if (this.blockDataPosition >= this.blockDataBytes)
 	readNextBlock ();
-      return this.blockData[this.blockDataPosition++];
+      return (this.blockData[this.blockDataPosition++] & 0xff);
     }
     else
       return this.realInputStream.read ();
   }
 
-  public int read (byte data[], int offset, int length) throws IOException
+  public int read (byte[] data, int offset, int length) throws IOException
   {
     if (this.readDataFromBlock)
     {
       if (this.blockDataPosition + length > this.blockDataBytes)
-	{
-	  int remain = this.blockDataBytes - this.blockDataPosition;
-	  if (remain != 0)
-	    {
-	      System.arraycopy (this.blockData, this.blockDataPosition, 
-				data, offset, remain);
-	      offset += remain;
-	      length -= remain;
-	    }
-	  readNextBlock ();
-	}
+	readNextBlock ();
 
       System.arraycopy (this.blockData, this.blockDataPosition,
 			data, offset, length);
-      this.blockDataPosition += length;
+      blockDataPosition += length;	
 
       return length;
     }
@@ -718,142 +622,52 @@
 
   public boolean readBoolean () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    boolean value = this.dataInputStream.readBoolean ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readBoolean ();
   }
 
   public byte readByte () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    byte value = this.dataInputStream.readByte ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readByte ();
   }
 
   public int readUnsignedByte () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedByte ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readUnsignedByte ();
   }
 
   public short readShort () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    short value = this.dataInputStream.readShort ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readShort ();
   }
 
   public int readUnsignedShort () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedShort ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readUnsignedShort ();
   }
 
   public char readChar () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    char value = this.dataInputStream.readChar ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readChar ();
   }
 
   public int readInt () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readInt ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readInt ();
   }
 
   public long readLong () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    long value = this.dataInputStream.readLong ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readLong ();
   }
 
   public float readFloat () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    float value = this.dataInputStream.readFloat ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readFloat ();
   }
 
   public double readDouble () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    double value = this.dataInputStream.readDouble ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readDouble ();
   }
 
   public void readFully (byte data[]) throws IOException
@@ -944,11 +758,11 @@
     // Apparently Block data is not used with GetField as per
     // empirical evidence against JDK 1.2.  Also see Mauve test
     // java.io.ObjectInputOutput.Test.GetPutField.
-    boolean oldmode = setBlockDataMode (false);
+    setBlockDataMode (false);
     readFully (prim_field_data);
     for (int i = 0; i < objs.length; ++ i)
       objs[i] = readObject ();
-    setBlockDataMode (oldmode);
+    setBlockDataMode (true);
 
     return new GetField ()
     {
@@ -1149,7 +963,7 @@
      de serialization mechanism provided by
      <code>ObjectInputStream</code>.  To make this method be used for
      writing objects, subclasses must invoke the 0-argument
-     constructor on this class from their constructor.
+     constructor on this class from there constructor.
 
      @see ObjectInputStream ()
   */
@@ -1329,20 +1143,20 @@
 			   ObjectStreamClass stream_osc)
     throws ClassNotFoundException, IOException
   {
-    //  DEBUGln ("In readFields");
+//  DEBUGln ("In readFields");
     if (call_read_method)
-      {
-	//    DEBUGln ("  call_read_method is true");
-	fieldsAlreadyRead = false;
-	boolean oldmode = setBlockDataMode (true);
-	callReadMethod (obj, stream_osc.forClass ());
-	setBlockDataMode (oldmode);
-	return;
-      }
-    
+    {
+//    DEBUGln ("  call_read_method is true");
+      fieldsAlreadyRead = false;
+      setBlockDataMode (true);
+      callReadMethod (obj, stream_osc.forClass ());
+      setBlockDataMode (false);
+      return;
+    }
+
     ObjectStreamField[] real_fields =
       ObjectStreamClass.lookup (stream_osc.forClass ()).fields;
-    
+
     boolean default_initialize, set_value;
     String field_name = null;
     Class type = null;
@@ -1350,159 +1164,152 @@
     ObjectStreamField real_field = null;
     int stream_idx = 0;
     int real_idx = 0;
-    
+
     while (stream_idx < stream_fields.length
 	   && real_idx < real_fields.length)
+    {
+      default_initialize = false;
+      set_value = true;
+
+      if (stream_idx == stream_fields.length)
+	default_initialize = true;
+      else
+      {
+	stream_field = stream_fields[stream_idx];
+	type = stream_field.getType ();
+      }
+
+      if (real_idx == real_fields.length)
+	set_value = false;
+      else
+      {
+	real_field = real_fields[real_idx];
+	type = real_field.getType ();
+	field_name = real_field.getName ();
+      }
+
+      if (set_value && !default_initialize)
       {
-	default_initialize = false;
-	set_value = true;
-	
-	if (stream_idx == stream_fields.length)
+	int comp_val =
+	  real_field.compareTo (stream_field);
+
+	if (comp_val < 0)
+	{
 	  default_initialize = true;
-	else
-	  {
-	    stream_field = stream_fields[stream_idx];
-	    type = stream_field.getType ();
-	  }
-	
-	if (real_idx == real_fields.length)
+	  real_idx++;
+	}
+	else if (comp_val > 0)
+	{
 	  set_value = false;
+	  stream_idx++;
+	}
 	else
-	  {
-	    real_field = real_fields[real_idx];
-	    type = real_field.getType ();
-	    field_name = real_field.getName ();
-	  }
-	
-	if (set_value && !default_initialize)
-	  {
-	    int comp_val =
-	      real_field.compareTo (stream_field);
-	    
-	    if (comp_val < 0)
-	      {
-		default_initialize = true;
-		real_idx++;
-	      }
-	    else if (comp_val > 0)
-	      {
-		set_value = false;
-		stream_idx++;
-	      }
-	    else
-	      {
-		real_idx++;
-		stream_idx++;
-	      }
-	  }
-	
-	try 
-	  {
-	    if (type == Boolean.TYPE)
-	      {
-		boolean value =
-		  default_initialize ? false : this.realInputStream.readBoolean ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setBooleanField (obj, field_name, value);
-	      }
-	    else if (type == Byte.TYPE)
-	      {
-		byte value =
-		  default_initialize ? 0 : this.realInputStream.readByte ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setByteField (obj, field_name, value);
-	      }
-	    else if (type == Character.TYPE)
-	      {
-		char value =
-		  default_initialize ? (char)0 : this.realInputStream.readChar ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setCharField (obj, field_name, value);
-	      }
-	    else if (type == Double.TYPE)
-	      {
-		double value =
-		  default_initialize ? 0 : this.realInputStream.readDouble ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setDoubleField (obj, field_name, value);
-	      }
-	    else if (type == Float.TYPE)
-	      {
-		float value =
-		  default_initialize ? 0 : this.realInputStream.readFloat ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setFloatField (obj, field_name, value);
-	      }
-	    else if (type == Integer.TYPE)
-	      {
-		int value =
-		  default_initialize ? 0 : this.realInputStream.readInt ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setIntField (obj, field_name, value);
-	      }
-	    else if (type == Long.TYPE)
-	      {
-		long value =
-		  default_initialize ? 0 : this.realInputStream.readLong ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setLongField (obj, field_name, value);
-	      }
-	    else if (type == Short.TYPE)
-	      {
-		short value =
-		  default_initialize ? (short)0 : this.realInputStream.readShort ();
-		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
-		if (set_value)
-		  setShortField (obj, field_name, value);
-	      }
-	    else
-	      {
-		Object value =
-		  default_initialize ? null : readObject ();
-		if (set_value)
-		  setObjectField (obj, field_name,
-				  real_field.getTypeString (), value);
-	      }
-	  }
-	catch (NoSuchFieldError e)
-	  {
-	    dumpElementln("XXXX " + field_name + " does not exist.");
-	  }
+	{
+	  real_idx++;
+	  stream_idx++;
+	}
       }
+
+      if (type == Boolean.TYPE)
+      {
+	boolean value =
+	  default_initialize ? false : this.realInputStream.readBoolean ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setBooleanField (obj, field_name, value);
+      }
+      else if (type == Byte.TYPE)
+      {
+	byte value =
+	  default_initialize ? 0 : this.realInputStream.readByte ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setByteField (obj, field_name, value);
+      }
+      else if (type == Character.TYPE)
+      {
+	char value =
+	  default_initialize ? (char)0 : this.realInputStream.readChar ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setCharField (obj, field_name, value);
+      }
+      else if (type == Double.TYPE)
+      {
+	double value =
+	  default_initialize ? 0 : this.realInputStream.readDouble ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setDoubleField (obj, field_name, value);
+      }
+      else if (type == Float.TYPE)
+      {
+	float value =
+	  default_initialize ? 0 : this.realInputStream.readFloat ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setFloatField (obj, field_name, value);
+      }
+      else if (type == Integer.TYPE)
+      {
+	int value =
+	  default_initialize ? 0 : this.realInputStream.readInt ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setIntField (obj, field_name, value);
+      }
+      else if (type == Long.TYPE)
+      {
+	long value =
+	  default_initialize ? 0 : this.realInputStream.readLong ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setLongField (obj, field_name, value);
+      }
+      else if (type == Short.TYPE)
+      {
+	short value =
+	  default_initialize ? (short)0 : this.realInputStream.readShort ();
+	if (!default_initialize && set_value)
+	  dumpElementln ("  " + field_name + ": " + value);
+	if (set_value)
+	  setShortField (obj, field_name, value);
+      }
+      else
+      {
+	Object value =
+	  default_initialize ? null : readObject ();
+	if (set_value)
+	  setObjectField (obj, field_name,
+			  real_field.getTypeString (), value);
+      }
+    }
   }
 
+
   // Toggles writing primitive data to block-data buffer.
-  private boolean setBlockDataMode (boolean on)
+  private void setBlockDataMode (boolean on)
   {
 //    DEBUGln ("Setting block data mode to " + on);
-    boolean oldmode = this.readDataFromBlock;
+
     this.readDataFromBlock = on;
 
     if (on)
       this.dataInputStream = this.blockDataInput;
     else
       this.dataInputStream = this.realInputStream;
-    return oldmode;
   }
 
 
   // returns a new instance of REAL_CLASS that has been constructed
-  // only to th level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)
+  // only to the level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)
   private Object newObject (Class real_class, Class constructor_class)
   {
     try
@@ -1540,34 +1347,191 @@
 
   // this native method is used to get access to the protected method
   // of the same name in SecurityManger
-  private static native ClassLoader currentClassLoader (SecurityManager sm);
+  private static ClassLoader currentClassLoader (SecurityManager sm)
+  {
+    // FIXME: This is too simple.
+    return ClassLoader.getSystemClassLoader ();
+  }
+
+  private static native Field getField (Class klass, String name)
+    throws java.lang.NoSuchFieldException;
 
-  private native void callReadMethod (Object obj, Class clazz);
+  private static native Method getMethod (Class klass, String name, Class args[])
+    throws java.lang.NoSuchMethodException;
 
+  private void callReadMethod (Object obj, Class klass) throws IOException
+  {
+    try
+      {
+	Class classArgs[] = {ObjectInputStream.class};
+	Method m = getMethod (klass, "readObject", classArgs);
+	if (m == null)
+	  return;
+	Object args[] = {this};
+	m.invoke (obj, args);
+      }
+    catch (InvocationTargetException x)
+      {
+        /* Rethrow if possible. */
+	Throwable exception = x.getTargetException();
+	if (exception instanceof RuntimeException)
+	  throw (RuntimeException) exception;
+	if (exception instanceof IOException)
+	  throw (IOException) exception;
+
+	throw new IOException ("Exception thrown from readObject() on " +
+			       klass + ": " + exception.getClass().getName());
+      }
+    catch (Exception x)
+      {
+	throw new IOException ("Failure invoking readObject() on " +
+			       klass + ": " + x.getClass().getName());
+      }
+  }
+    
   private native Object allocateObject (Class clazz)
     throws InstantiationException;
 
   private native void callConstructor (Class clazz, Object obj);
 
-  private native void setBooleanField (Object obj, String field_name,
-				       boolean val);
-  private native void setByteField (Object obj, String field_name,
-				    byte val);
-  private native void setCharField (Object obj, String field_name,
-				    char val);
-  private native void setDoubleField (Object obj, String field_name,
-				      double val);
-  private native void setFloatField (Object obj, String field_name,
-				     float val);
-  private native void setIntField (Object obj, String field_name,
-				   int val);
-  private native void setLongField (Object obj, String field_name,
-				    long val);
-  private native void setShortField (Object obj, String field_name,
-				     short val);
-  private native void setObjectField (Object obj, String field_name,
-					String type_code, Object val);
+  private void setBooleanField (Object obj, String field_name,
+				boolean val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setBoolean (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
 
+  private void setByteField (Object obj, String field_name,
+				byte val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setByte (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setCharField (Object obj, String field_name,
+			     char val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setChar (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setDoubleField (Object obj, String field_name,
+			       double val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setDouble (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setFloatField (Object obj, String field_name,
+			      float val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setFloat (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setIntField (Object obj, String field_name,
+			      int val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setInt (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setLongField (Object obj, String field_name,
+			      long val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setLong (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setShortField (Object obj, String field_name,
+			      short val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	f.setShort (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setObjectField (Object obj, String field_name, String type_code,
+			       Object val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setAccessible(true);
+	// FIXME: We should check the type_code here
+	f.set (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
 
   private static final int BUFFER_SIZE = 1024;
   private static final Class[] readObjectParams = { ObjectInputStream.class };
@@ -1589,42 +1553,18 @@
   private boolean fieldsAlreadyRead;
   private Vector validators;
 
-  private static boolean dump = false;
-
-  public static void setDump (boolean dodump)
-  {
-    dump = dodump;
-  }
+  private static boolean dump;  
 
   private void dumpElement (String msg)
   {
-    if (dump)
-      System.out.print (msg);
+    if (Configuration.DEBUG && dump)  
+      System.out.print(msg);
   }
-
+  
   private void dumpElementln (String msg)
   {
-    if (dump)
-      System.out.println (msg);
-  }
-
-  static
-  {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javaio");
-      }
-  }
-
-  private void DEBUG (String msg)
-  {
-    System.out.print (msg);
-  }
-
-
-  private void DEBUGln (String msg)
-  {
-    System.out.println (msg);
+    if (Configuration.DEBUG && dump)
+      System.out.println(msg);
   }
 }
 
