--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectInputStream.java	2003-12-03 02:20:26.000000000 -0700
+++ java/io/ObjectInputStream.java	2003-12-31 02:18:37.000000000 -0700
@@ -47,6 +47,7 @@
 import java.util.Hashtable;
 import java.util.Vector;
 
+
 import gnu.java.io.ObjectIdentityWrapper;
 import gnu.java.lang.reflect.TypeSignature;
 import java.lang.reflect.Field;
@@ -72,7 +73,7 @@
    *
    * @see #readStreamHeader()
    */
-  public ObjectInputStream (InputStream in)
+  public ObjectInputStream(InputStream in)
     throws IOException, StreamCorruptedException
   {
     if (Configuration.DEBUG)
@@ -95,13 +96,13 @@
     this.blockDataPosition = 0;
     this.blockDataBytes = 0;
     this.blockData = new byte[BUFFER_SIZE];
-    this.blockDataInput = new DataInputStream (this);
-    this.realInputStream = new DataInputStream (in);
+    this.blockDataInput = new DataInputStream(this);
+    this.realInputStream = new DataInputStream(in);
     this.nextOID = baseWireHandle;
     this.objectLookupTable = new Hashtable();
     this.validators = new Vector();
     this.classLookupTable = new Hashtable();
-    setBlockDataMode (true);
+    setBlockDataMode(true);
     readStreamHeader();
   }
 
@@ -121,10 +122,10 @@
    * @exception IOException Exception from underlying
    * <code>InputStream</code>.
    */
-  public final Object readObject () throws ClassNotFoundException, IOException
+  public final Object readObject() throws ClassNotFoundException, IOException
   {
     if (this.useSubclassMethod)
-      return readObjectOverride ();
+      return readObjectOverride();
 
     boolean was_deserializing;
 
@@ -132,12 +133,12 @@
     was_deserializing = this.isDeserializing;
 
     boolean is_consumed = false;
-    boolean old_mode = setBlockDataMode (false);
+    boolean old_mode = setBlockDataMode(false);
 
     this.isDeserializing = true;
 
-    byte marker = this.realInputStream.readByte ();
-    dumpElement ("MARKER: 0x" + Integer.toHexString(marker) + " ");
+    byte marker = this.realInputStream.readByte();
+    dumpElement("MARKER: 0x" + Integer.toHexString(marker) + " ");
 
     try
       {
@@ -154,43 +155,43 @@
 	  case TC_BLOCKDATALONG:
 	    {
 	      if (marker == TC_BLOCKDATALONG)
-		dumpElementln ("BLOCKDATALONG");
+		dumpElementln("BLOCKDATALONG");
 	      else
-		dumpElementln ("BLOCKDATA");
-	      readNextBlock (marker);
-	      throw new StreamCorruptedException ("Unexpected blockData");
+		dumpElementln("BLOCKDATA");
+	      readNextBlock(marker);
+	      throw new StreamCorruptedException("Unexpected blockData");
 	    }
 
 	  case TC_NULL:
 	    {
-	      dumpElementln ("NULL");
+	      dumpElementln("NULL");
 	      ret_val = null;
 	      break;
 	    }
 
 	  case TC_REFERENCE:
 	    {
-	      dumpElement ("REFERENCE ");
-	      Integer oid = new Integer (this.realInputStream.readInt ());
-	      dumpElementln (Integer.toHexString(oid.intValue()));
+	      dumpElement("REFERENCE ");
+	      Integer oid = new Integer(this.realInputStream.readInt());
+	      dumpElementln(Integer.toHexString(oid.intValue()));
 	      ret_val = ((ObjectIdentityWrapper)
-			 this.objectLookupTable.get (oid)).object;
+			 this.objectLookupTable.get(oid)).object;
 	      break;
 	    }
 
 	  case TC_CLASS:
 	    {
-	      dumpElementln ("CLASS");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class clazz = osc.forClass ();
-	      assignNewHandle (clazz);
+	      dumpElementln("CLASS");
+	      ObjectStreamClass osc = (ObjectStreamClass)readObject();
+	      Class clazz = osc.forClass();
+	      assignNewHandle(clazz);
 	      ret_val = clazz;
 	      break;
 	    }
 
 	  case TC_PROXYCLASSDESC:
 	    {
-	      dumpElementln ("PROXYCLASS");
+	      dumpElementln("PROXYCLASS");
 	      int n_intf = this.realInputStream.readInt();
 	      String[] intfs = new String[n_intf];
 	      for (int i = 0; i < n_intf; i++)
@@ -199,41 +200,41 @@
 		  System.out.println(intfs[i]);
 		}
 	      
-	      boolean oldmode = setBlockDataMode (true);
+	      boolean oldmode = setBlockDataMode(true);
 	      Class cl = resolveProxyClass(intfs);
 	      setBlockDataMode(oldmode);
 	      
-	      ObjectStreamClass osc = lookupClass (cl);
-	      assignNewHandle (osc);
+	      ObjectStreamClass osc = lookupClass(cl);
+	      assignNewHandle(osc);
 	      
 	      if (!is_consumed)
 		{
-		  byte b = this.realInputStream.readByte ();
+		  byte b = this.realInputStream.readByte();
 		  if (b != TC_ENDBLOCKDATA)
-		    throw new IOException ("Data annotated to class was not consumed." + b);
+		    throw new IOException("Data annotated to class was not consumed." + b);
 		}
 	      else
 		is_consumed = false;
-	      ObjectStreamClass superosc = (ObjectStreamClass)readObject ();
-	      osc.setSuperclass (superosc);
+	      ObjectStreamClass superosc = (ObjectStreamClass)readObject();
+	      osc.setSuperclass(superosc);
 	      ret_val = osc;
 	      break;
 	    }
 
 	  case TC_CLASSDESC:
 	    {
-	      ObjectStreamClass osc = readClassDescriptor ();
+	      ObjectStreamClass osc = readClassDescriptor();
 	      
 	      if (!is_consumed)
 		{
-		  byte b = this.realInputStream.readByte ();
+		  byte b = this.realInputStream.readByte();
 		  if (b != TC_ENDBLOCKDATA)
-		    throw new IOException ("Data annotated to class was not consumed." + b);
+		    throw new IOException("Data annotated to class was not consumed." + b);
 		}
 	      else
 		is_consumed = false;
 	      
-	      osc.setSuperclass ((ObjectStreamClass)readObject ());
+	      osc.setSuperclass ((ObjectStreamClass)readObject());
 	      ret_val = osc;
 	      break;
 	    }
@@ -241,105 +242,107 @@
 	  case TC_STRING:
 	  case TC_LONGSTRING:
 	    {
-	      dumpElement ("STRING=");
-	      String s = this.realInputStream.readUTF ();
-	      dumpElementln (s);
-	      ret_val = processResolution (s, assignNewHandle (s));
+	      dumpElement("STRING=");
+	      String s = this.realInputStream.readUTF();
+	      dumpElementln(s);
+	      ret_val = processResolution(s, assignNewHandle(s));
 	      break;
 	    }
 
 	  case TC_ARRAY:
 	    {
-	      dumpElementln ("ARRAY");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class componentType = osc.forClass ().getComponentType ();
-	      dumpElement ("ARRAY LENGTH=");
-	      int length = this.realInputStream.readInt ();
+	      dumpElementln("ARRAY");
+	      ObjectStreamClass osc = (ObjectStreamClass)readObject();
+	      Class componentType = osc.forClass().getComponentType();
+	      dumpElement("ARRAY LENGTH=");
+	      int length = this.realInputStream.readInt();
 	      dumpElementln (length + "; COMPONENT TYPE=" + componentType);
-	      Object array = Array.newInstance (componentType, length);
-	      int handle = assignNewHandle (array);
-	      readArrayElements (array, componentType);
-	      for (int i=0, len=Array.getLength(array); i < len; i++)
-		dumpElementln ("  ELEMENT[" + i + "]=" + Array.get(array, i));
-	      ret_val = processResolution (array, handle);
+	      Object array = Array.newInstance(componentType, length);
+	      int handle = assignNewHandle(array);
+	      readArrayElements(array, componentType);
+	      for (int i = 0, len = Array.getLength(array); i < len; i++)
+		dumpElementln("  ELEMENT[" + i + "]=" + Array.get(array, i));
+	      ret_val = processResolution(array, handle);
 	      break;
 	    }
 
 	  case TC_OBJECT:
 	    {
-	      dumpElementln ("OBJECT");
-	      ObjectStreamClass osc = (ObjectStreamClass)readObject ();
-	      Class clazz = osc.forClass ();
+	      dumpElementln("OBJECT");
+	      ObjectStreamClass osc = (ObjectStreamClass)readObject();
+	      Class clazz = osc.forClass();
 	      
-	      if (!Serializable.class.isAssignableFrom (clazz))
-		throw new NotSerializableException (clazz + " is not Serializable, and thus cannot be deserialized.");
+	      if (!Serializable.class.isAssignableFrom(clazz))
+		throw new NotSerializableException
+		  (clazz + " is not Serializable, and thus cannot be deserialized.");
 	      
-	      if (Externalizable.class.isAssignableFrom (clazz))
+	      if (Externalizable.class.isAssignableFrom(clazz))
 		{
 		  Externalizable obj = null;
 		  
 		  try
 		    {
-		      obj = (Externalizable)clazz.newInstance ();
+		      obj = (Externalizable)clazz.newInstance();
 		    }
 		  catch (InstantiationException e)
 		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created");
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created");
 		    }
 		  catch (IllegalAccessException e)
 		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created because class or zero-argument constructor is not accessible");
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created because class or "
+			 + "zero-argument constructor is not accessible");
 		    }
 		  catch (NoSuchMethodError e)
 		    {
-		      throw new ClassNotFoundException ("Instance of " + clazz
-							+ " could not be created because zero-argument constructor is not defined");
+		      throw new ClassNotFoundException
+			("Instance of " + clazz
+			 + " could not be created because zero-argument constructor is not defined");
 		    }
 		  
-		  int handle = assignNewHandle (obj);
+		  int handle = assignNewHandle(obj);
 		  
-		  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);
+		  boolean read_from_blocks = ((osc.getFlags() & SC_BLOCK_DATA) != 0);
 		  
 		  boolean oldmode = this.readDataFromBlock;
 		  if (read_from_blocks)
-		    setBlockDataMode (true);
+		    setBlockDataMode(true);
 		  
-		  obj.readExternal (this);
+		  obj.readExternal(this);
 		  
 		  if (read_from_blocks)
-		    setBlockDataMode (oldmode);
+		    setBlockDataMode(oldmode);
 		  
-		  ret_val = processResolution (obj, handle);
+		  ret_val = processResolution(obj, handle);
 		  break;
 		} // end if (Externalizable.class.isAssignableFrom (clazz))
 	      
 	      // find the first non-serializable, non-abstract
 	      // class in clazz's inheritance hierarchy
-	      Class first_nonserial = clazz.getSuperclass ();
-	      while (Serializable.class.isAssignableFrom (first_nonserial)
-		     || Modifier.isAbstract (first_nonserial.getModifiers ()))
-		first_nonserial = first_nonserial.getSuperclass ();
+	      Class first_nonserial = clazz.getSuperclass();
+	      while (Serializable.class.isAssignableFrom(first_nonserial)
+		     || Modifier.isAbstract(first_nonserial.getModifiers()))
+		first_nonserial = first_nonserial.getSuperclass();
 	      
 	      Object obj = null;
-	      obj = newObject (clazz, first_nonserial);
+	      obj = newObject(clazz, first_nonserial);
 	      
 	      if (obj == null)
-		throw new ClassNotFoundException ("Instance of " + clazz +
-						  " could not be created");
+		throw new ClassNotFoundException
+		  ("Instance of " + clazz + " could not be created");
 	      
-	      int handle = assignNewHandle (obj);
+	      int handle = assignNewHandle(obj);
 	      this.currentObject = obj;
 	      ObjectStreamClass[] hierarchy =
-		inputGetObjectStreamClasses (clazz);
+		inputGetObjectStreamClasses(clazz);
 	      
-	      for (int i=0; i < hierarchy.length; i++)
+	      for (int i = 0; i < hierarchy.length; i++)
 		{
 		  this.currentObjectStreamClass = hierarchy[i];
 		  
-		  dumpElementln ("Reading fields of "
-				 + this.currentObjectStreamClass.getName ());
+		  dumpElementln("Reading fields of " + this.currentObjectStreamClass.getName ());
 
 		  // XXX: should initialize fields in classes in the hierarchy
 		  // that aren't in the stream
@@ -349,118 +352,157 @@
 		  if (this.currentObjectStreamClass.hasReadMethod())
 		    {
 		      fieldsAlreadyRead = false;
-		      boolean oldmode = setBlockDataMode (true);
-		      callReadMethod (obj, this.currentObjectStreamClass);
-		      setBlockDataMode (oldmode);
-		      dumpElement ("ENDBLOCKDATA? ");
+		      boolean oldmode = setBlockDataMode(true);
+		      callReadMethod(obj, this.currentObjectStreamClass);
+		      setBlockDataMode(oldmode);
+		      dumpElement("ENDBLOCKDATA? ");
 		      try
 			{
 			  // FIXME: XXX: This try block is to catch EOF which is
 			  // thrown for some objects.  That indicates a bug in the logic.
-			  if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)
-			    throw new IOException ("No end of block data seen for class with readObject (ObjectInputStream) method.");
-			  dumpElementln ("yes");
+			  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)
+			    throw new IOException
+			      ("No end of block data seen for class with readObject (ObjectInputStream) method.");
+			  dumpElementln("yes");
 			}
 		      catch (EOFException e)
 			{
-			  dumpElementln ("no, got EOFException");
+			  dumpElementln("no, got EOFException");
 			}
 		      catch (IOException e)
 			{
-			  dumpElementln ("no, got IOException");
+			  dumpElementln("no, got IOException");
 			}
 		    }
 		  else
 		    {
-		      readFields (obj, currentObjectStreamClass);
+		      readFields(obj, currentObjectStreamClass);
 		    }
 		}
 
 	      this.currentObject = null;
 	      this.currentObjectStreamClass = null;
-	      ret_val = processResolution (obj, handle);
+	      ret_val = processResolution(obj, handle);
 	      break;
 	    }
 
 	  case TC_RESET:
-	    dumpElementln ("RESET");
-	    clearHandles ();
-	    ret_val = readObject ();
+	    dumpElementln("RESET");
+	    clearHandles();
+	    ret_val = readObject();
 	    break;
 
 	  case TC_EXCEPTION:
 	    {
-	      dumpElement ("EXCEPTION=");
-	      Exception e = (Exception)readObject ();
-	      dumpElementln (e.toString());
-	      clearHandles ();
-	      throw new WriteAbortedException ("Exception thrown during writing of stream", e);
+	      dumpElement("EXCEPTION=");
+	      Exception e = (Exception)readObject();
+	      dumpElementln(e.toString());
+	      clearHandles();
+	      throw new WriteAbortedException("Exception thrown during writing of stream", e);
 	    }
 
 	  default:
-	    throw new IOException ("Unknown marker on stream: " + marker);
+	    throw new IOException("Unknown marker on stream: " + marker);
 	  }
       }
     finally
       {
-	setBlockDataMode (old_mode);
+	setBlockDataMode(old_mode);
 	
 	this.isDeserializing = was_deserializing;
 	
 	if (! was_deserializing)
 	  {
-	    if (validators.size () > 0)
-	      invokeValidators ();
+	    if (validators.size() > 0)
+	      invokeValidators();
 	  }
       }
     
     return ret_val;
   }
 
-  protected ObjectStreamClass readClassDescriptor ()
+  /**
+   * This method reads a class descriptor from the real input stream
+   * and use these data to create a new instance of ObjectStreamClass.
+   * Fields are sorted and ordered for the real read which occurs for
+   * each instance of the described class. Be aware that if you call that
+   * method you must ensure that the stream is synchronized, in the other
+   * case it may be completely desynchronized.
+   *
+   * @return A new instance of ObjectStreamClass containing the freshly
+   * created descriptor.
+   * @throws ClassNotFoundException if the required class to build the
+   * descriptor has not been found in the system.
+   * @throws IOException An input/output error occured.
+   * @throws InvalidClassException If there was a compatibility problem
+   * between the class present in the system and the serialized class.
+   */
+  protected ObjectStreamClass readClassDescriptor()
     throws ClassNotFoundException, IOException
   {
-    dumpElement ("CLASSDESC NAME=");
-    String name = this.realInputStream.readUTF ();
-    dumpElement (name + "; UID=");
+    dumpElement("CLASSDESC NAME=");
+    String name = this.realInputStream.readUTF();
+    dumpElement(name + "; UID=");
     long uid = this.realInputStream.readLong ();
-    dumpElement (Long.toHexString(uid) + "; FLAGS=");
+    dumpElement(Long.toHexString(uid) + "; FLAGS=");
     byte flags = this.realInputStream.readByte ();
-    dumpElement (Integer.toHexString(flags) + "; FIELD COUNT=");
-    short field_count = this.realInputStream.readShort ();
-    dumpElementln (Short.toString(field_count));
+    dumpElement(Integer.toHexString(flags) + "; FIELD COUNT=");
+    short field_count = this.realInputStream.readShort();
+    dumpElementln(Short.toString(field_count));
     ObjectStreamField[] fields = new ObjectStreamField[field_count];
-    ObjectStreamClass osc = new ObjectStreamClass (name, uid,
-                                                   flags, fields);
-    assignNewHandle (osc);
+    ObjectStreamClass osc = new ObjectStreamClass(name, uid,
+						  flags, fields);
+    assignNewHandle(osc);
 	      
-    for (int i=0; i < field_count; i++)
+    for (int i = 0; i < field_count; i++)
       {
-	dumpElement ("  TYPE CODE=");
-	char type_code = (char)this.realInputStream.readByte ();
-	dumpElement (type_code + "; FIELD NAME=");
-	String field_name = this.realInputStream.readUTF ();
-	dumpElementln (field_name);
+	dumpElement("  TYPE CODE=");
+	char type_code = (char)this.realInputStream.readByte();
+	dumpElement(type_code + "; FIELD NAME=");
+	String field_name = this.realInputStream.readUTF();
+	dumpElementln(field_name);
 	String class_name;
 		  
+	// If the type code is an array or an object we must
+	// decode a String here. In the other case we convert
+	// the type code and pass it to ObjectStreamField.
+	// Type codes are decoded by gnu.java.lang.reflect.TypeSignature.
 	if (type_code == 'L' || type_code == '[')
-	  class_name = (String)readObject ();
+	  class_name = (String)readObject();
 	else
-	  class_name = String.valueOf (type_code);
+	  class_name = String.valueOf(type_code);
 		  
-	// There're many cases you can't get java.lang.Class from
-	// typename if your context class loader can't load it,
-	// then use typename to construct the field
 	fields[i] =
-	  new ObjectStreamField (field_name, class_name);
+	  new ObjectStreamField(field_name, class_name, currentLoader());
       }
 	      
-    Class clazz = resolveClass (osc);
-    boolean oldmode = setBlockDataMode (true);
-    osc.setClass (clazz, lookupClass (clazz.getSuperclass()));
-    classLookupTable.put (clazz, osc);
-    setBlockDataMode (oldmode);
-	      
+    /* Now that fields have been read we may resolve the class
+     * (and read annotation if needed). */
+    Class clazz = resolveClass(osc);
+    
+    for (int i = 0; i < field_count; i++)
+      {
+	Field f;
+	
+	try
+	  {
+	    f = clazz.getDeclaredField(fields[i].getName());
+	    if (f != null && !f.getType().equals(fields[i].getType()))
+	      throw new InvalidClassException
+		("invalid field type for " + fields[i].getName() + " in class "
+		 + name + " (requested was \"" + fields[i].getType()
+		 + " and found \"" + f.getType() + "\")"); 
+	  }
+	catch (NoSuchFieldException _)
+	  {
+	  }
+      }
+
+    boolean oldmode = setBlockDataMode(true);
+    osc.setClass(clazz, lookupClass(clazz.getSuperclass()));
+    classLookupTable.put(clazz, osc);
+    setBlockDataMode(oldmode);
+
     return osc;
   }
 
@@ -483,17 +525,20 @@
    * @exception IOException Exception from underlying
    * <code>OutputStream</code>.
    */
-  public void defaultReadObject ()
+  public void defaultReadObject()
     throws ClassNotFoundException, IOException, NotActiveException
   {
     if (this.currentObject == null || this.currentObjectStreamClass == null)
-      throw new NotActiveException ("defaultReadObject called by non-active class and/or object");
+      throw new NotActiveException("defaultReadObject called by non-active"
+				   + " class and/or object");
 
     if (fieldsAlreadyRead)
-      throw new NotActiveException ("defaultReadObject called but fields already read from stream (by defaultReadObject or readFields)");
+      throw new NotActiveException("defaultReadObject called but fields "
+				   + "already read from stream (by "
+				   + "defaultReadObject or readFields)");
 
     boolean oldmode = setBlockDataMode(false);
-    readFields (this.currentObject, this.currentObjectStreamClass);
+    readFields(this.currentObject, this.currentObjectStreamClass);
     setBlockDataMode(oldmode);
 
     fieldsAlreadyRead = true;
@@ -518,18 +563,20 @@
    * validator outside of the <code>readObject</code> method of the
    * object currently being deserialized
    */
-  public void registerValidation (ObjectInputValidation validator,
-				  int priority)
+  public void registerValidation(ObjectInputValidation validator,
+				 int priority)
     throws InvalidObjectException, NotActiveException
   {
     if (this.currentObject == null || this.currentObjectStreamClass == null)
-      throw new NotActiveException ("registerValidation called by non-active class and/or object");
+      throw new NotActiveException("registerValidation called by non-active "
+				   + "class and/or object");
 
     if (validator == null)
-      throw new InvalidObjectException ("attempt to add a null ObjectInputValidation object");
+      throw new InvalidObjectException("attempt to add a null "
+				       + "ObjectInputValidation object");
 
-    this.validators.addElement (new ValidatorAndPriority (validator,
-							  priority));
+    this.validators.addElement(new ValidatorAndPriority (validator,
+							 priority));
   }
 
 
@@ -549,19 +596,27 @@
    *
    * @see java.io.ObjectOutputStream#annotateClass (java.lang.Class)
    */
-  protected Class resolveClass (ObjectStreamClass osc)
+  protected Class resolveClass(ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-    return Class.forName (osc.getName(), true, currentLoader()); 
+    return Class.forName(osc.getName(), true, currentLoader());
   }
-  
-  private ClassLoader currentLoader ()
+
+  /**
+   * This method invokes the method currentClassLoader for the
+   * current security manager (or build an empty one if it is not
+   * present).
+   *
+   * @return The most recent non-system ClassLoader on the execution stack.
+   * @see java.lang.SecurityManager#currentClassLoader()
+   */
+  private ClassLoader currentLoader()
   {
-    SecurityManager sm = System.getSecurityManager ();
+    SecurityManager sm = System.getSecurityManager();
     if (sm == null)
       sm = new SecurityManager () {};
- 
-    return currentClassLoader (sm);
+    
+    return currentClassLoader(sm);
   }
 
   /**
@@ -571,17 +626,17 @@
    * the behaviour detected in the JDK by Kaffe's team.
    *
    * @param clazz Class to lookup in the hash table or for which
-   * we must build a descriptor. 
+   * we must build a descriptor.
    * @return A valid instance of ObjectStreamClass corresponding
    * to the specified class.
    */
-  private ObjectStreamClass lookupClass (Class clazz)
+  private ObjectStreamClass lookupClass(Class clazz)
   {
     ObjectStreamClass oclazz;
-    
-    oclazz = (ObjectStreamClass) classLookupTable.get(clazz);
+
+    oclazz = (ObjectStreamClass)classLookupTable.get(clazz);
     if (oclazz == null)
-      return ObjectStreamClass.lookup (clazz);
+      return ObjectStreamClass.lookup(clazz);
     else
       return oclazz;
   }
@@ -590,40 +645,40 @@
    * Reconstruct class hierarchy the same way
    * {@link java.io.ObjectStreamClass.getObjectStreamClasses(java.lang.Class)} does
    * but using lookupClass instead of ObjectStreamClass.lookup. This
-   * dup is necessary localize the lookup table. Hopefully some future rewritings will
-   * be able to prevent this.
+   * dup is necessary localize the lookup table. Hopefully some future
+   * rewritings will be able to prevent this.
    *
    * @param clazz This is the class for which we want the hierarchy.
    *
    * @return An array of valid {@link java.io.ObjectStreamClass} instances which
    * represent the class hierarchy for clazz.
    */
-  private ObjectStreamClass[] inputGetObjectStreamClasses (Class clazz)
+  private ObjectStreamClass[] inputGetObjectStreamClasses(Class clazz)
   {
-    ObjectStreamClass osc = lookupClass (clazz);
+    ObjectStreamClass osc = lookupClass(clazz);
 
     ObjectStreamClass[] ret_val;
 
     if (osc == null)
       return new ObjectStreamClass[0];
     else
-    {
-      Vector oscs = new Vector ();
-
-      while (osc != null)
       {
-	oscs.addElement (osc);
-	osc = osc.getSuper ();
-      }
+        Vector oscs = new Vector();
 
-      int count = oscs.size ();
-      ObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];
+        while (osc != null)
+          {
+            oscs.addElement(osc);
+            osc = osc.getSuper();
+	  }
+
+        int count = oscs.size();
+	ObjectStreamClass[] sorted_oscs = new ObjectStreamClass[count];
 
-      for (int i = count - 1; i >= 0; i--)
-	sorted_oscs[ count - i - 1 ] = (ObjectStreamClass)oscs.elementAt (i);
+        for (int i = count - 1; i >= 0; i--)
+          sorted_oscs[count - i - 1] = (ObjectStreamClass) oscs.elementAt(i);
 
-      return sorted_oscs;
-    }
+        return sorted_oscs;
+      }
   }
 
   /**
@@ -639,36 +694,40 @@
    *
    * @see #enableResolveObject(boolean)
    */
-  protected Object resolveObject (Object obj) throws IOException
+  protected Object resolveObject(Object obj) throws IOException
   {
     return obj;
   }
 
 
-  protected Class resolveProxyClass (String[] intfs)
+  protected Class resolveProxyClass(String[] intfs)
     throws IOException, ClassNotFoundException
   {
-    SecurityManager sm = System.getSecurityManager ();
+    SecurityManager sm = System.getSecurityManager();
     
     if (sm == null)
-      sm = new SecurityManager () {};
+      sm = new SecurityManager() {};
     
-    ClassLoader cl = currentClassLoader (sm);
+    ClassLoader cl = currentClassLoader(sm);
     
     Class[] clss = new Class[intfs.length];
-    if(cl == null){
-      for (int i = 0; i < intfs.length; i++)
-	clss[i] = Class.forName(intfs[i]);
-      cl = ClassLoader.getSystemClassLoader();
-    }
+    if(cl == null)
+      {
+	for (int i = 0; i < intfs.length; i++)
+	  clss[i] = Class.forName(intfs[i]);
+	cl = ClassLoader.getSystemClassLoader();
+      }
     else
       for (int i = 0; i < intfs.length; i++)
 	clss[i] = cl.loadClass(intfs[i]);
-    try {
-      return Proxy.getProxyClass(cl, clss);
-    } catch (IllegalArgumentException e) {
-      throw new ClassNotFoundException(null, e);
-    }
+    try 
+      {
+	return Proxy.getProxyClass(cl, clss);
+      } 
+    catch (IllegalArgumentException e) 
+      {
+	throw new ClassNotFoundException(null, e);
+      }
   }
   
   /**
@@ -684,9 +743,9 @@
   {
     if (enable)
       {
-	SecurityManager sm = System.getSecurityManager ();
+	SecurityManager sm = System.getSecurityManager();
 	if (sm != null)
-	  sm.checkPermission (new SerializablePermission ("enableSubstitution"));
+	  sm.checkPermission(new SerializablePermission("enableSubstitution"));
       }
 
     boolean old_val = this.resolveEnabled;
@@ -703,31 +762,31 @@
    * @exception StreamCorruptedException An invalid stream magic
    * number or stream version was read from the stream.
    */
-  protected void readStreamHeader ()
+  protected void readStreamHeader()
     throws IOException, StreamCorruptedException
   {
-    dumpElement ("STREAM MAGIC ");
-    if (this.realInputStream.readShort () != STREAM_MAGIC)
-      throw new StreamCorruptedException ("Invalid stream magic number");
+    dumpElement("STREAM MAGIC ");
+    if (this.realInputStream.readShort() != STREAM_MAGIC)
+      throw new StreamCorruptedException("Invalid stream magic number");
 
-    dumpElementln ("STREAM VERSION ");
-    if (this.realInputStream.readShort () != STREAM_VERSION)
-      throw new StreamCorruptedException ("Invalid stream version number");
+    dumpElementln("STREAM VERSION ");
+    if (this.realInputStream.readShort() != STREAM_VERSION)
+      throw new StreamCorruptedException("Invalid stream version number");
   }
 
-  public int read () throws IOException
+  public int read() throws IOException
   {
     if (this.readDataFromBlock)
       {
 	if (this.blockDataPosition >= this.blockDataBytes)
-	  readNextBlock ();
+	  readNextBlock();
 	return (this.blockData[this.blockDataPosition++] & 0xff);
       }
     else
-      return this.realInputStream.read ();
+      return this.realInputStream.read();
   }
 
-  public int read (byte[] data, int offset, int length) throws IOException
+  public int read(byte[] data, int offset, int length) throws IOException
   {
     if (this.readDataFromBlock)
       {
@@ -736,25 +795,25 @@
 	    int remain = this.blockDataBytes - this.blockDataPosition;
 	    if (remain != 0)
 	      {
-		System.arraycopy (this.blockData, this.blockDataPosition,
-				  data, offset, remain);
+		System.arraycopy(this.blockData, this.blockDataPosition,
+				 data, offset, remain);
 		offset += remain;
 		length -= remain;
 	      }
 	    readNextBlock ();
 	  }
 
-	System.arraycopy (this.blockData, this.blockDataPosition,
-			  data, offset, length);
+	System.arraycopy(this.blockData, this.blockDataPosition,
+			 data, offset, length);
 	this.blockDataPosition += length;
 
 	return length;
       }
     else
-      return this.realInputStream.read (data, offset, length);
+      return this.realInputStream.read(data, offset, length);
   }
 
-  public int available () throws IOException
+  public int available() throws IOException
   {
     if (this.readDataFromBlock)
       {
@@ -764,15 +823,15 @@
 	return this.blockDataBytes - this.blockDataPosition;
       }
     else
-      return this.realInputStream.available ();
+      return this.realInputStream.available();
   }
 
-  public void close () throws IOException
+  public void close() throws IOException
   {
-    this.realInputStream.close ();
+    this.realInputStream.close();
   }
 
-  public boolean readBoolean () throws IOException
+  public boolean readBoolean() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
@@ -786,160 +845,160 @@
     return value;
   }
 
-  public byte readByte () throws IOException
+  public byte readByte() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    byte value = this.dataInputStream.readByte ();
+      oldmode = setBlockDataMode(true);
+    byte value = this.dataInputStream.readByte();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public int readUnsignedByte () throws IOException
+  public int readUnsignedByte() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedByte ();
+      oldmode = setBlockDataMode(true);
+    int value = this.dataInputStream.readUnsignedByte();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public short readShort () throws IOException
+  public short readShort() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    short value = this.dataInputStream.readShort ();
+      oldmode = setBlockDataMode(true);
+    short value = this.dataInputStream.readShort();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public int readUnsignedShort () throws IOException
+  public int readUnsignedShort() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedShort ();
+      oldmode = setBlockDataMode(true);
+    int value = this.dataInputStream.readUnsignedShort();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public char readChar () throws IOException
+  public char readChar() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    char value = this.dataInputStream.readChar ();
+      oldmode = setBlockDataMode(true);
+    char value = this.dataInputStream.readChar();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public int readInt () throws IOException
+  public int readInt() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readInt ();
+      oldmode = setBlockDataMode(true);
+    int value = this.dataInputStream.readInt();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public long readLong () throws IOException
+  public long readLong() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    long value = this.dataInputStream.readLong ();
+      oldmode = setBlockDataMode(true);
+    long value = this.dataInputStream.readLong();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public float readFloat () throws IOException
+  public float readFloat() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    float value = this.dataInputStream.readFloat ();
+      oldmode = setBlockDataMode(true);
+    float value = this.dataInputStream.readFloat();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public double readDouble () throws IOException
+  public double readDouble() throws IOException
   {
     boolean switchmode = true;
     boolean oldmode = this.readDataFromBlock;
     if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
       switchmode = false;
     if (switchmode)
-      oldmode = setBlockDataMode (true);
-    double value = this.dataInputStream.readDouble ();
+      oldmode = setBlockDataMode(true);
+    double value = this.dataInputStream.readDouble();
     if (switchmode)
-      setBlockDataMode (oldmode);
+      setBlockDataMode(oldmode);
     return value;
   }
 
-  public void readFully (byte data[]) throws IOException
+  public void readFully(byte data[]) throws IOException
   {
-    this.dataInputStream.readFully (data);
+    this.dataInputStream.readFully(data);
   }
 
-  public void readFully (byte data[], int offset, int size)
+  public void readFully(byte data[], int offset, int size)
     throws IOException
   {
-    this.dataInputStream.readFully (data, offset, size);
+    this.dataInputStream.readFully(data, offset, size);
   }
 
-  public int skipBytes (int len) throws IOException
+  public int skipBytes(int len) throws IOException
   {
-    return this.dataInputStream.skipBytes (len);
+    return this.dataInputStream.skipBytes(len);
   }
 
   /**
    * @deprecated
    * @see java.io.DataInputStream#readLine ()
    */
-  public String readLine () throws IOException
+  public String readLine() throws IOException
   {
-    return this.dataInputStream.readLine ();
+    return this.dataInputStream.readLine();
   }
 
-  public String readUTF () throws IOException
+  public String readUTF() throws IOException
   {
-    return this.dataInputStream.readUTF ();
+    return this.dataInputStream.readUTF();
   }
 
   /**
@@ -950,47 +1009,64 @@
    */
   public static abstract class GetField
   {
-    public abstract ObjectStreamClass getObjectStreamClass ();
+    public abstract ObjectStreamClass getObjectStreamClass();
 
-    public abstract boolean defaulted (String name)
+    public abstract boolean defaulted(String name)
       throws IOException, IllegalArgumentException;
 
-    public abstract boolean get (String name, boolean defvalue)
+    public abstract boolean get(String name, boolean defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract char get (String name, char defvalue)
+    public abstract char get(String name, char defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract byte get (String name, byte defvalue)
+    public abstract byte get(String name, byte defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract short get (String name, short defvalue)
+    public abstract short get(String name, short defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract int get (String name, int defvalue)
+    public abstract int get(String name, int defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract long get (String name, long defvalue)
+    public abstract long get(String name, long defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract float get (String name, float defvalue)
+    public abstract float get(String name, float defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract double get (String name, double defvalue)
+    public abstract double get(String name, double defvalue)
       throws IOException, IllegalArgumentException;
 
-    public abstract Object get (String name, Object defvalue)
+    public abstract Object get(String name, Object defvalue)
       throws IOException, IllegalArgumentException;
   }
 
-  public GetField readFields ()
+  /**
+   * This method should be called by a method called 'readObject' in the
+   * deserializing class (if present). It cannot (and should not)be called
+   * outside of it. Its goal is to read all fields in the real input stream
+   * and keep them accessible through the {@link #GetField} class. Calling
+   * this method will not alterate the deserializing object.
+   *
+   * @return A valid freshly created 'GetField' instance to get access to
+   * the deserialized stream.
+   * @throws IOException An input/output exception occured. 
+   * @throws ClassNotFoundException 
+   * @throws NotActiveException
+   */
+  public GetField readFields()
     throws IOException, ClassNotFoundException, NotActiveException
   {
     if (this.currentObject == null || this.currentObjectStreamClass == null)
-      throw new NotActiveException ("readFields called by non-active class and/or object");
+      throw new NotActiveException("readFields called by non-active class and/or object");
+
+    if (prereadFields != null)
+      return prereadFields;
 
     if (fieldsAlreadyRead)
-      throw new NotActiveException ("readFields called but fields already read from stream (by defaultReadObject or readFields)");
+      throw new NotActiveException("readFields called but fields already read from"
+				   + " stream (by defaultReadObject or readFields)");
 
     final ObjectStreamClass clazz = this.currentObjectStreamClass;
     final byte[] prim_field_data = new byte[clazz.primFieldSize];
@@ -999,84 +1075,108 @@
     // Apparently Block data is not used with GetField as per
     // empirical evidence against JDK 1.2.  Also see Mauve test
     // java.io.ObjectInputOutput.Test.GetPutField.
-    boolean oldmode = setBlockDataMode (false);
-    readFully (prim_field_data);
+    boolean oldmode = setBlockDataMode(false);
+    readFully(prim_field_data);
     for (int i = 0; i < objs.length; ++ i)
-      objs[i] = readObject ();
-    setBlockDataMode (oldmode);
+      objs[i] = readObject();
+    setBlockDataMode(oldmode);
 
-    return new GetField ()
+    prereadFields = new GetField()
       {
-	public ObjectStreamClass getObjectStreamClass ()
+	public ObjectStreamClass getObjectStreamClass()
 	{
 	  return clazz;
 	}
 
-	public boolean defaulted (String name)
+	public boolean defaulted(String name)
 	  throws IOException, IllegalArgumentException
 	{
-	  return clazz.getField (name) == null;
+	  ObjectStreamField f = clazz.getField(name);
+	  
+	  /* First if we have a serialized field use the descriptor */
+	  if (f != null)
+	    {
+	      /* It is in serialPersistentFields but setClass tells us
+	       * it should not be set. This value is defaulted.
+	       */
+	      if (f.isPersistent() && !f.isToSet())
+		return true;
+	      
+	      return false;
+	    }
+
+	  /* This is not a serialized field. There should be
+	   * a default value only if the field really exists.
+	   */
+	  try
+	    {
+	      return (clazz.forClass().getDeclaredField (name) != null);
+	    }
+	  catch (NoSuchFieldException e)
+	    {
+	      throw new IllegalArgumentException(e.getMessage());
+	    }
 	}
 
-	public boolean get (String name, boolean defvalue)
+	public boolean get(String name, boolean defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Boolean.TYPE);
+	  ObjectStreamField field = getField(name, Boolean.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  return prim_field_data[field.getOffset ()] == 0 ? false : true;
+	  return prim_field_data[field.getOffset()] == 0 ? false : true;
 	}
 
-	public char get (String name, char defvalue)
+	public char get(String name, char defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Character.TYPE);
+	  ObjectStreamField field = getField(name, Character.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
 	  return (char)(((prim_field_data[off++] & 0xFF) << 8)
 			| (prim_field_data[off] & 0xFF));
 	}
 
-	public byte get (String name, byte defvalue)
+	public byte get(String name, byte defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Byte.TYPE);
+	  ObjectStreamField field = getField(name, Byte.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  return prim_field_data[field.getOffset ()];
+	  return prim_field_data[field.getOffset()];
 	}
 
-	public short get (String name, short defvalue)
+	public short get(String name, short defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Short.TYPE);
+	  ObjectStreamField field = getField(name, Short.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
 	  return (short)(((prim_field_data[off++] & 0xFF) << 8)
 			 | (prim_field_data[off] & 0xFF));
 	}
 
-	public int get (String name, int defvalue)
+	public int get(String name, int defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Integer.TYPE);
+	  ObjectStreamField field = getField(name, Integer.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
 	  return ((prim_field_data[off++] & 0xFF) << 24)
 	    | ((prim_field_data[off++] & 0xFF) << 16)
@@ -1084,15 +1184,15 @@
 	    | (prim_field_data[off] & 0xFF);
 	}
 
-	public long get (String name, long defvalue)
+	public long get(String name, long defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Long.TYPE);
+	  ObjectStreamField field = getField(name, Long.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
 	  return (long)(((prim_field_data[off++] & 0xFF) << 56)
 			| ((prim_field_data[off++] & 0xFF) << 48)
@@ -1104,31 +1204,31 @@
 			| (prim_field_data[off] & 0xFF));
 	}
 
-	public float get (String name, float defvalue)
+	public float get(String name, float defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Float.TYPE);
+	  ObjectStreamField field = getField(name, Float.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
-	  return Float.intBitsToFloat (((prim_field_data[off++] & 0xFF) << 24)
-				       | ((prim_field_data[off++] & 0xFF) << 16)
-				       | ((prim_field_data[off++] & 0xFF) << 8)
-				       | (prim_field_data[off] & 0xFF));
+	  return Float.intBitsToFloat(((prim_field_data[off++] & 0xFF) << 24)
+				      | ((prim_field_data[off++] & 0xFF) << 16)
+				      | ((prim_field_data[off++] & 0xFF) << 8)
+				      | (prim_field_data[off] & 0xFF));
 	}
 
-	public double get (String name, double defvalue)
+	public double get(String name, double defvalue)
 	  throws IOException, IllegalArgumentException
 	{
-	  ObjectStreamField field = getField (name, Double.TYPE);
+	  ObjectStreamField field = getField(name, Double.TYPE);
 
 	  if (field == null)
 	    return defvalue;
 
-	  int off = field.getOffset ();
+	  int off = field.getOffset();
 
 	  return Double.longBitsToDouble
 	    ( (long) (((prim_field_data[off++] & 0xFF) << 56)
@@ -1141,40 +1241,92 @@
 		      | (prim_field_data[off] & 0xFF)));
 	}
 
-	public Object get (String name, Object defvalue)
+	public Object get(String name, Object defvalue)
 	  throws IOException, IllegalArgumentException
 	{
 	  ObjectStreamField field =
-	    getField (name, defvalue == null ? null : defvalue.getClass ());
+	    getField(name, defvalue == null ? null : defvalue.getClass ());
 
 	  if (field == null)
 	    return defvalue;
 
-	  return objs[field.getOffset ()];
+	  return objs[field.getOffset()];
 	}
 
-	private ObjectStreamField getField (String name, Class type)
+	private ObjectStreamField getField(String name, Class type)
 	  throws IllegalArgumentException
 	{
-	  ObjectStreamField field = clazz.getField (name);
+	  ObjectStreamField field = clazz.getField(name);
+	  boolean illegal = false;
 
-	  if (field == null)
-	    return null;
-
-	  Class field_type = field.getType ();
-
-	  if (type == field_type ||
-	      (type == null && ! field_type.isPrimitive ()))
-	    return field;
-
-	  throw new IllegalArgumentException ("Field requested is of type "
-					      + field_type.getName ()
-					      + ", but requested type was "
-					      + (type == null ?
-						 "Object" : type.getName ()));
+	  try
+	    {
+	      try
+		{
+		  Class field_type = field.getType();
+		  
+		  if (type == field_type ||
+		      (type == null && !field_type.isPrimitive()))
+		    {
+		      /* See defaulted */
+		      return field;
+		    }
+	 
+		  illegal = true;
+		  throw new IllegalArgumentException
+		    ("Field requested is of type "
+		     + field_type.getName()
+		     + ", but requested type was "
+		     + (type == null ?  "Object" : type.getName()));
+		}
+	      catch (NullPointerException _)
+		{
+		  /* Here we catch NullPointerException, because it may
+		     only come from the call 'field.getType()'. If field
+		     is null, we have to return null and classpath ethic
+		     say we must try to avoid 'if (xxx == null)'.
+		  */
+		}
+	      catch (IllegalArgumentException e)
+		{
+		  throw e;
+		}
+	      
+	      return null;
+	    }
+	  finally
+	    {
+	      /* If this is an unassigned field we should return
+	       * the default value.
+	       */
+	      if (!illegal && field != null && !field.isToSet() && field.isPersistent())
+		return null;
+
+	      /* We do not want to modify transient fields. They should
+	       * be left to 0.
+	       */
+	      try
+		{
+		  Field f = clazz.forClass().getDeclaredField(name);
+		  if (Modifier.isTransient(f.getModifiers()))
+		    throw new IllegalArgumentException
+		      ("no such field (non transient) " + name);
+		  if (field == null && f.getType() != type)
+		    throw new IllegalArgumentException
+		      ("Invalid requested type for field " + name);
+		}
+	      catch (NoSuchFieldException e)
+		{
+		  if (field == null)
+		    throw new IllegalArgumentException(e.getMessage());
+		}
+	       
+	    }
 	}
       };
 
+    fieldsAlreadyRead = true;
+    return prereadFields;
   }
 
   /**
@@ -1188,12 +1340,12 @@
    *
    * @see #readObjectOverride()
    */
-  protected ObjectInputStream ()
+  protected ObjectInputStream()
     throws IOException, SecurityException
   {
-    SecurityManager sec_man = System.getSecurityManager ();
+    SecurityManager sec_man = System.getSecurityManager();
     if (sec_man != null)
-      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);
+      sec_man.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
     this.useSubclassMethod = true;
   }
 
@@ -1206,10 +1358,10 @@
    *
    * @see #ObjectInputStream()
    */
-  protected Object readObjectOverride ()
+  protected Object readObjectOverride()
     throws ClassNotFoundException, IOException, OptionalDataException
   {
-    throw new IOException ("Subclass of ObjectInputStream must implement readObjectOverride");
+    throw new IOException("Subclass of ObjectInputStream must implement readObjectOverride");
   }
 
   /**
@@ -1218,14 +1370,14 @@
    * @param obj The object for which we want a new handle.
    * @return A valid handle for the specified object.
    */
-  private int assignNewHandle (Object obj)
+  private int assignNewHandle(Object obj)
   {
-    this.objectLookupTable.put (new Integer (this.nextOID),
-				new ObjectIdentityWrapper (obj));
+    this.objectLookupTable.put(new Integer(this.nextOID),
+			       new ObjectIdentityWrapper(obj));
     return this.nextOID++;
   }
 
-  private Object processResolution (Object obj, int handle)
+  private Object processResolution(Object obj, int handle)
     throws IOException
   {
     if (obj instanceof Serializable)
@@ -1235,7 +1387,7 @@
 	  {
 	    Class classArgs[] = {};
 	    m = getMethod(obj.getClass(), "readResolve", classArgs);
-	    obj = m.invoke (obj, new Object[] {});	
+	    obj = m.invoke(obj, new Object[] {});	
 	  }
 	catch (NoSuchMethodException ignore)
 	  {
@@ -1249,42 +1401,42 @@
       }
 
     if (this.resolveEnabled)
-      obj = resolveObject (obj);
+      obj = resolveObject(obj);
 
-    this.objectLookupTable.put (new Integer (handle),
-				new ObjectIdentityWrapper (obj));
+    this.objectLookupTable.put(new Integer(handle),
+			       new ObjectIdentityWrapper(obj));
 
     return obj;
   }
 
-  private void clearHandles ()
+  private void clearHandles()
   {
-    this.objectLookupTable.clear ();
+    this.objectLookupTable.clear();
     this.nextOID = baseWireHandle;
   }
 
-  private void readNextBlock () throws IOException
+  private void readNextBlock() throws IOException
   {
-    readNextBlock (this.realInputStream.readByte ());
+    readNextBlock(this.realInputStream.readByte());
   }
 
-  private void readNextBlock (byte marker) throws IOException
+  private void readNextBlock(byte marker) throws IOException
   {
     if (marker == TC_BLOCKDATA)
       {
-	dumpElement ("BLOCK DATA SIZE=");
-	this.blockDataBytes = this.realInputStream.readUnsignedByte ();
+	dumpElement("BLOCK DATA SIZE=");
+	this.blockDataBytes = this.realInputStream.readUnsignedByte();
 	dumpElementln (Integer.toString(this.blockDataBytes));
       }
     else if (marker == TC_BLOCKDATALONG)
       {
-	dumpElement ("BLOCK DATA LONG SIZE=");
-	this.blockDataBytes = this.realInputStream.readInt ();
+	dumpElement("BLOCK DATA LONG SIZE=");
+	this.blockDataBytes = this.realInputStream.readInt();
 	dumpElementln (Integer.toString(this.blockDataBytes));
       }
     else
       {
-	throw new EOFException ("Attempt to read primitive data, but no data block is active.");
+	throw new EOFException("Attempt to read primitive data, but no data block is active.");
       }
 
     if (this.blockData.length < this.blockDataBytes)
@@ -1297,62 +1449,62 @@
   private void readArrayElements (Object array, Class clazz)
     throws ClassNotFoundException, IOException
   {
-    if (clazz.isPrimitive ())
+    if (clazz.isPrimitive())
       {
 	if (clazz == Boolean.TYPE)
 	  {
 	    boolean[] cast_array = (boolean[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readBoolean ();
+	      cast_array[i] = this.realInputStream.readBoolean();
 	    return;
 	  }
 	if (clazz == Byte.TYPE)
 	  {
 	    byte[] cast_array = (byte[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readByte ();
+	      cast_array[i] = this.realInputStream.readByte();
 	    return;
 	  }
 	if (clazz == Character.TYPE)
 	  {
 	    char[] cast_array = (char[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readChar ();
+	      cast_array[i] = this.realInputStream.readChar();
 	    return;
 	  }
 	if (clazz == Double.TYPE)
 	  {
 	    double[] cast_array = (double[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readDouble ();
+	      cast_array[i] = this.realInputStream.readDouble();
 	    return;
 	  }
 	if (clazz == Float.TYPE)
 	  {
 	    float[] cast_array = (float[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readFloat ();
+	      cast_array[i] = this.realInputStream.readFloat();
 	    return;
 	  }
 	if (clazz == Integer.TYPE)
 	  {
 	    int[] cast_array = (int[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readInt ();
+	      cast_array[i] = this.realInputStream.readInt();
 	    return;
 	  }
 	if (clazz == Long.TYPE)
 	  {
 	    long[] cast_array = (long[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readLong ();
+	      cast_array[i] = this.realInputStream.readLong();
 	    return;
 	  }
 	if (clazz == Short.TYPE)
 	  {
 	    short[] cast_array = (short[])array;
 	    for (int i=0; i < cast_array.length; i++)
-	      cast_array[i] = this.realInputStream.readShort ();
+	      cast_array[i] = this.realInputStream.readShort();
 	    return;
 	  }
       }
@@ -1360,7 +1512,7 @@
       {
 	Object[] cast_array = (Object[])array;
 	for (int i=0; i < cast_array.length; i++)
- 	  cast_array[i] = readObject ();
+ 	  cast_array[i] = readObject();
       }
   }
 
@@ -1369,7 +1521,7 @@
   {
     ObjectStreamField[] stream_fields = stream_osc.fields;
     ObjectStreamField[] real_fields =
-      lookupClass (stream_osc.forClass ()).fields;
+      lookupClass(stream_osc.forClass()).fields;
 
     boolean default_initialize, set_value;
     String field_name = null;
@@ -1390,7 +1542,7 @@
 	else
 	  {
 	    stream_field = stream_fields[stream_idx];
-	    type = stream_field.getType ();
+	    type = stream_field.getType();
 	  }
 
 	if (real_idx == real_fields.length)
@@ -1398,8 +1550,8 @@
 	else
 	  {
 	    real_field = real_fields[real_idx];
-	    type = real_field.getType ();
-	    field_name = real_field.getName ();
+	    type = real_field.getType();
+	    field_name = real_field.getName();
 	  }
 
 	if (set_value && !default_initialize)
@@ -1424,87 +1576,96 @@
 	      }
 	  }
 
+	if (stream_field.getOffset() < 0)
+	  {
+	    default_initialize = true;
+	    set_value = false;
+	  }
+	
+	if (!stream_field.isToSet()) 
+	  set_value = false;
+
 	try
 	  {
 	    if (type == Boolean.TYPE)
 	      {
 		boolean value =
-		  default_initialize ? false : this.realInputStream.readBoolean ();
+		  default_initialize ? false : this.realInputStream.readBoolean();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setBooleanField (obj, stream_osc.forClass (), field_name, value);
+		  setBooleanField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Byte.TYPE)
 	      {
 		byte value =
-		  default_initialize ? 0 : this.realInputStream.readByte ();
+		  default_initialize ? 0 : this.realInputStream.readByte();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setByteField (obj, stream_osc.forClass (), field_name, value);
+		  setByteField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Character.TYPE)
 	      {
 		char value =
-		  default_initialize ? (char)0 : this.realInputStream.readChar ();
+		  default_initialize ? (char)0 : this.realInputStream.readChar();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setCharField (obj, stream_osc.forClass (), field_name, value);
+		  setCharField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Double.TYPE)
 	      {
 		double value =
-		  default_initialize ? 0 : this.realInputStream.readDouble ();
+		  default_initialize ? 0 : this.realInputStream.readDouble();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setDoubleField (obj, stream_osc.forClass (), field_name, value);
+		  setDoubleField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Float.TYPE)
 	      {
 		float value =
-		  default_initialize ? 0 : this.realInputStream.readFloat ();
+		  default_initialize ? 0 : this.realInputStream.readFloat();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setFloatField (obj, stream_osc.forClass (), field_name, value);
+		  setFloatField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Integer.TYPE)
 	      {
 		int value =
-		  default_initialize ? 0 : this.realInputStream.readInt ();
+		  default_initialize ? 0 : this.realInputStream.readInt();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setIntField (obj, stream_osc.forClass (), field_name, value);
+		  setIntField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Long.TYPE)
 	      {
 		long value =
-		  default_initialize ? 0 : this.realInputStream.readLong ();
+		  default_initialize ? 0 : this.realInputStream.readLong();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setLongField (obj, stream_osc.forClass (), field_name, value);
+		  setLongField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else if (type == Short.TYPE)
 	      {
 		short value =
-		  default_initialize ? (short)0 : this.realInputStream.readShort ();
+		  default_initialize ? (short)0 : this.realInputStream.readShort();
 		if (!default_initialize && set_value)
-		  dumpElementln ("  " + field_name + ": " + value);
+		  dumpElementln("  " + field_name + ": " + value);
 		if (set_value)
-		  setShortField (obj, stream_osc.forClass (), field_name, value);
+		  setShortField(obj, stream_osc.forClass(), field_name, value);
 	      }
 	    else
 	      {
 		Object value =
-		  default_initialize ? null : readObject ();
+		  default_initialize ? null : readObject();
 		if (set_value)
-		  setObjectField (obj, stream_osc.forClass (), field_name,
-				  real_field.getTypeString (), value);
+		  setObjectField(obj, stream_osc.forClass(), field_name,
+				  real_field.getTypeString(), value);
 	      }
 	  }
 	catch (NoSuchFieldError e)
@@ -1545,20 +1706,20 @@
 
   // runs all registered ObjectInputValidations in prioritized order
   // on OBJ
-  private void invokeValidators () throws InvalidObjectException
+  private void invokeValidators() throws InvalidObjectException
   {
-    Object[] validators = new Object[this.validators.size ()];
+    Object[] validators = new Object[this.validators.size()];
     this.validators.copyInto (validators);
     Arrays.sort (validators);
 
     try
       {
 	for (int i=0; i < validators.length; i++)
-	  ((ObjectInputValidation)validators[i]).validateObject ();
+	  ((ObjectInputValidation)validators[i]).validateObject();
       }
     finally
       {
-	this.validators.removeAllElements ();
+	this.validators.removeAllElements();
       }
   }
 
@@ -1569,12 +1730,29 @@
    * @param sm SecurityManager instance which should be called.
    * @return The current class loader in the calling stack.
    */
-  private static native ClassLoader currentClassLoader (SecurityManager sm);
+  private static ClassLoader currentClassLoader (SecurityManager sm)
+  {
+    // FIXME: This is too simple.
+    return ClassLoader.getSystemClassLoader ();
+  }
 
-  private static Field getField (Class klass, String name)
+  /**
+   * This method tries to access a precise field called in the
+   * specified class. Before accessing the field, it tries to
+   * gain control on this field. If the field is either declared as 
+   * not persistent or transient then it returns null
+   * immediately.
+   *
+   * @param klass Class to get the field from.
+   * @param name Name of the field to access.
+   * @return Field instance representing the requested field.
+   * @throws NoSuchFieldException if the field does not exist.
+   */
+  private Field getField(Class klass, String name)
     throws java.lang.NoSuchFieldException
   {
     final Field f = klass.getDeclaredField(name);
+    ObjectStreamField sf = lookupClass(klass).getField(name);
     
     AccessController.doPrivileged(new PrivilegedAction()
       {
@@ -1584,6 +1762,14 @@
 	  return null;
 	}
       });
+
+    /* We do not want to modify transient fields. They should
+     * be left to 0.
+     * N.B.: Not valid if the field is in serialPersistentFields. 
+     */
+    if (Modifier.isTransient(f.getModifiers()) && !sf.isPersistent())
+      return null;
+   
     return f;
   }
 
@@ -1610,7 +1796,7 @@
 	Class classArgs[] = {ObjectInputStream.class};
 	Method m = getMethod (klass, "readObject", classArgs);
 	Object args[] = {this};
-	m.invoke (obj, args);
+	m.invoke(obj, args);
       }
     catch (NoSuchMethodException nsme)
       {
@@ -1625,14 +1811,17 @@
 	if (exception instanceof IOException)
 	  throw (IOException) exception;
 
-	throw new IOException ("Exception thrown from readObject() on " +
+	throw new IOException("Exception thrown from readObject() on " +
 			       klass + ": " + exception.getClass().getName());
       }
     catch (Exception x)
       {
-	throw new IOException ("Failure invoking readObject() on " +
+	throw new IOException("Failure invoking readObject() on " +
 			       klass + ": " + x.getClass().getName());
       }
+
+    // Invalidate fields which has been read through readFields.
+    prereadFields = null;
   }
     
   private native Object allocateObject (Class clazz)
@@ -1651,13 +1840,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setBooleanField (Object obj, Class klass, String field_name,
+  private void setBooleanField(Object obj, Class klass, String field_name,
 				boolean val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setBoolean (obj, val);
+	Field f = getField(klass, field_name);
+	f.setBoolean(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1679,13 +1868,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setByteField (Object obj, Class klass, String field_name,
+  private void setByteField(Object obj, Class klass, String field_name,
 			     byte val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setByte (obj, val);
+	Field f = getField(klass, field_name);
+	f.setByte(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1707,13 +1896,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setCharField (Object obj, Class klass, String field_name,
+  private void setCharField(Object obj, Class klass, String field_name,
 			     char val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setChar (obj, val);
+	Field f = getField(klass, field_name);
+	f.setChar(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1735,13 +1924,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setDoubleField (Object obj, Class klass, String field_name,
+  private void setDoubleField(Object obj, Class klass, String field_name,
 			       double val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setDouble (obj, val);
+	Field f = getField(klass, field_name);
+	f.setDouble(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1763,13 +1952,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setFloatField (Object obj, Class klass, String field_name,
+  private void setFloatField(Object obj, Class klass, String field_name,
 			      float val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setFloat (obj, val);
+	Field f = getField(klass, field_name);
+	f.setFloat(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1791,13 +1980,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setIntField (Object obj, Class klass, String field_name,
+  private void setIntField(Object obj, Class klass, String field_name,
 			    int val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setInt (obj, val);
+	Field f = getField(klass, field_name);
+	f.setInt(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1819,13 +2008,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setLongField (Object obj, Class klass, String field_name,
+  private void setLongField(Object obj, Class klass, String field_name,
 			     long val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setLong (obj, val);
+	Field f = getField(klass, field_name);
+	f.setLong(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1847,13 +2036,13 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setShortField (Object obj, Class klass, String field_name,
+  private void setShortField(Object obj, Class klass, String field_name,
 			      short val) throws IOException, InvalidClassException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	f.setShort (obj, val);
+	Field f = getField(klass, field_name);
+	f.setShort(obj, val);
       }
     catch (IllegalArgumentException _)
       {
@@ -1875,25 +2064,26 @@
    * @throws InvalidClassException if the specified field has not the required type.
    * @throws IOException if there is no field of that name in the specified class.
    */
-  private void setObjectField (Object obj, Class klass, String field_name,
+  private void setObjectField(Object obj, Class klass, String field_name,
 			       String type_code, Object val) throws IOException, InvalidClassException
   {
     try
       {
- 	Field f = getField (klass, field_name);
+ 	Field f = getField(klass, field_name);
 	ObjectStreamField of = new ObjectStreamField(field_name, f.getType());
 	
 	if (of.getTypeString() == null ||
 	    !of.getTypeString().equals(type_code))
           throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
- 	f.set (obj, val);
+ 	f.set(obj, val);
       }
     catch (InvalidClassException e)
       {
 	throw e;
       }
     catch (Exception _)
-      {}
+      {
+      }
   }
 
   private static final int BUFFER_SIZE = 1024;
@@ -1916,6 +2106,7 @@
   private boolean fieldsAlreadyRead;
   private Vector validators;
   private Hashtable classLookupTable;
+  private GetField prereadFields;
 
   private static boolean dump;
 
