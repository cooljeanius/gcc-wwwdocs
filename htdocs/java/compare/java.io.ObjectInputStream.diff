--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectInputStream.java	2003-12-03 02:20:26.000000000 -0700
+++ java/io/ObjectInputStream.java	2003-08-01 02:18:17.000000000 -0600
@@ -47,6 +47,7 @@
 import java.util.Hashtable;
 import java.util.Vector;
 
+
 import gnu.java.io.ObjectIdentityWrapper;
 import gnu.java.lang.reflect.TypeSignature;
 import java.lang.reflect.Field;
@@ -98,11 +99,10 @@
     this.blockDataInput = new DataInputStream (this);
     this.realInputStream = new DataInputStream (in);
     this.nextOID = baseWireHandle;
-    this.objectLookupTable = new Hashtable();
-    this.validators = new Vector();
-    this.classLookupTable = new Hashtable();
+    this.objectLookupTable = new Hashtable ();
+    this.validators = new Vector ();
     setBlockDataMode (true);
-    readStreamHeader();
+    readStreamHeader ();
   }
 
 
@@ -203,7 +203,7 @@
 	      Class cl = resolveProxyClass(intfs);
 	      setBlockDataMode(oldmode);
 	      
-	      ObjectStreamClass osc = lookupClass (cl);
+	      ObjectStreamClass osc = ObjectStreamClass.lookup(cl);
 	      assignNewHandle (osc);
 	      
 	      if (!is_consumed)
@@ -332,7 +332,7 @@
 	      int handle = assignNewHandle (obj);
 	      this.currentObject = obj;
 	      ObjectStreamClass[] hierarchy =
-		inputGetObjectStreamClasses (clazz);
+		ObjectStreamClass.getObjectStreamClasses (clazz);
 	      
 	      for (int i=0; i < hierarchy.length; i++)
 		{
@@ -455,10 +455,8 @@
 	  new ObjectStreamField (field_name, class_name);
       }
 	      
-    Class clazz = resolveClass (osc);
     boolean oldmode = setBlockDataMode (true);
-    osc.setClass (clazz, lookupClass (clazz.getSuperclass()));
-    classLookupTable.put (clazz, osc);
+    osc.setClass (resolveClass (osc));
     setBlockDataMode (oldmode);
 	      
     return osc;
@@ -552,78 +550,19 @@
   protected Class resolveClass (ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-    return Class.forName (osc.getName(), true, currentLoader()); 
-  }
-  
-  private ClassLoader currentLoader ()
-  {
     SecurityManager sm = System.getSecurityManager ();
     if (sm == null)
       sm = new SecurityManager () {};
- 
-    return currentClassLoader (sm);
-  }
 
-  /**
-   * Lookup a class stored in the local hashtable. If it is not
-   * use the global lookup function in ObjectStreamClass to build
-   * the ObjectStreamClass. This method is requested according to
-   * the behaviour detected in the JDK by Kaffe's team.
-   *
-   * @param clazz Class to lookup in the hash table or for which
-   * we must build a descriptor. 
-   * @return A valid instance of ObjectStreamClass corresponding
-   * to the specified class.
-   */
-  private ObjectStreamClass lookupClass (Class clazz)
-  {
-    ObjectStreamClass oclazz;
-    
-    oclazz = (ObjectStreamClass) classLookupTable.get(clazz);
-    if (oclazz == null)
-      return ObjectStreamClass.lookup (clazz);
-    else
-      return oclazz;
-  }
-
-  /**
-   * Reconstruct class hierarchy the same way
-   * {@link java.io.ObjectStreamClass.getObjectStreamClasses(java.lang.Class)} does
-   * but using lookupClass instead of ObjectStreamClass.lookup. This
-   * dup is necessary localize the lookup table. Hopefully some future rewritings will
-   * be able to prevent this.
-   *
-   * @param clazz This is the class for which we want the hierarchy.
-   *
-   * @return An array of valid {@link java.io.ObjectStreamClass} instances which
-   * represent the class hierarchy for clazz.
-   */
-  private ObjectStreamClass[] inputGetObjectStreamClasses (Class clazz)
-  {
-    ObjectStreamClass osc = lookupClass (clazz);
-
-    ObjectStreamClass[] ret_val;
+    // FIXME: currentClassLoader doesn't yet do anything useful. We need
+    // to call forName() with the classloader of the class which called 
+    // readObject(). See SecurityManager.getClassContext().
+    ClassLoader cl = currentClassLoader (sm);
 
-    if (osc == null)
-      return new ObjectStreamClass[0];
+    if (cl == null)
+      return Class.forName (osc.getName ());
     else
-    {
-      Vector oscs = new Vector ();
-
-      while (osc != null)
-      {
-	oscs.addElement (osc);
-	osc = osc.getSuper ();
-      }
-
-      int count = oscs.size ();
-      ObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];
-
-      for (int i = count - 1; i >= 0; i--)
-	sorted_oscs[ count - i - 1 ] = (ObjectStreamClass)oscs.elementAt (i);
-
-      return sorted_oscs;
-    }
+      return cl.loadClass (osc.getName ());
   }
 
   /**
@@ -774,142 +713,52 @@
 
   public boolean readBoolean () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    boolean value = this.dataInputStream.readBoolean ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readBoolean ();
   }
 
   public byte readByte () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    byte value = this.dataInputStream.readByte ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readByte ();
   }
 
   public int readUnsignedByte () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedByte ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readUnsignedByte ();
   }
 
   public short readShort () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    short value = this.dataInputStream.readShort ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readShort ();
   }
 
   public int readUnsignedShort () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readUnsignedShort ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readUnsignedShort ();
   }
 
   public char readChar () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    char value = this.dataInputStream.readChar ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readChar ();
   }
 
   public int readInt () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    int value = this.dataInputStream.readInt ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readInt ();
   }
 
   public long readLong () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    long value = this.dataInputStream.readLong ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readLong ();
   }
 
   public float readFloat () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    float value = this.dataInputStream.readFloat ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readFloat ();
   }
 
   public double readDouble () throws IOException
   {
-    boolean switchmode = true;
-    boolean oldmode = this.readDataFromBlock;
-    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)
-      switchmode = false;
-    if (switchmode)
-      oldmode = setBlockDataMode (true);
-    double value = this.dataInputStream.readDouble ();
-    if (switchmode)
-      setBlockDataMode (oldmode);
-    return value;
+    return this.dataInputStream.readDouble ();
   }
 
   public void readFully (byte data[]) throws IOException
@@ -1212,12 +1061,7 @@
     throw new IOException ("Subclass of ObjectInputStream must implement readObjectOverride");
   }
 
-  /**
-   * Assigns the next available handle to <code>obj</code>.
-   *
-   * @param obj The object for which we want a new handle.
-   * @return A valid handle for the specified object.
-   */
+  // assigns the next availible handle to OBJ
   private int assignNewHandle (Object obj)
   {
     this.objectLookupTable.put (new Integer (this.nextOID),
@@ -1369,7 +1213,7 @@
   {
     ObjectStreamField[] stream_fields = stream_osc.fields;
     ObjectStreamField[] real_fields =
-      lookupClass (stream_osc.forClass ()).fields;
+      ObjectStreamClass.lookup (stream_osc.forClass ()).fields;
 
     boolean default_initialize, set_value;
     String field_name = null;
@@ -1562,20 +1406,18 @@
       }
   }
 
-  /**
-   * This native method is used to get access to the protected method
-   * of the same name in SecurityManger.
-   *
-   * @param sm SecurityManager instance which should be called.
-   * @return The current class loader in the calling stack.
-   */
-  private static native ClassLoader currentClassLoader (SecurityManager sm);
+  // this native method is used to get access to the protected method
+  // of the same name in SecurityManger
+  private static ClassLoader currentClassLoader (SecurityManager sm)
+  {
+    // FIXME: This is too simple.
+    return ClassLoader.getSystemClassLoader ();
+  }
 
   private static Field getField (Class klass, String name)
     throws java.lang.NoSuchFieldException
   {
     final Field f = klass.getDeclaredField(name);
-    
     AccessController.doPrivileged(new PrivilegedAction()
       {
 	public Object run()
@@ -1640,260 +1482,125 @@
 
   private native void callConstructor (Class clazz, Object obj);
 
-  /**
-   * This method writes a "boolean" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The boolean value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setBooleanField (Object obj, Class klass, String field_name,
-				boolean val) throws IOException, InvalidClassException
+				boolean val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setBoolean (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes a "byte" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The byte value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setByteField (Object obj, Class klass, String field_name,
-			     byte val) throws IOException, InvalidClassException
+			     byte val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setByte (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes a "character" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The character value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setCharField (Object obj, Class klass, String field_name,
-			     char val) throws IOException, InvalidClassException
+			     char val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setChar (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes a "double" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The double value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setDoubleField (Object obj, Class klass, String field_name,
-			       double val) throws IOException, InvalidClassException
+			       double val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setDouble (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes a "float" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The float value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setFloatField (Object obj, Class klass, String field_name,
-			      float val) throws IOException, InvalidClassException
+			      float val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setFloat (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes an "integer" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The integer value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
   private void setIntField (Object obj, Class klass, String field_name,
-			    int val) throws IOException, InvalidClassException
+			    int val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setInt (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes the long value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The long value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
+
   private void setLongField (Object obj, Class klass, String field_name,
-			     long val) throws IOException, InvalidClassException
+			     long val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setLong (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes a "short" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The short value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
+
   private void setShortField (Object obj, Class klass, String field_name,
-			      short val) throws IOException, InvalidClassException
+			      short val)
   {
     try
       {
 	Field f = getField (klass, field_name);
 	f.setShort (obj, val);
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
-      }
     catch (Exception _)
       {
       }    
   }
 
-  /**
-   * This method writes an "object" value <code>val</code> in the specified field
-   * of the instance <code>obj</code> of the type <code>klass</code>.
-   *
-   * @param obj Instance to setup.
-   * @param klass Class type of the specified instance.
-   * @param field_name Name of the field in the specified class type.
-   * @param val The "object" value to write into the field.
-   * @throws InvalidClassException if the specified field has not the required type.
-   * @throws IOException if there is no field of that name in the specified class.
-   */
+
   private void setObjectField (Object obj, Class klass, String field_name,
-			       String type_code, Object val) throws IOException, InvalidClassException
+			       String type_code, Object val)
   {
     try
       {
- 	Field f = getField (klass, field_name);
-	ObjectStreamField of = new ObjectStreamField(field_name, f.getType());
-	
-	if (of.getTypeString() == null ||
-	    !of.getTypeString().equals(type_code))
-          throw new InvalidClassException("incompatible field type for " + klass.getName() + "." + field_name);
- 	f.set (obj, val);
-      }
-    catch (InvalidClassException e)
-      {
-	throw e;
+	Field f = getField (klass, field_name);
+	// FIXME: We should check the type_code here
+	f.set (obj, val);
       }
     catch (Exception _)
-      {}
+      {
+      }    
   }
 
   private static final int BUFFER_SIZE = 1024;
@@ -1915,7 +1622,6 @@
   private boolean isDeserializing;
   private boolean fieldsAlreadyRead;
   private Vector validators;
-  private Hashtable classLookupTable;
 
   private static boolean dump;
 
