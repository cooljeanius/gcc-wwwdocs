--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectInputStream.java	2004-07-23 02:23:52.000000000 -0600
+++ java/io/ObjectInputStream.java	2004-07-10 02:19:14.000000000 -0600
@@ -38,20 +38,24 @@
 
 package java.io;
 
-import gnu.classpath.Configuration;
-import gnu.java.io.ObjectIdentityWrapper;
-
 import java.lang.reflect.Array;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
+import java.security.PrivilegedAction;
+import java.security.AccessController;
 import java.util.Arrays;
 import java.util.Hashtable;
 import java.util.Vector;
 
 
+import gnu.java.io.ObjectIdentityWrapper;
+import gnu.java.lang.reflect.TypeSignature;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+
+import gnu.classpath.Configuration;
+
 public class ObjectInputStream extends InputStream
   implements ObjectInput, ObjectStreamConstants
 {
@@ -120,6 +124,15 @@
    */
   public final Object readObject() throws ClassNotFoundException, IOException
   {
+      if (callersClassLoader == null)
+	{
+	  callersClassLoader = getCallersClassLoader ();
+	  if (Configuration.DEBUG && dump)
+	    {
+	      dumpElementln ("CallersClassLoader = " + callersClassLoader);
+	    }
+	}
+
     if (this.useSubclassMethod)
       return readObjectOverride();
 
@@ -278,7 +291,29 @@
 	      
 	      if (osc.realClassIsExternalizable)
 		{
-		  Externalizable obj = osc.newInstance();
+		  Externalizable obj = null;
+		  
+		  try
+		    {
+		      obj = (Externalizable)clazz.newInstance();
+		    }
+		  catch (InstantiationException e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created");
+		    }
+		  catch (IllegalAccessException e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created because class or "
+			 + "zero-argument constructor is not accessible");
+		    }
+		  catch (NoSuchMethodError e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz
+			 + " could not be created because zero-argument constructor is not defined");
+		    }
 		  
 		  int handle = assignNewHandle(obj);
 		  
@@ -300,6 +335,9 @@
 	      Object obj = newObject(clazz, osc.firstNonSerializableParent);
 	      
 	      int handle = assignNewHandle(obj);
+	      Object prevObject = this.currentObject;
+	      ObjectStreamClass prevObjectStreamClass = this.currentObjectStreamClass;
+	      
 	      this.currentObject = obj;
 	      ObjectStreamClass[] hierarchy =
 		inputGetObjectStreamClasses(clazz);
@@ -322,11 +360,22 @@
 		      boolean oldmode = setBlockDataMode(true);
 		      callReadMethod(readObjectMethod, this.currentObjectStreamClass.forClass(), obj);
 		      setBlockDataMode(oldmode);
+		    }
+		  else
+		    {
+		      readFields(obj, currentObjectStreamClass);
+		    }
+
+		  if (this.currentObjectStreamClass.hasWriteMethod())
+		    {
 		      if(dump) dumpElement("ENDBLOCKDATA? ");
 		      try
 			{
-			  // FIXME: XXX: This try block is to catch EOF which is
-			  // thrown for some objects.  That indicates a bug in the logic.
+			  // FIXME: XXX: This try block is to
+			  // catch EOF which is thrown for some
+			  // objects.  That indicates a bug in
+			  // the logic.
+
 			  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)
 			    throw new IOException
 			      ("No end of block data seen for class with readObject (ObjectInputStream) method.");
@@ -341,14 +390,10 @@
 			  if(dump) dumpElementln("no, got IOException");
 			}
 		    }
-		  else
-		    {
-		      readFields(obj, currentObjectStreamClass);
-		    }
 		}
 
-	      this.currentObject = null;
-	      this.currentObjectStreamClass = null;
+	      this.currentObject = prevObject;
+	      this.currentObjectStreamClass = prevObjectStreamClass;
 	      ret_val = processResolution(osc, obj, handle);
 		  
 	      break;
@@ -694,7 +739,7 @@
   protected Class resolveClass(ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-    return Class.forName(osc.getName(), true, currentLoader());
+    return Class.forName(osc.getName(), true, callersClassLoader);
   }
 
   /**
@@ -1787,6 +1832,8 @@
    * @return The current class loader in the calling stack.
    */
   private static native ClassLoader currentClassLoader (SecurityManager sm);
+  
+  private native ClassLoader getCallersClassLoader();
 
   private void callReadMethod (Method readObject, Class klass, Object obj) throws IOException
   {
@@ -1844,6 +1891,8 @@
 
   private static boolean dump = false && Configuration.DEBUG;
 
+  private ClassLoader callersClassLoader;
+
   // The nesting depth for debugging output
   private int depth = 0;
 
