--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectInputStream.java	2004-07-10 02:22:15.000000000 -0600
+++ java/io/ObjectInputStream.java	2004-07-10 02:19:14.000000000 -0600
@@ -38,20 +38,24 @@
 
 package java.io;
 
-import gnu.classpath.Configuration;
-import gnu.java.io.ObjectIdentityWrapper;
-
 import java.lang.reflect.Array;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
+import java.security.PrivilegedAction;
+import java.security.AccessController;
 import java.util.Arrays;
 import java.util.Hashtable;
 import java.util.Vector;
 
 
+import gnu.java.io.ObjectIdentityWrapper;
+import gnu.java.lang.reflect.TypeSignature;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+
+import gnu.classpath.Configuration;
+
 public class ObjectInputStream extends InputStream
   implements ObjectInput, ObjectStreamConstants
 {
@@ -120,6 +124,15 @@
    */
   public final Object readObject() throws ClassNotFoundException, IOException
   {
+      if (callersClassLoader == null)
+	{
+	  callersClassLoader = getCallersClassLoader ();
+	  if (Configuration.DEBUG && dump)
+	    {
+	      dumpElementln ("CallersClassLoader = " + callersClassLoader);
+	    }
+	}
+
     if (this.useSubclassMethod)
       return readObjectOverride();
 
@@ -134,6 +147,9 @@
     this.isDeserializing = true;
 
     byte marker = this.realInputStream.readByte();
+
+    depth += 2;
+
     if(dump) dumpElement("MARKER: 0x" + Integer.toHexString(marker) + " ");
 
     try
@@ -151,9 +167,9 @@
 	  case TC_BLOCKDATALONG:
 	    {
 	      if (marker == TC_BLOCKDATALONG)
-		if(dump) dumpElementln("BLOCKDATALONG");
+		{ if(dump) dumpElementln("BLOCKDATALONG"); }
 	      else
-		if(dump) dumpElementln("BLOCKDATA");
+		{ if(dump) dumpElementln("BLOCKDATA"); }
 	      readNextBlock(marker);
 	      throw new StreamCorruptedException("Unexpected blockData");
 	    }
@@ -275,7 +291,29 @@
 	      
 	      if (osc.realClassIsExternalizable)
 		{
-		  Externalizable obj = osc.newInstance();
+		  Externalizable obj = null;
+		  
+		  try
+		    {
+		      obj = (Externalizable)clazz.newInstance();
+		    }
+		  catch (InstantiationException e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created");
+		    }
+		  catch (IllegalAccessException e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz + " could not be created because class or "
+			 + "zero-argument constructor is not accessible");
+		    }
+		  catch (NoSuchMethodError e)
+		    {
+		      throw new ClassNotFoundException
+			("Instance of " + clazz
+			 + " could not be created because zero-argument constructor is not defined");
+		    }
 		  
 		  int handle = assignNewHandle(obj);
 		  
@@ -297,6 +335,9 @@
 	      Object obj = newObject(clazz, osc.firstNonSerializableParent);
 	      
 	      int handle = assignNewHandle(obj);
+	      Object prevObject = this.currentObject;
+	      ObjectStreamClass prevObjectStreamClass = this.currentObjectStreamClass;
+	      
 	      this.currentObject = obj;
 	      ObjectStreamClass[] hierarchy =
 		inputGetObjectStreamClasses(clazz);
@@ -319,34 +360,42 @@
 		      boolean oldmode = setBlockDataMode(true);
 		      callReadMethod(readObjectMethod, this.currentObjectStreamClass.forClass(), obj);
 		      setBlockDataMode(oldmode);
+		    }
+		  else
+		    {
+		      readFields(obj, currentObjectStreamClass);
+		    }
+
+		  if (this.currentObjectStreamClass.hasWriteMethod())
+		    {
 		      if(dump) dumpElement("ENDBLOCKDATA? ");
 		      try
 			{
-			  // FIXME: XXX: This try block is to catch EOF which is
-			  // thrown for some objects.  That indicates a bug in the logic.
+			  // FIXME: XXX: This try block is to
+			  // catch EOF which is thrown for some
+			  // objects.  That indicates a bug in
+			  // the logic.
+
 			  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)
 			    throw new IOException
 			      ("No end of block data seen for class with readObject (ObjectInputStream) method.");
 			  if(dump) dumpElementln("yes");
 			}
-		      catch (EOFException e)
-			{
-			  if(dump) dumpElementln("no, got EOFException");
-			}
+// 		      catch (EOFException e)
+// 			{
+// 			  if(dump) dumpElementln("no, got EOFException");
+// 			}
 		      catch (IOException e)
 			{
 			  if(dump) dumpElementln("no, got IOException");
 			}
 		    }
-		  else
-		    {
-		      readFields(obj, currentObjectStreamClass);
-		    }
 		}
 
-	      this.currentObject = null;
-	      this.currentObjectStreamClass = null;
+	      this.currentObject = prevObject;
+	      this.currentObjectStreamClass = prevObjectStreamClass;
 	      ret_val = processResolution(osc, obj, handle);
+		  
 	      break;
 	    }
 
@@ -375,6 +424,8 @@
 	
 	this.isDeserializing = was_deserializing;
 	
+	depth -= 2;
+	
 	if (! was_deserializing)
 	  {
 	    if (validators.size() > 0)
@@ -688,7 +739,7 @@
   protected Class resolveClass(ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-    return Class.forName(osc.getName(), true, currentLoader());
+    return Class.forName(osc.getName(), true, callersClassLoader);
   }
 
   /**
@@ -1781,6 +1832,8 @@
    * @return The current class loader in the calling stack.
    */
   private static native ClassLoader currentClassLoader (SecurityManager sm);
+  
+  private native ClassLoader getCallersClassLoader();
 
   private void callReadMethod (Method readObject, Class klass, Object obj) throws IOException
   {
@@ -1838,6 +1891,11 @@
 
   private static boolean dump = false && Configuration.DEBUG;
 
+  private ClassLoader callersClassLoader;
+
+  // The nesting depth for debugging output
+  private int depth = 0;
+
   private void dumpElement (String msg)
   {
     System.out.print(msg);
@@ -1846,6 +1904,9 @@
   private void dumpElementln (String msg)
   {
     System.out.println(msg);
+    for (int i = 0; i < depth; i++)
+      System.out.print (" ");
+    System.out.print (Thread.currentThread() + ": ");
   }
 
   static
