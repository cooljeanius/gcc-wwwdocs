--- /home/tromey/gnu/egcs/classpath/classpath/java/io/ObjectInputStream.java	Tue Jan 22 15:49:55 2002
+++ java/io/ObjectInputStream.java	Tue Jan 22 16:01:33 2002
@@ -38,6 +38,8 @@
 
 package java.io;
 
+import gnu.classpath.Configuration;
+
 import java.lang.reflect.Array;
 import java.lang.reflect.Modifier;
 import java.util.Arrays;
@@ -50,7 +52,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.InvocationTargetException;
 
-import gnu.classpath.Configuration;
+
 
 public class ObjectInputStream extends InputStream
   implements ObjectInput, ObjectStreamConstants
@@ -72,6 +74,21 @@
   public ObjectInputStream (InputStream in)
     throws IOException, StreamCorruptedException
   {
+    if (Configuration.DEBUG)
+      {
+	String val = System.getProperty("gcj.dumpobjects");
+	if (dump == false && val != null && !val.equals(""))
+	  {
+	    dump = true;
+	    System.out.println ("Serialization debugging enabled");
+	  }
+	else if (dump == true && (val == null || val.equals("")))
+	  {
+	    dump = false;
+	    System.out.println ("Serialization debugging disabled");
+	  }
+      }
+
     this.resolveEnabled = false;
     this.isDeserializing = false;
     this.blockDataPosition = 0;
@@ -193,8 +210,8 @@
 				   (class_name));
 	}
 
-	setBlockDataMode (true);
-	osc.setClass (resolveClass (osc));
+	Class cl = resolveClass (osc);
+	osc.setClass (cl);
 	setBlockDataMode (false);
 
 	if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)
@@ -481,28 +498,16 @@
   protected Class resolveClass (ObjectStreamClass osc)
     throws ClassNotFoundException, IOException
   {
-//    DEBUGln ("Resolving " + osc);
-
     SecurityManager sm = System.getSecurityManager ();
 
-    if (sm == null)
-      sm = new SecurityManager () {};
-
+    // FIXME: currentClassLoader doesn't yet do anything useful. We need
+    // to call forName() with the classloader of the class which called 
+    // readObject(). See SecurityManager.getClassContext().
     ClassLoader cl = currentClassLoader (sm);
 
-    if (cl == null)
-    {
-//      DEBUGln ("No class loader found");
-      return Class.forName (osc.getName ());
-    }
-    else
-    {
-//      DEBUGln ("Using " + cl);
-      return cl.loadClass (osc.getName ());
-    }
+    return Class.forName (osc.getName (), true, cl);
   }
 
-
   /**
      Allows subclasses to resolve objects that are read from the
      stream with other objects to be returned in their place.  This
@@ -574,21 +579,23 @@
     {
       if (this.blockDataPosition >= this.blockDataBytes)
 	readNextBlock ();
-      return this.blockData[this.blockDataPosition++];
+      return (this.blockData[this.blockDataPosition++] & 0xff);
     }
     else
       return this.realInputStream.read ();
   }
 
-  public int read (byte data[], int offset, int length) throws IOException
+  public int read (byte[] data, int offset, int length) throws IOException
   {
     if (this.readDataFromBlock)
     {
-      if (this.blockDataPosition + length >= this.blockDataBytes)
+      if (this.blockDataPosition + length > this.blockDataBytes)
 	readNextBlock ();
 
       System.arraycopy (this.blockData, this.blockDataPosition,
 			data, offset, length);
+      blockDataPosition += length;	
+
       return length;
     }
     else
@@ -956,7 +963,7 @@
      de serialization mechanism provided by
      <code>ObjectInputStream</code>.  To make this method be used for
      writing objects, subclasses must invoke the 0-argument
-     constructor on this class from their constructor.
+     constructor on this class from there constructor.
 
      @see ObjectInputStream ()
   */
@@ -1302,7 +1309,7 @@
 
 
   // returns a new instance of REAL_CLASS that has been constructed
-  // only to th level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)
+  // only to the level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)
   private Object newObject (Class real_class, Class constructor_class)
   {
     try
@@ -1340,34 +1347,182 @@
 
   // this native method is used to get access to the protected method
   // of the same name in SecurityManger
-  private static native ClassLoader currentClassLoader (SecurityManager sm);
+  private static ClassLoader currentClassLoader (SecurityManager sm)
+  {
+    // FIXME: This is too simple.
+    return ClassLoader.getSystemClassLoader ();
+  }
 
-  private native void callReadMethod (Object obj, Class clazz);
+  private static native Field getField (Class klass, String name)
+    throws java.lang.NoSuchFieldException;
+
+  private static native Method getMethod (Class klass, String name, Class args[])
+    throws java.lang.NoSuchMethodException;
+
+  private void callReadMethod (Object obj, Class klass) throws IOException
+  {
+    try
+      {
+	Class classArgs[] = {ObjectInputStream.class};
+	Method m = getMethod (klass, "readObject", classArgs);
+	if (m == null)
+	  return;
+	Object args[] = {this};
+	m.invoke (obj, args);
+      }
+    catch (InvocationTargetException x)
+      {
+        /* Rethrow if possible. */
+	Throwable exception = x.getTargetException();
+	if (exception instanceof RuntimeException)
+	  throw (RuntimeException) exception;
+	if (exception instanceof IOException)
+	  throw (IOException) exception;
 
+	throw new IOException ("Exception thrown from readObject() on " +
+			       klass + ": " + exception.getClass().getName());
+      }
+    catch (Exception x)
+      {
+	throw new IOException ("Failure invoking readObject() on " +
+			       klass + ": " + x.getClass().getName());
+      }
+  }
+    
   private native Object allocateObject (Class clazz)
     throws InstantiationException;
 
   private native void callConstructor (Class clazz, Object obj);
 
-  private native void setBooleanField (Object obj, String field_name,
-				       boolean val);
-  private native void setByteField (Object obj, String field_name,
-				    byte val);
-  private native void setCharField (Object obj, String field_name,
-				    char val);
-  private native void setDoubleField (Object obj, String field_name,
-				      double val);
-  private native void setFloatField (Object obj, String field_name,
-				     float val);
-  private native void setIntField (Object obj, String field_name,
-				   int val);
-  private native void setLongField (Object obj, String field_name,
-				    long val);
-  private native void setShortField (Object obj, String field_name,
-				     short val);
-  private native void setObjectField (Object obj, String field_name,
-					String type_code, Object val);
+  private void setBooleanField (Object obj, String field_name,
+				boolean val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setBoolean (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setByteField (Object obj, String field_name,
+				byte val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setByte (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
 
+  private void setCharField (Object obj, String field_name,
+			     char val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setChar (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setDoubleField (Object obj, String field_name,
+			       double val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setDouble (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setFloatField (Object obj, String field_name,
+			      float val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setFloat (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+  private void setIntField (Object obj, String field_name,
+			      int val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setInt (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setLongField (Object obj, String field_name,
+			      long val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setLong (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setShortField (Object obj, String field_name,
+			      short val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	f.setShort (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
+
+
+  private void setObjectField (Object obj, String field_name, String type_code,
+			       Object val)
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	// FIXME: We should check the type_code here
+	f.set (obj, val);
+      }
+    catch (Exception _)
+      {
+      }    
+  }
 
   private static final int BUFFER_SIZE = 1024;
   private static final Class[] readObjectParams = { ObjectInputStream.class };
@@ -1389,42 +1544,18 @@
   private boolean fieldsAlreadyRead;
   private Vector validators;
 
-  private static boolean dump;
-
-  public static void setDump (boolean dodump)
-  {
-    dump = dodump;
-  }
+  private static boolean dump;  
 
   private void dumpElement (String msg)
   {
-    if (dump)
-      System.out.print (msg);
+    if (Configuration.DEBUG && dump)  
+      System.out.print(msg);
   }
-
+  
   private void dumpElementln (String msg)
   {
-    if (dump)
-      System.out.println (msg);
-  }
-
-  static
-  {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javaio");
-      }
-  }
-
-  private void DEBUG (String msg)
-  {
-    System.out.print (msg);
-  }
-
-
-  private void DEBUGln (String msg)
-  {
-    System.out.println (msg);
+    if (Configuration.DEBUG && dump)
+      System.out.println(msg);
   }
 }
 
