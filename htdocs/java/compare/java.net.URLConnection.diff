--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URLConnection.java	2004-09-13 02:44:27.000000000 -0600
+++ java/net/URLConnection.java	2004-07-23 02:18:45.000000000 -0600
@@ -46,8 +46,11 @@
 import java.text.SimpleDateFormat;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Hashtable;
 import java.util.Locale;
 import java.util.Map;
+import java.util.StringTokenizer;
+import gnu.gcj.io.MimeTypes;
 
 
 /**
@@ -113,6 +116,9 @@
    */
   private static boolean defaultUseCaches = true;
 
+  private static ContentHandlerFactory defaultFactory
+    = new gnu.java.net.DefaultContentHandlerFactory();
+
   /**
    * This variable determines whether or not interaction is allowed with
    * the user.  For example, to prompt for a username and password.
@@ -161,12 +167,13 @@
    */
   protected URL url;
 
+  private static Hashtable handlers = new Hashtable();
   private static SimpleDateFormat[] dateFormats;
   private static boolean dateformats_initialized;
 
   /* Cached ParsePosition, used when parsing dates. */
   private ParsePosition position;
- 
+
   /**
    * Creates a URL connection to a given URL. A real connection is not made.
    * Use #connect to do this.
@@ -404,77 +411,40 @@
   }
 
   /**
-   * This method returns the content of the document pointed to by the
-   * URL as an Object.  The type of object depends on the MIME type of
-   * the object and particular content hander loaded.  Most text type
-   * content handlers will return a subclass of
-   * <code>InputStream</code>.  Images usually return a class that
-   * implements <code>ImageProducer<code>.  There is not guarantee
-   * what type of object will be returned, however.
-
-<p>
-
-   * This class first determines the MIME type of the content, then
-   * creates a ContentHandler object to process the input.  If the
-   * <code>ContentHandlerFactory</code> is set, then that object is
-   * called to load a content handler, otherwise a class called
-   * gnu.java.net.content.&lt;content_type&gt; is tried.  If this
-   * handler does not exist, the method will simple return the
-   * <code>InputStream</code> returned by
-   * <code>getInputStream()</code>.  Note that the default
-   * implementation of <code>getInputStream()</code> throws a
-   * <code>UnknownServiceException</code> so subclasses are encouraged
-   * to override this method.
+   * This method returns the content of the document pointed to by the URL
+   * as an Object.  The type of object depends on the MIME type of the
+   * object and particular content hander loaded.  Most text type content
+   * handlers will return a subclass of InputStream.  Images usually return
+   * a class that implements ImageProducer.  There is not guarantee what
+   * type of object will be returned, however.
+   * <p>
+   * This class first determines the MIME type of the content, then creates
+   * a ContentHandler object to process the input.  If the ContentHandlerFactory
+   * is set, then that object is called to load a content handler, otherwise
+   * a class called gnu.java.net.content.&lt;content_type&gt; is tried.
+   * The default class will also be used if the content handler factory returns
+   * a null content handler.
    *
-   * @exception IOException If an error with the connection occurs.
+   * @exception IOException If an error occurs
    * @exception UnknownServiceException If the protocol does not support the
-   * content type at all.
+   * content type
    */
   public Object getContent() throws IOException
   {
-    //  connect();
-    String type = getContentType();
-
-    // First try the factory
-    ContentHandler ch = null;
-
-    if (factory != null)
-      ch = factory.createContentHandler(type);
-
-    if (ch != null)
-      return ch.getContent(this);
-
-    // Then try our default class
-    try
-      {
-	String typeClass = type.replace('/', '.');
-	
-	// deal with "Content-Type: text/html; charset=ISO-8859-1"
-	int parameterBegin = typeClass.indexOf(';');
-	if (parameterBegin >= 1)
-	  typeClass = typeClass.substring(0, parameterBegin);
+    if (!connected)
+      connect();
 
-	Class cls = Class.forName("gnu.java.net.content." + typeClass);
-
-	Object obj = cls.newInstance();
+    // FIXME: Doc indicates that other criteria should be applied as
+    // heuristics to determine the true content type, e.g. see 
+    // guessContentTypeFromName() and guessContentTypeFromStream methods
+    // as well as FileNameMap class & fileNameMap field & get/set methods.
+    String type = getContentType();
+    ContentHandler ch = getContentHandler(type);
 
-	if (obj instanceof ContentHandler)
-	  {
-	    ch = (ContentHandler) obj;
-	    return ch.getContent(this);
-	  }
-      }
-    catch (ClassNotFoundException e)
-      {
-      }
-    catch (InstantiationException e)
-      {
-      }
-    catch (IllegalAccessException e)
-      {
-      }
+    if (ch == null)
+      return getInputStream();
 
-    return getInputStream();
+    return ch.getContent(this);
   }
 
   /**
@@ -918,7 +888,22 @@
    */
   public static String guessContentTypeFromName(String filename)
   {
-    return getFileNameMap().getContentTypeFor(filename.toLowerCase());
+    int dot = filename.lastIndexOf (".");
+    
+    if (dot != -1)
+      {
+	if (dot == filename.length())
+	  return ("application/octet-stream");
+	else
+	  filename = filename.substring (dot + 1);
+      }
+    
+    String type = MimeTypes.getMimeTypeFromExtension (filename);
+    
+    if (type == null)
+      return("application/octet-stream");
+
+    return type;
   }
 
   /**
@@ -940,7 +925,10 @@
   public static String guessContentTypeFromStream(InputStream is)
     throws IOException
   {
-    return ("application/octet-stream");
+    is.mark(1024);
+    // FIXME: Implement this. Use system mimetype informations (like "file").
+    is.reset();
+    return null;
   }
 
   /**
@@ -951,12 +939,8 @@
    *
    * @since 1.2
    */
-  public static synchronized FileNameMap getFileNameMap()
+  public static FileNameMap getFileNameMap()
   {
-    // Delayed initialization.
-    if (fileNameMap == null)
-      fileNameMap = new MimeTypeMapper();
-
     return fileNameMap;
   }
 
@@ -982,6 +966,91 @@
     fileNameMap = map;
   }
 
+  private ContentHandler getContentHandler(String contentType)
+  {
+    ContentHandler handler;
+
+    // No content type so just handle it as the default.
+    if (contentType == null || contentType.equals(""))
+      return null;
+
+    // See if a handler has been cached for this content type.
+    // For efficiency, if a content type has been searched for but not
+    // found, it will be in the hash table but as the contentType String
+    // instead of a ContentHandler.
+    if ((handler = (ContentHandler) handlers.get(contentType)) != null)
+      if (handler instanceof ContentHandler)
+	return handler;
+      else
+	return null;
+
+    // If a non-default factory has been set, use it.
+    if (factory != null)
+      handler = factory.createContentHandler(contentType);
+
+    // Now try default factory. Using this factory to instantiate built-in
+    // content handlers is preferable  
+    if (handler == null)
+      handler = defaultFactory.createContentHandler(contentType);
+
+    // User-set factory has not returned a handler. Use the default search 
+    // algorithm.
+    if (handler == null)
+      {
+	// Get the list of packages to check and append our default handler
+	// to it, along with the JDK specified default as a last resort.
+	// Except in very unusual environments the JDK specified one shouldn't
+	// ever be needed (or available).
+	String propVal = System.getProperty("java.content.handler.pkgs");
+	propVal = (propVal == null) ? "" : (propVal + "|");
+	propVal = propVal + "gnu.java.net.content|sun.net.www.content";
+
+	// Replace the '/' character in the content type with '.' and
+	// all other non-alphabetic, non-numeric characters with '_'.
+	char[] cArray = contentType.toCharArray();
+	for (int i = 0; i < cArray.length; i++)
+	  {
+	    if (cArray[i] == '/')
+	      cArray[i] = '.';
+	    else if (! ((cArray[i] >= 'A' && cArray[i] <= 'Z') || 
+			(cArray[i] >= 'a' && cArray[i] <= 'z') ||
+			(cArray[i] >= '0' && cArray[i] <= '9')))
+	      cArray[i] = '_';
+	  }
+	String contentClass = new String(cArray);
+
+	// See if a class of this content type exists in any of the packages.
+	StringTokenizer pkgPrefix = new StringTokenizer(propVal, "|");
+	do
+	  {
+	    String facName = pkgPrefix.nextToken() + "." + contentClass;
+	    try
+	      {
+		handler =
+		  (ContentHandler) Class.forName(facName).newInstance();
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null, go on to next element.
+	      }
+	  } while ((handler == null ||
+		    ! (handler instanceof ContentHandler)) &&
+		   pkgPrefix.hasMoreTokens());
+      }
+
+    // Update the hashtable with the new content handler.
+    if (handler != null && handler instanceof ContentHandler)
+      {
+	handlers.put(contentType, handler);
+	return handler;
+      }
+
+    // For efficiency on subsequent searches, put a dummy entry in the hash
+    // table for content types that don't have a non-default ContentHandler.
+    handlers.put(contentType, contentType);
+    return null;
+  }
+  
   // We don't put these in a static initializer, because it creates problems
   // with initializer co-dependency: SimpleDateFormat's constructors eventually 
   // depend on URLConnection (via the java.text.*Symbols classes).
