--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URLConnection.java	2004-04-18 02:22:21.000000000 -0600
+++ java/net/URLConnection.java	2004-03-21 02:18:06.000000000 -0700
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -35,10 +35,11 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package java.net;
 
-import java.io.IOException;
 import java.io.InputStream;
+import java.io.IOException;
 import java.io.OutputStream;
 import java.security.AllPermission;
 import java.security.Permission;
@@ -49,7 +50,8 @@
 import java.util.Hashtable;
 import java.util.Locale;
 import java.util.Map;
-
+import java.util.StringTokenizer;
+import gnu.gcj.io.MimeTypes;
 
 /**
  * Written using on-line Java Platform 1.2 API Specification, as well
@@ -57,6 +59,7 @@
  * Status:  One guessContentTypeFrom... methods not implemented.
  *    getContent method assumes content type from response; see comment there.
  */
+
 /**
  * This class models a connection that retrieves the information pointed
  * to by a URL object.  This is typically a connection to a remote node
@@ -96,18 +99,18 @@
    * instance and store it here.
    */
   private static FileNameMap fileNameMap;
-
+ 
   /**
    * This is the ContentHandlerFactory set by the caller, if any
    */
   private static ContentHandlerFactory factory;
-
+  
   /**
    * This is the default value that will be used to determine whether or
    * not user interaction should be allowed.
    */
-  private static boolean defaultAllowUserInteraction;
-
+  private static boolean defaultAllowUserInteraction = false;
+  
   /**
    * This is the default flag indicating whether or not to use caches to
    * store the data returned from a server
@@ -124,18 +127,18 @@
    * Indicates whether or not a connection has been established to the
    * destination specified in the URL
    */
-  protected boolean connected;
-
+  protected boolean connected = false;
+  
   /**
    * Indicates whether or not input can be read from this URL
    */
   protected boolean doInput = true;
-
+  
   /**
    * Indicates whether or not output can be sent to this URL
    */
-  protected boolean doOutput;
-
+  protected boolean doOutput = false;
+  
   /**
    * If this flag is set, the protocol is allowed to cache data whenever
    * it can (caching is not guaranteed). If it is not set, the protocol
@@ -155,16 +158,16 @@
    * modified more recently than the date set in this variable.  That date
    * should be specified as the number of seconds since 1/1/1970 GMT.
    */
-  protected long ifModifiedSince;
+  protected long ifModifiedSince = 0L;
 
   /**
    * This is the URL associated with this connection
    */
   protected URL url;
-  private static SimpleDateFormat dateFormat1;
-  private static SimpleDateFormat dateFormat2;
-  private static SimpleDateFormat dateFormat3;
-  private static boolean dateformats_initialized;
+
+  private static Hashtable handlers = new Hashtable();
+  private static SimpleDateFormat dateFormat1, dateFormat2, dateFormat3;
+  private static boolean dateformats_initialized = false;
 
   /**
    * Creates a URL connection to a given URL. A real connection is not made.
@@ -185,8 +188,6 @@
   /**
    * Establishes the actual connection to the URL associated with this
    * connection object
-   *
-   * @exception IOException if an error occurs
    */
   public abstract void connect() throws IOException;
 
@@ -229,7 +230,7 @@
   /**
    * Returns the value of the content-encoding field or null if it is not
    * known or not present.
-   *
+   * 
    * @return The content-encoding field
    */
   public String getContentEncoding()
@@ -294,7 +295,7 @@
    * Returns a String representing the value of the header field having
    * the named key.  Returns null if the header field does not exist.
    *
-   * @param name The key of the header field
+   * @param The key of the header field
    *
    * @return The value of the header field as a String
    */
@@ -306,9 +307,7 @@
 
   /**
    * Returns a map of all sent header fields
-   *
-   * @return all header fields
-   *
+   * 
    * @since 1.4
    */
   public Map getHeaderFields()
@@ -331,18 +330,18 @@
    */
   public int getHeaderFieldInt(String name, int defaultValue)
   {
-    String value = getHeaderField(name);
-
+    String value = getHeaderField (name);
+    
     if (value == null)
       return defaultValue;
 
     try
       {
-	return Integer.parseInt(value);
+        return Integer.parseInt (value);
       }
-    catch (NumberFormatException e)
-      {
-	return defaultValue;
+    catch (NumberFormatException e) 
+      { 
+        return defaultValue;
       }
   }
 
@@ -358,25 +357,25 @@
    * @return Returns the date value of the header filed or the default value
    * if the field is missing or malformed
    */
-  public long getHeaderFieldDate(String name, long defaultValue)
+  public long getHeaderFieldDate (String name, long defaultValue)
   {
     if (! dateformats_initialized)
-      initializeDateFormats();
-
+      initializeDateFormats ();
+    
     long result = defaultValue;
-    String str = getHeaderField(name);
-
+    String str = getHeaderField (name);
+    
     if (str != null)
       {
 	Date date;
-	if ((date = dateFormat1.parse(str, new ParsePosition(0))) != null)
-	  result = date.getTime();
-	else if ((date = dateFormat2.parse(str, new ParsePosition(0))) != null)
-	  result = date.getTime();
-	else if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)
-	  result = date.getTime();
+	if ((date = dateFormat1.parse (str, new ParsePosition (0))) != null)
+	  result = date.getTime ();
+	else if ((date = dateFormat2.parse (str, new ParsePosition (0))) != null)
+	  result = date.getTime ();
+	else if ((date = dateFormat3.parse (str, new ParsePosition (0))) != null)
+	  result = date.getTime ();
       }
-
+    
     return result;
   }
 
@@ -386,12 +385,12 @@
    * getHeaderField(int) method allows access to the corresponding value for
    * this tag.
    *
-   * @param index The index into the header field list to retrieve the key for.
+   * @param index The index into the header field list to retrieve the key for. 
    *
    * @return The header field key or null if index is past the end
    * of the headers.
    */
-  public String getHeaderFieldKey(int index)
+  public String getHeaderFieldKey (int index)
   {
     // Subclasses for specific protocols override this.
     return null;
@@ -408,7 +407,7 @@
    * This class first determines the MIME type of the content, then creates
    * a ContentHandler object to process the input.  If the ContentHandlerFactory
    * is set, then that object is called to load a content handler, otherwise
-   * a class called gnu.java.net.content.&lt;content_type&gt; is tried.
+   * a class called gnu.java.net.content.<content_type> is tried.
    * The default class will also be used if the content handler factory returns
    * a null content handler.
    *
@@ -418,50 +417,25 @@
    */
   public Object getContent() throws IOException
   {
-    //  connect();
-    String type = getContentType();
-
-    // First try the factory
-    ContentHandler ch = null;
-
-    if (factory != null)
-      ch = factory.createContentHandler(type);
-
-    if (ch != null)
-      return ch.getContent(this);
+    if (!connected)
+      connect();
 
-    // Then try our default class
-    try
-      {
-	Class cls =
-	  Class.forName("gnu.java.net.content." + type.replace('/', '.'));
-
-	Object obj = cls.newInstance();
+    // FIXME: Doc indicates that other criteria should be applied as
+    // heuristics to determine the true content type, e.g. see 
+    // guessContentTypeFromName() and guessContentTypeFromStream methods
+    // as well as FileNameMap class & fileNameMap field & get/set methods.
+    String type = getContentType();
+    ContentHandler ch = setContentHandler(type);
 
-	if (! (obj instanceof ContentHandler))
-	  throw new UnknownServiceException(type);
+    if (ch == null)
+      return getInputStream();
 
-	ch = (ContentHandler) obj;
-	return ch.getContent(this);
-      }
-    catch (ClassNotFoundException e)
-      {
-      }
-    catch (InstantiationException e)
-      {
-      }
-    catch (IllegalAccessException e)
-      {
-      }
-
-    throw new UnknownServiceException(type);
+    return ch.getContent(this);
   }
 
   /**
    * Retrieves the content of this URLConnection
    *
-   * @param classes The allowed classes for the content
-   *
    * @exception IOException If an error occurs
    * @exception UnknownServiceException If the protocol does not support the
    * content type
@@ -469,7 +443,7 @@
   public Object getContent(Class[] classes) throws IOException
   {
     // FIXME: implement this
-    return getContent();
+    return getContent ();
   }
 
   /**
@@ -506,8 +480,8 @@
   public InputStream getInputStream() throws IOException
   {
     // Subclasses for specific protocols override this.
-    throw new UnknownServiceException("Protocol " + url.getProtocol()
-                                      + " does not support input.");
+    throw new UnknownServiceException("Protocol " + url.getProtocol() +
+			" does not support input.");
   }
 
   /**
@@ -522,14 +496,14 @@
   public OutputStream getOutputStream() throws IOException
   {
     // Subclasses for specific protocols override this.
-    throw new UnknownServiceException("Protocol " + url.getProtocol()
-                                      + " does not support output.");
+    throw new UnknownServiceException("Protocol " + url.getProtocol() +
+			" does not support output.");
   }
 
   /**
    * The methods prints the value of this object as a String by calling the
    * toString() method of its associated URL.  Overrides Object.toString()
-   *
+   * 
    * @return A String representation of this object
    */
   public String toString()
@@ -541,7 +515,7 @@
    * Returns the value of a flag indicating whether or not input is going
    * to be done for this connection.  This default to true unless the
    * doOutput flag is set to false, in which case this defaults to false.
-   *
+   * 
    * @param input <code>true</code> if input is to be done,
    * <code>false</code> otherwise
    *
@@ -550,7 +524,7 @@
   public void setDoInput(boolean input)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     doInput = input;
   }
@@ -579,7 +553,7 @@
   public void setDoOutput(boolean output)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     doOutput = output;
   }
@@ -654,7 +628,7 @@
   public void setUseCaches(boolean usecaches)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     useCaches = usecaches;
   }
@@ -685,7 +659,7 @@
   public void setIfModifiedSince(long ifmodifiedsince)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     ifModifiedSince = ifmodifiedsince;
   }
@@ -721,9 +695,9 @@
    *
    * @param use true to use caches if possible by default, false otherwise
    */
-  public void setDefaultUseCaches(boolean use)
+  public void setDefaultUseCaches(boolean defaultusecaches)
   {
-    defaultUseCaches = use;
+    defaultUseCaches = defaultusecaches;
   }
 
   /**
@@ -731,23 +705,23 @@
    *
    * @param key The name of the property
    * @param value The value of the property
-   *
+   * 
    * @exception IllegalStateException If already connected
    * @exception NullPointerException If key is null
    *
    * @see URLConnection#getRequestProperty(String key)
    * @see URLConnection#addRequestProperty(String key, String value)
-   *
+   * 
    * @since 1.4
    */
   public void setRequestProperty(String key, String value)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     if (key == null)
-      throw new NullPointerException("key is null");
-
+      throw new NullPointerException ("key is null");
+    
     // Do nothing unless overridden by subclasses that support setting
     // header fields in the request.
   }
@@ -761,20 +735,20 @@
    *
    * @exception IllegalStateException If already connected
    * @exception NullPointerException If key is null
-   *
+   * 
    * @see URLConnection#getRequestProperty(String key)
    * @see URLConnection#setRequestProperty(String key, String value)
-   *
+   * 
    * @since 1.4
    */
   public void addRequestProperty(String key, String value)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     if (key == null)
-      throw new NullPointerException("key is null");
-
+      throw new NullPointerException ("key is null");
+    
     // Do nothing unless overridden by subclasses that support adding
     // header fields in the request.
   }
@@ -794,7 +768,7 @@
   public String getRequestProperty(String key)
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     // Overridden by subclasses that support reading header fields from the
     // request.
@@ -813,7 +787,7 @@
   public Map getRequestProperties()
   {
     if (connected)
-      throw new IllegalStateException("Already connected");
+      throw new IllegalStateException ("Already connected");
 
     // Overridden by subclasses that support reading header fields from the
     // request.
@@ -833,7 +807,7 @@
    *
    * @see URLConnection#setRequestProperty(String key, String value)
    */
-  public static void setDefaultRequestProperty(String key, String value)
+  public static void setDefaultRequestProperty (String key, String value)
   {
     // This method does nothing since JDK 1.3.
   }
@@ -846,7 +820,7 @@
    * @param key The request property to return the default value of
    *
    * @return The value of the default property or null if not available
-   *
+   * 
    * @deprecated 1.3 The method getRequestProperty should be used instead.
    * This method does nothing now.
    *
@@ -870,9 +844,10 @@
    * @exception SecurityException If a security manager exists and its
    * checkSetFactory method doesn't allow the operation
    */
-  public static synchronized void setContentHandlerFactory(ContentHandlerFactory factory)
+  public static synchronized void setContentHandlerFactory
+                                    (ContentHandlerFactory fac)
   {
-    if (URLConnection.factory != null)
+    if (factory != null)
       throw new Error("ContentHandlerFactory already set");
 
     // Throw an exception if an extant security mgr precludes
@@ -881,7 +856,7 @@
     if (s != null)
       s.checkSetFactory();
 
-    URLConnection.factory = factory;
+    factory = fac;
   }
 
   /**
@@ -898,14 +873,29 @@
    */
   public static String guessContentTypeFromName(String filename)
   {
-    return getFileNameMap().getContentTypeFor(filename.toLowerCase());
+    int dot = filename.lastIndexOf (".");
+    
+    if (dot != -1)
+      {
+	if (dot == filename.length())
+	  return ("application/octet-stream");
+	else
+	  filename = filename.substring (dot + 1);
+      }
+    
+    String type = MimeTypes.getMimeTypeFromExtension (filename);
+    
+    if (type == null)
+      return("application/octet-stream");
+
+    return type;
   }
 
   /**
    * Returns the MIME type of a stream based on the first few characters
    * at the beginning of the stream.  This routine can be used to determine
    * the MIME type if a server is believed to be returning an incorrect
-   * MIME type.  This method returns "application/octet-stream" if it
+   * MIME type.  This method returns "application/octet-stream" if it 
    * cannot determine the MIME type.
    * <p>
    * NOTE: Overriding MIME types sent from the server can be obnoxious
@@ -920,7 +910,10 @@
   public static String guessContentTypeFromStream(InputStream is)
     throws IOException
   {
-    return ("application/octet-stream");
+    is.mark(1024);
+    // FIXME: Implement this. Use system mimetype informations (like "file").
+    is.reset();
+    return null;
   }
 
   /**
@@ -931,12 +924,8 @@
    *
    * @since 1.2
    */
-  public static synchronized FileNameMap getFileNameMap()
+  public static FileNameMap getFileNameMap()
   {
-    // Delayed initialization.
-    if (fileNameMap == null)
-      fileNameMap = new MimeTypeMapper();
-
     return fileNameMap;
   }
 
@@ -948,7 +937,7 @@
    *
    * @exception SecurityException If a security manager exists and its
    * checkSetFactory method doesn't allow the operation
-   *
+   * 
    * @since 1.2
    */
   public static void setFileNameMap(FileNameMap map)
@@ -962,6 +951,86 @@
     fileNameMap = map;
   }
 
+  private ContentHandler setContentHandler(String contentType)
+  {
+    ContentHandler handler;
+
+    // No content type so just handle it as the default.
+    if (contentType == null || contentType.equals(""))
+      return null;
+
+    // See if a handler has been cached for this content type.
+    // For efficiency, if a content type has been searched for but not
+    // found, it will be in the hash table but as the contentType String
+    // instead of a ContentHandler.
+    if ((handler = (ContentHandler) handlers.get(contentType)) != null)
+      if (handler instanceof ContentHandler)
+	return handler;
+      else
+	return null;
+
+    // If a non-default factory has been set, use it to find the content type.
+    if (factory != null)
+      handler = factory.createContentHandler(contentType);
+
+    // Non-default factory may have returned null or a factory wasn't set.
+    // Use the default search algorithm to find a handler for this content type.
+    if (handler == null)
+      {
+	// Get the list of packages to check and append our default handler
+	// to it, along with the JDK specified default as a last resort.
+	// Except in very unusual environments the JDK specified one shouldn't
+	// ever be needed (or available).
+	String propVal = System.getProperty("java.content.handler.pkgs");
+	propVal = (propVal == null) ? "" : (propVal + "|");
+	propVal = propVal + "gnu.gcj.content|sun.net.www.content";
+
+	// Replace the '/' character in the content type with '.' and
+	// all other non-alphabetic, non-numeric characters with '_'.
+	StringTokenizer pkgPrefix = new StringTokenizer(propVal, "|");
+	char[] cArray = contentType.toCharArray();
+	for (int i = 0; i < cArray.length; i++)
+	  {
+	    if (cArray[i] == '/')
+	      cArray[i] = '.';
+	    else if (! ((cArray[i] >= 'A' && cArray[i] <= 'Z') || 
+			(cArray[i] >= 'a' && cArray[i] <= 'z') ||
+			(cArray[i] >= '0' && cArray[i] <= '9')))
+	      cArray[i] = '_';
+	  }
+	String contentClass = new String(cArray);
+
+	// See if a class of this content type exists in any of the packages.
+	do
+	  {
+	    String facName = pkgPrefix.nextToken() + "." + contentClass;
+	    try
+	      {
+		handler =
+		  (ContentHandler) Class.forName(facName).newInstance();
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null, go on to next element.
+	      }
+	  } while ((handler == null ||
+		    ! (handler instanceof ContentHandler)) &&
+		   pkgPrefix.hasMoreTokens());
+      }
+
+    // Update the hashtable with the new content handler.
+    if (handler != null && handler instanceof ContentHandler)
+      {
+	handlers.put(contentType, handler);
+	return handler;
+      }
+
+    // For efficiency on subsequent searches, put a dummy entry in the hash
+    // table for content types that don't have a non-default ContentHandler.
+    handlers.put(contentType, contentType);
+    return null;
+  }
+  
   // We don't put these in a static initializer, because it creates problems
   // with initializer co-dependency: SimpleDateFormat's constructors eventually 
   // depend on URLConnection (via the java.text.*Symbols classes).
@@ -971,10 +1040,10 @@
       return;
 
     Locale locale = new Locale("En", "Us", "Unix");
-    dateFormat1 =
-      new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", locale);
-    dateFormat2 =
-      new SimpleDateFormat("EEEE, dd-MMM-yy hh:mm:ss 'GMT'", locale);
+    dateFormat1 = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", 
+                                       locale);
+    dateFormat2 = new SimpleDateFormat("EEEE, dd-MMM-yy hh:mm:ss 'GMT'", 
+                                       locale);
     dateFormat3 = new SimpleDateFormat("EEE MMM d hh:mm:ss yyyy", locale);
     dateformats_initialized = true;
   }
