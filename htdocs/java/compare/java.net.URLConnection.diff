--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URLConnection.java	2003-05-03 02:23:09.000000000 -0600
+++ java/net/URLConnection.java	2003-05-09 02:27:01.000000000 -0600
@@ -42,11 +42,15 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.security.Permission;
-import java.util.Collections;
+import java.security.AllPermission;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.Hashtable;
 import java.util.Map;
+import java.util.StringTokenizer;
+import gnu.gcj.io.MimeTypes;
 
 /**
  * Written using on-line Java Platform 1.2 API Specification, as well
@@ -93,8 +97,8 @@
    * to do this is implemented by this class, so just create an empty
    * instance and store it here.
    */
-  private static FileNameMap fileNameMap = new MimeTypeMapper();
-
+  private static FileNameMap fileNameMap;
+ 
   /**
    * This is the ContentHandlerFactory set by the caller, if any
    */
@@ -113,11 +117,6 @@
   private static boolean defaultUseCaches = true;
 
   /**
-   * This is a Hashable for setting default request properties
-   */
-  private static Hashtable def_req_props = new Hashtable();
-
-  /**
    * This variable determines whether or not interaction is allowed with
    * the user.  For example, to prompt for a username and password.
    */
@@ -165,10 +164,11 @@
    */
   protected URL url;
 
-  /**
-   * The list of request properties for this connection
-   */
-  private final Hashtable req_props;
+  private static ContentHandler contentHandler;
+  private static Hashtable handlers = new Hashtable();
+  private static Locale locale; 
+  private static SimpleDateFormat dateFormat1, dateFormat2, dateFormat3;
+  private static boolean dateformats_initialized = false;
 
   /**
    * Creates a URL connection to a given URL. A real connection is not made.
@@ -184,7 +184,6 @@
     this.url = url;
     allowUserInteraction = defaultAllowUserInteraction;
     useCaches = defaultUseCaches;
-    req_props = new Hashtable(def_req_props);
   }
 
   /**
@@ -226,11 +225,7 @@
    */
   public String getContentType()
   {
-    String type = getHeaderField("content-type");
-    if (type == null)
-      type = guessContentTypeFromName(getURL().getFile());
-
-    return(type);
+    return getHeaderField("content-type");
   }
 
   /**
@@ -307,15 +302,19 @@
    */
   public String getHeaderField(String name)
   {
-    for (int i = 0; ; i++)
-      {
-        String key = getHeaderFieldKey(i);
-        if (key == null)
-          return(null);
+    // Subclasses for specific protocols override this.
+    return null;
+  }
 
-        if (key.toLowerCase().equals(name.toLowerCase()))
-          return(getHeaderField(i));
-      }
+  /**
+   * Returns a map of all sent header fields
+   * 
+   * @since 1.4
+   */
+  public Map getHeaderFields()
+  {
+    // Subclasses for specific protocols override this.
+    return null;
   }
 
   /**
@@ -323,59 +322,54 @@
    * is not present or cannot be parsed as an integer, the default value
    * will be returned.
    *
-   * @param key The header field key to lookup
-   * @param def The defaule value if the header field is not found
-   * or can't be parsed.
+   * @param name The name of the header field
+   * @param val The default value
    *
    * @return The value of the header field or the default value if the field
    * is missing or malformed
    */
-  public int getHeaderFieldInt(String key, int def)
+  public int getHeaderFieldInt(String name, int val)
   {
-    String value = getHeaderField(key);
-    if (value == null)
-      return(def);
-
-    int retval = def;
+    String str = getHeaderField(name);
     try
       {
-        retval = Integer.parseInt(value);
+	if (str != null)
+	  val = Integer.parseInt(str);
       }
-    catch (NumberFormatException e) 
-      { 
-        return(def);
+    catch (NumberFormatException e)
+      {
+	; // Do nothing; val is the default.
       }
-
-    return(retval);
-  } 
+    return val;
+  }
 
   /**
    * Returns the value of the named header field as a date.  This date will
    * be the number of seconds since midnight 1/1/1970 GMT or the default
    * value if the field is not present or cannot be converted to a date.
    *
-   * @param key The header field key to lookup
-   * @param def The default value if the header field is not found
-   * or can't be converted.
-   */
-  public long getHeaderFieldDate(String key, long def)
-  {
-    String value = getHeaderField(key);
-    if (value == null)
-      return(def);
-
-    // This needs to change since Date(String) is deprecated, but DateFormat
-    // doesn't seem to be working for some reason
-    //DateFormat df = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);
-    //df.setLenient(true);
-
-    //Date d = df.parse(value, new ParsePosition(0));
-    Date d = new Date(value);
-
-    if (d == null)
-      return(def);
-       
-    return(d.getTime() / 1000);
+   * @param name The name of the header field
+   * @param val The dafault date
+   *
+   * @return Returns the date value of the header filed or the default value
+   * if the field is missing or malformed
+   */
+  public long getHeaderFieldDate(String name, long val)
+  {
+    if (! dateformats_initialized)
+      initializeDateFormats();
+    String str = getHeaderField(name);
+    if (str != null)
+      {
+        Date date;
+	if ((date = dateFormat1.parse(str, new ParsePosition(0))) != null)
+	  val = date.getTime();
+	else if ((date = dateFormat2.parse(str, new ParsePosition(0))) != null)
+	  val = date.getTime();
+	else if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)
+	  val = date.getTime();
+      }
+    return val;
   }
 
   /**
@@ -416,41 +410,29 @@
    */
   public Object getContent() throws IOException
   {
-    //  connect();
-    String type = getContentType();
-
-    // First try the factory
-    ContentHandler ch = null;
-    if (factory != null)
-      ch = factory.createContentHandler(type);
-
-    if (ch != null)
-      return(ch.getContent(this));
-
-    // Then try our default class
-    try
-      {
-        Class cls = Class.forName("gnu.java.net.content." + 
-                                  type.replace('/', '.'));
-     
-        Object obj = cls.newInstance();
-        if (!(obj instanceof ContentHandler))
-          throw new UnknownServiceException(type);
+    // FIXME: Doc indicates that other criteria should be applied as
+    // heuristics to determine the true content type, e.g. see 
+    // guessContentTypeFromName() and guessContentTypeFromStream methods
+    // as well as FileNameMap class & fileNameMap field & get/set methods.
+    String cType = getContentType();
+    contentHandler = setContentHandler(cType);
+    if (contentHandler == null)
+      return getInputStream();
 
-        ch = (ContentHandler)obj;
-        return(ch.getContent(this));
-      }
-    catch (ClassNotFoundException e)
-      {
-      }
-    catch (InstantiationException e)
-      {
-      }
-    catch (IllegalAccessException e)
-      {
-      }
+    return contentHandler.getContent(this);
+  }
 
-    throw new UnknownServiceException(type);
+  /**
+   * Retrieves the content of this URLConnection
+   *
+   * @exception IOException If an error occurs
+   * @exception UnknownServiceException If the protocol does not support the
+   * content type
+   */
+  public Object getContent(Class[] classes) throws IOException
+  {
+    // FIXME: implement this
+    return getContent ();
   }
 
   /**
@@ -486,7 +468,9 @@
    */
   public InputStream getInputStream() throws IOException
   {
-    return(null);
+    // Subclasses for specific protocols override this.
+    throw new UnknownServiceException("Protocol " + url.getProtocol() +
+			" does not support input.");
   }
 
   /**
@@ -500,7 +484,9 @@
    */
   public OutputStream getOutputStream() throws IOException
   {
-    return(null);
+    // Subclasses for specific protocols override this.
+    throw new UnknownServiceException("Protocol " + url.getProtocol() +
+			" does not support output.");
   }
 
   /**
@@ -511,15 +497,17 @@
    */
   public String toString()
   {
-    return(url.toString());
+    return this.getClass().getName() + ":" + url.toString();
   }
 
   /**
    * Returns the value of a flag indicating whether or not input is going
    * to be done for this connection.  This default to true unless the
    * doOutput flag is set to false, in which case this defaults to false.
+   * 
+   * @param doinput The new value of the doInput field
    *
-   * @param input true if input is to be done, false otherwise
+   * @exception IllegalStateException If already connected
    */
   public void setDoInput(boolean input)
   {
@@ -621,14 +609,16 @@
    * Sets a boolean flag indicating whether or not caching will be used
    * (if possible) to store data downloaded via the connection.
    *
-   * @param use_cache true if caching should be used if possible,
-   * false otherwise.
+   * @param usecaches The new value
    *
    * @exception IllegalStateException If already connected
    */
-  public void setUseCaches(boolean use_caches)
+  public void setUseCaches(boolean usecaches)
   {
-    useCaches = use_caches;
+    if (connected)
+      throw new IllegalStateException ("Already connected");
+
+    useCaches = usecaches;
   }
 
   /**
@@ -649,13 +639,17 @@
    * passed should  be 0 if this feature is to be disabled or the time expressed
    * as the number of seconds since midnight 1/1/1970 GMT otherwise.
    *
-   * @param modified_since The new ifModifiedSince value
+   * @param ifmodifiedsince The new value in milliseconds
+   * since January 1, 1970 GMT
    *
    * @exception IllegalStateException If already connected
    */
-  public void setIfModifiedSince(long modified_since)
+  public void setIfModifiedSince(long ifmodifiedsince)
   {
-    ifModifiedSince = modified_since;
+    if (connected)
+      throw new IllegalStateException ("Already connected");
+
+    ifModifiedSince = ifmodifiedsince;
   }
 
   /**
@@ -673,44 +667,69 @@
   }
 
   /**
+   * Returns the default value of the useCaches field
+   */
+  public boolean getDefaultUseCaches()
+  {
+    return defaultUseCaches;
+  }
+
+  /**
    * Sets the default value used to determine whether or not caching
    * of documents will be done when possible.
    *
    * @param use true to use caches if possible by default, false otherwise
    */
-  public synchronized void setDefaultUseCaches(boolean use)
+  public void setDefaultUseCaches(boolean defaultusecaches)
   {
-    defaultUseCaches = use;
+    defaultUseCaches = defaultusecaches;
   }
 
   /**
    * Returns the default value used to determine whether or not caching
    * of documents will be done when possible.
    *
-   * @return true if caches will be used, false otherwise
+   * @param key Key of the property to set
+   * @param value Value of the Property to set
+   *
+   * @exception IllegalStateException If already connected
+   * @exception NullPointerException If key is null
    *
    * @see URLConnection#getRequestProperty(String key)
    * @see URLConnection#addRequestProperty(String key, String value)
    */
-  public boolean getDefaultUseCaches()
+  public void setRequestProperty(String key, String value)
   {
-    return defaultUseCaches;
+    if (connected)
+      throw new IllegalStateException ("Already connected");
+
+    // Do nothing unless overridden by subclasses that support setting
+    // header fields in the request.
   }
 
   /**
    * Sets the value of the named request property
    *
-   * @param key The name of the property
-   * @param value The value of the property
+   * @param key Key of the property to add
+   * @param value Value of the Property to add
+   *
+   * @exception IllegalStateException If already connected
+   * @exception NullPointerException If key is null
    * 
    * @see URLConnection#getRequestProperty(String key)
    * @see URLConnection#setRequestProperty(String key, String value)
    * 
    * @since 1.4
    */
-  public void setRequestProperty(String key, String value)
+  public void addRequestProperty(String key, String value)
   {
-    req_props.put(key.toLowerCase(), value);
+    if (connected)
+      throw new IllegalStateException ("Already connected");
+
+    if (getRequestProperty (key) == null)
+      {
+        setRequestProperty (key, value);
+      }
   }
 
   /**
@@ -727,7 +746,12 @@
    */
   public String getRequestProperty(String key)
   {
-    return((String)req_props.get(key.toLowerCase()));
+    if (connected)
+      throw new IllegalStateException ("Already connected");
+
+    // Overridden by subclasses that support reading header fields from the
+    // request.
+    return null;
   }
 
   /**
@@ -741,7 +765,9 @@
    */
   public Map getRequestProperties()
   {
-    return Collections.unmodifiableMap(req_props);
+    // Overridden by subclasses that support reading header fields from the
+    // request.
+    return null;
   }
 
   /**
@@ -756,10 +782,10 @@
    *
    * @see URLConnectionr#setRequestProperty(String key, String value)
    */
-  public static synchronized void setDefaultRequestProperty (String key,
-                                                             String value)
+  public static void setDefaultRequestProperty(String key, String value)
   {
-    def_req_props.put(key.toLowerCase(), value);
+    // Do nothing unless overridden by subclasses that support setting
+    // default request properties.
   }
 
   /**
@@ -777,7 +803,8 @@
    */
   public static String getDefaultRequestProperty(String key)
   {
-    return((String)def_req_props.get(key.toLowerCase()));
+    // Overridden by subclasses that support default request properties.
+    return null;
   }
 
   /**
@@ -821,7 +848,22 @@
    */
   public static String guessContentTypeFromName(String filename)
   {
-    return(fileNameMap.getContentTypeFor(filename.toLowerCase()));
+    int dot = filename.lastIndexOf (".");
+    
+    if (dot != -1)
+      {
+	if (dot == filename.length())
+	  return ("application/octet-stream");
+	else
+	  filename = filename.substring (dot + 1);
+      }
+    
+    String type = MimeTypes.getMimeTypeFromExtension (filename);
+    
+    if (type == null)
+      return("application/octet-stream");
+
+    return type;
   }
 
   /**
@@ -843,7 +885,10 @@
   public static String guessContentTypeFromStream(InputStream is)
     throws IOException
   {
-    return("application/octet-stream");
+    is.mark(1024);
+    // FIXME: Implement this. Use system mimetype informations (like "file").
+    is.reset();
+    return null;
   }
 
   /**
@@ -880,5 +925,101 @@
 
     fileNameMap = map;
   }
+
+  private ContentHandler setContentHandler(String contentType)
+  {
+    ContentHandler handler;
+
+    // No content type so just handle it as the default.
+    if (contentType == null || contentType == "")
+      return null;
+
+    // See if a handler has been cached for this content type.
+    // For efficiency, if a content type has been searched for but not
+    // found, it will be in the hash table but as the contentType String
+    // instead of a ContentHandler.
+    if ((handler = (ContentHandler) handlers.get(contentType)) != null)
+      if (handler instanceof ContentHandler)
+	return handler;
+      else
+	return null;
+
+    // If a non-default factory has been set, use it to find the content type.
+    if (factory != null)
+      handler = factory.createContentHandler(contentType);
+
+    // Non-default factory may have returned null or a factory wasn't set.
+    // Use the default search algorithm to find a handler for this content type.
+    if (handler == null)
+      {
+	// Get the list of packages to check and append our default handler
+	// to it, along with the JDK specified default as a last resort.
+	// Except in very unusual environments the JDK specified one shouldn't
+	// ever be needed (or available).
+	String propVal = System.getProperty("java.content.handler.pkgs");
+	propVal = (propVal == null) ? "" : (propVal + "|");
+	propVal = propVal + "gnu.gcj.content|sun.net.www.content";
+
+	// Replace the '/' character in the content type with '.' and
+	// all other non-alphabetic, non-numeric characters with '_'.
+	StringTokenizer pkgPrefix = new StringTokenizer(propVal, "|");
+	char[] cArray = contentType.toCharArray();
+	for (int i = 0; i < cArray.length; i++)
+	  {
+	    if (cArray[i] == '/')
+	      cArray[i] = '.';
+	    else if (! ((cArray[i] >= 'A' && cArray[i] <= 'Z') || 
+			(cArray[i] >= 'a' && cArray[i] <= 'z') ||
+			(cArray[i] >= '0' && cArray[i] <= '9')))
+	      cArray[i] = '_';
+	  }
+	String contentClass = new String(cArray);
+
+	// See if a class of this content type exists in any of the packages.
+	do
+	  {
+	    String facName = pkgPrefix.nextToken() + "." + contentClass;
+	    try
+	      {
+		handler =
+		  (ContentHandler) Class.forName(facName).newInstance();
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null, go on to next element.
+	      }
+	  } while ((handler == null ||
+		    ! (handler instanceof ContentHandler)) &&
+		   pkgPrefix.hasMoreTokens());
+      }
+
+    // Update the hashtable with the new content handler.
+    if (handler != null && handler instanceof ContentHandler)
+      {
+	handlers.put(contentType, handler);
+	return handler;
+      }
+
+    // For efficiency on subsequent searches, put a dummy entry in the hash
+    // table for content types that don't have a non-default ContentHandler.
+    handlers.put(contentType, contentType);
+    return null;
+  }
+  
+  // We don't put these in a static initializer, because it creates problems
+  // with initializer co-dependency: SimpleDateFormat's constructors eventually 
+  // depend on URLConnection (via the java.text.*Symbols classes).
+  private synchronized void initializeDateFormats()
+  {
+    if (dateformats_initialized)
+      return;
+    locale = new Locale("En", "Us", "Unix");
+    dateFormat1 = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", 
+                                       locale);
+    dateFormat2 = new SimpleDateFormat("EEEE, dd-MMM-yy hh:mm:ss 'GMT'", 
+                                       locale);
+    dateFormat3 = new SimpleDateFormat("EEE MMM d hh:mm:ss yyyy", locale);
+    dateformats_initialized = true;
+  }
 } // class URLConnection
 
