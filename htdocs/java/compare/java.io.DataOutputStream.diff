--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/DataOutputStream.java	Mon Mar 24 02:18:31 2003
+++ java/io/DataOutputStream.java	Tue Mar 25 02:17:55 2003
@@ -56,48 +56,6 @@
  */
 public class DataOutputStream extends FilterOutputStream implements DataOutput
 {
-  
-  private byte[] buf = new byte[8];
-  
-  // FIXME: This method should eventually die.  I'd bet there are
-  // at least half a dozen UTF converters scattered throughout the
-  // code.  String getBytes("UTF-8") would work as well, but might
-  // have higher overhead. Perhaps a shared internal method for
-  // this someplace?
-  static final byte[] convertToUTF(String s) throws IOException
-  {
-    ByteArrayOutputStream os = new ByteArrayOutputStream(s.length());
-  
-    for (int i = 0; i < s.length(); i++)
-      {
-        char c = s.charAt(i);
-        if ((c <= 0x007F) && (c != 0))
-          {
-            os.write(c);
-          }
-        else if ((c <= 0x07FF) || (c == 0))
-          {
-            byte b1 = (byte)(0xC0 | (c >> 6));
-            byte b2 = (byte)(0x80 | (c & 0x3F));
-  
-            os.write(b1);
-            os.write(b2);
-          }
-        else
-          {
-            byte b1 = (byte)(0xE0 | (c >> 12));
-            byte b2 = (byte)(0x80 | ((c >> 6) & 0x3F));
-            byte b3 = (byte)(0x80 | (c & 0x3F));
-  
-            os.write(b1);
-            os.write(b2);
-            os.write(b3);
-          }
-      }
-  
-    return(os.toByteArray());
-  }
-  
   /**
    * This is the total number of bytes that have been written to the
    * stream by this object instance.
@@ -208,12 +166,10 @@
    *
    * @exception IOException If an error occurs
    */
-  public final synchronized void writeShort (int s) throws IOException
+  public final void writeShort (int v) throws IOException
   {
-    buf[0] = (byte)((s & 0xff00) >> 8);
-    buf[1] = (byte)(s & 0x00ff);
-  
-    write(buf, 0, 2);
+    write ((byte) (0xff & (v >> 8)));
+    write ((byte) (0xff & v));
   }
 
   /**
@@ -225,12 +181,10 @@
    *
    * @exception IOException If an error occurs
    */
-  public final synchronized void writeChar (int c) throws IOException
+  public final void writeChar (int v) throws IOException
   {
-    buf[0] = (byte)((c & 0xff00) >> 8);
-    buf[1] = (byte)((int)c & 0x00ff);
-  
-    write(buf, 0, 2);
+    write ((byte) (0xff & (v >> 8)));
+    write ((byte) (0xff & v));
   }
 
   /**
@@ -241,14 +195,12 @@
    *
    * @exception IOException If an error occurs
    */
-  public final synchronized void writeInt (int v) throws IOException
+  public final void writeInt (int v) throws IOException
   {
-    buf[0] = (byte)((v & 0xff000000) >> 24);
-    buf[1] = (byte)((v & 0x00ff0000) >> 16);
-    buf[2] = (byte)((v & 0x0000ff00) >> 8);
-    buf[3] = (byte)(v & 0x000000ff);
-  
-    write(buf, 0, 4);
+    write ((byte) (0xff & (v >> 24)));
+    write ((byte) (0xff & (v >> 16)));
+    write ((byte) (0xff & (v >>  8)));
+    write ((byte) (0xff & v));
   }
 
   /**
@@ -259,18 +211,16 @@
    *
    * @exception IOException If an error occurs
    */
-  public final synchronized void writeLong (long v) throws IOException
+  public final void writeLong (long v) throws IOException
   {
-    buf[0] = (byte)((v & 0xff00000000000000L) >> 56);
-    buf[1] = (byte)((v & 0x00ff000000000000L) >> 48);
-    buf[2] = (byte)((v & 0x0000ff0000000000L) >> 40);
-    buf[3] = (byte)((v & 0x000000ff00000000L) >> 32);
-    buf[4] = (byte)((v & 0x00000000ff000000L) >> 24);
-    buf[5] = (byte)((v & 0x0000000000ff0000L) >> 16);
-    buf[6] = (byte)((v & 0x000000000000ff00L) >> 8);
-    buf[7] = (byte)(v & 0x00000000000000ffL);
-  
-    write(buf, 0, 8);
+    write ((byte) (0xff & (v >> 56)));
+    write ((byte) (0xff & (v >> 48)));
+    write ((byte) (0xff & (v >> 40)));
+    write ((byte) (0xff & (v >> 32)));
+    write ((byte) (0xff & (v >> 24)));
+    write ((byte) (0xff & (v >> 16)));
+    write ((byte) (0xff & (v >>  8)));
+    write ((byte) (0xff & v));
   }
 
   /**
@@ -325,15 +275,8 @@
   public final void writeBytes (String s) throws IOException
   {
     int len = s.length();
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len];
-  
-    for (int i = 0; i < len; i++)
-      buf[i] = (byte)(s.charAt(i) & 0xff);
-  
-    write(buf, 0, buf.length);
+    for (int i = 0; i < len; ++i)
+      writeByte (s.charAt(i));
   }
 
   /**
@@ -348,18 +291,8 @@
   public final void writeChars (String s) throws IOException
   {
     int len = s.length();
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len * 2];
-  
-    for (int i = 0; i < len; i++)
-      {
-        buf[i * 2] = (byte)((s.charAt(i) & 0xff00) >> 8);
-        buf[(i * 2) + 1] = (byte)(s.charAt(i) & 0x00ff);
-      }
-  
-    write(buf, 0, buf.length);
+    for (int i = 0; i < len; ++i)
+      writeChar (s.charAt(i));
   }
 
   /**
@@ -389,17 +322,47 @@
    *
    * @exception IOException If an error occurs
    */
-  public synchronized final void writeUTF (String v) throws IOException
+  public final void writeUTF (String s) throws IOException
   {
-    // FIXME:  Stylistically, replacing this with s.getBytes("UTF-8")
-    // would be better. However, that's likely to be expensive because of
-    // the char encoder overhead. Maybe we should have an easily
-    // invokable UTF-8 converter function, but I'm not sure this is the
-    // right class for it to live in. 
-    byte[] buf = convertToUTF(v);
-  
-    writeShort(buf.length);
-    write(buf, 0, buf.length);
+    int len = s.length();
+    int sum = 0;
+
+    for (int i = 0; i < len && sum <= 65535; ++i)
+      {
+	char c = s.charAt(i);
+	if (c >= '\u0001' && c <= '\u007f')
+	  sum += 1;
+	else if (c == '\u0000' || (c >= '\u0080' && c <= '\u07ff'))
+	  sum += 2;
+	else
+	  sum += 3;
+      }
+
+    if (sum > 65535)
+      throw new UTFDataFormatException ();
+
+    writeShort (sum);
+
+    for (int i = 0; i < len; ++i)
+      {
+	char c = s.charAt(i);
+	if (c >= '\u0001' && c <= '\u007f')
+	  write (c);
+	else if (c == '\u0000' || (c >= '\u0080' && c <= '\u07ff'))
+	  {
+	    write (0xc0 | (0x1f & (c >> 6)));
+	    write (0x80 | (0x3f & c));
+	  }
+	else
+	  {
+	    // JSL says the first byte should be or'd with 0xc0, but
+	    // that is a typo.  Unicode says 0xe0, and that is what is
+	    // consistent with DataInputStream.
+	    write (0xe0 | (0x0f & (c >> 12)));
+	    write (0x80 | (0x3f & (c >> 6)));
+	    write (0x80 | (0x3f & c));
+	  }
+      }
   }
 
 } // class DataOutputStream
