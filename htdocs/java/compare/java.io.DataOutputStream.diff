--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/DataOutputStream.java	Tue Apr  8 02:23:45 2003
+++ java/io/DataOutputStream.java	Tue Mar 25 02:17:55 2003
@@ -56,48 +56,6 @@
  */
 public class DataOutputStream extends FilterOutputStream implements DataOutput
 {
-  
-  private byte[] buf = new byte[8];
-  
-  // FIXME: This method should eventually die.  I'd bet there are
-  // at least half a dozen UTF converters scattered throughout the
-  // code.  String getBytes("UTF-8") would work as well, but might
-  // have higher overhead. Perhaps a shared internal method for
-  // this someplace?
-  static final byte[] convertToUTF(String s) throws IOException
-  {
-    ByteArrayOutputStream os = new ByteArrayOutputStream(s.length());
-  
-    for (int i = 0; i < s.length(); i++)
-      {
-        char c = s.charAt(i);
-        if ((c <= 0x007F) && (c != 0))
-          {
-            os.write(c);
-          }
-        else if ((c <= 0x07FF) || (c == 0))
-          {
-            byte b1 = (byte)(0xC0 | (c >> 6));
-            byte b2 = (byte)(0x80 | (c & 0x3F));
-  
-            os.write(b1);
-            os.write(b2);
-          }
-        else
-          {
-            byte b1 = (byte)(0xE0 | (c >> 12));
-            byte b2 = (byte)(0x80 | ((c >> 6) & 0x3F));
-            byte b3 = (byte)(0x80 | (c & 0x3F));
-  
-            os.write(b1);
-            os.write(b2);
-            os.write(b3);
-          }
-      }
-  
-    return(os.toByteArray());
-  }
-  
   /**
    * This is the total number of bytes that have been written to the
    * stream by this object instance.
@@ -172,19 +130,13 @@
   }
 
   /**
-   * This method writes a Java boolean value to an output stream.  If
-   * <code>value</code> is <code>true</code>, a byte with the value of
-   * 1 will be written, otherwise a byte with the value of 0 will be
-   * written.
+   * This method writes a Java <code>boolean</code> to the underlying output 
+   * stream. For a value of <code>true</code>, 1 is written to the stream.
+   * For a value of <code>false</code>, 0 is written.
    *
-   * The value written can be read using the <code>readBoolean</code>
-   * method in <code>DataInput</code>.
-   *
-   * @param value The boolean value to write
+   * @param b The <code>boolean</code> value to write to the stream
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readBoolean
    */
   public final void writeBoolean (boolean v) throws IOException
   {
@@ -192,19 +144,13 @@
   }
 
   /**
-   * This method writes a Java byte value to an output stream.  The
-   * byte to be written will be in the lowest 8 bits of the
-   * <code>int</code> value passed.
+   * This method writes a Java <code>byte</code> value to the underlying
+   * output stream.
    *
-   * The value written can be read using the <code>readByte</code> or
-   * <code>readUnsignedByte</code> methods in <code>DataInput</code>.
-   *
-   * @param value The int value to write
+   * @param b The <code>byte</code> to write to the stream, passed as 
+   * the low eight bits of an <code>int</code>.
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readByte
-   * @see DataInput#readUnsignedByte
    */
   public final void writeByte (int v) throws IOException
   {
@@ -212,146 +158,84 @@
   }
 
   /**
-   * This method writes a Java short value to an output stream.  The
-   * char to be written will be in the lowest 16 bits of the <code>int</code>
-   * value passed.  These bytes will be written "big endian".  That is,
-   * with the high byte written first in the following manner:
-   * <p>
-   * <code>byte0 = (byte)((value & 0xFF00) >> 8);<br>
-   * byte1 = (byte)(value & 0x00FF);</code>
-   * <p>
+   * This method writes a Java <code>short</code> to the stream, high byte
+   * first.  This method requires two bytes to encode the value.
    *
-   * The value written can be read using the <code>readShort</code> and
-   * <code>readUnsignedShort</code> methods in <code>DataInput</code>.
-   *
-   * @param value The int value to write as a 16-bit value
+   * @param s The <code>short</code> value to write to the stream,
+   * passed as an <code>int</code>.
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readShort
-   * @see DataInput#readUnsignedShort
    */
-  public final synchronized void writeShort (int s) throws IOException
+  public final void writeShort (int v) throws IOException
   {
-    buf[0] = (byte)((s & 0xff00) >> 8);
-    buf[1] = (byte)(s & 0x00ff);
-  
-    write(buf, 0, 2);
+    write ((byte) (0xff & (v >> 8)));
+    write ((byte) (0xff & v));
   }
 
   /**
-   * This method writes a Java char value to an output stream.  The
-   * char to be written will be in the lowest 16 bits of the <code>int</code>
-   * value passed.  These bytes will be written "big endian".  That is,
-   * with the high byte written first in the following manner:
-   * <p>
-   * <code>byte0 = (byte)((value & 0xFF00) >> 8);<br>
-   * byte1 = (byte)(value & 0x00FF);</code>
-   * <p>
+   * This method writes a single <code>char</code> value to the stream,
+   * high byte first.
    *
-   * The value written can be read using the <code>readChar</code>
-   * method in <code>DataInput</code>.
-   *
-   * @param value The char value to write
+   * @param c The <code>char</code> value to write, 
+   * passed as an <code>int</code>.
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readChar
    */
-  public final synchronized void writeChar (int c) throws IOException
+  public final void writeChar (int v) throws IOException
   {
-    buf[0] = (byte)((c & 0xff00) >> 8);
-    buf[1] = (byte)((int)c & 0x00ff);
-  
-    write(buf, 0, 2);
+    write ((byte) (0xff & (v >> 8)));
+    write ((byte) (0xff & v));
   }
 
   /**
-   * This method writes a Java int value to an output stream.  The 4 bytes
-   * of the passed value will be written "big endian".  That is, with
-   * the high byte written first in the following manner:
-   * <p>
-   * <code>byte0 = (byte)((value & 0xFF000000) >> 24);<br>
-   * byte1 = (byte)((value & 0x00FF0000) >> 16);<br>
-   * byte2 = (byte)((value & 0x0000FF00) >> 8);<br>
-   * byte3 = (byte)(value & 0x000000FF);</code>
-   * <p>
+   * This method writes a Java <code>int</code> to the stream, high bytes
+   * first.  This method requires four bytes to encode the value.
    *
-   * The value written can be read using the <code>readInt</code>
-   * method in <code>DataInput</code>.
-   *
-   * @param value The int value to write
+   * @param i The <code>int</code> value to write to the stream.
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readInt
    */
-  public final synchronized void writeInt (int v) throws IOException
+  public final void writeInt (int v) throws IOException
   {
-    buf[0] = (byte)((v & 0xff000000) >> 24);
-    buf[1] = (byte)((v & 0x00ff0000) >> 16);
-    buf[2] = (byte)((v & 0x0000ff00) >> 8);
-    buf[3] = (byte)(v & 0x000000ff);
-  
-    write(buf, 0, 4);
+    write ((byte) (0xff & (v >> 24)));
+    write ((byte) (0xff & (v >> 16)));
+    write ((byte) (0xff & (v >>  8)));
+    write ((byte) (0xff & v));
   }
 
   /**
-   * This method writes a Java long value to an output stream.  The 8 bytes
-   * of the passed value will be written "big endian".  That is, with
-   * the high byte written first in the following manner:
-   * <p>
-   * <code>byte0 = (byte)((value & 0xFF00000000000000L) >> 56);<br>
-   * byte1 = (byte)((value & 0x00FF000000000000L) >> 48);<br>
-   * byte2 = (byte)((value & 0x0000FF0000000000L) >> 40);<br>
-   * byte3 = (byte)((value & 0x000000FF00000000L) >> 32);<br>
-   * byte4 = (byte)((value & 0x00000000FF000000L) >> 24);<br>
-   * byte5 = (byte)((value & 0x0000000000FF0000L) >> 16);<br>
-   * byte6 = (byte)((value & 0x000000000000FF00L) >> 8);<br>
-   * byte7 = (byte)(value & 0x00000000000000FFL);</code>
-   * <p>
+   * This method writes a Java <code>long</code> to the stream, high bytes
+   * first.  This method requires eight bytes to encode the value.
    *
-   * The value written can be read using the <code>readLong</code>
-   * method in <code>DataInput</code>.
-   *
-   * @param value The long value to write
+   * @param l The <code>long</code> value to write to the stream.
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readLong
    */
-  public final synchronized void writeLong (long v) throws IOException
+  public final void writeLong (long v) throws IOException
   {
-    buf[0] = (byte)((v & 0xff00000000000000L) >> 56);
-    buf[1] = (byte)((v & 0x00ff000000000000L) >> 48);
-    buf[2] = (byte)((v & 0x0000ff0000000000L) >> 40);
-    buf[3] = (byte)((v & 0x000000ff00000000L) >> 32);
-    buf[4] = (byte)((v & 0x00000000ff000000L) >> 24);
-    buf[5] = (byte)((v & 0x0000000000ff0000L) >> 16);
-    buf[6] = (byte)((v & 0x000000000000ff00L) >> 8);
-    buf[7] = (byte)(v & 0x00000000000000ffL);
-  
-    write(buf, 0, 8);
+    write ((byte) (0xff & (v >> 56)));
+    write ((byte) (0xff & (v >> 48)));
+    write ((byte) (0xff & (v >> 40)));
+    write ((byte) (0xff & (v >> 32)));
+    write ((byte) (0xff & (v >> 24)));
+    write ((byte) (0xff & (v >> 16)));
+    write ((byte) (0xff & (v >>  8)));
+    write ((byte) (0xff & v));
   }
 
   /**
    * This method writes a Java <code>float</code> value to the stream.  This
-   * value is written by first calling the method
+   * value is written by first calling the method 
    * <code>Float.floatToIntBits</code>
    * to retrieve an <code>int</code> representing the floating point number,
    * then writing this <code>int</code> value to the stream exactly the same
    * as the <code>writeInt()</code> method does.
    *
-   * The value written can be read using the <code>readFloat</code>
-   * method in <code>DataInput</code>.
-   *
-   * @param value The float value to write
+   * @param f The floating point number to write to the stream.
    *
    * @exception IOException If an error occurs
    *
    * @see writeInt
-   * @see DataInput#readFloat
-   * @see Float#floatToIntBits
    */
   public final void writeFloat (float v) throws IOException
   {
@@ -366,16 +250,12 @@
    * then writing this <code>long</code> value to the stream exactly the same
    * as the <code>writeLong()</code> method does.
    *
-   * The value written can be read using the <code>readDouble</code>
-   * method in <code>DataInput</code>.
+   * @param d The double precision floating point number to write to 
+   * the stream.
    *
-   * @param value The double value to write
-   *
-   * @exception IOException If any other error occurs
+   * @exception IOException If an error occurs
    *
    * @see writeLong
-   * @see DataInput#readDouble
-   * @see Double#doubleToLongBits
    */
   public final void writeDouble (double v) throws IOException
   {
@@ -386,54 +266,33 @@
    * This method writes all the bytes in a <code>String</code> out to the
    * stream.  One byte is written for each character in the
    * <code>String</code>.
-   * The high eight bits of each character are discarded, thus this
-   * method is inappropriate for completely representing Unicode characters.
+   * The high eight bits of each character are discarded.
    *
-   * @param value The <code>String</code> to write
+   * @param s The <code>String</code> to write to the stream
    *
    * @exception IOException If an error occurs
    */
   public final void writeBytes (String s) throws IOException
   {
     int len = s.length();
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len];
-  
-    for (int i = 0; i < len; i++)
-      buf[i] = (byte)(s.charAt(i) & 0xff);
-  
-    write(buf, 0, buf.length);
+    for (int i = 0; i < len; ++i)
+      writeByte (s.charAt(i));
   }
 
   /**
-   * This method writes all the characters of a <code>String</code> to an
-   * output stream as an array of <code>char</code>'s. Each character
-   * is written using the method specified in the <code>writeChar</code>
-   * method.
+   * This method writes all the characters in a <code>String</code> to the
+   * stream.  There will be two bytes for each character value.  The high
+   * byte of the character will be written first.
    *
-   * @param value The String to write
+   * @param s The <code>String</code> to write to the stream.
    *
    * @exception IOException If an error occurs
-   *
-   * @see writeChar
    */
   public final void writeChars (String s) throws IOException
   {
     int len = s.length();
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len * 2];
-  
-    for (int i = 0; i < len; i++)
-      {
-        buf[i * 2] = (byte)((s.charAt(i) & 0xff00) >> 8);
-        buf[(i * 2) + 1] = (byte)(s.charAt(i) & 0x00ff);
-      }
-  
-    write(buf, 0, buf.length);
+    for (int i = 0; i < len; ++i)
+      writeChar (s.charAt(i));
   }
 
   /**
@@ -459,26 +318,51 @@
    * character value are stored in bits 0-5 of byte three, with the high bits
    * of that byte set to "10".
    *
-   * The value written can be read using the <code>readUTF</code>
-   * method in <code>DataInput</code>.
-   *
    * @param s The <code>String</code> to write to the output in UTF format
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readUTF
    */
-  public synchronized final void writeUTF (String v) throws IOException
+  public final void writeUTF (String s) throws IOException
   {
-    // FIXME:  Stylistically, replacing this with s.getBytes("UTF-8")
-    // would be better. However, that's likely to be expensive because of
-    // the char encoder overhead. Maybe we should have an easily
-    // invokable UTF-8 converter function, but I'm not sure this is the
-    // right class for it to live in. 
-    byte[] buf = convertToUTF(v);
-  
-    writeShort(buf.length);
-    write(buf, 0, buf.length);
+    int len = s.length();
+    int sum = 0;
+
+    for (int i = 0; i < len && sum <= 65535; ++i)
+      {
+	char c = s.charAt(i);
+	if (c >= '\u0001' && c <= '\u007f')
+	  sum += 1;
+	else if (c == '\u0000' || (c >= '\u0080' && c <= '\u07ff'))
+	  sum += 2;
+	else
+	  sum += 3;
+      }
+
+    if (sum > 65535)
+      throw new UTFDataFormatException ();
+
+    writeShort (sum);
+
+    for (int i = 0; i < len; ++i)
+      {
+	char c = s.charAt(i);
+	if (c >= '\u0001' && c <= '\u007f')
+	  write (c);
+	else if (c == '\u0000' || (c >= '\u0080' && c <= '\u07ff'))
+	  {
+	    write (0xc0 | (0x1f & (c >> 6)));
+	    write (0x80 | (0x3f & c));
+	  }
+	else
+	  {
+	    // JSL says the first byte should be or'd with 0xc0, but
+	    // that is a typo.  Unicode says 0xe0, and that is what is
+	    // consistent with DataInputStream.
+	    write (0xe0 | (0x0f & (c >> 12)));
+	    write (0x80 | (0x3f & (c >> 6)));
+	    write (0x80 | (0x3f & c));
+	  }
+      }
   }
 
 } // class DataOutputStream
