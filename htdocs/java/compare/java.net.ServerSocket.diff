--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/ServerSocket.java	2004-04-13 02:20:23.000000000 -0600
+++ java/net/ServerSocket.java	2004-03-22 02:18:55.000000000 -0700
@@ -8,7 +8,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -36,6 +36,7 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package java.net;
 
 import gnu.java.net.PlainSocketImpl;
@@ -43,7 +44,6 @@
 import java.nio.channels.IllegalBlockingModeException;
 import java.nio.channels.ServerSocketChannel;
 
-
 /* Written using on-line Java Platform 1.2 API Specification.
  * Status:  I believe all methods are implemented.
  */
@@ -55,7 +55,7 @@
  * server sockets are ready to communicate with one another utilizing
  * whatever application layer protocol they desire.
  *
- * As with the <code>Socket</code> class, most instance methods of this class
+ * As with the <code>Socket</code> class, most instance methods of this class 
  * simply redirect their calls to an implementation class.
  *
  * @author Aaron M. Renn (arenn@urbanophile.com)
@@ -78,36 +78,34 @@
    * True if socket is bound.
    */
   private boolean bound;
-
+  
   /*
    * This constructor is only used by java.nio.
    */
-
   // FIXME: Workaround a bug in gcj.
   //ServerSocket (PlainSocketImpl impl) throws IOException
-  ServerSocket(SocketImpl impl) throws IOException
+  ServerSocket (SocketImpl impl) throws IOException
   {
     if (impl == null)
       throw new NullPointerException("impl may not be null");
 
     this.impl = impl;
-    this.impl.create(true);
+    this.impl.create (true);
   }
 
   /*
    * This method is only used by java.nio.
    */
-
   // FIXME: Workaround a bug in gcj.
   //PlainSocketImpl getImpl()
   SocketImpl getImpl()
   {
     return impl;
   }
-
+  
   /**
    * Constructor that simply sets the implementation.
-   *
+   * 
    * @exception IOException If an error occurs
    *
    * @specnote This constructor is public since JDK 1.4
@@ -128,12 +126,13 @@
    * connection queue on this socket will be set to 50.
    *
    * @param port The port number to bind to
-   *
+   * 
    * @exception IOException If an error occurs
    * @exception SecurityException If a security manager exists and its
    * checkListen method doesn't allow the operation
    */
-  public ServerSocket(int port) throws IOException
+  public ServerSocket (int port)
+    throws IOException
   {
     this(port, 50);
   }
@@ -151,7 +150,8 @@
    * @exception SecurityException If a security manager exists and its
    * checkListen method doesn't allow the operation
    */
-  public ServerSocket(int port, int backlog) throws IOException
+  public ServerSocket (int port, int backlog)
+    throws IOException
   {
     this(port, backlog, null);
   }
@@ -173,13 +173,13 @@
    *
    * @since 1.1
    */
-  public ServerSocket(int port, int backlog, InetAddress bindAddr)
+  public ServerSocket (int port, int backlog, InetAddress bindAddr)
     throws IOException
   {
     this();
 
     // bind/listen socket
-    bind(new InetSocketAddress(bindAddr, port), backlog);
+    bind (new InetSocketAddress (bindAddr, port), backlog);
   }
 
   /**
@@ -191,20 +191,21 @@
    * @exception IllegalArgumentException If address type is not supported
    * @exception SecurityException If a security manager exists and its
    * checkListen method doesn't allow the operation
-   *
+   * 
    * @since 1.4
    */
-  public void bind(SocketAddress endpoint) throws IOException
+  public void bind (SocketAddress endpoint)
+    throws IOException
   {
-    bind(endpoint, 50);
+    bind (endpoint, 50);
   }
-
+ 
   /**
    * Binds the server socket to a specified socket address
    *
    * @param endpoint The socket address to bind to
    * @param backlog The length of the pending connection queue
-   *
+   * 
    * @exception IOException If an error occurs
    * @exception IllegalArgumentException If address type is not supported
    * @exception SecurityException If a security manager exists and its
@@ -212,27 +213,26 @@
    *
    * @since 1.4
    */
-  public void bind(SocketAddress endpoint, int backlog)
-    throws IOException
+  public void bind (SocketAddress endpoint, int backlog) throws IOException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
+    
     if (! (endpoint instanceof InetSocketAddress))
-      throw new IllegalArgumentException("Address type not supported");
+      throw new IllegalArgumentException ("Address type not supported");
 
     InetSocketAddress tmp = (InetSocketAddress) endpoint;
 
-    SecurityManager s = System.getSecurityManager();
+    SecurityManager s = System.getSecurityManager ();
     if (s != null)
-      s.checkListen(tmp.getPort());
+      s.checkListen (tmp.getPort ());
 
     InetAddress addr = tmp.getAddress();
-
+    
     // Initialize addr with 0.0.0.0.
     if (addr == null)
       addr = InetAddress.ANY_IF;
-
+    
     try
       {
 	impl.bind(addr, tmp.getPort());
@@ -241,21 +241,21 @@
       }
     catch (IOException exception)
       {
-	close();
-	throw exception;
+        close();
+        throw exception;
       }
     catch (RuntimeException exception)
       {
-	close();
-	throw exception;
+        close();
+        throw exception;
       }
     catch (Error error)
       {
-	close();
-	throw error;
+        close();
+        throw error;
       }
   }
-
+  
   /**
    * This method returns the local address to which this socket is bound
    *
@@ -263,17 +263,17 @@
    */
   public InetAddress getInetAddress()
   {
-    if (! isBound())
+    if (!isBound())
       return null;
-
+    
     try
       {
-	return (InetAddress) impl.getOption(SocketOptions.SO_BINDADDR);
+        return (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);
       }
     catch (SocketException e)
       {
-	// This never happens as we are bound.
-	return null;
+        // This never happens as we are bound.
+        return null;
       }
   }
 
@@ -284,34 +284,30 @@
    */
   public int getLocalPort()
   {
-    if (! isBound())
+    if (!isBound())
       return -1;
-
+    
     return impl.getLocalPort();
   }
 
   /**
    * Returns the local socket address
    *
-   * @return the local socket address, null if not bound
-   * 
    * @since 1.4
    */
   public SocketAddress getLocalSocketAddress()
   {
-    if (! isBound())
+    if (!isBound())
       return null;
-
+    
     return new InetSocketAddress(getInetAddress(), getLocalPort());
   }
 
   /**
-   * Accepts a new connection and returns a connected <code>Socket</code>
-   * instance representing that connection.  This method will block until a
+   * Accepts a new connection and returns a connected <code>Socket</code> 
+   * instance representing that connection.  This method will block until a 
    * connection is available.
    *
-   * @return socket object for the just accepted connection
-   *
    * @exception IOException If an error occurs
    * @exception SecurityException If a security manager exists and its
    * checkListen method doesn't allow the operation
@@ -320,17 +316,17 @@
    * @exception SocketTimeoutException If a timeout was previously set with
    * setSoTimeout and the timeout has been reached
    */
-  public Socket accept() throws IOException
+  public Socket accept () throws IOException
   {
-    SecurityManager sm = System.getSecurityManager();
+    SecurityManager sm = System.getSecurityManager ();
     if (sm != null)
-      sm.checkListen(impl.getLocalPort());
+      sm.checkListen (impl.getLocalPort ());
 
     Socket socket = new Socket();
-
+    
     try
       {
-	implAccept(socket);
+        implAccept(socket);
       }
     catch (IOException e)
       {
@@ -341,15 +337,15 @@
 	catch (IOException e2)
 	  {
 	  }
-
+	
 	throw e;
       }
-
+    
     return socket;
   }
 
   /**
-   * This protected method is used to help subclasses override
+   * This protected method is used to help subclasses override 
    * <code>ServerSocket.accept()</code>.  The passed in socket will be
    * connected when this method returns.
    *
@@ -361,19 +357,21 @@
    *
    * @since 1.1
    */
-  protected final void implAccept(Socket socket) throws IOException
+  protected final void implAccept (Socket socket)
+    throws IOException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
+    
     // The Sun spec says that if we have an associated channel and
     // it is in non-blocking mode, we throw an IllegalBlockingModeException.
     // However, in our implementation if the channel itself initiated this
     // operation, then we must honor it regardless of its blocking mode.
-    if (getChannel() != null && ! getChannel().isBlocking()
-        && ! ((PlainSocketImpl) getImpl()).isInChannelOperation())
-      throw new IllegalBlockingModeException();
-
+    if (getChannel() != null
+        && !getChannel().isBlocking ()
+        && !((PlainSocketImpl) getImpl()).isInChannelOperation())
+      throw new IllegalBlockingModeException ();
+	    
     impl.accept(socket.getImpl());
   }
 
@@ -382,11 +380,11 @@
    *
    * @exception IOException If an error occurs
    */
-  public void close() throws IOException
+  public void close () throws IOException
   {
     if (isClosed())
       return;
-
+    
     impl.close();
     impl = null;
     bound = false;
@@ -401,8 +399,6 @@
    *
    * The socket only has a ServerSocketChannel if its created
    * by ServerSocketChannel.open.
-   *
-   * @return the associated socket channel, null if none exists
    * 
    * @since 1.4
    */
@@ -413,8 +409,6 @@
 
   /**
    * Returns true when the socket is bound, otherwise false
-   *
-   * @return true if socket is bound, false otherwise
    * 
    * @since 1.4
    */
@@ -425,8 +419,6 @@
 
   /**
    * Returns true if the socket is closed, otherwise false
-   *
-   * @return true if socket is closed, false otherwise
    * 
    * @since 1.4
    */
@@ -437,7 +429,7 @@
 
   /**
    * Sets the value of SO_TIMEOUT.  A value of 0 implies that SO_TIMEOUT is
-   * disabled (ie, operations never time out).  This is the number of
+   * disabled (ie, operations never time out).  This is the number of 
    * milliseconds a socket operation can block before an
    * InterruptedIOException is thrown.
    *
@@ -447,11 +439,11 @@
    *
    * @since 1.1
    */
-  public void setSoTimeout(int timeout) throws SocketException
+  public void setSoTimeout (int timeout) throws SocketException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
+    
     if (timeout < 0)
       throw new IllegalArgumentException("SO_TIMEOUT value must be >= 0");
 
@@ -470,135 +462,135 @@
    *
    * @since 1.1
    */
-  public int getSoTimeout() throws IOException
+  public int getSoTimeout () throws IOException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
+    
     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);
 
-    if (! (timeout instanceof Integer))
+    if (!(timeout instanceof Integer))
       throw new IOException("Internal Error");
 
-    return ((Integer) timeout).intValue();
+    return ((Integer)timeout).intValue();
   }
 
   /**
    * Enables/Disables the SO_REUSEADDR option
-   *
-   * @param on true if SO_REUSEADDR should be enabled, false otherwise
    * 
    * @exception SocketException If an error occurs
-   *
+   * 
    * @since 1.4
    */
-  public void setReuseAddress(boolean on) throws SocketException
+  public void setReuseAddress (boolean on)
+    throws SocketException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
-    impl.setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
+    
+    impl.setOption (SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
   }
 
   /**
    * Checks if the SO_REUSEADDR option is enabled
-   *
-   * @return true if SO_REUSEADDR is set, false otherwise
-   *
+   * 
    * @exception SocketException If an error occurs
-   *
+   * 
    * @since 1.4
    */
-  public boolean getReuseAddress() throws SocketException
+  public boolean getReuseAddress()
+    throws SocketException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
+    
+    Object reuseaddr = impl.getOption (SocketOptions.SO_REUSEADDR);
 
-    Object reuseaddr = impl.getOption(SocketOptions.SO_REUSEADDR);
-
-    if (! (reuseaddr instanceof Boolean))
-      throw new SocketException("Internal Error");
-
-    return ((Boolean) reuseaddr).booleanValue();
+    if (!(reuseaddr instanceof Boolean))
+      throw new SocketException ("Internal Error");
+    
+    return ((Boolean) reuseaddr).booleanValue ();
   }
 
   /**
    * This method sets the value for the system level socket option
    * SO_RCVBUF to the specified value.  Note that valid values for this
    * option are specific to a given operating system.
-   *
+   * 
    * @param size The new receive buffer size.
-   *
+   * 
    * @exception SocketException If an error occurs or Socket is not connected
    * @exception IllegalArgumentException If size is 0 or negative
    *
    * @since 1.4
    */
-  public void setReceiveBufferSize(int size) throws SocketException
+  public void setReceiveBufferSize (int size)
+    throws SocketException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
-
+    
     if (size <= 0)
-      throw new IllegalArgumentException("SO_RCVBUF value must be > 0");
+      throw new IllegalArgumentException ("SO_RCVBUF value must be > 0");
 
-    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));
+    impl.setOption (SocketOptions.SO_RCVBUF, new Integer (size));
   }
 
   /**
    * This method returns the value of the system level socket option
    * SO_RCVBUF, which is used by the operating system to tune buffer
    * sizes for data transfers.
-   *
+   * 
    * @return The receive buffer size.
-   *
+   *             
    * @exception SocketException If an error occurs or Socket is not connected
-   *
+   * 
    * @since 1.4
    */
-  public int getReceiveBufferSize() throws SocketException
+  public int getReceiveBufferSize ()
+    throws SocketException
   {
     if (isClosed())
       throw new SocketException("ServerSocket is closed");
+    
+    Object buf = impl.getOption (SocketOptions.SO_RCVBUF);
 
-    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);
-
-    if (! (buf instanceof Integer))
-      throw new SocketException("Internal Error: Unexpected type");
-
-    return ((Integer) buf).intValue();
+    if (!(buf instanceof Integer))
+      throw new SocketException ("Internal Error: Unexpected type");
+    
+    return ((Integer) buf).intValue ();
   }
 
   /**
-   * Returns the value of this socket as a <code>String</code>.
+   * Returns the value of this socket as a <code>String</code>. 
    *
    * @return This socket represented as a <code>String</code>.
    */
-  public String toString()
+  public String toString ()
   {
-    if (! isBound())
+    if (!isBound())
       return "ServerSocket[unbound]";
-
-    return ("ServerSocket[addr=" + getInetAddress() + ",port="
-           + impl.getPort() + ",localport=" + impl.getLocalPort() + "]");
+    
+    return ("ServerSocket[addr=" + getInetAddress()
+	    + ",port=" + impl.getPort()
+	    + ",localport=" + impl.getLocalPort()
+	    + "]");
   }
 
   /**
-   * Sets the <code>SocketImplFactory</code> for all
+   * Sets the <code>SocketImplFactory</code> for all 
    * <code>ServerSocket</code>'s.  This may only be done
    * once per virtual machine.  Subsequent attempts will generate an
    * exception.  Note that a <code>SecurityManager</code> check is made prior
    * to setting the factory.  If insufficient privileges exist to set the
    * factory, an exception will be thrown
    *
-   * @param fac the factory to set
-   *
    * @exception SecurityException If this operation is not allowed by the
    * <code>SecurityManager</code>.
    * @exception SocketException If the factory object is already defined
    * @exception IOException If any other error occurs
    */
-  public static synchronized void setSocketFactory(SocketImplFactory fac)
+  public static synchronized void setSocketFactory (SocketImplFactory fac)
     throws IOException
   {
     factory = fac;
