--- /home/tromey/gnu/Nightly/classpath/classpath/java/util/zip/DeflaterOutputStream.java	2003-06-16 02:24:05.000000000 -0600
+++ java/util/zip/DeflaterOutputStream.java	2003-11-07 02:19:02.000000000 -0700
@@ -1,5 +1,5 @@
-/* java.util.zip.DeflaterOutputStream
-   Copyright (C) 2001 Free Software Foundation, Inc.
+/* DeflaterOutputStream.java - Output filter for compressing.
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -60,16 +60,11 @@
  */
 public class DeflaterOutputStream extends FilterOutputStream
 {
-  /** 
-   * This buffer is used temporarily to retrieve the bytes from the
-   * deflater and write them to the underlying output stream.  
-   */
-  protected byte[] buf;
-
-  /** 
-   * The deflater which is used to deflate the stream.
-   */
-  protected Deflater def;
+  public void close () throws IOException
+  {
+    finish ();
+    out.close();
+  }
 
   /**
    * Deflates everything in the def's input buffers.  This will call
@@ -78,18 +73,13 @@
    */
   protected void deflate () throws IOException
   {
-    while (! def.needsInput())
+    do
       {
 	int len = def.deflate(buf, 0, buf.length);
-
-	//	System.err.println("DOS deflated " + len + " out of " + buf.length);
-	if (len <= 0)
-	  break;
-	out.write(buf, 0, len);
-      }
-
-    if (! def.needsInput())
-      throw new InternalError("Can't deflate all input?");
+	if (len > 0)
+	  out.write(buf, 0, len);
+       }
+    while (! def.needsInput());
   }
 
   /** 
@@ -130,19 +120,6 @@
     def = defl;
   }
 
-  /**  
-   * Flushes the stream by calling flush() on the deflater and then
-   * on the underlying stream.  This ensures that all bytes are
-   * flushed.  This function doesn't work in Sun's JDK, but only in
-   * jazzlib.
-   */
-  public void flush() throws IOException
-  {
-    def.flush();
-    deflate();
-    out.flush();
-  }
-
   /**
    * Finishes the stream by calling finish() on the deflater.  This
    * was the only way to ensure that all bytes are flushed in Sun's
@@ -150,49 +127,50 @@
    */
   public void finish () throws IOException
   {
+    inbufWrite();
     def.finish();
     while (! def.finished ())
       {
 	int len = def.deflate(buf, 0, buf.length);
-	if (len <= 0)
-	  break;
-	out.write(buf, 0, len);
+	if (len > 0)
+	  out.write(buf, 0, len);
       }
-    if (! def.finished())
-      throw new InternalError("Can't deflate all input?");
-    out.flush();
   }
 
-  /**
-   * Calls finish () and closes the stream. 
-   */
-  public void close() throws IOException
+  public void write (int bval) throws IOException
   {
-    finish();
-    out.close();
+    if (inbuf == null)
+      inbuf = new byte[128];
+    else if (inbufLength == inbuf.length)
+      inbufWrite ();
+    inbuf[inbufLength++] = (byte) bval;
   }
 
-  /**
-   * Writes a single byte to the compressed output stream.
-   * @param bval the byte value.
-   */
-  public void write(int bval) throws IOException
+  public void write (byte[] buf, int off, int len) throws IOException
   {
-    byte[] b = new byte[1];
-    b[0] = (byte) bval;
-    write(b, 0, 1);
+    inbufWrite ();
+    def.setInput (buf, off, len);
+    deflate ();
   }
 
-  /**
-   * Writes a len bytes from an array to the compressed stream.
-   * @param buf the byte array.
-   * @param off the offset into the byte array where to start.
-   * @param len the number of bytes to write.
-   */
-  public void write(byte[] buf, int off, int len) throws IOException
+  private void inbufWrite () throws IOException
   {
-    //    System.err.println("DOS with off " + off + " and len " + len);
-    def.setInput(buf, off, len);
-    deflate();
+    if (inbufLength > 0)
+      {
+	int size = inbufLength;
+	inbufLength = 0;
+	write (inbuf, 0, size);
+      }
   }
+
+  // Used, if needed, for write(int).
+  private byte[] inbuf;
+  // Used length of inbuf.
+  private int inbufLength;
+
+  // The retrieval buffer.
+  protected byte[] buf;
+
+  // Deflater used to compress data.
+  protected Deflater def;
 }
