--- /home/tromey/gnu/classpath/classpath/java/util/zip/DeflaterOutputStream.java	Tue Jan 22 15:50:10 2002
+++ java/util/zip/DeflaterOutputStream.java	Tue Jan 22 16:01:46 2002
@@ -1,5 +1,5 @@
-/* java.util.zip.DeflaterOutputStream
-   Copyright (C) 2001 Free Software Foundation, Inc.
+/* DeflaterOutputStream.java - Output filter for compressing.
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -41,158 +41,104 @@
 import java.io.OutputStream;
 import java.io.IOException;
 
+/**
+ * @author Tom Tromey
+ * @date May 17, 1999
+ */
+
 /* Written using on-line Java Platform 1.2 API Specification
  * and JCL book.
  * Believed complete and correct.
  */
 
-/**
- * This is a special FilterOutputStream deflating the bytes that are
- * written through it.  It uses the Deflater for deflating.
- *
- * A special thing to be noted is that flush() doesn't flush
- * everything in Sun's JDK, but it does so in jazzlib. This is because
- * Sun's Deflater doesn't have a way to flush() everything, without
- * finishing the stream.
- *
- * @author Tom Tromey, Jochen Hoenicke
- * @date Jan 11, 2001 
- */
 public class DeflaterOutputStream extends FilterOutputStream
 {
-  /** 
-   * This buffer is used temporarily to retrieve the bytes from the
-   * deflater and write them to the underlying output stream.  
-   */
-  protected byte[] buf;
-
-  /** 
-   * The deflater which is used to deflate the stream.
-   */
-  protected Deflater def;
+  public void close () throws IOException
+  {
+    finish ();
+    out.close();
+  }
 
-  /**
-   * Deflates everything in the def's input buffers.  This will call
-   * <code>def.deflate()</code> until all bytes from the input buffers
-   * are processed.
-   */
-  protected void deflate() throws IOException
+  protected void deflate () throws IOException
   {
-    while (! def.needsInput())
+    do
       {
 	int len = def.deflate(buf, 0, buf.length);
+	if (len > 0)
+	  out.write(buf, 0, len);
+       }
+    while (! def.needsInput());
+  }
 
-	//	System.err.println("DOS deflated " + len + " out of " + buf.length);
-	if (len <= 0)
-	  break;
-	out.write(buf, 0, len);
-      }
+  public DeflaterOutputStream (OutputStream out)
+  {
+    this (out, new Deflater (), 512);
+  }
 
-    if (! def.needsInput())
-      throw new InternalError("Can't deflate all input?");
+  public DeflaterOutputStream (OutputStream out, Deflater defl)
+  {
+    this (out, defl, 512);
   }
 
-  /** 
-   * Creates a new DeflaterOutputStream with a default Deflater and
-   * default buffer size.
-   * @param out the output stream where deflated output should be written.
-   */
-  public DeflaterOutputStream(OutputStream out)
-  {
-    this(out, new Deflater(), 512);
-  }
-
-  /** 
-   * Creates a new DeflaterOutputStream with the given Deflater and
-   * default buffer size.
-   * @param out the output stream where deflated output should be written.
-   * @param defl the underlying deflater.
-   */
-  public DeflaterOutputStream(OutputStream out, Deflater defl)
-  {
-    this(out, defl, 512);
-  }
-
-  /** 
-   * Creates a new DeflaterOutputStream with the given Deflater and
-   * buffer size.
-   * @param out the output stream where deflated output should be written.
-   * @param defl the underlying deflater.
-   * @param bufsize the buffer size.
-   * @exception IllegalArgumentException if bufsize isn't positive.
-   */
   public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)
   {
-    super(out);
-    if (bufsize <= 0)
-      throw new IllegalArgumentException("bufsize <= 0");
+    super (out);
     buf = new byte[bufsize];
     def = defl;
   }
 
-  /**  
-   * Flushes the stream by calling flush() on the deflater and then
-   * on the underlying stream.  This ensures that all bytes are
-   * flushed.  This function doesn't work in Sun's JDK, but only in
-   * jazzlib.
-   */
-  public void flush() throws IOException
-  {
-    def.flush();
-    deflate();
-    out.flush();
-  }
-
-  /**
-   * Finishes the stream by calling finish() on the deflater.  This
-   * was the only way to ensure that all bytes are flushed in Sun's
-   * JDK.  
-   */
-  public void finish() throws IOException
+  public void finish () throws IOException
   {
+    if (inbufLength > 0)
+      {
+	def.setInput (inbuf, 0, inbufLength);
+	deflate ();
+	inbufLength = 0;
+      }
     def.finish();
-    while (! def.finished())
+    while (! def.finished ())
       {
 	int len = def.deflate(buf, 0, buf.length);
-	if (len <= 0)
-	  break;
-	out.write(buf, 0, len);
+	if (len > 0)
+	  out.write(buf, 0, len);
       }
-    if (! def.finished())
-      throw new InternalError("Can't deflate all input?");
-    out.flush();
   }
 
-  /**
-   * Calls finish () and closes the stream. 
-   */
-  public void close() throws IOException
+  public void write (int bval) throws IOException
   {
-    finish();
-    out.close();
+    if (inbuf == null)
+      {
+	inbuf = new byte[128];
+      }
+    else if (inbufLength == inbuf.length)
+      {
+	def.setInput (inbuf, 0, inbufLength);
+	deflate ();
+	inbufLength = 0;
+      }
+    inbuf[inbufLength++] = (byte) bval;
   }
 
-  /**
-   * Writes a single byte to the compressed output stream.
-   * @param bval the byte value.
-   */
-  public void write(int bval) throws IOException
-  {
-    byte[] b = new byte[1];
-    b[0] = (byte) bval;
-    write(b, 0, 1);
-  }
-
-  /**
-   * Writes a len bytes from an array to the compressed stream.
-   * @param buf the byte array.
-   * @param off the offset into the byte array where to start.
-   * @param len the number of bytes to write.
-   */
-  public void write(byte[] buf, int off, int len) throws IOException
-  {
-    //    System.err.println("DOS with off " + off + " and len " + len);
-    def.setInput(buf, off, len);
-    deflate();
+  public void write (byte[] buf, int off, int len) throws IOException
+  {
+    if (inbufLength > 0)
+      {
+	def.setInput (inbuf, 0, inbufLength);
+	deflate ();
+	inbufLength = 0;
+      }
+    def.setInput (buf, off, len);
+    deflate ();
   }
+
+  // Used, if needed, for write(int).
+  private byte[] inbuf;
+  // Used length of inbuf.
+  private int inbufLength;
+
+  // The retrieval buffer.
+  protected byte[] buf;
+
+  // Deflater used to compress data.
+  protected Deflater def;
 }
