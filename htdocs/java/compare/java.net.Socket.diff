--- /home/tromey/gnu/classpath/classpath/java/net/Socket.java	Mon Sep 16 15:09:24 2002
+++ java/net/Socket.java	Thu Oct  3 11:50:56 2002
@@ -38,7 +38,8 @@
 package java.net;
 
 import java.io.*;
-import java.nio.channels.*;
+import java.nio.channels.SocketChannel;
+import java.nio.channels.IllegalBlockingModeException;
 
 /* Written using on-line Java Platform 1.2 API Specification.
  * Status:  I believe all methods are implemented.
@@ -79,19 +80,29 @@
    */
   SocketImpl impl;
 
+  private boolean inputShutdown;
+  private boolean outputShutdown;
+
+  SocketChannel ch; // this field must have been set if created by SocketChannel
+
   // Constructors
 
   /**
    * Initializes a new instance of <code>Socket</code> object without 
    * connecting to a remote host.  This useful for subclasses of socket that 
    * might want this behavior.
+   *
+   * @specnote This constructor is public since JDK 1.4
    */
-  protected Socket ()
+  public Socket ()
   {
     if (factory != null)
       impl = factory.createSocketImpl();
     else
       impl = new PlainSocketImpl();
+
+    inputShutdown = false;
+    outputShutdown = false;
   }
 
   /**
@@ -113,6 +124,8 @@
   protected Socket (SocketImpl impl) throws SocketException
   {
     this.impl = impl;
+    this.inputShutdown = false;
+    this.outputShutdown = false;
   }
 
   /**
@@ -125,6 +138,8 @@
    * @exception UnknownHostException If the hostname cannot be resolved to a
    * network address.
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   public Socket (String host, int port)
     throws UnknownHostException, IOException
@@ -140,6 +155,8 @@
    * @param port The port number to connect to
    *
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   public Socket (InetAddress address, int port)
     throws IOException 
@@ -179,6 +196,8 @@
    * @param localPort The local port to connect to
    *
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   public Socket (InetAddress address, int port,
 		 InetAddress localAddr, int localPort) throws IOException
@@ -198,6 +217,8 @@
    * for a datagram socket
    *
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    *
    * @deprecated Use the <code>DatagramSocket</code> class to create
    * datagram oriented sockets.
@@ -219,6 +240,8 @@
    * <code>false</code> to create a datagram socket.
    *
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    *
    * @deprecated Use the <code>DatagramSocket</code> class to create
    * datagram oriented sockets.
@@ -242,11 +265,16 @@
    * @param stream true for a stream socket, false for a datagram socket
    *
    * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,
                  boolean stream) throws IOException
   {
     this();
+    this.inputShutdown = false;
+    this.outputShutdown = false;
+
     if (impl == null)
       throw new IOException("Cannot initialize Socket implementation");
 
@@ -267,6 +295,78 @@
   }
 
   /**
+   * Binds the socket to the givent local address/port
+   *
+   * @param bindpoint The address/port to bind to
+   *
+   * @exception IOException If an error occurs
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
+   * @exception IllegalArgumentException If the address type is not supported
+   * 
+   * @since 1.4
+   */
+  public void bind (SocketAddress bindpoint) throws IOException
+  {
+    if ( !(bindpoint instanceof InetSocketAddress))
+      throw new IllegalArgumentException ();
+
+    InetSocketAddress tmp = (InetSocketAddress) bindpoint;
+    impl.bind (tmp.getAddress(), tmp.getPort());
+  }
+  
+  /**
+   * Connects the socket with a remote address.
+   *
+   * @param endpoint The address to connect to
+   *
+   * @exception IOException If an error occurs
+   * @exception IllegalArgumentException If the addess type is not supported
+   * @exception IllegalBlockingModeException If this socket has an associated
+   * channel, and the channel is in non-blocking mode
+   * 
+   * @since 1.4
+   */
+  public void connect (SocketAddress endpoint)
+    throws IOException
+  {
+    if (! (endpoint instanceof InetSocketAddress))
+      throw new IllegalArgumentException ("Address type not supported");
+
+    if (ch != null && !ch.isBlocking ())
+      throw new IllegalBlockingModeException ();
+    
+    impl.connect (endpoint, 0);
+  }
+
+  /**
+   * Connects the socket with a remote address. A timeout of zero is
+   * interpreted as an infinite timeout. The connection will then block
+   * until established or an error occurs.
+   *
+   * @param endpoint The address to connect to
+   *
+   * @exception IOException If an error occurs
+   * @exception IllegalArgumentException If the address type is not supported
+   * @exception IllegalBlockingModeException If this socket has an associated
+   * channel, and the channel is in non-blocking mode
+   * @exception SocketTimeoutException If the timeout is reached
+   * 
+   * @since 1.4
+   */
+  public void connect (SocketAddress endpoint, int timeout)
+    throws IOException
+  {
+    if (! (endpoint instanceof InetSocketAddress))
+      throw new IllegalArgumentException ("Address type not supported");
+
+    if (ch != null && !ch.isBlocking ())
+      throw new IllegalBlockingModeException ();
+    
+    impl.connect (endpoint, timeout);
+  }
+
+  /**
    * Returns the address of the remote end of the socket.  If this socket
    * is not connected, then <code>null</code> is returned.
    *
@@ -345,6 +445,36 @@
   }
 
   /**
+   * If the socket is already bound this returns the local SocketAddress,
+   * otherwise null
+   *
+   * @since 1.4
+   */
+  public SocketAddress getLocalSocketAddress()
+  {
+    InetAddress addr = getLocalAddress ();
+
+    if (addr == null)
+      return null;
+    
+    return new InetSocketAddress (addr, impl.getLocalPort());
+  }
+
+  /**
+   * If the socket is already connected this returns the remote SocketAddress,
+   * otherwise null
+   *
+   * @since 1.4
+   */
+  public SocketAddress getRemoteSocketAddress()
+  {
+    if (!isConnected ())
+      return null;
+
+    return new InetSocketAddress (impl.getInetAddress (), impl.getPort ());
+  }
+
+  /**
    * Returns an InputStream for reading from this socket.
    *
    * @return The InputStream object
@@ -425,6 +555,7 @@
    * SO_LINGER not set.
    *
    * @exception SocketException If an error occurs or Socket not connected
+   * @exception IllegalArgumentException If linger is negative
    */
   public void setSoLinger(boolean on, int linger) throws SocketException
   {
@@ -474,6 +605,58 @@
   }
 
   /**
+   * Sends urgent data through the socket
+   *
+   * @param data The data to send.
+   * Only the lowest eight bits of data are sent
+   *
+   * @exception IOException If an error occurs
+   *
+   * @since 1.4
+   */
+  public void sendUrgentData (int data) throws IOException
+  {
+    impl.sendUrgentData (data);
+  }
+
+  /**
+   * Enables/disables the SO_OOBINLINE option
+   * 
+   * @param on True if SO_OOBLINE should be enabled 
+   * 
+   * @exception SocketException If an error occurs
+   * 
+   * @since 1.4
+   */
+  public void setOOBInline (boolean on) throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException("Not connected");
+
+    impl.setOption(SocketOptions.SO_OOBINLINE, new Boolean(on));
+  }
+
+  /**
+   * Returns the current setting of the SO_OOBINLINE option for this socket
+   * 
+   * @exception SocketException If an error occurs
+   * 
+   * @since 1.4
+   */
+  public boolean getOOBInline () throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException("Not connected");
+
+    Object buf = impl.getOption(SocketOptions.SO_OOBINLINE);
+
+    if (buf instanceof Boolean)
+      return(((Boolean)buf).booleanValue());
+    else
+      throw new SocketException("Internal Error: Unexpected type");
+  }
+  
+  /**
    * Sets the value of the SO_TIMEOUT option on the socket.  If this value
    * is set, and an read/write is performed that does not complete within
    * the timeout period, a short count is returned (or an EWOULDBLOCK signal
@@ -534,6 +717,7 @@
    * @param size The new send buffer size.
    *
    * @exception SocketException If an error occurs or Socket not connected
+   * @exception IllegalArgumentException If size is 0 or negative
    *
    * @since 1.2
    */
@@ -580,6 +764,7 @@
    * @param size The new receive buffer size.
    *
    * @exception SocketException If an error occurs or Socket is not connected
+   * @exception IllegalArgumentException If size is 0 or negative
    *
    * @since 1.2
    */
@@ -619,6 +804,47 @@
   }
 
   /**
+   * This method sets the value for the socket level socket option
+   * SO_KEEPALIVE.
+   *
+   * @param on True if SO_KEEPALIVE should be enabled
+   *
+   * @exception SocketException If an error occurs or Socket is not connected
+   *
+   * @since Java 1.3
+   */
+  public void setKeepAlive (boolean on) throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException("Not connected");
+
+    impl.setOption(SocketOptions.SO_KEEPALIVE, new Boolean(on));
+  }
+
+  /**
+   * This method returns the value of the socket level socket option
+   * SO_KEEPALIVE.
+   *
+   * @return The setting
+   *
+   * @exception SocketException If an error occurs or Socket is not connected
+   *
+   * @since Java 1.3
+   */
+  public boolean getKeepAlive () throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException("Not connected");
+
+    Object buf = impl.getOption(SocketOptions.SO_KEEPALIVE);
+
+    if (buf instanceof Boolean)
+      return(((Boolean)buf).booleanValue());
+    else
+      throw new SocketException("Internal Error: Unexpected type");
+  }
+
+  /**
    * Closes the socket.
    *
    * @exception IOException If an error occurs
@@ -669,26 +895,160 @@
     factory = fac;
   }
 
+  /**
+   * Closes the input side of the socket stream.
+   *
+   * @exception IOException If an error occurs.
+   */
   public void shutdownInput() throws IOException
   {
-    // impl.shutdownInput();
+    if (impl != null)
+      impl.shutdownInput();
+
+    inputShutdown = true;
   }
 
+  /**
+   * Closes the output side of the socket stream.
+   *
+   * @exception IOException If an error occurs.
+   */
   public void shutdownOutput() throws IOException
   {
-    // impl.shutdownOutput();
+    if (impl != null)
+      impl.shutdownOutput();
+    
+    outputShutdown = true;
   }
 
-  SocketChannel ch; // this field must have been set if created by SocketChannel
-
   /**
-   * Returns the socket channel associated with 
-   * this socket.
-   * 
+   * Returns the socket channel associated with this socket.
+   *
    * It returns null if no associated socket exists.
    */
-  public SocketChannel getChannel() 
+  public SocketChannel getChannel()
   {
     return ch;
   }
+
+  /**
+   * Checks if the SO_REUSEADDR option is enabled
+   *
+   * @exception SocketException If an error occurs
+   *
+   * @since 1.4
+   */
+  public boolean getReuseAddress () throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException ("Cannot initialize Socket implementation");
+
+    Object reuseaddr = impl.getOption (SocketOptions.SO_REUSEADDR);
+
+    if (!(reuseaddr instanceof Boolean))
+      throw new SocketException ("Internal Error");
+
+    return ((Boolean) reuseaddr).booleanValue ();
+  }
+
+  /**
+   * Enables/Disables the SO_REUSEADDR option
+   *
+   * @exception SocketException If an error occurs
+   *
+   * @since 1.4
+   */
+  public void setReuseAddress (boolean on) throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException ("Cannot initialize Socket implementation");
+
+    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));
+  }
+
+  /**
+   * Returns the current traffic class
+   *
+   * @exception SocketException If an error occurs
+   *
+   * @see Socket:setTrafficClass
+   *
+   * @since 1.4
+   */
+  public int getTrafficClass () throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException ("Cannot initialize Socket implementation");
+
+    Object obj = impl.getOption(SocketOptions.IP_TOS);
+
+    if (obj instanceof Integer)
+      return ((Integer) obj).intValue ();
+    else
+      throw new SocketException ("Unexpected type");
+  }
+
+  /**
+   * Sets the traffic class value
+   *
+   * @param tc The traffic class
+   *
+   * @exception SocketException If an error occurs
+   * @exception IllegalArgumentException If tc value is illegal
+   *
+   * @see Socket:getTrafficClass
+   *
+   * @since 1.4
+   */
+  public void setTrafficClass (int tc) throws SocketException
+  {
+    if (impl == null)
+      throw new SocketException ("Cannot initialize Socket implementation");
+
+    if (tc < 0 || tc > 255)
+      throw new IllegalArgumentException();
+
+    impl.setOption (SocketOptions.IP_TOS, new Integer (tc));
+  }
+
+  /**
+   * Checks if the socket is connected
+   */
+  public boolean isConnected ()
+  {
+    return impl.getInetAddress () != null;
+  }
+
+  /**
+   * Checks if the socket is already bound.
+   */
+  public boolean isBound ()
+  {
+    return getLocalAddress () != null;
+  }
+
+  /**
+   * Checks if the socket is closed.
+   */
+  public boolean isClosed ()
+  {
+    // FIXME: implement this.
+    return false;
+  }
+
+  /**
+   * Checks if the socket's input stream is shutdown
+   */
+  public boolean isInputShutdown ()
+  {
+    return inputShutdown;
+  }
+
+  /**
+   * Checks if the socket's output stream is shutdown
+   */
+  public boolean isOutputShutdown ()
+  {
+    return outputShutdown;
+  }
 }
