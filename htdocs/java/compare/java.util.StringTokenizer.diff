--- /home/tromey/gnu/classpath/classpath/java/util/StringTokenizer.java	Mon Mar 25 15:38:04 2002
+++ java/util/StringTokenizer.java	Tue Jan 22 16:01:43 2002
@@ -1,5 +1,5 @@
-/* StringTokenizer -- breaks a String into tokens
-   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+/* java.util.StringTokenizer
+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -39,79 +39,75 @@
 package java.util;
 
 /**
- * This class splits a string into tokens.  The caller can set on which
+ * This class splits a string into tokens.  The caller can set on which 
  * delimiters the string should be split and if the delimiters should be
- * returned. This is much simpler than {@link java.io.StreamTokenizer}.
+ * returned.
  *
- * <p>You may change the delimiter set on the fly by calling
+ * You may change the delimiter set on the fly by calling
  * nextToken(String).  But the semantic is quite difficult; it even
  * depends on calling <code>hasMoreTokens()</code>.  You should call
  * <code>hasMoreTokens()</code> before, otherwise the old delimiters
- * after the last token are candidates for being returned.
+ * after the last token are returned.
  *
- * <p>If you want to get the delimiters, you have to use the three argument
+ * If you want to get the delimiters, you have to use the three argument
  * constructor.  The delimiters are returned as token consisting of a
- * single character.
+ * single character.  
  *
  * @author Jochen Hoenicke
  * @author Warren Levy <warrenl@cygnus.com>
- * @see java.io.StreamTokenizer
- * @status updated to 1.4
  */
 public class StringTokenizer implements Enumeration
 {
-  // WARNING: StringTokenizer is a CORE class in the bootstrap cycle. See the
-  // comments in vm/reference/java/lang/Runtime for implications of this fact.
-
   /**
    * The position in the str, where we currently are.
    */
   private int pos;
-
   /**
    * The string that should be split into tokens.
    */
-  private final String str;
-
-  /**
-   * The length of the string.
-   */
-  private final int len;
-
+  private String str;
   /**
    * The string containing the delimiter characters.
    */
   private String delim;
-
   /**
    * Tells, if we should return the delimiters.
    */
-  private final boolean retDelims;
+  private boolean retDelims;
+
+  /*{ 
+     invariant {
+     pos >= 0 :: "position is negative";
+     pos <= str.length() :: "position is out of string";
+     str != null :: "String is null";
+     delim != null :: "Delimiters are null";
+     }
+     } */
 
   /**
    * Creates a new StringTokenizer for the string <code>str</code>,
-   * that should split on the default delimiter set (space, tab,
+   * that should split on the default delimiter set (space, tap,
    * newline, return and formfeed), and which doesn't return the
    * delimiters.
-   *
-   * @param str The string to split
-   * @throws NullPointerException if str is null
+   * @param str The string to split.
    */
   public StringTokenizer(String str)
+    /*{ require { str != null :: "str must not be null"; } } */
   {
     this(str, " \t\n\r\f", false);
   }
 
   /**
-   * Create a new StringTokenizer, that splits the given string on
+   * Create a new StringTokenizer, that splits the given string on 
    * the given delimiter characters.  It doesn't return the delimiter
    * characters.
    *
-   * @param str the string to split
-   * @param delim a string containing all delimiter characters
-   * @throws NullPointerException if either argument is null
+   * @param str The string to split.
+   * @param delim A string containing all delimiter characters.
    */
   public StringTokenizer(String str, String delim)
+    /*{ require { str != null :: "str must not be null";
+       delim != null :: "delim must not be null"; } } */
   {
     this(str, delim, false);
   }
@@ -123,34 +119,34 @@
    * characters are returned as tokens of their own.  The delimiter
    * tokens always consist of a single character.
    *
-   * @param str the string to split
-   * @param delim a string containing all delimiter characters
-   * @param returnDelims tells, if you want to get the delimiters
-   * @throws NullPointerException if str or delim is null
+   * @param str The string to split.
+   * @param delim A string containing all delimiter characters.
+   * @param returnDelims Tells, if you want to get the delimiters.
    */
   public StringTokenizer(String str, String delim, boolean returnDelims)
+    /*{ require { str != null :: "str must not be null";
+       delim != null :: "delim must not be null"; } } */
   {
-    len = str.length();
     this.str = str;
-    // The toString() hack causes the NullPointerException.
-    this.delim = delim.toString();
+    this.delim = delim;
     this.retDelims = returnDelims;
     this.pos = 0;
   }
 
   /**
    * Tells if there are more tokens.
-   *
-   * @return true if the next call of nextToken() will succeed
+   * @return True, if the next call of nextToken() succeeds, false otherwise.
    */
   public boolean hasMoreTokens()
   {
-    if (! retDelims)
+    if (!retDelims)
       {
-        while (pos < len && delim.indexOf(str.charAt(pos)) >= 0)
-          pos++;
+	while (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)
+	  {
+	    pos++;
+	  }
       }
-    return pos < len;
+    return pos < str.length();
   }
 
   /**
@@ -158,13 +154,13 @@
    * <code>delim</code>.  The change of the delimiter set is
    * permanent, ie. the next call of nextToken(), uses the same
    * delimiter set.
-   *
-   * @param delim a string containing the new delimiter characters
-   * @return the next token with respect to the new delimiter characters
-   * @throws NoSuchElementException if there are no more tokens
-   * @throws NullPointerException if delim is null
+   * @param delim a string containing the new delimiter characters.
+   * @return the next token with respect to the new delimiter characters.
+   * @exception NoSuchElementException if there are no more tokens.
    */
   public String nextToken(String delim) throws NoSuchElementException
+    /*{ require { hasMoreTokens() :: "no more Tokens available";
+       ensure { $return != null && $return.length() > 0; } } */
   {
     this.delim = delim;
     return nextToken();
@@ -172,24 +168,32 @@
 
   /**
    * Returns the nextToken of the string.
-   *
-   * @return the next token with respect to the current delimiter characters
-   * @throws NoSuchElementException if there are no more tokens
+   * @param delim a string containing the new delimiter characters.
+   * @return the next token with respect to the new delimiter characters.
+   * @exception NoSuchElementException if there are no more tokens.
    */
   public String nextToken() throws NoSuchElementException
+    /*{ require { hasMoreTokens() :: "no more Tokens available";
+       ensure { $return != null && $return.length() > 0; } } */
   {
-    if (pos < len && delim.indexOf(str.charAt(pos)) >= 0)
+    if (pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)
       {
-        if (retDelims)
-          return str.substring(pos, ++pos);
-        while (++pos < len && delim.indexOf(str.charAt(pos)) >= 0);
+	if (retDelims)
+	  return str.substring(pos, ++pos);
+
+	while (++pos < str.length() && delim.indexOf(str.charAt(pos)) > -1)
+	  {
+	    /* empty */
+	  }
       }
-    if (pos < len)
+    if (pos < str.length())
       {
-        int start = pos;
-        while (++pos < len && delim.indexOf(str.charAt(pos)) < 0);
-
-        return str.substring(start, pos);
+	int start = pos;
+	while (++pos < str.length() && delim.indexOf(str.charAt(pos)) == -1)
+	  {
+	    /* empty */
+	  }
+	return str.substring(start, pos);
       }
     throw new NoSuchElementException();
   }
@@ -197,9 +201,9 @@
   /**
    * This does the same as hasMoreTokens. This is the
    * <code>Enumeration</code interface method.
-   *
-   * @return true, if the next call of nextElement() will succeed
-   * @see #hasMoreTokens()
+   * @return True, if the next call of nextElement() succeeds, false
+   * otherwise.  
+   * @see #hasMoreTokens
    */
   public boolean hasMoreElements()
   {
@@ -209,10 +213,9 @@
   /**
    * This does the same as nextTokens. This is the
    * <code>Enumeration</code interface method.
-   *
-   * @return the next token with respect to the current delimiter characters
-   * @throws NoSuchElementException if there are no more tokens
-   * @see #nextToken()
+   * @return the next token with respect to the new delimiter characters.
+   * @exception NoSuchElementException if there are no more tokens.
+   * @see #nextToken
    */
   public Object nextElement() throws NoSuchElementException
   {
@@ -222,47 +225,49 @@
   /**
    * This counts the number of remaining tokens in the string, with
    * respect to the current delimiter set.
-   *
-   * @return the number of times <code>nextTokens()</code> will succeed
-   * @see #nextToken()
+   * @return the number of times <code>nextTokens()</code> will
+   * succeed.  
+   * @see #nextToken
    */
   public int countTokens()
   {
     int count = 0;
     int delimiterCount = 0;
-    boolean tokenFound = false; // Set when a non-delimiter is found
+    boolean tokenFound = false;		// Set when a non-delimiter is found
     int tmpPos = pos;
 
     // Note for efficiency, we count up the delimiters rather than check
     // retDelims every time we encounter one.  That way, we can
     // just do the conditional once at the end of the method
-    while (tmpPos < len)
+    while (tmpPos < str.length())
       {
-        if (delim.indexOf(str.charAt(tmpPos++)) >= 0)
-          {
-            if (tokenFound)
-              {
-                // Got to the end of a token
-                count++;
-                tokenFound = false;
-              }
-            delimiterCount++; // Increment for this delimiter
-          }
-        else
-          {
-            tokenFound = true;
-            // Get to the end of the token
-            while (tmpPos < len
-                   && delim.indexOf(str.charAt(tmpPos)) < 0)
-              ++tmpPos;
-          }
+	if (delim.indexOf(str.charAt(tmpPos++)) > -1)
+	  {
+	    if (tokenFound)
+	      {
+		// Got to the end of a token
+	        count++;
+	        tokenFound = false;
+	      }
+
+	    delimiterCount++;		// Increment for this delimiter
+	  }
+	else
+	  {
+	    tokenFound = true;
+
+	    // Get to the end of the token
+	    while (tmpPos < str.length()
+		   && delim.indexOf(str.charAt(tmpPos)) == -1)
+	      ++tmpPos;
+	  }
       }
 
-    // Make sure to count the last token
+    // Make sure to count the last token 
     if (tokenFound)
       count++;
 
     // if counting delmiters add them into the token count
     return retDelims ? count + delimiterCount : count;
   }
-} // class StringTokenizer
+}
