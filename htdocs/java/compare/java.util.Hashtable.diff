--- /home/tromey/gnu/egcs/classpath/classpath/java/util/Hashtable.java	Tue May  7 11:02:06 2002
+++ java/util/Hashtable.java	Sun Apr  7 15:27:50 2002
@@ -1,6 +1,6 @@
 /* Hashtable.java -- a class providing a basic hashtable data structure,
    mapping Object --> Object
-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -102,9 +102,6 @@
 public class Hashtable extends Dictionary
   implements Map, Cloneable, Serializable
 {
-  // WARNING: Hashtable is a CORE class in the bootstrap cycle. See the
-  // comments in vm/reference/java/lang/Runtime for implications of this fact.
-
   /** Default number of buckets. This is the value the JDK 1.3 uses. Some
    * early documentation specified this value as 101. That is incorrect.
    */
@@ -179,7 +176,7 @@
    * pair. A Hashtable Entry is identical to a HashMap Entry, except that
    * `null' is not allowed for keys and values.
    */
-  private static final class HashEntry extends AbstractMap.BasicMapEntry
+  private static final class HashEntry extends BasicMapEntry
   {
     /** The next entry in the linked list. */
     HashEntry next;
@@ -343,9 +340,9 @@
    *
    * @param value the value to search for in this Hashtable
    * @return true if at least one key maps to the value
+   * @throws NullPointerException if <code>value</code> is null
    * @see #contains(Object)
    * @see #containsKey(Object)
-   * @throws NullPointerException if <code>value</code> is null
    * @since 1.2
    */
   public boolean containsValue(Object value)
@@ -364,7 +361,7 @@
     // Must throw on null argument even if the table is empty
     if (value == null)
       throw new NullPointerException();
- 
+
     return false;
   }
 
@@ -514,9 +511,9 @@
       {
         Map.Entry e = (Map.Entry) itr.next();
         // Optimize in case the Entry is one of our own.
-        if (e instanceof AbstractMap.BasicMapEntry)
+        if (e instanceof BasicMapEntry)
           {
-            AbstractMap.BasicMapEntry entry = (AbstractMap.BasicMapEntry) e;
+            BasicMapEntry entry = (BasicMapEntry) e;
             put(entry.key, entry.value);
           }
         else
@@ -766,9 +763,9 @@
   /**
    * Returns true if this Hashtable equals the supplied Object <code>o</code>.
    * As specified by Map, this is:
-   * <code>
+   * <pre>
    * (o instanceof Map) && entrySet().equals(((Map) o).entrySet());
-   * </code>
+   * </pre>
    *
    * @param o the object to compare to
    * @return true if o is an equal map
@@ -815,10 +812,7 @@
    */
   private int hash(Object key)
   {
-    // Note: Inline Math.abs here, for less method overhead, and to avoid
-    // a bootstrap dependency, since Math relies on native methods.
-    int hash = key.hashCode() % buckets.length;
-    return hash < 0 ? -hash : hash;
+    return Math.abs(key.hashCode() % buckets.length);
   }
 
   /**
@@ -829,8 +823,7 @@
    * @return the matching entry, if found, or null
    * @see #entrySet()
    */
-  // Package visible, for use in nested classes.
-  HashEntry getEntry(Object o)
+  private HashEntry getEntry(Object o)
   {
     if (! (o instanceof Map.Entry))
       return null;
@@ -876,7 +869,7 @@
   /**
    * Increases the size of the Hashtable and rehashes all keys to new array
    * indices; this is called when the addition of a new value would cause
-   * size() &gt; threshold. Note that the existing Entry objects are reused in
+   * size() > threshold. Note that the existing Entry objects are reused in
    * the new hash table.
    * <p>
    *
@@ -1146,4 +1139,4 @@
       return type == VALUES ? e.value : e.key;
     }
   } // class Enumerator
-} // class Hashtable
+}
