--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URLClassLoader.java	2004-04-13 02:20:24.000000000 -0600
+++ java/net/URLClassLoader.java	2003-08-29 02:18:11.000000000 -0600
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -35,6 +35,7 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package java.net;
 
 import java.io.ByteArrayOutputStream;
@@ -42,23 +43,23 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FilePermission;
-import java.io.IOException;
 import java.io.InputStream;
-import java.security.AccessControlContext;
+import java.io.IOException;
 import java.security.AccessController;
+import java.security.AccessControlContext;
 import java.security.CodeSource;
-import java.security.PermissionCollection;
-import java.security.PrivilegedAction;
 import java.security.SecureClassLoader;
+import java.security.PrivilegedAction;
+import java.security.PermissionCollection;
 import java.security.cert.Certificate;
 import java.util.Enumeration;
-import java.util.HashMap;
 import java.util.Vector;
+import java.util.HashMap;
 import java.util.jar.Attributes;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
-
+import gnu.gcj.runtime.SharedLibHelper;
 
 /**
  * A secure class loader that can load classes and resources from
@@ -117,6 +118,7 @@
  * @author Mark Wielaard (mark@klomp.org)
  * @author Wu Gansha (gansha.wu@intel.com)
  */
+ 
 public class URLClassLoader extends SecureClassLoader
 {
   // Class Variables
@@ -128,7 +130,7 @@
    * XXX - Keeps these loaders forever which prevents garbage collection.
    */
   private static HashMap urlloaders = new HashMap();
-
+    
   /**
    * A cache to store mappings between handler factory and its
    * private protocol handler cache (also a HashMap), so we can avoid
@@ -142,12 +144,12 @@
   private final Vector urls = new Vector();
 
   /**
-   * Store pre-parsed information for each url into this vector
-   * each element is a URL loader, corresponding to the URL of
+   * Store pre-parsed information for each url into this vector 
+   * each element is a URL loader, corresponding to the URL of 
    * the same index in "urls"
    */
   private final Vector urlinfos = new Vector();
-
+    
   /** Factory used to get the protocol handlers of the URLs */
   private final URLStreamHandlerFactory factory;
 
@@ -159,12 +161,12 @@
   private final AccessControlContext securityContext;
 
   // Helper classes
-
-  /**
+ 
+  /** 
    * A <code>URLLoader</code> contains all logic to load resources from a
    * given base <code>URL</code>.
    */
-  abstract static class URLLoader
+  static abstract class URLLoader
   {
     /**
      * Our classloader to get info from if needed.
@@ -193,6 +195,17 @@
     }
 
     /**
+     * Returns a <code>Class</code> loaded by this
+     * <code>URLLoader</code>, or <code>null</code> when this loader
+     * either can't load the class or doesn't know how to load classes
+     * at all.
+     */
+    Class getClass(String className)
+    {
+      return null;
+    }
+
+    /**
      * Returns a <code>Resource</code> loaded by this
      * <code>URLLoader</code>, or <code>null</code> when no
      * <code>Resource</code> with the given name exists.
@@ -210,14 +223,14 @@
     }
   }
 
-  /**
+  /** 
    * A <code>Resource</code> represents a resource in some
    * <code>URLLoader</code>. It also contains all information (e.g.,
    * <code>URL</code>, <code>CodeSource</code>, <code>Manifest</code> and
    * <code>InputStream</code>) that is necessary for loading resources
    * and creating classes from a <code>URL</code>.
    */
-  abstract static class Resource
+  static abstract class Resource
   {
     final URLLoader loader;
     final String name;
@@ -272,10 +285,10 @@
    * A <code>JarURLLoader</code> is a type of <code>URLLoader</code>
    * only loading from jar url.
    */
-  static final class JarURLLoader extends URLLoader
+  final static class JarURLLoader extends URLLoader
   {
     final JarFile jarfile; // The jar file for this url
-    final URL baseJarURL; // Base jar: url for all resources loaded from jar
+    final URL baseJarURL;  // Base jar: url for all resources loaded from jar
 
     public JarURLLoader(URLClassLoader classloader, URL baseURL)
     {
@@ -292,17 +305,13 @@
       URL baseJarURL = null;
       JarFile jarfile = null;
       try
-        {
-	  baseJarURL =
-	    new URL(null, jarURL, classloader.getURLStreamHandler("jar"));
-
-	  jarfile =
-	    ((JarURLConnection) baseJarURL.openConnection()).getJarFile();
-        }
-      catch (IOException ioe)
-        {
-	  /* ignored */
-        }
+	{
+	  baseJarURL
+	    = new URL(null, jarURL, classloader.getURLStreamHandler("jar"));
+	  jarfile
+	    = ((JarURLConnection) baseJarURL.openConnection()).getJarFile();
+	}
+      catch (IOException ioe) { /* ignored */ }
 
       this.baseJarURL = baseJarURL;
       this.jarfile = jarfile;
@@ -315,10 +324,10 @@
 	return null;
 
       if (name.startsWith("/"))
-	name = name.substring(1);
+        name = name.substring(1);
 
       JarEntry je = jarfile.getJarEntry(name);
-      if (je != null)
+      if(je != null)
 	return new JarURLResource(this, name, je);
       else
 	return null;
@@ -327,17 +336,17 @@
     Manifest getManifest()
     {
       try
-        {
+	{
 	  return (jarfile == null) ? null : jarfile.getManifest();
-        }
+	}
       catch (IOException ioe)
-        {
+	{
 	  return null;
-        }
+	}
     }
   }
 
-  static final class JarURLResource extends Resource
+  final static class JarURLResource extends Resource
   {
     private final JarEntry entry;
 
@@ -349,12 +358,12 @@
 
     InputStream getInputStream() throws IOException
     {
-      return ((JarURLLoader) loader).jarfile.getInputStream(entry);
+      return ((JarURLLoader)loader).jarfile.getInputStream(entry);
     }
 
     int getLength()
     {
-      return (int) entry.getSize();
+      return (int)entry.getSize();
     }
 
     Certificate[] getCertificates()
@@ -365,25 +374,25 @@
     URL getURL()
     {
       try
-        {
-	  return new URL(((JarURLLoader) loader).baseJarURL, name,
-	                 loader.classloader.getURLStreamHandler("jar"));
-        }
-      catch (MalformedURLException e)
-        {
+	{
+	  return new URL(((JarURLLoader)loader).baseJarURL, name,
+			 loader.classloader.getURLStreamHandler("jar"));
+	}
+      catch(MalformedURLException e)
+	{
 	  InternalError ie = new InternalError();
 	  ie.initCause(e);
 	  throw ie;
-        }
+	}
     }
   }
 
   /**
    * Loader for remote directories.
    */
-  static final class RemoteURLLoader extends URLLoader
+  final static class RemoteURLLoader extends URLLoader
   {
-    private final String protocol;
+    final private String protocol;
 
     RemoteURLLoader(URLClassLoader classloader, URL url)
     {
@@ -398,9 +407,9 @@
     Resource getResource(String name)
     {
       try
-        {
-	  URL url =
-	    new URL(baseURL, name, classloader.getURLStreamHandler(protocol));
+	{
+	  URL url = new URL(baseURL, name,
+			    classloader.getURLStreamHandler(protocol));
 	  URLConnection connection = url.openConnection();
 
 	  // Open the connection and check the stream
@@ -411,9 +420,9 @@
 	  // We can do some extra checking if it is a http request
 	  if (connection instanceof HttpURLConnection)
 	    {
-	      int response =
-		((HttpURLConnection) connection).getResponseCode();
-	      if (response / 100 != 2)
+	      int response
+		= ((HttpURLConnection)connection).getResponseCode();
+	      if (response/100 != 2)
 		return null;
 	    }
 
@@ -421,25 +430,25 @@
 	    return new RemoteResource(this, name, url, stream, length);
 	  else
 	    return null;
-        }
+	}
       catch (IOException ioe)
-        {
+	{
 	  return null;
-        }
+	}
     }
   }
 
   /**
    * A resource from some remote location.
    */
-  static final class RemoteResource extends Resource
+  final static class RemoteResource extends Resource
   {
-    private final URL url;
-    private final InputStream stream;
-    private final int length;
+    final private URL url;
+    final private InputStream stream;
+    final private int length;
 
     RemoteResource(RemoteURLLoader loader, String name, URL url,
-                   InputStream stream, int length)
+		   InputStream stream, int length)
     {
       super(loader, name);
       this.url = url;
@@ -464,12 +473,69 @@
   }
 
   /**
+   * A <code>SoURLLoader</code> is a type of <code>URLLoader</code>
+   * that loads classes and resources from a shared library.
+   */
+  final static class SoURLLoader extends URLLoader
+  {
+    SharedLibHelper helper;
+
+    SoURLLoader(URLClassLoader classloader, URL url)
+    {
+      super(classloader, url);
+      helper = SharedLibHelper.findHelper(classloader, url.getFile(),
+					  noCertCodeSource);
+    }
+
+    Class getClass(String className)
+    {
+      return helper.findClass(className);
+    }
+
+    Resource getResource(String name)
+    {
+      URL url = helper.findResource(name);
+      if (url == null)
+	return null;
+      return new SoResource(this, name, url);
+    }
+  }
+
+  final static class SoResource extends Resource
+  {
+    SoResource(SoURLLoader loader, String name, URL url)
+    {
+      super(loader, name);
+      this.url = url;
+    }
+
+    InputStream getInputStream() throws IOException
+    {
+      URLConnection conn = url.openConnection();
+      return conn.getInputStream();
+    }
+
+    public int getLength()
+    {
+      // FIXME we could find this by asking the core object.
+      return -1;
+    }
+
+    public URL getURL ()
+    {
+      return url;
+    }
+
+    final URL url;
+  }
+
+  /**
    * A <code>FileURLLoader</code> is a type of <code>URLLoader</code>
    * only loading from file url.
    */
-  static final class FileURLLoader extends URLLoader
+  final static class FileURLLoader extends URLLoader
   {
-    File dir; //the file for this file url
+    File dir;   //the file for this file url
 
     FileURLLoader(URLClassLoader classloader, URL url)
     {
@@ -481,13 +547,13 @@
     Resource getResource(String name)
     {
       File file = new File(dir, name);
-      if (file.exists() && ! file.isDirectory())
+      if (file.exists() && !file.isDirectory())
 	return new FileResource(this, name, file);
       return null;
     }
   }
 
-  static final class FileResource extends Resource
+  final static class FileResource extends Resource
   {
     final File file;
 
@@ -501,28 +567,28 @@
     {
       return new FileInputStream(file);
     }
-
+                        
     public int getLength()
     {
-      return (int) file.length();
+      return (int)file.length();
     }
 
     public URL getURL()
     {
       try
-        {
+	{
 	  return new URL(loader.baseURL, name,
-	                 loader.classloader.getURLStreamHandler("file"));
-        }
-      catch (MalformedURLException e)
-        {
+			 loader.classloader.getURLStreamHandler("file"));
+	}
+      catch(MalformedURLException e)
+	{
 	  InternalError ie = new InternalError();
 	  ie.initCause(e);
 	  throw ie;
-        }
+	}
     }
   }
-
+    
   // Constructors
 
   /**
@@ -576,7 +642,7 @@
    * load classes and resources (after using the supplied parent ClassLoader).
    * @exception SecurityException if the SecurityManager disallows the
    * creation of a ClassLoader.
-   * @exception SecurityException
+   * @exception SecurityException 
    * @param urls Locations that should be searched by this ClassLoader when
    * resolving Classes or Resources.
    * @param parent The parent class loader used before trying this class
@@ -606,7 +672,7 @@
    * @param securityContext the security context of the unprivileged code.
    */
   private URLClassLoader(ClassLoader parent,
-                         AccessControlContext securityContext)
+			 AccessControlContext securityContext)
   {
     super(parent);
     this.factory = null;
@@ -624,7 +690,7 @@
    * protocol handlers of the supplied URLs.
    * @exception SecurityException if the SecurityManager disallows the
    * creation of a ClassLoader.
-   * @exception SecurityException
+   * @exception SecurityException 
    * @param urls Locations that should be searched by this ClassLoader when
    * resolving Classes or Resources.
    * @param parent The parent class loader used before trying this class
@@ -632,8 +698,9 @@
    * @param factory Used to get the protocol handler for the URLs.
    * @see SecureClassLoader
    */
-  public URLClassLoader(URL[] urls, ClassLoader parent,
-                        URLStreamHandlerFactory factory)
+  public URLClassLoader(URL[] urls,
+			ClassLoader parent,
+			URLStreamHandlerFactory factory)
     throws SecurityException
   {
     super(parent);
@@ -644,7 +711,7 @@
     // If this factory is still not in factoryCache, add it,
     //   since we only support three protocols so far, 5 is enough 
     //   for cache initial size
-    synchronized (factoryCache)
+    synchronized(factoryCache)
       {
 	if (factory != null && factoryCache.get(factory) == null)
 	  factoryCache.put(factory, new HashMap(5));
@@ -664,22 +731,24 @@
 
   private void addURLImpl(URL newUrl)
   {
-    synchronized (urlloaders)
+    synchronized(urlloaders)
       {
 	if (newUrl == null)
 	  return; // Silently ignore...
-
+        
 	// Check global cache to see if there're already url loader
 	// for this url.
-	URLLoader loader = (URLLoader) urlloaders.get(newUrl);
+	URLLoader loader = (URLLoader)urlloaders.get(newUrl);
 	if (loader == null)
 	  {
 	    String file = newUrl.getFile();
-
+	    String protocol = newUrl.getProtocol();
 	    // Check that it is not a directory
-	    if (! (file.endsWith("/") || file.endsWith(File.separator)))
+	    if ("gcjlib".equals(protocol))
+	      loader = new SoURLLoader(this, newUrl);
+	    else if (! (file.endsWith("/") || file.endsWith(File.separator)))
 	      loader = new JarURLLoader(this, newUrl);
-	    else if ("file".equals(newUrl.getProtocol()))
+	    else if ("file".equals(protocol))
 	      loader = new FileURLLoader(this, newUrl);
 	    else
 	      loader = new RemoteURLLoader(this, newUrl);
@@ -700,10 +769,12 @@
   private void addURLs(URL[] newUrls)
   {
     for (int i = 0; i < newUrls.length; i++)
+    {
       addURLImpl(newUrls[i]);
+    }
   }
 
-  /**
+  /** 
    * Defines a Package based on the given name and the supplied manifest
    * information. The manifest indicates the tile, version and
    * vendor information of the specification and implementation and wheter the
@@ -718,16 +789,22 @@
    * @param url the code source url to seal the package
    * @return the defined Package
    */
-  protected Package definePackage(String name, Manifest manifest, URL url)
+  protected Package definePackage(String name, Manifest manifest, URL url) 
     throws IllegalArgumentException
   {
     Attributes attr = manifest.getMainAttributes();
-    String specTitle = attr.getValue(Attributes.Name.SPECIFICATION_TITLE);
-    String specVersion = attr.getValue(Attributes.Name.SPECIFICATION_VERSION);
-    String specVendor = attr.getValue(Attributes.Name.SPECIFICATION_VENDOR);
-    String implTitle = attr.getValue(Attributes.Name.IMPLEMENTATION_TITLE);
-    String implVersion = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
-    String implVendor = attr.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);
+    String specTitle =
+      attr.getValue(Attributes.Name.SPECIFICATION_TITLE); 
+    String specVersion =
+      attr.getValue(Attributes.Name.SPECIFICATION_VERSION); 
+    String specVendor =
+      attr.getValue(Attributes.Name.SPECIFICATION_VENDOR); 
+    String implTitle =
+      attr.getValue(Attributes.Name.IMPLEMENTATION_TITLE); 
+    String implVersion =
+      attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION); 
+    String implVendor =
+      attr.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);
 
     // Look if the Manifest indicates that this package is sealed
     // XXX - most likely not completely correct!
@@ -736,11 +813,13 @@
     // But how do we get that jar manifest here?
     String sealed = attr.getValue(Attributes.Name.SEALED);
     if ("false".equals(sealed))
+    {
       // make sure that the URL is null so the package is not sealed
       url = null;
+    }
 
-    return definePackage(name, specTitle, specVersion, specVendor, implTitle,
-                         implVersion, implVendor, url);
+    return definePackage(name, specTitle, specVersion, specVendor,
+			 implTitle, implVersion, implVendor, url);
   }
 
   /**
@@ -757,7 +836,20 @@
   {
     // Just try to find the resource by the (almost) same name
     String resourceName = className.replace('.', '/') + ".class";
-    Resource resource = findURLResource(resourceName);
+    int max = urls.size();
+    Resource resource = null;
+    for (int i = 0; i < max && resource == null; i++)
+      {
+	URLLoader loader = (URLLoader)urlinfos.elementAt(i);
+	if (loader == null)
+	  continue;
+
+	Class k = loader.getClass(className);
+	if (k != null)
+	  return k;
+
+	resource = loader.getResource(resourceName);
+      }
     if (resource == null)
       throw new ClassNotFoundException(className + " not found in " + urls);
 
@@ -765,81 +857,80 @@
     // construct the class (and watch out for those nasty IOExceptions)
     try
       {
-	byte[] data;
+	byte [] data;
 	InputStream in = resource.getInputStream();
-	try
+	int length = resource.getLength();
+	if (length != -1)
 	  {
-	    int length = resource.getLength();
-	    if (length != -1)
-	      {
-		// We know the length of the data.
-		// Just try to read it in all at once
-		data = new byte[length];
-		int pos = 0;
-		while (length - pos > 0)
-		  {
-		    int len = in.read(data, pos, length - pos);
-		    if (len == -1)
-		      throw new EOFException("Not enough data reading from: "
-		                             + in);
-		    pos += len;
-		  }
-	      }
-	    else
+	    // We know the length of the data.
+	    // Just try to read it in all at once
+	    data = new byte[length];
+	    int pos = 0;
+	    while(length - pos > 0)
 	      {
-		// We don't know the data length.
-		// Have to read it in chunks.
-		ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
-		byte[] b = new byte[4096];
-		int l = 0;
-		while (l != -1)
-		  {
-		    l = in.read(b);
-		    if (l != -1)
-		      out.write(b, 0, l);
-		  }
-		data = out.toByteArray();
+		int len = in.read(data, pos, length - pos);
+		if (len == -1)
+		  throw new EOFException("Not enough data reading from: "
+					 + in);
+		pos += len;
 	      }
 	  }
-	finally
+	else
 	  {
-	    in.close();
+	    // We don't know the data length.
+	    // Have to read it in chunks.
+	    ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
+	    byte b[] = new byte[4096];
+	    int l = 0;
+	    while (l != -1)
+	      {
+		l = in.read(b);
+		if (l != -1)
+		  out.write(b, 0, l);
+	      }
+	    data = out.toByteArray();
 	  }
 	final byte[] classData = data;
 
 	// Now get the CodeSource
 	final CodeSource source = resource.getCodeSource();
-
+	
 	// Find out package name
 	String packageName = null;
 	int lastDot = className.lastIndexOf('.');
 	if (lastDot != -1)
 	  packageName = className.substring(0, lastDot);
-
+	
 	if (packageName != null && getPackage(packageName) == null)
 	  {
 	    // define the package
 	    Manifest manifest = resource.loader.getManifest();
 	    if (manifest == null)
-	      definePackage(packageName, null, null, null, null, null, null,
-	                    null);
+	      definePackage(packageName,
+			    null, null, null, null, null, null, null);
 	    else
 	      definePackage(packageName, manifest, resource.loader.baseURL);
 	  }
-
+	
 	// And finally construct the class!
 	SecurityManager sm = System.getSecurityManager();
 	if (sm != null && securityContext != null)
-	  return (Class) AccessController.doPrivileged(new PrivilegedAction()
-	      {
-		public Object run()
+	  {
+	    return (Class)AccessController.doPrivileged
+	      (new PrivilegedAction()
 		{
-		  return defineClass(className, classData, 0,
-		                     classData.length, source);
-		}
-	      }, securityContext);
+		  public Object run()
+		  {
+		    return defineClass(className, classData,
+				       0, classData.length,
+				       source);
+		  }
+		}, securityContext);
+	  }
 	else
-	  return defineClass(className, classData, 0, classData.length, source);
+	  return defineClass(className, classData,
+			     0, classData.length,
+			     source);
       }
     catch (IOException ioe)
       {
@@ -859,10 +950,10 @@
     int max = urls.size();
     for (int i = 0; i < max; i++)
       {
-	URLLoader loader = (URLLoader) urlinfos.elementAt(i);
+	URLLoader loader = (URLLoader)urlinfos.elementAt(i);
 	if (loader == null)
 	  continue;
-
+	
 	Resource resource = loader.getResource(resourceName);
 	if (resource != null)
 	  return resource;
@@ -881,7 +972,7 @@
     Resource resource = findURLResource(resourceName);
     if (resource != null)
       return resource.getURL();
-
+    
     // Resource not found
     return null;
   }
@@ -902,9 +993,9 @@
     synchronized (factoryCache)
       {
 	// Check if there're handler for the same protocol in cache.
-	HashMap cache = (HashMap) factoryCache.get(factory);
-	handler = (URLStreamHandler) cache.get(protocol);
-	if (handler == null)
+	HashMap cache = (HashMap)factoryCache.get(factory);
+	handler = (URLStreamHandler)cache.get(protocol);
+	if(handler == null)
 	  {
 	    // Add it to cache.
 	    handler = factory.createURLStreamHandler(protocol);
@@ -923,14 +1014,13 @@
    * @return a (possible empty) enumeration of URLs where the resource can be
    * found
    */
-  public Enumeration findResources(String resourceName)
-    throws IOException
+  public Enumeration findResources(String resourceName) throws IOException
   {
     Vector resources = new Vector();
     int max = urls.size();
     for (int i = 0; i < max; i++)
       {
-	URLLoader loader = (URLLoader) urlinfos.elementAt(i);
+	URLLoader loader = (URLLoader)urlinfos.elementAt(i);
 	Resource resource = loader.getResource(resourceName);
 	if (resource != null)
 	  resources.add(resource.getURL());
@@ -962,25 +1052,29 @@
   {
     // XXX - This implementation does exactly as the Javadoc describes.
     // But maybe we should/could use URLConnection.getPermissions()?
+
     // First get the permissions that would normally be granted
     PermissionCollection permissions = super.getPermissions(source);
-
+        
     // Now add any extra permissions depending on the URL location.
     URL url = source.getLocation();
     String protocol = url.getProtocol();
     if (protocol.equals("file"))
       {
 	String file = url.getFile();
-
 	// If the file end in / it must be an directory.
 	if (file.endsWith("/") || file.endsWith(File.separator))
-	  // Grant permission to read everything in that directory and
-	  // all subdirectories.
-	  permissions.add(new FilePermission(file + "-", "read"));
+	  {
+	    // Grant permission to read everything in that directory and
+	    // all subdirectories.
+	    permissions.add(new FilePermission(file + "-", "read"));
+	  }
 	else
-	  // It is a 'normal' file.
-	  // Grant permission to access that file.
-	  permissions.add(new FilePermission(file, "read"));
+	  {
+	    // It is a 'normal' file.
+	    // Grant permission to access that file.
+	    permissions.add(new FilePermission(file, "read"));
+	  }
       }
     else
       {
@@ -992,7 +1086,7 @@
 
     return permissions;
   }
-
+    
   /**
    * Returns all the locations that this class loader currently uses the
    * resolve classes and resource. This includes both the initially supplied
@@ -1015,7 +1109,7 @@
    * @exception SecurityException when the calling code does not have
    * permission to access the given <code>URL</code>s
    */
-  public static URLClassLoader newInstance(URL[] urls)
+  public static URLClassLoader newInstance(URL urls[])
     throws SecurityException
   {
     return newInstance(urls, null);
@@ -1033,7 +1127,8 @@
    * @exception SecurityException when the calling code does not have
    * permission to access the given <code>URL</code>s
    */
-  public static URLClassLoader newInstance(URL[] urls, final ClassLoader parent)
+  public static URLClassLoader newInstance(URL urls[],
+					   final ClassLoader parent)
     throws SecurityException
   {
     SecurityManager sm = System.getSecurityManager();
@@ -1042,21 +1137,21 @@
     else
       {
 	final Object securityContext = sm.getSecurityContext();
-
 	// XXX - What to do with anything else then an AccessControlContext?
-	if (! (securityContext instanceof AccessControlContext))
-	  throw new SecurityException("securityContext must be AccessControlContext: "
-	                              + securityContext);
-
+	if (!(securityContext instanceof AccessControlContext))
+	  throw new SecurityException
+	    ("securityContext must be AccessControlContext: "
+	     + securityContext);
+	
 	URLClassLoader loader =
-	  (URLClassLoader) AccessController.doPrivileged(new PrivilegedAction()
+	  (URLClassLoader)AccessController.doPrivileged(new PrivilegedAction()
+	    {
+	      public Object run()
 	      {
-		public Object run()
-		{
-		  return new URLClassLoader(parent,
-		                            (AccessControlContext) securityContext);
-		}
-	      });
+		return new URLClassLoader
+		  (parent, (AccessControlContext)securityContext);
+	      }
+	    });
 	loader.addURLs(urls);
 	return loader;
       }
