--- /home/tromey/gnu/egcs/classpath/classpath/java/util/HashSet.java	Fri Oct 26 16:06:57 2001
+++ java/util/HashSet.java	Tue Oct 16 09:14:34 2001
@@ -1,5 +1,5 @@
-/* HashSet.java -- a class providing a HashMap-backed Set
-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+/* HashSet.java -- a class providing a HashMap-backet Set
+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -33,115 +33,87 @@
 import java.io.ObjectOutputStream;
 
 /**
- * This class provides a HashMap-backed implementation of the Set interface.
- * <p>
+ * This class provides a HashMap-backed implementation of the 
+ * Set interface.
  *
- * Most operations are O(1), assuming no hash collisions.  In the worst
- * case (where all hashes collide), operations are O(n). Setting the
- * initial capacity too low will force many resizing operations, but
- * setting the initial capacity too high (or loadfactor too low) leads
- * to wasted memory and slower iteration.
- * <p>
+ * Each element in the Set is a key in the backing HashMap; each key
+ * maps to a static token, denoting that the key does, in fact, exist.
  *
- * HashSet accepts the null key and null values.  It is not synchronized,
- * so if you need multi-threaded access, consider using:<br>
- * <code>Set s = Collections.synchronizedSet(new HashSet(...));</code>
- * <p>
+ * Most operations are O(1), assuming no hash collisions.  In the worst
+ * case (where all hases collide), operations are O(n).
  *
- * The iterators are <i>fail-fast</i>, meaning that any structural
- * modification, except for <code>remove()</code> called on the iterator
- * itself, cause the iterator to throw a
- * {@link ConcurrentModificationException} rather than exhibit
- * non-deterministic behavior.
+ * HashSet is a part of the JDK1.2 Collections API.
  *
- * @author Jon Zeppieri
- * @author Eric Blake <ebb9@email.byu.edu>
- * @see Collection
- * @see Set
- * @see TreeSet
- * @see Collections#synchronizedSet(Set)
- * @see HashMap
- * @see LinkedHashSet
- * @since 1.2
- * @status updated to 1.4
+ * @author      Jon Zeppieri
  */
 public class HashSet extends AbstractSet
   implements Set, Cloneable, Serializable
 {
-  /**
-   * Compatible with JDK 1.2.
-   */
-  private static final long serialVersionUID = -5024744406713321676L;
-
-  /**
-   * The HashMap which backs this Set.
-   */
-  private transient HashMap map;
+  /** the HashMap which backs this Set */
+  transient HashMap map;
+  static final long serialVersionUID = -5024744406713321676L;
 
   /**
-   * Construct a new, empty HashSet whose backing HashMap has the default
-   * capacity (11) and loadFacor (0.75).
+   * construct a new, empty HashSet whose backing HashMap has the default 
+   * capacity and loadFacor
    */
   public HashSet()
   {
-    this(HashMap.DEFAULT_CAPACITY, HashMap.DEFAULT_LOAD_FACTOR);
+    map = new HashMap();
   }
 
   /**
-   * Construct a new, empty HashSet whose backing HashMap has the supplied
-   * capacity and the default load factor (0.75).
+   * construct a new, empty HashSet whose backing HashMap has the supplied
+   * capacity and the default load factor
    *
-   * @param initialCapacity the initial capacity of the backing HashMap
-   * @throws IllegalArgumentException if the capacity is negative
+   * @param          initialCapacity          the initial capacity of the backing
+   *                                          HashMap
    */
   public HashSet(int initialCapacity)
   {
-    this(initialCapacity, HashMap.DEFAULT_LOAD_FACTOR);
+    map = new HashMap(initialCapacity);
   }
 
   /**
-   * Construct a new, empty HashSet whose backing HashMap has the supplied
-   * capacity and load factor.
+   * construct a new, empty HashSet whose backing HashMap has the supplied
+   * capacity and load factor
    *
-   * @param initialCapacity the initial capacity of the backing HashMap
-   * @param loadFactor the load factor of the backing HashMap
-   * @throws IllegalArgumentException if either argument is negative, or
-   *         if loadFactor is POSITIVE_INFINITY or NaN
+   * @param          initialCapacity          the initial capacity of the backing
+   *                                          HashMap
+   * @param          loadFactor               the load factor of the backing HashMap
    */
   public HashSet(int initialCapacity, float loadFactor)
   {
-    map = init(initialCapacity, loadFactor);
+    map = new HashMap(initialCapacity, loadFactor);
   }
 
   /**
-   * Construct a new HashSet with the same elements as are in the supplied
-   * collection (eliminating any duplicates, of course). The backing storage
-   * has twice the size of the collection, or the default size of 11,
-   * whichever is greater; and the default load factor (0.75).
+   * construct a new HashSet with the same elements as are in the supplied
+   * collection (eliminating any duplicates, of course; the backing HashMap
+   * will have the default capacity and load factor
    *
-   * @param c a collection of initial set elements
-   * @throws NullPointerException if c is null
+   * @param          c          a collection containing the elements with
+   *                            which this set will be initialized
    */
   public HashSet(Collection c)
   {
-    this(Math.max(2 * c.size(), HashMap.DEFAULT_CAPACITY));
+    map = new HashMap();
     addAll(c);
   }
 
   /**
-   * Adds the given Object to the set if it is not already in the Set.
-   * This set permits a null element.
+   * adds the given Object to the set if it is not already in the Set,
+   * returns true if teh element was added, false otherwise
    *
-   * @param o the Object to add to this Set
-   * @return true if the set did not already contain o
+   * @param       o       the Object to add to this Set
    */
   public boolean add(Object o)
   {
-    return map.put(o, "") == null;
+    return (map.put(o, Boolean.TRUE) == null);
   }
 
   /**
-   * Empties this Set of all elements; this takes constant time.
+   * empties this Set of all elements; this is a fast operation [O(1)]
    */
   public void clear()
   {
@@ -149,67 +121,53 @@
   }
 
   /**
-   * Returns a shallow copy of this Set. The Set itself is cloned; its
-   * elements are not.
-   *
-   * @return a shallow clone of the set
+   * returns a shallow copy of this Set (the Set itself is cloned; its 
+   * elements are not)
    */
   public Object clone()
   {
     HashSet copy = null;
     try
       {
-        copy = (HashSet) super.clone();
+	copy = (HashSet) super.clone();
       }
     catch (CloneNotSupportedException x)
       {
-        // Impossible to get here.
       }
     copy.map = (HashMap) map.clone();
     return copy;
   }
 
   /**
-   * Returns true if the supplied element is in this Set.
+   * returns true if the supplied element is in this Set, false otherwise
    *
-   * @param o the Object to look for
-   * @return true if it is in the set
+   * @param        o         the Object whose presence in this Set we are testing for
    */
   public boolean contains(Object o)
   {
     return map.containsKey(o);
   }
 
-  /**
-   * Returns true if this set has no elements in it.
-   *
-   * @return <code>size() == 0</code>.
+  /** 
+   * returns true if this set has no elements in it (size() == 0)
    */
   public boolean isEmpty()
   {
-    return map.size == 0;
+    return map.isEmpty();
   }
 
   /**
-   * Returns an Iterator over the elements of this Set, which visits the
-   * elements in no particular order.  For this class, the Iterator allows
-   * removal of elements. The iterator is fail-fast, and will throw a
-   * ConcurrentModificationException if the set is modified externally.
-   *
-   * @return a set iterator
-   * @see ConcurrentModificationException
+   * returns an Iterator over the elements of this Set; the Iterator allows
+   * removal of elements
    */
   public Iterator iterator()
   {
-    // Avoid creating intermediate keySet() object by using non-public API.
-    return map.iterator(HashMap.KEYS);
+    return map.keySet().iterator();
   }
 
   /**
-   * Removes the supplied Object from this Set if it is in the Set.
-   *
-   * @param o the object to remove
-   * @return true if an element was removed
+   * removes the supplied Object from this Set if it is in the Set; returns
+   * true if an element was removed, false otherwise
    */
   public boolean remove(Object o)
   {
@@ -217,42 +175,18 @@
   }
 
   /**
-   * Returns the number of elements in this Set (its cardinality).
-   *
-   * @return the size of the set
+   * returns the number of elements in this Set
    */
   public int size()
   {
-    return map.size;
-  }
-
-  /**
-   * Helper method which initializes the backing Map. Overridden by
-   * LinkedHashSet for correct semantics.
-   *
-   * @param capacity the initial capacity
-   * @param load the initial load factor
-   * @return the backing HashMap
-   */
-  HashMap init(int capacity, float load)
-  {
-    return new HashMap(capacity, load);
+    return map.size();
   }
 
-  /**
-   * Serializes this object to the given stream.
-   *
-   * @param s the stream to write to
-   * @throws IOException if the underlying stream fails
-   * @serialData the <i>capacity</i> (int) and <i>loadFactor</i> (float)
-   *             of the backing store, followed by the set size (int),
-   *             then a listing of its elements (Object) in no order
-   */
+  /** Serialize this Object in a manner which is binary-compatible with the 
+    * JDK */
   private void writeObject(ObjectOutputStream s) throws IOException
   {
-    s.defaultWriteObject();
-    // Avoid creating intermediate keySet() object by using non-public API.
-    Iterator it = map.iterator(HashMap.KEYS);
+    Iterator it = iterator();
     s.writeInt(map.buckets.length);
     s.writeFloat(map.loadFactor);
     s.writeInt(map.size);
@@ -260,23 +194,25 @@
       s.writeObject(it.next());
   }
 
-  /**
-   * Deserializes this object from the given stream.
-   *
-   * @param s the stream to read from
-   * @throws ClassNotFoundException if the underlying stream fails
-   * @throws IOException if the underlying stream fails
-   * @serialData the <i>capacity</i> (int) and <i>loadFactor</i> (float)
-   *             of the backing store, followed by the set size (int),
-   *             then a listing of its elements (Object) in no order
-   */
-  private void readObject(ObjectInputStream s)
-    throws IOException, ClassNotFoundException
-  {
-    s.defaultReadObject();
-
-    map = init(s.readInt(), s.readFloat());
-    for (int size = s.readInt(); size > 0; size--)
-      map.put(s.readObject(), "");
+  /** Deserialize this Object in a manner which is binary-compatible with 
+    * the JDK */
+  private void readObject(ObjectInputStream s) throws IOException,
+    ClassNotFoundException
+  {
+    int i, size, capacity;
+    float loadFactor;
+    Object element;
+
+    capacity = s.readInt();
+    loadFactor = s.readFloat();
+    size = s.readInt();
+
+    map = new HashMap(capacity, loadFactor);
+
+    for (i = 0; i < size; i++)
+      {
+	element = s.readObject();
+	map.put(element, Boolean.TRUE);
+      }
   }
 }
