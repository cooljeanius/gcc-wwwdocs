--- /home/tromey/gnu/Nightly/classpath/classpath/java/awt/image/SinglePixelPackedSampleModel.java	2004-04-13 02:20:18.000000000 -0600
+++ java/awt/image/SinglePixelPackedSampleModel.java	2004-01-09 02:18:04.000000000 -0700
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000, 2002, 2003, 2004  Free Software Foundation
+/* Copyright (C) 2000, 2002, 2003  Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -162,63 +162,6 @@
 			   1  // length
 			   );
   }
-  
-  /**
-   * This is a more efficient implementation of the default implementation in the super
-   * class. 
-   * @param x The x-coordinate of the pixel rectangle to store in <code>obj</code>.
-   * @param y The y-coordinate of the pixel rectangle to store in <code>obj</code>.
-   * @param w The width of the pixel rectangle to store in <code>obj</code>.
-   * @param h The height of the pixel rectangle to store in <code>obj</code>.
-   * @param obj The primitive array to store the pixels into or null to force creation.
-   * @param data The DataBuffer that is the source of the pixel data.
-   * @return The primitive array containing the pixel data.
-   * @see java.awt.image.SampleModel#getDataElements(int, int, int, int, java.lang.Object, java.awt.image.DataBuffer)
-   */
-  public Object getDataElements(int x, int y, int w, int h, Object obj,
-							DataBuffer data)
-  {
-    int size = w*h;
-    int dataSize = size;
-    Object pixelData = null;
-    switch (getTransferType())
-    {
-      case DataBuffer.TYPE_BYTE:
-        pixelData = ((DataBufferByte) data).getData();
-        if (obj == null) obj = new byte[dataSize];
-        break;
-       case DataBuffer.TYPE_USHORT:
-         pixelData = ((DataBufferUShort) data).getData();
-         if (obj == null) obj = new short[dataSize];
-         break;
-        case DataBuffer.TYPE_INT:
-          pixelData = ((DataBufferInt) data).getData();
-          if (obj == null) obj = new int[dataSize];
-          break;
-         default:
-             // Seems like the only sensible thing to do.
-           throw new ClassCastException();
-      }
-      if(x==0 && scanlineStride == w)
-      { 
-        // The full width need to be copied therefore we can copy in one shot.
-        System.arraycopy(pixelData, scanlineStride*y + data.getOffset(), obj, 0, size);
-      }
-      else
-      {  
-        // Since we do not need the full width we need to copy line by line.
-        int outOffset = 0;
-        int dataOffset = scanlineStride*y + x + data.getOffset();
-        for (int yy = y; yy<(y+h); yy++)
-        {
-          System.arraycopy(pixelData, dataOffset, obj, outOffset, w);
-          dataOffset += scanlineStride;
-          outOffset += w;
-        }
-      }
-    return obj;
-  }
-  
 
   public int[] getPixel(int x, int y, int[] iArray, DataBuffer data)
   {
@@ -258,51 +201,7 @@
     int samples = data.getElem(offset);
     return (samples & bitMasks[b]) >>> bitOffsets[b];
   }
-  
-  /**
-   * This method implements a more efficient way to set data elements than the default
-   * implementation of the super class. It sets the data elements line by line instead 
-   * of pixel by pixel.
-   * @param x The x-coordinate of the data elements in <code>obj</code>.
-   * @param y The y-coordinate of the data elements in <code>obj</code>.
-   * @param w The width of the data elements in <code>obj</code>.
-   * @param h The height of the data elements in <code>obj</code>.
-   * @param obj The primitive array containing the data elements to set.
-   * @param data The DataBuffer to store the data elements into.
-   * @see java.awt.image.SampleModel#setDataElements(int, int, int, int, java.lang.Object, java.awt.image.DataBuffer)
-   */
-  public void setDataElements(int x, int y, int w, int h,
-				Object obj, DataBuffer data)
-  {
-    
-    Object pixelData;
-    switch (getTransferType())
-    {
-      case DataBuffer.TYPE_BYTE:
-        pixelData = ((DataBufferByte) data).getData();
-        break;
-       case DataBuffer.TYPE_USHORT:
-         pixelData = ((DataBufferUShort) data).getData();
-         break;
-       case DataBuffer.TYPE_INT:
-         pixelData = ((DataBufferInt) data).getData();
-         break;
-       default:
-          // Seems like the only sensible thing to do.
-          throw new ClassCastException();
-    }
-    
-    int inOffset = 0;
-    int dataOffset = scanlineStride*y + x + data.getOffset();
-    for (int yy=y; yy<(y+h); yy++)
-    {
-      System.arraycopy(obj,inOffset,pixelData,dataOffset,w);
-      dataOffset += scanlineStride;
-      inOffset += w;
-    }
-  }
-  
-  
+
   public void setDataElements(int x, int y, Object obj, DataBuffer data)
   {
     int offset = scanlineStride*y + x + data.getOffset();
@@ -374,39 +273,6 @@
     data.setElem(offset, samples);
   }
 
-  /**
-   * This method implements a more efficient way to set pixels than the default
-   * implementation of the super class. It copies the pixel components directly
-   * from the input array instead of creating a intermediate buffer.
-   * @param x The x-coordinate of the pixel rectangle in <code>obj</code>.
-   * @param y The y-coordinate of the pixel rectangle in <code>obj</code>.
-   * @param w The width of the pixel rectangle in <code>obj</code>.
-   * @param h The height of the pixel rectangle in <code>obj</code>.
-   * @param obj The primitive array containing the pixels to set.
-   * @param data The DataBuffer to store the pixels into.
-   * @see java.awt.image.SampleModel#setPixels(int, int, int, int, int[], java.awt.image.DataBuffer)
-   */
-  public void setPixels(int x, int y, int w, int h, int[] iArray,
-						DataBuffer data)
-  {
-    int inOffset = 0;
-    int[] pixel = new int[numBands];
-    for (int yy=y; yy<(y+h); yy++)
-     {
-      int offset = scanlineStride*yy + x;
-      for (int xx=x; xx<(x+w); xx++)
-       { 
-        int samples = 0;
-        for (int b=0; b<numBands; b++)
-          samples |= (iArray[inOffset+b] << bitOffsets[b]) & bitMasks[b];
-        data.setElem(0, offset, samples);
-        inOffset += numBands;
-        offset += 1;
-      }
-    }
-  }
-  
-  
   public void setSample(int x, int y, int b, int s, DataBuffer data)
   {
     int offset = scanlineStride*y + x;
@@ -416,24 +282,4 @@
     samples |= (s << bitOffsets[b]) & bitMask;
     data.setElem(offset, samples);
   }
-  
-  /**
-   * Creates a String with some information about this SampleModel.
-   * @return A String describing this SampleModel.
-   * @see java.lang.Object#toString()
-   */
-  public String toString()
-  {
-    StringBuffer result = new StringBuffer();
-    result.append(getClass().getName());
-    result.append("[");
-    result.append("scanlineStride=").append(scanlineStride);
-    for(int i=0; i < bitMasks.length; i+=1)
-    {
-      result.append(", mask[").append(i).append("]=0x").append(Integer.toHexString(bitMasks[i]));
-    }
-    
-    result.append("]");
-    return result.toString();
-  }
 }
