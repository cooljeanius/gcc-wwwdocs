--- /home/tromey/gnu/Nightly/classpath/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-06-08 02:25:49.000000000 -0600
+++ jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-01-14 02:18:59.000000000 -0700
@@ -63,6 +63,10 @@
 
 JNIEnv *gdk_env;
 
+#ifdef PORTABLE_NATIVE_SYNC
+JavaVM *gdk_vm;
+#endif
+
 GtkWindowGroup *global_gtk_window_group;
 
 /*
@@ -83,25 +87,18 @@
   NSA_INIT (env, clazz);
 
   /* GTK requires a program's argc and argv variables, and requires that they
-     be valid.   Set it up. */
-  argv = (char **) g_malloc (sizeof (char *) * 2);
-  argv[0] = (char *) g_malloc(1);
-#if 1
-  strcpy(argv[0], "");
-#else  /* The following is a more efficient alternative, but less intuitively
-	* expresses what we are trying to do.   This code is only run once, so
-	* I'm going for intuitive. */
-  argv[0][0] = '\0';
-#endif
+     be valid.  */
+
+  argv = (char **) malloc (sizeof (char *) * 2);
+  argv[0] = "";
   argv[1] = NULL;
 
   /* until we have JDK 1.2 JNI, assume we have a VM with threads that 
      match what GLIB was compiled for */
 #ifdef PORTABLE_NATIVE_SYNC
-  (*env)->GetJavaVM( env, &the_vm );
-  g_thread_init ( &portable_native_sync_jni_functions );
-  /* Debugging progress message; uncomment if needed: */
-  /*   printf("called gthread init\n"); */
+  (*env)->GetJavaVM( env, &gdk_vm );
+  g_thread_init ( &g_thread_jni_functions );
+  printf("called gthread init\n");
 #else
   g_thread_init ( NULL );
 #endif
@@ -124,15 +121,16 @@
 
   if ((homedir = getenv ("HOME")))
     {
-      rcpath = (char *) g_malloc (strlen (homedir) + strlen (RC_FILE) + 2);
+      rcpath = (char *) malloc (strlen (homedir) + strlen (RC_FILE) + 2);
       sprintf (rcpath, "%s/%s", homedir, RC_FILE);
     }
   
   gtk_rc_parse ((rcpath) ? rcpath : RC_FILE);
 
-  g_free (rcpath);
-  g_free (argv[0]);
-  g_free (argv);
+  if (rcpath)
+    free (rcpath);
+
+  free (argv);
 
   /* setup cached IDs for posting GTK events to Java */
 /*    gtkgenericpeer = (*env)->FindClass (env,  */
