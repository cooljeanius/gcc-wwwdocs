--- /home/tromey/gnu/Nightly/classpath/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-06-08 02:25:49.000000000 -0600
+++ jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-06-18 02:19:02.000000000 -0600
@@ -63,8 +63,18 @@
 
 JNIEnv *gdk_env;
 
+#ifdef PORTABLE_NATIVE_SYNC
+JavaVM *gdk_vm;
+#endif
+
 GtkWindowGroup *global_gtk_window_group;
 
+double dpi_conversion_factor;
+
+static void init_dpi_conversion_factor ();
+static void dpi_changed_cb (GtkSettings  *settings,
+                            GParamSpec   *pspec);
+
 /*
  * Call gtk_init.  It is very important that this happen before any other
  * gtk calls.
@@ -83,25 +93,18 @@
   NSA_INIT (env, clazz);
 
   /* GTK requires a program's argc and argv variables, and requires that they
-     be valid.   Set it up. */
-  argv = (char **) g_malloc (sizeof (char *) * 2);
-  argv[0] = (char *) g_malloc(1);
-#if 1
-  strcpy(argv[0], "");
-#else  /* The following is a more efficient alternative, but less intuitively
-	* expresses what we are trying to do.   This code is only run once, so
-	* I'm going for intuitive. */
-  argv[0][0] = '\0';
-#endif
+     be valid.  */
+
+  argv = (char **) malloc (sizeof (char *) * 2);
+  argv[0] = "";
   argv[1] = NULL;
 
   /* until we have JDK 1.2 JNI, assume we have a VM with threads that 
      match what GLIB was compiled for */
 #ifdef PORTABLE_NATIVE_SYNC
-  (*env)->GetJavaVM( env, &the_vm );
-  g_thread_init ( &portable_native_sync_jni_functions );
-  /* Debugging progress message; uncomment if needed: */
-  /*   printf("called gthread init\n"); */
+  (*env)->GetJavaVM( env, &gdk_vm );
+  g_thread_init ( &g_thread_jni_functions );
+  printf("called gthread init\n");
 #else
   g_thread_init ( NULL );
 #endif
@@ -124,15 +127,16 @@
 
   if ((homedir = getenv ("HOME")))
     {
-      rcpath = (char *) g_malloc (strlen (homedir) + strlen (RC_FILE) + 2);
+      rcpath = (char *) malloc (strlen (homedir) + strlen (RC_FILE) + 2);
       sprintf (rcpath, "%s/%s", homedir, RC_FILE);
     }
   
   gtk_rc_parse ((rcpath) ? rcpath : RC_FILE);
 
-  g_free (rcpath);
-  g_free (argv[0]);
-  g_free (argv);
+  if (rcpath)
+    free (rcpath);
+
+  free (argv);
 
   /* setup cached IDs for posting GTK events to Java */
 /*    gtkgenericpeer = (*env)->FindClass (env,  */
@@ -168,7 +172,7 @@
 					       "postMenuActionEvent",
 					       "()V");
   postMouseEventID = (*env)->GetMethodID (env, gtkcomponentpeer, 
-					  "postMouseEvent", "(IJIIIIZ)V");
+                                          "postMouseEvent", "(IJIIIIZ)V");
   postConfigureEventID = (*env)->GetMethodID (env, gtkwindowpeer, 
 					      "postConfigureEvent", "(IIII)V");
   postWindowEventID = (*env)->GetMethodID (env, gtkwindowpeer,
@@ -196,6 +200,8 @@
 					     "postTextEvent",
 					     "()V");
   global_gtk_window_group = gtk_window_group_new ();
+
+  init_dpi_conversion_factor ();
 }
 
 /*
@@ -209,3 +215,36 @@
   gtk_main ();
   gdk_threads_leave ();
 }
+
+/* This is a big hack, needed until this pango bug is resolved:
+   http://bugzilla.gnome.org/show_bug.cgi?id=119081.
+   See: http://www.geocrawler.com/archives/3/522/2003/8/0/10579352/
+   for details. */
+static void
+init_dpi_conversion_factor ()
+{
+  GtkSettings *settings = gtk_settings_get_default ();
+  GObjectClass *klass;
+
+  klass = G_OBJECT_CLASS (GTK_SETTINGS_GET_CLASS (settings));
+  if (g_object_class_find_property (klass, "gtk-xft-dpi"))
+    {
+      int int_dpi;
+      g_object_get (settings, "gtk-xft-dpi", &int_dpi, NULL);
+      dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
+      g_signal_connect (settings, "notify::gtk-xft-dpi",
+                        G_CALLBACK (dpi_changed_cb), NULL);
+    }
+  else
+    /* Approximate. */
+    dpi_conversion_factor = PANGO_SCALE * 72.0 / 96.;
+}
+
+static void
+dpi_changed_cb (GtkSettings  *settings,
+                GParamSpec   *pspec)
+{
+  int int_dpi;
+  g_object_get (settings, "gtk-xft-dpi", &int_dpi, NULL);
+  dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
+}
