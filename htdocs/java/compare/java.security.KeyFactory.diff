--- /home/tromey/gnu/Nightly/classpath/classpath/java/security/KeyFactory.java	Sun Mar  9 02:19:36 2003
+++ java/security/KeyFactory.java	Tue Jan 22 16:01:36 2002
@@ -1,5 +1,5 @@
 /* KeyFactory.java --- Key Factory Class
-   Copyright (C) 1999, 2003, Free Software Foundation, Inc.
+   Copyright (C) 1999 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -36,49 +36,23 @@
 exception statement from your version. */
 
 package java.security;
-
 import java.security.spec.KeySpec;
 import java.security.spec.InvalidKeySpecException;
-import java.security.NoSuchAlgorithmException;
 
 /**
- * <p>Key factories are used to convert keys (opaque cryptographic keys of type
- * {@link Key}) into key specifications (transparent representations of the
- * underlying key material), and vice versa.</p>
- *
- * <p>Key factories are bi-directional. That is, they allow you to build an
- * opaque key object from a given key specification (key material), or to
- * retrieve the underlying key material of a key object in a suitable format.</p>
- *
- * <p>Multiple compatible key specifications may exist for the same key. For
- * example, a <i>DSA</i> public key may be specified using {@link
- * java.security.spec.DSAPublicKeySpec} or {@link
- * java.security.spec.X509EncodedKeySpec}. A key factory can be used to
- * translate between compatible key specifications.</p>
- *
- * <p>The following is an example of how to use a key factory in order to
- * instantiate a <i>DSA</i> public key from its encoding. Assume Alice has
- * received a digital signature from Bob. Bob also sent her his public key (in
- * encoded format) to verify his signature. Alice then performs the following
- * actions:
- *
- * <pre>
- *  X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);
- *  KeyFactory keyFactory = KeyFactory.getInstance("DSA");
- *  PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);
- *  Signature sig = Signature.getInstance("DSA");
- *  sig.initVerify(bobPubKey);
- *  sig.update(data);
- *  sig.verify(signature);
- * </pre>
- *
- * @since 1.2
- * @see Key
- * @see PublicKey
- * @see PrivateKey
- * @see KeySpec
- * @see java.security.spec.DSAPublicKeySpec
- * @see java.security.spec.X509EncodedKeySpec
+   Key factories are used to convert keys (opaque cryptographic 
+   keys of type Key) into key specifications (transparent 
+   representations of the underlying key material).
+
+   Key factories are bi-directional. They allow a key class 
+   to be converted into a key specification (key material) and
+   back again.
+
+   For example DSA public keys can be specified as 
+   DSAPublicKeySpec or X509EncodedKeySpec. The key factory
+   translate these key specifications. 
+
+   @since JDK 1.2
    @author Mark Benvenuto
  */
 public class KeyFactory
@@ -88,12 +62,11 @@
   private String algorithm;
 
   /**
-   * Creates a <code>KeyFactory</code> object.
-   *
-   * @param keyFacSpi the delegate.
-   * @param provider the provider.
-   * @param algorithm the name of the algorithm to associate with this
-   * <code>KeyFactory</code>.
+     Constructs a new keyFactory with the specified parameters.
+
+     @param keyFacSpi Key Factory SPI to use
+     @param provider the provider of the Key Factory SPI
+     @param algorithm the name of the key algorithm for this key factory
    */
   protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider,
 		       String algorithm)
@@ -103,49 +76,44 @@
     this.algorithm = algorithm;
   }
 
-  /**
-   * Generates a <code>KeyFactory</code> object that implements the specified
-   * algorithm. If the default provider package provides an implementation of
-   * the requested algorithm, an instance of <code>KeyFactory</code> containing
-   * that implementation is returned. If the algorithm is not available in the
-   * default package, other packages are searched.
-   *
-   * @param algorithm the name of the requested key algorithm. See Appendix A
-   * in the Java Cryptography Architecture API Specification &amp; Reference
-   * for information about standard algorithm names.
-   * @return a <code>KeyFactory</code> object for the specified algorithm.
-   * @throws NoSuchAlgorithmException if the requested algorithm is not
-   * available in the default provider package or any of the other provider
-   * packages that were searched.
+  /** 
+     Gets an instance of the KeyFactory class representing
+     the specified key factory. If the algorithm is not 
+     found then, it throws NoSuchAlgorithmException.
+
+     @param algorithm the name of algorithm to choose
+     @return a KeyFactory repesenting the desired algorithm
+
+     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers
    */
   public static KeyFactory getInstance(String algorithm)
     throws NoSuchAlgorithmException
   {
     Provider[] p = Security.getProviders();
+
     for (int i = 0; i < p.length; i++)
-      try
-        {
-          getInstance(algorithm, p[i]);
-        }
-      catch (NoSuchAlgorithmException ignored) {}
+      {
+	String classname = p[i].getProperty("KeyFactory." + algorithm);
+	if (classname != null)
+	  return getInstance(classname, algorithm, p[i]);
+      }
 
     throw new NoSuchAlgorithmException(algorithm);
   }
 
-  /**
-   * Generates a <code>KeyFactory</code> object for the specified algorithm
-   * from the specified provider.
-   *
-   * @param algorithm the name of the requested key algorithm. See Appendix A
-   * in the Java Cryptography Architecture API Specification &amp; Reference
-   * for information about standard algorithm names.
-   * @param provider the name of the provider.
-   * @return a <code>KeyFactory</code> object for the specified algorithm.
-   * @throws NoSuchAlgorithmException if the algorithm is not available from
-   * the specified provider.
-   * @throws NoSuchProviderException if the provider has not been configured.
-   * @throws IllegalArgumentException if the provider name is null or empty.
-   * @see Provider
+  /** 
+     Gets an instance of the KeyFactory class representing
+     the specified key factory from the specified provider. 
+     If the algorithm is not found then, it throws 
+     NoSuchAlgorithmException. If the provider is not found, then 
+     it throws NoSuchProviderException.
+
+     @param algorithm the name of algorithm to choose
+     @param provider the name of the provider to find the algorithm in
+     @return a KeyFactory repesenting the desired algorithm
+
+     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider
+     @throws NoSuchProviderException if the provider is not found
    */
   public static KeyFactory getInstance(String algorithm, String provider)
     throws NoSuchAlgorithmException, NoSuchProviderException
@@ -154,85 +122,39 @@
     if (p == null)
       throw new NoSuchProviderException();
 
-    return getInstance(algorithm, p);
-  }
-
-  /**
-   * Generates a <code>KeyFactory</code> object for the specified algorithm from
-   * the specified provider. Note: the <code>provider</code> doesn't have to be
-   * registered.
-   *
-   * @param algorithm the name of the requested key algorithm. See Appendix A
-   * in the Java Cryptography Architecture API Specification &amp; Reference for
-   * information about standard algorithm names.
-   * @param provider the provider.
-   * @return a <code>KeyFactory</code> object for the specified algorithm.
-   * @throws NoSuchAlgorithmException if the algorithm is not available from
-   * the specified provider.
-   * @throws IllegalArgumentException if the <code>provider</code> is
-   * <code>null</code>.
-   * @since 1.4
-   * @see Provider
-   */
-  public static KeyFactory getInstance(String algorithm, Provider provider)
-    throws NoSuchAlgorithmException
-  {
-    if (provider == null)
-      throw new IllegalArgumentException();
-
-    // try the name as is
-    String className = provider.getProperty("KeyFactory." + algorithm);
-    if (className == null) // try all uppercase
-      {
-        String upper = algorithm.toUpperCase();
-        className = provider.getProperty("KeyFactory." + upper);
-        if (className == null) // try if it's an alias
-          {
-            String alias =
-                provider.getProperty("Alg.Alias.KeyFactory." + algorithm);
-            if (alias == null) // try all-uppercase alias name
-              {
-                alias = provider.getProperty("Alg.Alias.KeyFactory." + upper);
-                if (alias == null) // spit the dummy
-                  throw new NoSuchAlgorithmException(algorithm);
-              }
-            className = provider.getProperty("KeyFactory." + alias);
-            if (className == null)
-              throw new NoSuchAlgorithmException(algorithm);
-          }
-      }
-    return getInstance(className, algorithm, provider);
+    return getInstance(p.getProperty("KeyFactory." + algorithm),
+		       algorithm, p);
   }
 
-  private static KeyFactory getInstance(String classname, String algorithm,
+  private static KeyFactory getInstance(String classname,
+					String algorithm,
 					Provider provider)
     throws NoSuchAlgorithmException
   {
+
     try
       {
-        return new KeyFactory(
-            (KeyFactorySpi) Class.forName(classname).newInstance(),
-            provider,
-            algorithm);
+	return new KeyFactory((KeyFactorySpi) Class.forName(classname).
+			      newInstance(), provider, algorithm);
       }
     catch (ClassNotFoundException cnfe)
       {
-        throw new NoSuchAlgorithmException("Class not found");
+	throw new NoSuchAlgorithmException("Class not found");
       }
     catch (InstantiationException ie)
       {
-        throw new NoSuchAlgorithmException("Class instantiation failed");
+	throw new NoSuchAlgorithmException("Class instantiation failed");
       }
     catch (IllegalAccessException iae)
       {
-        throw new NoSuchAlgorithmException("Illegal Access");
+	throw new NoSuchAlgorithmException("Illegal Access");
       }
   }
 
   /**
-   * Returns the provider of this key factory object.
-   *
-   * @return the provider of this key factory object.
+     Gets the provider that the class is from.
+
+     @return the provider of this class
    */
   public final Provider getProvider()
   {
@@ -240,10 +162,9 @@
   }
 
   /**
-   * Gets the name of the algorithm associated with this <code>KeyFactory</code>.
-   *
-   * @return the name of the algorithm associated with this
-   * <code>KeyFactory</code>.
+     Returns the name of the algorithm used
+
+     @return A string with the name of the algorithm
    */
   public final String getAlgorithm()
   {
@@ -251,51 +172,52 @@
   }
 
   /**
-   * Generates a public key object from the provided key specification (key
-   * material).
-   *
-   * @param keySpec the specification (key material) of the public key.
-   * @return the public key.
-   * @throws InvalidKeySpecException if the given key specification is
-   * inappropriate for this key factory to produce a public key.
+     Generates a public key from the provided key specification.
+
+     @param keySpec key specification
+
+     @return the public key
+
+     @throws InvalidKeySpecException invalid key specification for
+     this key factory to produce a public key
    */
-  public final PublicKey generatePublic(KeySpec keySpec)
-    throws InvalidKeySpecException
+  public final PublicKey generatePublic(KeySpec keySpec) throws
+    InvalidKeySpecException
   {
     return keyFacSpi.engineGeneratePublic(keySpec);
   }
 
   /**
-   * Generates a private key object from the provided key specification (key
-   * material).
-   *
-   * @param keySpec the specification (key material) of the private key.
-   * @return the private key.
-   * @throws InvalidKeySpecException if the given key specification is
-   * inappropriate for this key factory to produce a private key.
+     Generates a private key from the provided key specification.
+
+     @param keySpec key specification
+
+     @return the private key
+
+     @throws InvalidKeySpecException invalid key specification for
+     this key factory to produce a private key
    */
-  public final PrivateKey generatePrivate(KeySpec keySpec)
-    throws InvalidKeySpecException
+  public final PrivateKey generatePrivate(KeySpec keySpec) throws
+    InvalidKeySpecException
   {
     return keyFacSpi.engineGeneratePrivate(keySpec);
   }
 
   /**
-   * Returns a specification (key material) of the given key object.
-   * <code>keySpec</code> identifies the specification class in which the key
-   * material should be returned. It could, for example, be
-   * <code>DSAPublicKeySpec.class</code>, to indicate that the key material
-   * should be returned in an instance of the {@link
-   * java.security.spec.DSAPublicKeySpec} class.
-   *
-   * @param key the key.
-   * @param keySpec the specification class in which the key material should be
-   * returned.
-   * @return the underlying key specification (key material) in an instance of
-   * the requested specification class.
-   * @throws InvalidKeySpecException if the requested key specification is
-   * inappropriate for the given key, or the given key cannot be processed
-   * (e.g., the given key has an unrecognized algorithm or format).
+     Returns a key specification for the given key. keySpec 
+     identifies the specification class to return the key 
+     material in.
+
+     @param key the key
+     @param keySpec the specification class to return the 
+     key material in.
+
+     @return the key specification in an instance of the requested
+     specification class
+
+     @throws InvalidKeySpecException the requested key specification
+     is inappropriate for this key or the key is 
+     unrecognized.
    */
   public final KeySpec getKeySpec(Key key, Class keySpec)
     throws InvalidKeySpecException
@@ -304,13 +226,15 @@
   }
 
   /**
-   * Translates a key object, whose provider may be unknown or potentially
-   * untrusted, into a corresponding key object of this key factory.
-   *
-   * @param key the key whose provider is unknown or untrusted.
-   * @return the translated key.
-   * @throws InvalidKeyException if the given key cannot be processed by this
-   * key factory.
+     Translates the key from an unknown or untrusted provider
+     into a key for this key factory.
+
+     @param the key from an unknown or untrusted provider
+
+     @return the translated key
+
+     @throws InvalidKeySpecException if the key cannot be 
+     processed by this key factory
    */
   public final Key translateKey(Key key) throws InvalidKeyException
   {
