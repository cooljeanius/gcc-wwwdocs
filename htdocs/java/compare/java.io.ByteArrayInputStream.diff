--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ByteArrayInputStream.java	2004-04-13 02:20:21.000000000 -0600
+++ java/io/ByteArrayInputStream.java	2002-01-22 16:01:32.000000000 -0700
@@ -83,7 +83,7 @@
    * bytes supplied to the reader.  Please use caution in changing the 
    * contents of the buffer while this stream is open.
    *
-   * @param buffer The byte array buffer this stream will read from.
+   * @param buf The byte array buffer this stream will read from.
    */
   public ByteArrayInputStream(byte[] buffer)
   {
@@ -105,7 +105,7 @@
    * bytes supplied to the reader.  Please use caution in changing the 
    * contents of the buffer while this stream is open.
    *
-   * @param buffer The byte array buffer this stream will read from.
+   * @param buf The byte array buffer this stream will read from.
    * @param offset The index into the buffer to start reading bytes from
    * @param length The number of bytes to read from the buffer
    */
@@ -146,12 +146,12 @@
    * position 0 in the stream.  This is in constrast to some other
    * stream types where there is no default mark position.
    *
-   * @param readLimit The number of bytes this stream must remember.
+   * @param readlimit The number of bytes this stream must remember.
    * This parameter is ignored.
    */
-  public synchronized void mark(int readLimit)
+  public synchronized void mark(int readAheadLimit)
   {
-    // readLimit is ignored per Java Class Lib. book, p.220.
+    // readAheadLimit is ignored per Java Class Lib. book, p.220.
     mark = pos;
   }
 
@@ -197,19 +197,19 @@
    * <p>
    * This method does not block.
    *
-   * @param buffer The array into which the bytes read should be stored.
+   * @param buf The array into which the bytes read should be stored.
    * @param offset The offset into the array to start storing bytes
-   * @param length The requested number of bytes to read
+   * @param len The requested number of bytes to read
    *
    * @return The actual number of bytes read, or -1 if end of stream.
    */
-  public synchronized int read(byte[] buffer, int offset, int length)
+  public synchronized int read(byte[] b, int off, int len)
   {
     if (pos >= count)
       return -1;
 
-    int numBytes = Math.min(count - pos, length);
-    System.arraycopy(buf, pos, buffer, offset, numBytes);
+    int numBytes = Math.min(count - pos, len);
+    System.arraycopy(buf, pos, b, off, numBytes);
     pos += numBytes;
     return numBytes;
   }
@@ -234,17 +234,17 @@
    * position the stream at the end of the buffer.  The actual number
    * of bytes skipped is returned.
    *
-   * @param num The requested number of bytes to skip
+   * @param num_bytes The requested number of bytes to skip
    *
    * @return The actual number of bytes skipped.
    */
-  public synchronized long skip(long num)
+  public synchronized long skip(long n)
   {
     // Even though the var numBytes is a long, in reality it can never
     // be larger than an int since the result of subtracting 2 positive
     // ints will always fit in an int.  Since we have to return a long
     // anyway, numBytes might as well just be a long.
-    long numBytes = Math.min((long) (count - pos), num < 0 ? 0L : num);
+    long numBytes = Math.min((long) (count - pos), n < 0 ? 0L : n);
     pos += numBytes;
     return numBytes;
   }
