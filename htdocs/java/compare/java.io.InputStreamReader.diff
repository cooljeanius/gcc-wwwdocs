--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/InputStreamReader.java	Mon Mar 10 02:19:32 2003
+++ java/io/InputStreamReader.java	Sun Mar 23 02:18:02 2003
@@ -1,5 +1,5 @@
 /* InputStreamReader.java -- Reader than transforms bytes to chars
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,184 +37,165 @@
 
 
 package java.io;
-
-import gnu.java.io.EncodingManager;
-import gnu.java.io.decode.Decoder;
+import gnu.gcj.convert.*;
 
 /**
-  * This class reads characters from a byte input stream.   The characters
-  * read are converted from bytes in the underlying stream by a 
-  * decoding layer.  The decoding layer transforms bytes to chars according
-  * to an encoding standard.  There are many available encodings to choose 
-  * from.  The desired encoding can either be specified by name, or if no
-  * encoding is selected, the system default encoding will be used.  The
-  * system default encoding name is determined from the system property
-  * <code>file.encoding</code>.  The only encodings that are guaranteed to 
-  * be availalbe are "8859_1" (the Latin-1 character set) and "UTF8".
-  * Unforunately, Java does not provide a mechanism for listing the
-  * ecodings that are supported in a given implementation.
-  * <p>
-  * Here is a list of standard encoding names that may be available:
-  * <p>
-  * <ul>
-  * <li>8859_1 (ISO-8859-1/Latin-1)
-  * <li>8859_2 (ISO-8859-2/Latin-2)
-  * <li>8859_3 (ISO-8859-3/Latin-3)
-  * <li>8859_4 (ISO-8859-4/Latin-4)
-  * <li>8859_5 (ISO-8859-5/Latin-5)
-  * <li>8859_6 (ISO-8859-6/Latin-6)
-  * <li>8859_7 (ISO-8859-7/Latin-7)
-  * <li>8859_8 (ISO-8859-8/Latin-8)
-  * <li>8859_9 (ISO-8859-9/Latin-9)
-  * <li>ASCII (7-bit ASCII)
-  * <li>UTF8 (UCS Transformation Format-8)
-  * <li>More later
-  * </ul>
-  * <p>
-  * It is recommended that applications do not use 
-  * <code>InputStreamReader</code>'s
-  * directly.  Rather, for efficiency purposes, an object of this class
-  * should be wrapped by a <code>BufferedReader</code>.
-  * <p>
-  * Due to a deficiency the Java class library design, there is no standard
-  * way for an application to install its own byte-character encoding.
-  *
-  * @see BufferedReader
-  * @see InputStream
-  *
-  * @author Aaron M. Renn (arenn@urbanophile.com)
-  */
+ * @author Per Bothner <bothner@cygnus.com>
+ * @date April 22, 1998.  
+ */
+/* Written using "Java Class Libraries", 2nd edition, plus online
+ * API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status:  Believed complete and correct, but only supports 8859_1.
+ */
+
 public class InputStreamReader extends Reader
 {
-  /*
-   * Instance Variables
-   */
-
-   /* 
-    * This is the byte-character decoder class that does the reading and
-    * translation of bytes from the underlying stream.
-    */
-  private Decoder in;
-
-  /*************************************************************************/
-
-  /**
-    * This method initializes a new instance of <code>InputStreamReader</code>
-    * to read from the specified stream using the default encoding.
-    *
-    * @param in The <code>InputStream</code> to read from 
-    */
+  BufferedInputStream in;
+
+  // Buffer of chars read from in and converted but not consumed.
+  char[] work;
+  // Next available character (in work buffer) to read.
+  int wpos;
+  // Last available character (in work buffer) to read.
+  int wcount;
+
+  BytesToUnicode converter;
+
   public InputStreamReader(InputStream in)
   {
-    if (in == null)
-      throw new NullPointerException();
-    this.in = EncodingManager.getDecoder(in);
-  }
-
-  /*************************************************************************/
-
-  /**
-    * This method initializes a new instance of <code>InputStreamReader</code>
-    * to read from the specified stream using a caller supplied character
-    * encoding scheme.  Note that due to a deficiency in the Java language
-    * design, there is no way to determine which encodings are supported.
-    * 
-    * @param in The <code>InputStream</code> to read from
-    * @param encoding_name The name of the encoding scheme to use
-    *
-    * @exception UnsupportedEncodingException If the encoding scheme 
-    * requested is not available.
-    */
-  public InputStreamReader(InputStream in, String encoding_name) 
+    this(in, BytesToUnicode.getDefaultDecoder());
+  }
+
+  public InputStreamReader(InputStream in, String enc)
     throws UnsupportedEncodingException
   {
-    if (in == null || encoding_name == null)
-      throw new NullPointerException();
-    this.in = EncodingManager.getDecoder(in, encoding_name);
-  }
-
-  /*************************************************************************/
-
-  /*
-   * Instance Methods
-   */
-
-  /**
-    * This method returns the name of the encoding that is currently in use
-    * by this object.  If the stream has been closed, this method is allowed
-    * to return <code>null</code>.
-    *
-    * @param The current encoding name
-    */
-  public String getEncoding()
-  {
-    return(in.getSchemeName());
+    this(in, BytesToUnicode.getDecoder(enc));
   }
 
-  /*************************************************************************/
+  private InputStreamReader(InputStream in, BytesToUnicode decoder)
+  {
+    // FIXME: someone could pass in a BufferedInputStream whose buffer
+    // is smaller than the longest encoded character for this
+    // encoding.  We will probably go into an infinite loop in this
+    // case.  We probably ought to just have our own byte buffering
+    // here.
+    this.in = in instanceof BufferedInputStream
+              ? (BufferedInputStream) in
+              : new BufferedInputStream(in);
+    /* Don't need to call super(in) here as long as the lock gets set. */
+    this.lock = in;
+    converter = decoder;
+    converter.setInput(this.in.buf, 0, 0);
+  }
 
-  /**
-    * This method closes this stream, as well as the underlying 
-    * <code>InputStream</code>.
-    *
-    * @exception IOException If an error occurs
-    */
   public void close() throws IOException
   {
-    in.close();
+    synchronized (lock)
+      {
+	if (in != null)
+	  in.close();
+	in = null;
+	work = null;
+	wpos = wcount = 0;
+      }
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method checks to see if the stream is read to be read.  It
-    * will return <code>true</code> if is, or <code>false</code> if it is not.
-    * If the stream is not ready to be read, it could (although is not required
-    * to) block on the next read attempt.
-    *
-    * @return <code>true</code> if the stream is ready to be read, 
-    * <code>false</code> otherwise
-    *
-    * @exception IOException If an error occurs
-    */
-  public boolean ready() throws IOException
+  public String getEncoding()
   {
-    return(in.ready());
+    return in != null ? converter.getName() : null;
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method reads a single character of data from the stream.
-    *
-    * @return The char read, as an int, or -1 if end of stream.
-    *
-    * @exception IOException If an error occurs
-    */
-  public int read() throws IOException
+  public boolean ready() throws IOException
   {
-    return(in.read());
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (wpos < wcount)
+	  return true;
+
+	// According to the spec, an InputStreamReader is ready if its
+	// input buffer is not empty (above), or if bytes are
+	// available on the underlying byte stream.
+	return in.available () > 0;
+      }
+  }
+
+  public int read(char buf[], int offset, int length) throws IOException
+  {
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (length == 0)
+	  return 0;
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill our buffer.
+	    if (! refill ())
+	      return -1;
+	    wavail = wcount - wpos;
+	  }
+
+	if (length > wavail)
+	  length = wavail;
+	System.arraycopy(work, wpos, buf, offset, length);
+	wpos += length;
+	return length;
+      }
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method reads up to <code>len</code> characters from the stream into
-    * the specified array starting at index <code>offset</code> into the
-    * array.
-    *
-    * @param buf The character array to recieve the data read
-    * @param offset The offset into the array to start storing characters
-    * @param len The requested number of characters to read.
-    *
-    * @return The actual number of characters read, or -1 if end of stream.
-    *
-    * @exception IOException If an error occurs
-    */
-  public int read(char[] buf, int offset, int len) throws IOException
+  public int read() throws IOException
   {
-    return(in.read(buf, offset, len));
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill our buffer.
+	    if (! refill ())
+	      return -1;
+	  }
+
+	return work[wpos++];
+      }
+  }
+
+  // Read more bytes and convert them into the WORK buffer.
+  // Return false on EOF.
+  private boolean refill () throws IOException
+  {
+    wcount = wpos = 0;
+
+    if (work == null)
+      work = new char[100];
+
+    for (;;)
+      {
+	// We have knowledge of the internals of BufferedInputStream
+	// here.  Eww.
+	in.mark (0);
+	// BufferedInputStream.refill() can only be called when
+	// `pos>=count'.
+	boolean r = in.pos < in.count || in.refill ();
+	in.reset ();
+	if (! r)
+	  return false;
+	converter.setInput(in.buf, in.pos, in.count);
+	int count = converter.read (work, wpos, work.length - wpos);
+	in.skip(converter.inpos - in.pos);
+	if (count > 0)
+	  {
+	    wcount += count;
+	    return true;
+	  }
+      }
   }
-
-} // class InputStreamReader
-
+}
