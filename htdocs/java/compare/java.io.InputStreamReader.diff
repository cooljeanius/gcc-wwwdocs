--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/InputStreamReader.java	2003-05-07 02:23:22.000000000 -0600
+++ java/io/InputStreamReader.java	2003-05-07 02:22:00.000000000 -0600
@@ -38,8 +38,7 @@
 
 package java.io;
 
-import gnu.java.io.EncodingManager;
-import gnu.java.io.decode.Decoder;
+import gnu.gcj.convert.*;
 
 /**
  * This class reads characters from a byte input stream.   The characters
@@ -88,11 +87,16 @@
  */
 public class InputStreamReader extends Reader
 {
-  /* 
-   * This is the byte-character decoder class that does the reading and
-   * translation of bytes from the underlying stream.
-   */
-  private Decoder in;
+  BufferedInputStream in;
+
+  // Buffer of chars read from in and converted but not consumed.
+  char[] work;
+  // Next available character (in work buffer) to read.
+  int wpos;
+  // Last available character (in work buffer) to read.
+  int wcount;
+
+  BytesToUnicode converter;
 
   /**
    * This method initializes a new instance of <code>InputStreamReader</code>
@@ -102,9 +106,7 @@
    */
   public InputStreamReader(InputStream in)
   {
-    if (in == null)
-      throw new NullPointerException();
-    this.in = EncodingManager.getDecoder(in);
+    this(in, BytesToUnicode.getDefaultDecoder());
   }
 
   /**
@@ -122,11 +124,23 @@
   public InputStreamReader(InputStream in, String encoding_name)
     throws UnsupportedEncodingException
   {
-    if (in == null
-        || encoding_name == null)
-      throw new NullPointerException();
-    
-    this.in = EncodingManager.getDecoder(in, encoding_name);
+    this(in, BytesToUnicode.getDecoder(encoding_name));
+  }
+
+  private InputStreamReader(InputStream in, BytesToUnicode decoder)
+  {
+    // FIXME: someone could pass in a BufferedInputStream whose buffer
+    // is smaller than the longest encoded character for this
+    // encoding.  We will probably go into an infinite loop in this
+    // case.  We probably ought to just have our own byte buffering
+    // here.
+    this.in = in instanceof BufferedInputStream
+              ? (BufferedInputStream) in
+              : new BufferedInputStream(in);
+    /* Don't need to call super(in) here as long as the lock gets set. */
+    this.lock = in;
+    converter = decoder;
+    converter.setInput(this.in.buf, 0, 0);
   }
 
   /**
@@ -137,7 +151,14 @@
    */
   public void close() throws IOException
   {
-    in.close();
+    synchronized (lock)
+      {
+	if (in != null)
+	  in.close();
+	in = null;
+	work = null;
+	wpos = wcount = 0;
+      }
   }
 
   /**
@@ -149,7 +170,7 @@
    */
   public String getEncoding()
   {
-    return(in.getSchemeName());
+    return in != null ? converter.getName() : null;
   }
 
   /**
@@ -165,25 +186,46 @@
    */
   public boolean ready() throws IOException
   {
-    return(in.ready());
-  }
-
-  /**
-   * This method reads up to <code>len</code> characters from the stream into
-   * the specified array starting at index <code>offset</code> into the
-   * array.
-   *
-   * @param buf The character array to recieve the data read
-   * @param offset The offset into the array to start storing characters
-   * @param len The requested number of characters to read.
-   *
-   * @return The actual number of characters read, or -1 if end of stream.
-   *
-   * @exception IOException If an error occurs
-   */
-  public int read(char[] buf, int offset, int len) throws IOException
-  {
-    return(in.read(buf, offset, len));
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (wpos < wcount)
+	  return true;
+
+	// According to the spec, an InputStreamReader is ready if its
+	// input buffer is not empty (above), or if bytes are
+	// available on the underlying byte stream.
+	return in.available () > 0;
+      }
+  }
+
+  public int read(char buf[], int offset, int length) throws IOException
+  {
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (length == 0)
+	  return 0;
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill our buffer.
+	    if (! refill ())
+	      return -1;
+	    wavail = wcount - wpos;
+	  }
+
+	if (length > wavail)
+	  length = wavail;
+	System.arraycopy(work, wpos, buf, offset, length);
+	wpos += length;
+	return length;
+      }
   }
 
   /**
@@ -195,7 +237,52 @@
    */
   public int read() throws IOException
   {
-    return(in.read());
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill our buffer.
+	    if (! refill ())
+	      return -1;
+	  }
+
+	return work[wpos++];
+      }
+  }
+
+  // Read more bytes and convert them into the WORK buffer.
+  // Return false on EOF.
+  private boolean refill () throws IOException
+  {
+    wcount = wpos = 0;
+
+    if (work == null)
+      work = new char[100];
+
+    for (;;)
+      {
+	// We have knowledge of the internals of BufferedInputStream
+	// here.  Eww.
+	in.mark (0);
+	// BufferedInputStream.refill() can only be called when
+	// `pos>=count'.
+	boolean r = in.pos < in.count || in.refill ();
+	in.reset ();
+	if (! r)
+	  return false;
+	converter.setInput(in.buf, in.pos, in.count);
+	int count = converter.read (work, wpos, work.length - wpos);
+	in.skip(converter.inpos - in.pos);
+	if (count > 0)
+	  {
+	    wcount += count;
+	    return true;
+	  }
+      }
   }
 
 } // class InputStreamReader
