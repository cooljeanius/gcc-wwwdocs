--- /home/tromey/gnu/classpath/classpath/java/util/Properties.java	Tue Apr 30 17:58:37 2002
+++ java/util/Properties.java	Tue Jan 22 16:01:42 2002
@@ -1,5 +1,5 @@
-/* Properties.java -- a set of persistent properties
-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* java.util.Properties
+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,88 +37,64 @@
 
 
 package java.util;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.PrintWriter;
-import java.io.PrintStream;
-import java.io.OutputStreamWriter;
+import java.io.*;
 
 /**
- * A set of persistent properties, which can be saved or loaded from a stream.
- * A property list may also contain defaults, searched if the main list
- * does not contain a property for a given key.
- *
  * An example of a properties file for the german language is given
  * here.  This extends the example given in ListResourceBundle.
  * Create a file MyResource_de.properties with the following contents
  * and put it in the CLASSPATH.  (The character
  * <code>\</code><code>u00e4</code> is the german &auml;)
- *
  * 
-<pre>s1=3
-s2=MeineDisk
-s3=3. M\<code></code>u00e4rz 96
-s4=Die Diskette ''{1}'' enth\<code></code>u00e4lt {0} in {2}.
-s5=0
-s6=keine Dateien
-s7=1
-s8=eine Datei
-s9=2
-s10={0,number} Dateien
-s11=Das Formatieren schlug fehl mit folgender Exception: {0}
-s12=FEHLER
-s13=Ergebnis
-s14=Dialog
-s15=Auswahlkriterium
-s16=1,3</pre>
+ * <pre>
+ * s1=3
+ * s2=MeineDisk
+ * s3=3. M\<code></code>u00e4rz 96
+ * s4=Die Diskette ''{1}'' enth\<code></code>u00e4lt {0} in {2}.
+ * s5=0
+ * s6=keine Dateien
+ * s7=1
+ * s8=eine Datei
+ * s9=2
+ * s10={0,number} Dateien
+ * s11=Das Formatieren schlug fehl mit folgender Exception: {0}
+ * s12=FEHLER
+ * s13=Ergebnis
+ * s14=Dialog
+ * s15=Auswahlkriterium
+ * s16=1,3
+ * </pre>
  *
- * <p>Although this is a sub class of a hash table, you should never
+ * Although this is a sub class of a hash table, you should never
  * insert anything other than strings to this property, or several
  * methods, that need string keys and values, will fail.  To ensure
  * this, you should use the <code>get/setProperty</code> method instead
  * of <code>get/put</code>.
  *
- * Properties are saved in ISO 8859-1 encoding, using Unicode escapes with
- * a single <code>u</code> for any character which cannot be represented.
- *
- * @author Jochen Hoenicke
- * @author Eric Blake <ebb9@email.byu.edu>
  * @see PropertyResourceBundle
- * @status updated to 1.4
+ * @author Jochen Hoenicke
  */
 public class Properties extends Hashtable
 {
-  // WARNING: Properties is a CORE class in the bootstrap cycle. See the
-  // comments in vm/reference/java/lang/Runtime for implications of this fact.
-
   /**
    * The property list that contains default values for any keys not
-   * in this property list.
-   *
-   * @serial the default properties
+   * in this property list.  
    */
   protected Properties defaults;
 
-  /**
-   * Compatible with JDK 1.0+.
-   */
   private static final long serialVersionUID = 4112578634029874840L;
 
   /**
-   * Creates a new empty property list with no default values.
+   * Creates a new empty property list.
    */
   public Properties()
   {
+    this.defaults = null;
   }
 
   /**
    * Create a new empty property list with the specified default values.
-   *
-   * @param defaults a Properties object containing the default values
+   * @param defaults a Properties object containing the default values.
    */
   public Properties(Properties defaults)
   {
@@ -126,21 +102,6 @@
   }
 
   /**
-   * Adds the given key/value pair to this properties.  This calls
-   * the hashtable method put.
-   *
-   * @param key the key for this property
-   * @param value the value for this property
-   * @return The old value for the given key
-   * @see #getProperty(String)
-   * @since 1.2
-   */
-  public Object setProperty(String key, String value)
-  {
-    return put(key, value);
-  }
-
-  /**
    * Reads a property list from an input stream.  The stream should
    * have the following format: <br>
    *
@@ -159,176 +120,173 @@
    *
    * Escape sequences <code>\t, \n, \r, \\, \", \', \!, \#, \ </code>(a
    * space), and unicode characters with the
-   * <code>\\u</code><em>xxxx</em> notation are detected, and
+   * <code>\</code><code>u</code>xxxx notation are detected, and 
    * converted to the corresponding single character. <br>
    *
-   * 
-<pre># This is a comment
-key     = value
-k\:5      \ a string starting with space and ending with newline\n
-# This is a multiline specification; note that the value contains
-# no white space.
-weekdays: Sunday,Monday,Tuesday,Wednesday,\\
-          Thursday,Friday,Saturday
-# The safest way to include a space at the end of a value:
-label   = Name:\\u0020</pre>
+   * <pre>
+   * # This is a comment
+   * key     = value
+   * k\:5      \ a string starting with space and ending with newline\n
+   * # This is a multiline specification; note that the value contains
+   * # no white space.
+   * weekdays: Sunday,Monday,Tuesday,Wednesday,\
+   *           Thursday,Friday,Saturday
+   * # The safest way to include a space at the end of a value:
+   * label   = Name:\<code></code>u0020
+   * </pre>
    *
    * @param in the input stream
-   * @throws IOException if an error occurred when reading the input
-   * @throws NullPointerException if in is null
-   */
+   * @exception IOException if an error occurred when reading
+   * from the input.  */
   public void load(InputStream inStream) throws IOException
   {
     // The spec says that the file must be encoded using ISO-8859-1.
     BufferedReader reader =
       new BufferedReader(new InputStreamReader(inStream, "ISO-8859-1"));
     String line;
-
+    
     while ((line = reader.readLine()) != null)
       {
-        char c = 0;
-        int pos = 0;
-        while (pos < line.length()
-               && Character.isWhitespace(c = line.charAt(pos)))
-          pos++;
-
-        // If line is empty or begins with a comment character,
-        // skip this line.
-        if (pos == line.length() || c == '#' || c == '!')
-          continue;
-
-        // The characters up to the next Whitespace, ':', or '='
-        // describe the key.  But look for escape sequences.
-        StringBuffer key = new StringBuffer();
-        while (pos < line.length()
-               && ! Character.isWhitespace(c = line.charAt(pos++))
-               && c != '=' && c != ':')
-          {
-            if (c == '\\')
-              {
-                if (pos == line.length())
-                  {
-                    // The line continues on the next line.
-                    line = reader.readLine();
-                    pos = 0;
-                    while (pos < line.length()
-                           && Character.isWhitespace(c = line.charAt(pos)))
-                      pos++;
-                  }
-                else
-                  {
-                    c = line.charAt(pos++);
-                    switch (c)
-                      {
-                      case 'n':
-                        key.append('\n');
-                        break;
-                      case 't':
-                        key.append('\t');
-                        break;
-                      case 'r':
-                        key.append('\r');
-                        break;
-                      case 'u':
-                        if (pos + 4 <= line.length())
-                          {
-                            char uni = (char) Integer.parseInt
-                              (line.substring(pos, pos + 4), 16);
-                            key.append(uni);
-                            pos += 4;
-                          }        // else throw exception?
-                        break;
-                      default:
-                        key.append(c);
-                        break;
-                      }
-                  }
-              }
-            else
-              key.append(c);
-          }
-
-        boolean isDelim = (c == ':' || c == '=');
-        while (pos < line.length()
-               && Character.isWhitespace(c = line.charAt(pos)))
-          pos++;
-
-        if (! isDelim && (c == ':' || c == '='))
-          {
-            pos++;
-            while (pos < line.length()
-                   && Character.isWhitespace(c = line.charAt(pos)))
-              pos++;
-          }
-
-        StringBuffer element = new StringBuffer(line.length() - pos);
-        while (pos < line.length())
-          {
-            c = line.charAt(pos++);
-            if (c == '\\')
-              {
-                if (pos == line.length())
-                  {
-                    // The line continues on the next line.
-                    line = reader.readLine();
-                    pos = 0;
-                    while (pos < line.length()
-                           && Character.isWhitespace(c = line.charAt(pos)))
-                      pos++;
-                    element.ensureCapacity(line.length() - pos +
-                                           element.length());
-                  }
-                else
-                  {
-                    c = line.charAt(pos++);
-                    switch (c)
-                      {
-                      case 'n':
-                        element.append('\n');
-                        break;
-                      case 't':
-                        element.append('\t');
-                        break;
-                      case 'r':
-                        element.append('\r');
-                        break;
-                      case 'u':
-                        if (pos + 4 <= line.length())
-                          {
-                            char uni = (char) Integer.parseInt
-                              (line.substring(pos, pos + 4), 16);
-                            element.append(uni);
-                            pos += 4;
-                          }        // else throw exception?
-                        break;
-                      default:
-                        element.append(c);
-                        break;
-                      }
-                  }
-              }
-            else
-              element.append(c);
-          }
-        put(key.toString(), element.toString());
+	char c = 0;
+	int pos = 0;
+	while (pos < line.length()
+	       && Character.isWhitespace(c = line.charAt(pos)))
+	  pos++;
+
+	// If line is empty or begins with a comment character,
+	// skip this line.
+	if (pos == line.length() || c == '#' || c == '!')
+	  continue;
+
+	// The characters up to the next Whitespace, ':', or '='
+	// describe the key.  But look for escape sequences.
+	StringBuffer key = new StringBuffer();
+	while (pos < line.length()
+	       && !Character.isWhitespace(c = line.charAt(pos++))
+	       && c != '=' && c != ':')
+	  {
+	    if (c == '\\')
+	      {
+		if (pos == line.length())
+		  {
+		    // The line continues on the next line.
+		    line = reader.readLine();
+		    pos = 0;
+		    while (pos < line.length()
+			   && Character.isWhitespace(c = line.charAt(pos)))
+		      pos++;
+		  }
+		else
+		  {
+		    c = line.charAt(pos++);
+		    switch (c)
+		      {
+		      case 'n':
+			key.append('\n');
+			break;
+		      case 't':
+			key.append('\t');
+			break;
+		      case 'r':
+			key.append('\r');
+			break;
+		      case 'u':
+			if (pos + 4 <= line.length())
+			  {
+			    char uni = (char) Integer.parseInt
+			      (line.substring(pos, pos + 4), 16);
+			    key.append(uni);
+			    pos += 4;
+			  }	// else throw exception?
+			break;
+		      default:
+			key.append(c);
+			break;
+		      }
+		  }
+	      }
+	    else
+	      key.append(c);
+	  }
+
+	boolean isDelim = (c == ':' || c == '=');
+	while (pos < line.length()
+	       && Character.isWhitespace(c = line.charAt(pos)))
+	  pos++;
+
+	if (!isDelim && (c == ':' || c == '='))
+	  {
+	    pos++;
+	    while (pos < line.length()
+		   && Character.isWhitespace(c = line.charAt(pos)))
+	      pos++;
+	  }
+
+	StringBuffer element = new StringBuffer(line.length() - pos);
+	while (pos < line.length())
+	  {
+	    c = line.charAt(pos++);
+	    if (c == '\\')
+	      {
+		if (pos == line.length())
+		  {
+		    // The line continues on the next line.
+		    line = reader.readLine();
+		    pos = 0;
+		    while (pos < line.length()
+			   && Character.isWhitespace(c = line.charAt(pos)))
+		      pos++;
+		    element.ensureCapacity(line.length() - pos +
+					   element.length());
+		  }
+		else
+		  {
+		    c = line.charAt(pos++);
+		    switch (c)
+		      {
+		      case 'n':
+			element.append('\n');
+			break;
+		      case 't':
+			element.append('\t');
+			break;
+		      case 'r':
+			element.append('\r');
+			break;
+		      case 'u':
+			if (pos + 4 <= line.length())
+			  {
+			    char uni = (char) Integer.parseInt
+			      (line.substring(pos, pos + 4), 16);
+			    element.append(uni);
+			    pos += 4;
+			  }	// else throw exception?
+			break;
+		      default:
+			element.append(c);
+			break;
+		      }
+		  }
+	      }
+	    else
+	      element.append(c);
+	  }
+	put(key.toString(), element.toString());
       }
   }
 
   /**
    * Calls <code>store(OutputStream out, String header)</code> and
    * ignores the IOException that may be thrown.
-   *
-   * @param out the stream to write to
-   * @param header a description of the property list
-   * @throws ClassCastException if this property contains any key or
-   *         value that are not strings
-   * @deprecated use {@link #store(OutputStream, String)} instead
+   * @deprecated use store instead.
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
    */
   public void save(OutputStream out, String header)
   {
     try
       {
-        store(out, header);
+	store(out, header);
       }
     catch (IOException ex)
       {
@@ -336,14 +294,13 @@
   }
 
   /**
-   * Writes the key/value pairs to the given output stream, in a format
-   * suitable for <code>load</code>.<br>
+   * Writes the key/value pairs to the given output stream. <br>
    *
    * If header is not null, this method writes a comment containing
    * the header as first line to the stream.  The next line (or first
    * line if header is null) contains a comment with the current date.
    * Afterwards the key/value pairs are written to the stream in the
-   * following format.<br>
+   * following format. <br>
    *
    * Each line has the form <code>key = value</code>.  Newlines,
    * Returns and tabs are written as <code>\n,\t,\r</code> resp.
@@ -351,42 +308,47 @@
    * preceeded by a backslash.  Spaces are preceded with a backslash,
    * if and only if they are at the beginning of the key.  Characters
    * that are not in the ascii range 33 to 127 are written in the
-   * <code>\</code><code>u</code>xxxx Form.<br>
-   *
-   * Following the listing, the output stream is flushed but left open.
+   * <code>\</code><code>u</code>xxxx Form.
    *
    * @param out the output stream
-   * @param header the header written in the first line, may be null
-   * @throws ClassCastException if this property contains any key or
-   *         value that isn't a string
-   * @throws IOException if writing to the stream fails
-   * @throws NullPointerException if out is null
-   * @since 1.2
+   * @param header the header written in the first line, may be null.
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
    */
   public void store(OutputStream out, String header) throws IOException
   {
     // The spec says that the file must be encoded using ISO-8859-1.
     PrintWriter writer
-      = new PrintWriter(new OutputStreamWriter(out, "ISO-8859-1"));
+      = new PrintWriter(new OutputStreamWriter (out, "ISO-8859-1"));
     if (header != null)
       writer.println("#" + header);
-    writer.println("#" + new Date());
+    writer.println("#" + new Date().toString());
     list(writer);
     writer.flush();
   }
 
   /**
+   * Adds the given key/value pair to this properties.  This calls
+   * the hashtable method put.
+   * @param key the key for this property
+   * @param value the value for this property
+   * @return The old value for the given key.
+   * @since JDK1.2 */
+  public Object setProperty(String key, String value)
+  {
+    return put(key, value);
+  }
+
+  /**
    * Gets the property with the specified key in this property list.
    * If the key is not found, the default property list is searched.
-   * If the property is not found in the default, null is returned.
-   *
-   * @param key The key for this property
-   * @return the value for the given key, or null if not found
-   * @throws ClassCastException if this property contains any key or
-   *         value that isn't a string
-   * @see #defaults
-   * @see #setProperty(String, String)
-   * @see #getProperty(String, String)
+   * If the property is not found in default or the default of
+   * default, null is returned.
+   * @param key The key for this property.
+   * @param defaulValue A default value
+   * @return The value for the given key, or null if not found. 
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
    */
   public String getProperty(String key)
   {
@@ -396,16 +358,13 @@
   /**
    * Gets the property with the specified key in this property list.  If
    * the key is not found, the default property list is searched.  If the
-   * property is not found in the default, the specified defaultValue is
-   * returned.
-   *
-   * @param key The key for this property
-   * @param defaultValue A default value
-   * @return The value for the given key
-   * @throws ClassCastException if this property contains any key or
-   *         value that isn't a string
-   * @see #defaults
-   * @see #setProperty(String, String)
+   * property is not found in default or the default of default, the 
+   * specified defaultValue is returned.
+   * @param key The key for this property.
+   * @param defaulValue A default value
+   * @return The value for the given key.
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
    */
   public String getProperty(String key, String defaultValue)
   {
@@ -413,145 +372,184 @@
     // Eliminate tail recursion.
     do
       {
-        String value = (String) prop.get(key);
-        if (value != null)
-          return value;
-        prop = prop.defaults;
+	String value = (String) prop.get(key);
+	if (value != null)
+	  return value;
+	prop = prop.defaults;
       }
     while (prop != null);
     return defaultValue;
   }
 
+  private final void addHashEntries(Hashtable base)
+  {
+    if (defaults != null)
+      defaults.addHashEntries(base);
+    Enumeration keys = keys();
+    while (keys.hasMoreElements())
+      base.put(keys.nextElement(), base);
+  }
+
   /**
    * Returns an enumeration of all keys in this property list, including
    * the keys in the default property list.
-   *
-   * @return an Enumeration of all defined keys
    */
   public Enumeration propertyNames()
   {
-    // We make a new Set that holds all the keys, then return an enumeration
-    // for that. This prevents modifications from ruining the enumeration,
-    // as well as ignoring duplicates.
-    Properties prop = this;
-    Set s = new HashSet();
-    // Eliminate tail recursion.
-    do
+    // We make a new Hashtable that holds all the keys.  Then we
+    // return an enumeration for this hash.  We do this because we
+    // don't want modifications to be reflected in the enumeration
+    // (per JCL), and because there doesn't seem to be a
+    // particularly better way to ensure that duplicates are
+    // ignored.
+    Hashtable t = new Hashtable();
+    addHashEntries(t);
+    return t.keys();
+  }
+
+  /**
+   * Formats a key/value pair for output in a properties file.
+   * See store for a description of the format.
+   * @param key the key.
+   * @param value the value.
+   * @see #store
+   */
+  private String formatForOutput(String key, String value)
+  {
+    // This is a simple approximation of the expected line size.
+    StringBuffer result =
+      new StringBuffer(key.length() + value.length() + 16);
+    boolean head = true;
+    for (int i = 0; i < key.length(); i++)
       {
-        s.addAll(prop.keySet());
-        prop = prop.defaults;
+	char c = key.charAt(i);
+	switch (c)
+	  {
+	  case '\n':
+	    result.append("\\n");
+	    break;
+	  case '\r':
+	    result.append("\\r");
+	    break;
+	  case '\t':
+	    result.append("\\t");
+	    break;
+	  case '\\':
+	    result.append("\\\\");
+	    break;
+	  case '!':
+	    result.append("\\!");
+	    break;
+	  case '#':
+	    result.append("\\#");
+	    break;
+	  case '=':
+	    result.append("\\=");
+	    break;
+	  case ':':
+	    result.append("\\:");
+	    break;
+	  case ' ':
+	    result.append("\\ ");
+	    break;
+	  default:
+	    if (c < 32 || c > '~')
+	      {
+		String hex = Integer.toHexString(c);
+		result.append("\\u0000".substring(0, 6 - hex.length()));
+		result.append(hex);
+	      }
+	    else
+	        result.append(c);
+	  }
+	if (c != 32)
+	  head = false;
       }
-    while (prop != null);
-    return Collections.enumeration(s);
+    result.append('=');
+    head = true;
+    for (int i = 0; i < value.length(); i++)
+      {
+	char c = value.charAt(i);
+	switch (c)
+	  {
+	  case '\n':
+	    result.append("\\n");
+	    break;
+	  case '\r':
+	    result.append("\\r");
+	    break;
+	  case '\t':
+	    result.append("\\t");
+	    break;
+	  case '\\':
+	    result.append("\\\\");
+	    break;
+	  case '!':
+	    result.append("\\!");
+	    break;
+	  case '#':
+	    result.append("\\#");
+	    break;
+	  case ' ':
+	    result.append(head ? "\\ " : " ");
+	    break;
+	  default:
+	    if (c < 32 || c > '~')
+	      {
+		String hex = Integer.toHexString(c);
+		result.append("\\u0000".substring(0, 6 - hex.length()));
+		result.append(hex);
+	      }
+	    else
+	      result.append(c);
+	  }
+	if (c != 32)
+	  head = false;
+      }
+    return result.toString();
   }
 
   /**
    * Writes the key/value pairs to the given print stream.  They are
-   * written in the way described in the method store. This does not visit
-   * the keys in the default properties.
-   *
-   * @param out the stream, where the key/value pairs are written to
-   * @throws ClassCastException if this property contains any key or
-   *         value that isn't a string
-   * @see #store(OutputStream, String)
+   * written in the way, described in the method store.
+   * @param out the stream, where the key/value pairs are written to.
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
+   * @see #store
    */
   public void list(PrintStream out)
   {
-    Iterator iter = entrySet().iterator();
-    int i = size();
-    StringBuffer s = new StringBuffer(); // Reuse the same buffer.
-    while (--i >= 0)
+    Enumeration keys = keys();
+    Enumeration elts = elements();
+    while (keys.hasMoreElements())
       {
-        Map.Entry entry = (Map.Entry) iter.next();
-        formatForOutput((String) entry.getKey(), s, true);
-        s.append('=');
-        formatForOutput((String) entry.getValue(), s, false);
-        out.println(s);
+	String key = (String) keys.nextElement();
+	String elt = (String) elts.nextElement();
+	String output = formatForOutput(key, elt);
+	out.println(output);
       }
   }
 
   /**
    * Writes the key/value pairs to the given print writer.  They are
    * written in the way, described in the method store.
-   *
-   * @param out the writer, where the key/value pairs are written to
-   * @throws ClassCastException if this property contains any key or
-   *         value that isn't a string
-   * @see #store(OutputStream, String)
-   * @see #list(PrintStream)
-   * @since 1.1
+   * @param out the writer, where the key/value pairs are written to.
+   * @exception ClassCastException if this property contains any key or
+   * value that isn't a string.
+   * @see #store
+   * @see #list(java.io.PrintStream)
+   * @since JDK1.1
    */
   public void list(PrintWriter out)
   {
-    Iterator iter = entrySet().iterator();
-    int i = size();
-    StringBuffer s = new StringBuffer(); // Reuse the same buffer.
-    while (--i >= 0)
-      {
-        Map.Entry entry = (Map.Entry) iter.next();
-        formatForOutput((String) entry.getKey(), s, true);
-        s.append('=');
-        formatForOutput((String) entry.getValue(), s, false);
-        out.println(s);
-      }
-  }
-
-  /**
-   * Formats a key or value for output in a properties file.
-   * See store for a description of the format.
-   *
-   * @param str the string to format
-   * @param buffer the buffer to add it to
-   * @param key true if all ' ' must be escaped for the key, false if only
-   *        leading spaces must be escaped for the value
-   * @see #store(OutputStream, String)
-   */
-  private void formatForOutput(String str, StringBuffer buffer, boolean key)
-  {
-    if (key)
-      {
-        buffer.setLength(0);
-        buffer.ensureCapacity(str.length());
-      }
-    else
-      buffer.ensureCapacity(buffer.length() + str.length());
-    boolean head = true;
-    int size = str.length();
-    for (int i = 0; i < size; i++)
+    Enumeration keys = keys();
+    Enumeration elts = elements();
+    while (keys.hasMoreElements())
       {
-        char c = str.charAt(i);
-        switch (c)
-          {
-          case '\n':
-            buffer.append("\\n");
-            break;
-          case '\r':
-            buffer.append("\\r");
-            break;
-          case '\t':
-            buffer.append("\\t");
-            break;
-          case ' ':
-            buffer.append(head ? "\\ " : " ");
-            break;
-          case '\\':
-          case '!':
-          case '#':
-          case '=':
-          case ':':
-            buffer.append('\\').append(c);
-          default:
-            if (c < ' ' || c > '~')
-              {
-                String hex = Integer.toHexString(c);
-                buffer.append("\\u0000".substring(0, 6 - hex.length()));
-                buffer.append(hex);
-              }
-            else
-              buffer.append(c);
-          }
-        if (c != ' ')
-          head = key;
+	String key = (String) keys.nextElement();
+	String elt = (String) elts.nextElement();
+	String output = formatForOutput(key, elt);
+	out.println(output);
       }
   }
-} // class Properties
+}
