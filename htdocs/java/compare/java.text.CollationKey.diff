--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/CollationKey.java	2003-06-16 02:24:03.000000000 -0600
+++ java/text/CollationKey.java	2003-06-13 02:27:40.000000000 -0600
@@ -66,11 +66,6 @@
 public final class CollationKey implements Comparable
 {
   /**
-   * This is the <code>Collator</code> this object was created from.
-   */
-  private Collator collator;
-
-  /**
    * This is the <code>String</code> this object represents.
    */
   private String originalText;
@@ -78,13 +73,23 @@
   /**
    * This is the bit value for this key.
    */
-  private byte[] key;
+  private int[] key;
 
-  CollationKey (Collator collator, String originalText, byte[] key)
+  CollationKey (CollationElementIterator iter, String originalText,
+		int strength)
   {
-    this.collator = collator;
     this.originalText = originalText;
-    this.key = key;
+
+    // Compute size of required array.
+    int size = 0;
+    while (RuleBasedCollator.next(iter, strength)
+	   != CollationElementIterator.NULLORDER)
+      ++size;
+
+    iter.reset();
+    key = new int[size];
+    for (int i = 0; i < size; i++)
+      key[i] = RuleBasedCollator.next(iter, strength);
   }
 
   /**
@@ -98,23 +103,15 @@
    */
   public int compareTo (CollationKey ck)
   {
-    int i;
-    for (i = 0; i < key.length; i++)
-      {
-        if (ck.key.length <= i)
-          return 1;
-
-        if (key [i] < ck.key [i])
-          return -1;
+    int max = Math.min (key.length, ck.key.length);
 
-        if (key [i] > ck.key [i])
-          return 1;
+    for (int i = 0; i < max; ++i)
+      {
+	if (key[i] != ck.key[i])
+	  return key[i] - ck.key[i];
       }
 
-    if (i == ck.key.length)
-      return 0;
-    else
-      return -1;
+    return key.length - ck.key.length;
   }
 
   /**
@@ -151,22 +148,17 @@
    */
   public boolean equals (Object obj)
   {
-    if (obj == null)
-      return false;
-
     if (! (obj instanceof CollationKey))
       return false;
 
     CollationKey ck = (CollationKey) obj;
 
-    if (!ck.collator.equals (collator))
+    if (key.length != ck.key.length)
       return false;
 
-    if (!ck.getSourceString ().equals (getSourceString ()))
-      return false;
-
-    if (!ck.toByteArray ().equals (toByteArray ()))
-      return false;
+    for (int i = 0; i < key.length; ++i)
+      if (key[i] != ck.key[i])
+	return false;
 
     return true;
   }
@@ -191,7 +183,11 @@
    */
   public int hashCode ()
   {
-    return key.hashCode ();
+    // We just follow BitSet instead of thinking up something new.
+    long h = originalText.hashCode();
+    for (int i = key.length - 1; i >= 0; --i)
+      h ^= key[i] * (i + 1);
+    return (int) ((h >> 32) ^ h);
   }
   
   /**
@@ -201,6 +197,15 @@
    */
   public byte[] toByteArray ()
   {
-    return key;
+    byte[] r = new byte[4 * key.length];
+    int off = 0;
+    for (int i = 0; i < key.length; ++i)
+      {
+	r[off++] = (byte) ((key[i] >>> 24) & 255);
+	r[off++] = (byte) ((key[i] >>> 16) & 255);
+	r[off++] = (byte) ((key[i] >>>  8) & 255);
+	r[off++] = (byte) ((key[i]       ) & 255);
+      }
+    return r;
   }
 }
