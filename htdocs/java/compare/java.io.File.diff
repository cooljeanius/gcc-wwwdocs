--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/File.java	2003-06-16 02:23:52.000000000 -0600
+++ java/io/File.java	2003-06-13 02:27:33.000000000 -0600
@@ -40,8 +40,7 @@
 
 import java.net.MalformedURLException;
 import java.net.URL;
-import gnu.classpath.Configuration;
-import gnu.java.io.PlatformHelper;
+import gnu.gcj.runtime.FileDeleter;
 
 /* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
  * "The Java Language Specification", ISBN 0-201-63451-1
@@ -60,6 +59,27 @@
 public class File implements Serializable, Comparable
 {
   private static final long serialVersionUID = 301077366599181567L;
+	
+  // QUERY arguments to access function.
+  private final static int READ = 0;
+  private final static int WRITE = 1;
+  private final static int EXISTS = 2;
+
+  // QUERY arguments to stat function.
+  private final static int DIRECTORY = 0;
+  private final static int ISFILE = 1;
+  private final static int ISHIDDEN = 2;
+
+  // QUERY arguments to attr function.
+  private final static int MODIFIED = 0;
+  private final static int LENGTH = 1;
+  
+  private final native long attr (int query);
+  // On OSF1 V5.0, `stat' is a macro.  It is easiest to use the name
+  // `_stat' instead.  We do the same thing for `_access' just in
+  // case.
+  private final native boolean _access (int query);
+  private final native boolean _stat (int query);
 
   /**
    * This is the path separator string for the current host. This field
@@ -91,43 +111,30 @@
    */
   public static final char pathSeparatorChar = pathSeparator.charAt(0);
   
+
+  static final String tmpdir = System.getProperty("java.io.tmpdir");
+  static int maxPathLen;
+  static boolean caseSensitive;
+  static String dupSeparator = separator + separator;
+  
   static
   {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javaio");
-      }
+    init_native();
   }
   
+  // Native function called at class initialization. This should should
+  // set the maxPathLen and caseSensitive variables.
+  private static native void init_native();
+
   /**
    * This is the path to the file set when the object is created.  It
    * may be an absolute or relative path name.
    */
   private String path;
 
-  /*
-   * This native method does the actual check of whether or not a file
-   * is a plain file or not.  It also handles the existence check to
-   * eliminate the overhead of a call to exists()
-   */
-  private native boolean isFileInternal(String path);
-
-  /*
-   * This method does the actual check of whether or not a file is a
-   * directory or not.  It also handle the existence check to eliminate
-   * the overhead of a call to exists()
-   */
-  private native boolean isDirectoryInternal(String path);
-
-  /**
-   * This native method checks file permissions for reading
-   */
-  private synchronized native boolean canReadInternal(String path);
-
-  /**
-   * This native method checks file permissions for writing
-   */
-  private synchronized native boolean canWriteInternal(String path);
+  // We keep a counter for use by createTempFile.  We choose the first
+  // value randomly to try to avoid clashes with other VMs.
+  private static long counter = Double.doubleToLongBits (Math.random ());
 
   /**
    * This method tests whether or not the current thread is allowed to
@@ -144,11 +151,8 @@
    */
   public boolean canRead ()
   {
-    // Test for existence. This also does the SecurityManager check
-    if (!exists ())
-      return false;
-
-    return canReadInternal (path);
+    checkRead ();
+    return _access (READ);
   }
 
   /**
@@ -167,27 +171,11 @@
    */
   public boolean canWrite ()
   {
-    // We still need to do a SecurityCheck since exists() only checks
-    // for read access
     checkWrite ();
-     
-    // Test for existence.  This is required by the spec
-    if (!exists())
-      return false;
-
-    if (!isDirectory())
-      return canWriteInternal (path);
-    else
-      try
-        {
-  	  File test = createTempFile ("test-dir-write", null, this);
-  	  return (test != null && test.delete ());
-        }
-      catch (IOException ioe)
-        {
-  	  return false;
-        }
+    return _access (WRITE);
   }
+  
+  private native boolean performCreate() throws IOException;
 
   /**
    * This method creates a new file of zero length with the same name as
@@ -209,13 +197,13 @@
   public boolean createNewFile() throws IOException
   {
     checkWrite ();
-    return createInternal (getPath ());
+    return performCreate();
   }
  
   /*
    * This native method handles the actual deleting of the file
    */
-  private native boolean deleteInternal(String path);
+  private native boolean performDelete ();
 
   /**
    * This method deletes the file represented by this object.  If this file
@@ -233,7 +221,7 @@
     if (s != null)
       s.checkDelete (path);
     
-    return deleteInternal(path);
+    return performDelete ();
   }
 
   /**
@@ -253,22 +241,16 @@
    */
   public boolean equals (Object obj)
   {
-    if (obj == null)
+    if (! (obj instanceof File))
       return false;
     
-    if (!(obj instanceof File))
-      return false;
-
-    File f = (File) obj;
-
-    return f.getPath ().equals (getPath ());
+    File other = (File) obj;
+    if (caseSensitive)
+      return path.equals(other.path);
+    else
+      return path.equalsIgnoreCase(other.path);
   }
 
-  /*
-   * This native method does the actual checking of file existence.
-   */
-  private native boolean existsInternal(String path);
-
   /**
    * This method tests whether or not the file represented by the object
    * actually exists on the filesystem.
@@ -280,7 +262,7 @@
   public boolean exists ()
   {
     checkRead ();
-    return existsInternal (path);
+    return _access (EXISTS);
   }
 
   /**
@@ -291,15 +273,69 @@
    */
   public File (String name)
   {
-    path = name;
+    path = normalizePath (name);
+  }
+
+  // Remove duplicate and redundant separator characters.
+  private String normalizePath(String p)
+  {
+    // On Windows, convert any '/' to '\'.  This appears to be the same logic
+    // that Sun's Win32 Java performs.
+    if (separatorChar == '\\')
+      p = p.replace ('/', '\\');
+
+    int dupIndex = p.indexOf(dupSeparator);
+    int plen = p.length();
+
+    // Special case: permit Windows UNC path prefix.
+    if (dupSeparator.equals("\\\\") && dupIndex == 0)
+      dupIndex = p.indexOf(dupSeparator, 1);
 
-    // Per the spec
-    if (path == null)
-      throw new NullPointerException("File name is null");
-
-    while (!PlatformHelper.isRootDirectory(path)
-  	 && PlatformHelper.endWithSeparator(path))
-        path = PlatformHelper.removeTailSeparator(path);
+    if (dupIndex == -1)
+      {
+        // Ignore trailing separator (though on Windows "a:\", for
+        // example, is a valid and minimal path).
+        if (plen > 1 && p.charAt (plen - 1) == separatorChar)
+	  {
+	    if (! (separatorChar == '\\' && plen == 3 && p.charAt (1) == ':'))
+	      return p.substring (0, plen - 1);
+	  }
+	else
+	  return p;
+      }
+    
+    StringBuffer newpath = new StringBuffer(plen);
+    int last = 0;
+    while (dupIndex != -1)
+      {
+        newpath.append(p.substring(last, dupIndex));
+	// Ignore the duplicate path characters.
+	while (p.charAt(dupIndex) == separatorChar)
+	  {
+	    dupIndex++;
+	    if (dupIndex == plen)
+	      return newpath.toString();
+	  }
+	newpath.append(separatorChar);
+	last = dupIndex;
+	dupIndex = p.indexOf(dupSeparator, last);
+      }
+    
+    // Again, ignore possible trailing separator (except special cases
+    // like "a:\" on Windows).
+    int end;
+    if (plen > 1 && p.charAt (plen - 1) == separatorChar)
+    {
+      if (separatorChar == '\\' && plen == 3 && p.charAt (1) == ':')
+        end = plen;
+      else
+        end = plen - 1;
+    }
+    else
+      end = plen;
+    newpath.append(p.substring(last, end));
+    
+    return newpath.toString();
   }
  
   /**
@@ -309,12 +345,24 @@
    * name.  If the directory path name ends in the separator string, another
    * separator string will still be appended.
    *
-   * @param dirPath The path to the directory the file resides in
+   * @param dirname The path to the directory the file resides in
    * @param name The name of the file
    */
   public File (String dirPath, String name)
   {
-    this (dirPath == null ? (File) null : new File (dirPath), name);
+    if (name == null)
+      throw new NullPointerException ();
+    if (dirPath != null && dirPath.length() > 0)
+      {
+	// Try to be smart about the number of separator characters.
+	if (dirPath.charAt(dirPath.length() - 1) == separatorChar
+	    || name.length() == 0)
+	  path = normalizePath(dirPath + name);
+	else
+	  path = normalizePath(dirPath + separatorChar + name);
+      }
+    else
+      path = normalizePath(name);
   }
 
   /**
@@ -329,21 +377,7 @@
    */
   public File (File directory, String name)
   {
-    if (directory == null)
-      {
-        String dirname = System.getProperty("user.dir");
-        if (dirname == null)
-          throw new IllegalArgumentException
-  		("Cannot determine default user directory");
-
-        directory = new File(dirname);
-      }
-
-    String dirpath = directory.getPath();
-    if (PlatformHelper.isRootDirectory(dirpath))
-      path = dirpath + name;
-    else
-      path = dirpath + separator + name;
+    this (directory == null ? null : directory.path, name);
   }
 
   /**
@@ -359,15 +393,43 @@
   {
     if (isAbsolute ())
       return path;
-    
-    String dir = System.getProperty ("user.dir");
-    if (dir == null)
-      return path;
-
-    if (PlatformHelper.endWithSeparator (dir))
-      return dir + path;
-
-    return dir + separator + path;
+    else if (separatorChar == '\\' 
+             && path.length () > 0 && path.charAt (0) == '\\')
+      {
+        // On Windows, even if the path starts with a '\\' it is not
+        // really absolute until we prefix the drive specifier from
+        // the current working directory to it.
+        return System.getProperty ("user.dir").substring (0, 2) + path;
+      }
+    else if (separatorChar == '\\' 
+             && path.length () > 1 && path.charAt (1) == ':'
+             && ((path.charAt (0) >= 'a' && path.charAt (0) <= 'z')
+                 || (path.charAt (0) >= 'A' && path.charAt (0) <= 'Z')))
+      {
+        // On Windows, a process has a current working directory for
+        // each drive and a path like "G:foo\bar" would mean the 
+        // absolute path "G:\wombat\foo\bar" if "\wombat" is the 
+        // working directory on the G drive.
+        String drvDir = null;
+        try
+          {
+            drvDir = new File (path.substring (0, 2)).getCanonicalPath ();
+          }
+        catch (IOException e)
+          {
+            drvDir = path.substring (0, 2) + "\\";
+          }
+        
+        // Note: this would return "C:\\." for the path "C:.", if "\"
+        // is the working folder on the C drive, but this is 
+        // consistent with what Sun's JRE 1.4.1.01 actually returns!
+        if (path.length () > 2)
+          return drvDir + '\\' + path.substring (2, path.length ());
+        else
+          return drvDir;
+      }
+    else
+      return System.getProperty ("user.dir") + separatorChar + path;
   }
 
   /**
@@ -396,11 +458,7 @@
    *
    * @exception IOException If an error occurs
    */
-  public String getCanonicalPath () throws IOException
-  {
-    String abspath = getAbsolutePath();
-    return PlatformHelper.toCanonicalForm(abspath);
-  }
+  public native String getCanonicalPath () throws IOException;
 
   /**
    * This method returns a <code>File</code> object representing the
@@ -427,14 +485,30 @@
    */
   public String getName ()
   {
-    int pos = PlatformHelper.lastIndexOfSeparator (path);
-    if (pos == -1)
-      return path;
+    int nameSeqIndex = 0;
 
-    if (PlatformHelper.endWithSeparator (path))
-      return "";
+    if (separatorChar == '\\' && path.length () > 1)
+      {
+        // On Windows, ignore the drive specifier or the leading '\\'
+        // of a UNC network path, if any (a.k.a. the "prefix").
+        if ((path.charAt (0) == '\\' && path.charAt (1) == '\\')
+            || (((path.charAt (0) >= 'a' && path.charAt (0) <= 'z')
+		 || (path.charAt (0) >= 'A' && path.charAt (0) <= 'Z'))
+		&& path.charAt (1) == ':'))
+	  {
+	    if (path.length () > 2)
+	      nameSeqIndex = 2;
+	    else
+	      return "";
+	  }
+      }
+
+    String nameSeq 
+      = (nameSeqIndex > 0 ? path.substring (nameSeqIndex) : path);
 
-    return path.substring (pos + separator.length ());
+    int last = nameSeq.lastIndexOf (separatorChar);
+
+    return nameSeq.substring (last + 1);
   }
 
   /**
@@ -446,16 +520,56 @@
    */
   public String getParent ()
   {
-    if (PlatformHelper.isRootDirectory (path))
-      return null;
+    String prefix = null;
+    int nameSeqIndex = 0;
 
-    String par_path = path;
+    // The "prefix", if present, is the leading "/" on UNIX and 
+    // either the drive specifier (e.g. "C:") or the leading "\\"
+    // of a UNC network path on Windows.
+    if (separatorChar == '/' && path.charAt (0) == '/')
+      {
+        prefix = "/";
+        nameSeqIndex = 1;
+      }
+    else if (separatorChar == '\\' && path.length () > 1)
+      {
+        if ((path.charAt (0) == '\\' && path.charAt (1) == '\\')
+            || (((path.charAt (0) >= 'a' && path.charAt (0) <= 'z')
+                 || (path.charAt (0) >= 'A' && path.charAt (0) <= 'Z'))
+                && path.charAt (1) == ':'))
+          {
+            prefix = path.substring (0, 2);
+            nameSeqIndex = 2;
+          }
+      }
 
-    int pos = PlatformHelper.lastIndexOfSeparator (par_path);
-    if (pos == -1)
-      return null;
+    // According to the JDK docs, the returned parent path is the 
+    // portion of the name sequence before the last separator
+    // character, if found, prefixed by the prefix, otherwise null.
+    if (nameSeqIndex < path.length ())
+      {
+        String nameSeq = path.substring (nameSeqIndex, path.length ());
+        int last = nameSeq.lastIndexOf (separatorChar);
+        if (last == -1)
+          return prefix;
+        else if (last == (nameSeq.length () - 1))
+          // Note: The path would not have a trailing separator
+          // except for cases like "C:\" on Windows (see 
+          // normalizePath( )), where Sun's JRE 1.4 returns null.
+          return null;
+        else if (last == 0)
+          last++;
 
-    return par_path.substring (0, pos);
+        if (prefix != null)
+          return prefix + nameSeq.substring (0, last);
+        else
+          return nameSeq.substring (0, last);
+      }
+    else
+      // Sun's JRE 1.4 returns null if the prefix is the only 
+      // component of the path - so "/" gives null on UNIX and 
+      // "C:", "\\", etc. return null on Windows.
+      return null;
   }
 
   /**
@@ -471,10 +585,7 @@
   public File getParentFile ()
   {
     String parent = getParent ();
-    if (parent == null)
-      return null;
-
-    return new File (parent);
+    return (parent == null ? null : new File (parent));
   }
 
   /**
@@ -497,7 +608,10 @@
    */
   public int hashCode ()
   {
-    return getPath().hashCode() ^ 1234321;
+    if (caseSensitive)
+      return (path.hashCode() ^ 1234321);
+    else
+      return (path.toLowerCase().hashCode() ^ 1234321);
   }
 
   /**
@@ -509,13 +623,7 @@
    * @return <code>true</code> if this object represents an absolute 
    * file name, <code>false</code> otherwise.
    */
-  public boolean isAbsolute ()
-  {
-    if (PlatformHelper.beginWithRootPathPrefix (path) > 0)
-      return true;
-    else
-      return false;
-  }
+  public native boolean isAbsolute ();
 
   /**
    * This method tests whether or not the file represented by this object
@@ -530,7 +638,7 @@
   public boolean isDirectory ()
   {
     checkRead ();
-    return isDirectoryInternal (path); 
+    return _stat (DIRECTORY);
   }
 
   /**
@@ -546,7 +654,7 @@
   public boolean isFile ()
   {
     checkRead ();
-    return isFileInternal (path);
+    return _stat (ISFILE);
   }
 
   /**
@@ -562,20 +670,10 @@
    */
   public boolean isHidden ()
   {
-    // FIXME: this only works on UNIX
-    if (getName().startsWith("."))
-      return true;
-    else
-      return false;
+    checkRead ();
+    return _stat (ISHIDDEN);
   }
 
-  /*
-   * This native method does the actual work of getting the last file
-   * modification time.  It also does the existence check to avoid the
-   * overhead of a call to exists()
-   */
-  private native long lastModifiedInternal(String path);
-
   /**
    * This method returns the last modification time of this file.  The
    * time value returned is an abstract value that should not be interpreted
@@ -592,15 +690,9 @@
   public long lastModified ()
   {
     checkRead ();
-    return lastModifiedInternal (path);
+    return attr (MODIFIED);
   }
 
-  /*
-   * This native method actually determines the length of the file and
-   * handles the existence check
-   */
-  private native long lengthInternal(String path);
-
   /**
    * This method returns the length of the file represented by this object,
    * or 0 if the specified file does not exist.
@@ -612,14 +704,17 @@
   public long length ()
   {
     checkRead ();
-    return lengthInternal (path);
+    return attr (LENGTH);
   }
 
   /*
    * This native function actually produces the list of file in this
    * directory
    */
-  private native String[] listInternal (String dirname);
+    
+  private final native Object[] performList (FilenameFilter filter,
+					     FileFilter fileFilter,
+					     Class result_type);
 
   /**
    * This method returns a array of <code>String</code>'s representing the
@@ -651,37 +746,7 @@
   public String[] list (FilenameFilter filter)
   {
     checkRead ();
-
-    // Get the list of files
-    String list_path = PlatformHelper.removeTailSeparator(path);
-    File dir = new File(list_path);
-
-    if (! dir.exists() || ! dir.isDirectory() ) return null;
-    
-    String files[] = listInternal(list_path);
-    
-    if (files == null)
-      return new String[0];
-    if (filter == null)
-      return files;
-    
-    // Apply the filter
-    int count = 0;
-    for (int i = 0; i < files.length; i++)
-      {
-        if (filter.accept(this, files[i]))
-  	  ++count;
-        else
-  	  files[i] = null;
-      }
-
-    String[] retfiles = new String[count];
-    count = 0;
-    for (int i = 0; i < files.length; i++)
-      if (files[i] != null)
-        retfiles[count++] = files[i];
-
-    return retfiles;
+    return (String[]) performList (filter, null, String.class);
   }
 
   /**
@@ -704,7 +769,8 @@
    */
   public String[] list ()
   {
-    return list (null);
+    checkRead ();
+    return (String[]) performList (null, null, String.class);
   }
 
   /**
@@ -727,7 +793,8 @@
    */
   public File[] listFiles ()
   {
-    return listFiles ((FilenameFilter) null);
+    checkRead ();
+    return (File[]) performList (null, null, File.class);
   }
   
   /**
@@ -756,17 +823,8 @@
    */
   public File[] listFiles (FilenameFilter filter)
   {
-    String[] filelist = list (filter);
-    
-    if (filelist == null)
-      return null;
-
-    File[] fobjlist = new File [filelist.length];
-
-    for (int i = 0; i < filelist.length; i++)
-      fobjlist [i] = new File (this, filelist [i]);
-
-    return fobjlist;
+    checkRead ();
+    return (File[]) performList (filter, null, File.class);
   }
 
   /**
@@ -795,29 +853,8 @@
    */
   public File[] listFiles (FileFilter filter)
   {
-    File[] fobjlist = listFiles ((FilenameFilter) null);
-
-    if (fobjlist == null)
-      return null;
-
-    if (filter == null)
-      return fobjlist;
-
-    int count = 0;
-    for (int i = 0; i < fobjlist.length; i++)
-      if (filter.accept(fobjlist[i]) == true)
-        ++count;
-
-    File[] final_list = new File[count];
-    count = 0;
-    for (int i = 0; i < fobjlist.length; i++)
-      if (filter.accept(fobjlist[i]) == true)
-        {
-          final_list[count] = fobjlist[i];
-          ++count;
-        }
-
-    return final_list;
+    checkRead ();
+    return (File[]) performList (null, filter, File.class);
   }
 
   /**
@@ -843,24 +880,20 @@
    */
   public URL toURL () throws MalformedURLException
   {
-    String abspath = getAbsolutePath ();
-    
-    try
-      {
-        if (new File (abspath).isDirectory ())
-  	  abspath = abspath + separator;
-      }
-    catch(Exception _) { }
-    
-    String url_string = "file://" + abspath;
-    
-    return new URL (url_string);
+    // On Win32, Sun's JDK returns URLs of the form "file:/c:/foo/bar.txt",
+    // while on UNIX, it returns URLs of the form "file:/foo/bar.txt". 
+    if (separatorChar == '\\')
+      return new URL ("file:/" + getAbsolutePath ().replace ('\\', '/')
+		      + (isDirectory() ? "/" : ""));
+    else
+      return new URL ("file:" + getAbsolutePath ()
+		      + (isDirectory() ? "/" : ""));
   }
 
   /*
    * This native method actually creates the directory
    */
-  private native boolean mkdirInternal (String path);
+  private final native boolean performMkdir ();
 
   /**
    * This method creates a directory for the path represented by this object.
@@ -873,8 +906,23 @@
   public boolean mkdir ()
   {
     checkWrite ();
-    String mk_path = PlatformHelper.removeTailSeparator (path);
-    return mkdirInternal (mk_path);
+    return performMkdir ();
+  }
+
+  private static boolean mkdirs (File x)
+  {
+    if (x.isDirectory())
+      return true;
+    String p = x.getPath();
+    String parent = x.getParent();
+    if (parent != null)
+      {
+	x.path = parent;
+	if (! mkdirs (x))
+	  return false;
+	x.path = p;
+      }
+    return x.mkdir();
   }
 
   /**
@@ -888,27 +936,16 @@
    */
   public boolean mkdirs ()
   {
-    String parent = getParent();
-    if (parent == null)
-      {
-        return mkdir();
-      }
-      
-    File f = new File(parent);
-    if (!f.exists())
-      {
-        boolean rc = f.mkdirs();
-        if (rc == false)
-          return false;
-      }
-
-    return mkdir ();
+    checkWrite ();
+    if (isDirectory ())
+      return false;
+    return mkdirs (new File (path));
   }
 
-  /**
-   * This method is used to create a temporary file
-   */
-  private static native boolean createInternal (String name) throws IOException;
+  private static synchronized String nextValue ()
+  {
+    return Long.toString(counter++, Character.MAX_RADIX);
+  }
 
   /**
    * This method creates a temporary file in the specified directory.  If 
@@ -947,54 +984,65 @@
     // Grab the system temp directory if necessary
     if (directory == null)
       {
-        String dirname = System.getProperty ("java.io.tmpdir");
-        if (dirname == null)
-          throw new IOException ("Cannot determine system temporary directory"); 
+	String dirname = tmpdir;
+	if (dirname == null)
+	  throw 
+	    new IOException ("Cannot determine system temporary directory"); 
 	
-        directory = new File (dirname);
-        if (!directory.exists ())
-          throw new IOException ("System temporary directory "
-                                 + directory.getName () + " does not exist.");
-        if (!directory.isDirectory ())
-          throw new IOException ("System temporary directory "
-                                 + directory.getName ()
-                                 + " is not really a directory.");
+	directory = new File (dirname);
+	if (!directory.exists ())
+	  throw new IOException ("System temporary directory " 
+				 + directory.getName() + " does not exist.");
+	if (!directory.isDirectory())
+	  throw new IOException ("System temporary directory " 
+				 + directory.getName() 
+				 + " is not really a directory.");
       }
 
-    // Now process the prefix and suffix.
     if (prefix.length () < 3)
       throw new IllegalArgumentException ("Prefix too short: " + prefix);
 
     if (suffix == null)
       suffix = ".tmp";
 
-    // Now identify a file name and make sure it doesn't exist
-    File f;
-    for(;;)
+    // Truncation rules.
+    // `6' is the number of characters we generate.
+    if (prefix.length () + 6 + suffix.length () > maxPathLen)
       {
-        String filename = prefix + System.currentTimeMillis () + suffix;
-        f = new File (directory, filename);
-
-        if (f.exists ())
-          continue;
-        else
-          break;
+	int suf_len = 0;
+	if (suffix.charAt(0) == '.')
+	  suf_len = 4;
+	suffix = suffix.substring(0, suf_len);
+	if (prefix.length () + 6 + suf_len > maxPathLen)
+	  prefix = prefix.substring(0, maxPathLen - 6 - suf_len);
       }
 
-    // Verify that we are allowed to create this file
-    SecurityManager sm = System.getSecurityManager();
-    if (sm != null)
-      sm.checkWrite(f.getAbsolutePath());
+    File f;
+
+    // How many times should we try?  We choose 100.
+    for (int i = 0; i < 100; ++i)
+      {
+	// This is ugly.
+	String t = "ZZZZZZ" + nextValue ();
+	String l = prefix + t.substring(t.length() - 6) + suffix;
+	try
+	  {
+	    f = new File(directory, l);
+	    if (f.createNewFile())
+	      return f;
+	  }
+	catch (IOException ignored)
+	  {
+	  }
+      }
 
-    // Now create the file and return our file object
-    createInternal(f.getAbsolutePath()); 
-    return f;
+    throw new IOException ("cannot create temporary file");
   }
 
   /*
    * This native method sets the permissions to make the file read only.
    */
-  private native boolean setReadOnlyInternal (String path);
+  private native boolean performSetReadOnly();
 
   /**
    * This method sets the file represented by this object to be read only.
@@ -1012,16 +1060,12 @@
    */
   public boolean setReadOnly ()
   {
-    // Test for existence.
-    if (!exists ())
-      return false;
-
-    // We still need to do a SecurityCheck since exists() only checks
-    // for read access
     checkWrite ();
-    return setReadOnlyInternal (path);
+    return performSetReadOnly();
   }
 
+  private static native File[] performListRoots();
+
   /**
    * This method returns an array of filesystem roots.  Some operating systems
    * have volume oriented filesystem.  This method provides a mechanism for
@@ -1035,10 +1079,38 @@
    */
   public static File[] listRoots ()
   {
-    File[] f = new File[1];
-    f[0] = new File("/");
-
-    return f;
+    File[] roots = performListRoots();
+    
+    SecurityManager s = System.getSecurityManager();
+    if (s != null)
+      {
+	// Only return roots to which the security manager permits read access.
+	int count = roots.length;
+	for (int i = 0; i < roots.length; i++)
+	  {
+	    try
+	      {
+        	s.checkRead (roots[i].path);		
+	      }
+	    catch (SecurityException sx)
+	      {
+	        roots[i] = null;
+		count--;
+	      }
+	  }
+	if (count != roots.length)
+	  {
+	    File[] newRoots = new File[count];
+	    int k = 0;
+	    for (int i=0; i < roots.length; i++)
+	      {
+	        if (roots[i] != null)
+		  newRoots[k++] = roots[i];
+	      }
+	    roots = newRoots;
+	  }
+      }
+    return roots;
   }
 
   /**
@@ -1090,25 +1162,12 @@
    *
    * @since 1.2
    */
-  public int compareTo (File other)
+  public int compareTo(File other)
   {
-    String p1, p2;
-    
-    try
-      {  
-        p1 = getCanonicalPath ();
-        p2 = other.getCanonicalPath ();
-      }
-    catch(IOException e)
-      {
-        // FIXME: What do we do here?  The spec requires the canonical path.
-        // Even if we don't call the method, we must replicate the functionality
-        // which per the spec can fail.  What happens in that situation?
-        // I just assume the files are equal!
-        return 0;
-      }
-
-    return p1.compareTo (p2);
+    if (caseSensitive)
+      return path.compareTo (other.path);
+    else
+      return path.compareToIgnoreCase (other.path);
   }
 
   /**
@@ -1132,15 +1191,16 @@
    *
    * @since 1.2
    */
-  public int compareTo (Object obj)
+  public int compareTo(Object o)
   {
-    return compareTo ((File) obj);
+    File other = (File) o;
+    return compareTo (other);
   }
 
   /*
    * This native method actually performs the rename.
    */
-  private native boolean renameToInternal(String target, String dest);
+  private native boolean performRenameTo (File dest);
 
   /**
    * This method renames the file represented by this object to the path
@@ -1156,15 +1216,21 @@
    */
   public synchronized boolean renameTo (File dest)
   {
-    checkWrite ();
-    // Call our native rename method
-    return renameToInternal (path, dest.getPath ());
+    SecurityManager s = System.getSecurityManager();
+    String sname = getName();
+    String dname = dest.getName();
+    if (s != null)
+      {
+	s.checkWrite (sname);
+	s.checkWrite (dname);
+      }
+    return performRenameTo (dest);
   }
 
   /*
    * This method does the actual setting of the modification time.
    */
-  private native boolean setLastModifiedInternal (String path, long time);
+  private native boolean performSetLastModified(long time);
  
   /**
    * This method sets the modification time on the file to the specified
@@ -1184,11 +1250,8 @@
    */
   public boolean setLastModified (long time) 
   {
-    if (time < 0)
-      throw new IllegalArgumentException("Negative modification time: " + time);
-
     checkWrite ();
-    return setLastModifiedInternal (path, time);
+    return performSetLastModified(time);
   }
 
   private void checkWrite ()
@@ -1210,28 +1273,20 @@
   }
 
   /** 
-   * Calling this method requests that the file represented by this object
-   * be deleted when the virtual machine exits.  Note that this request cannot
-   * be cancelled.  Also, it will only be carried out if the virtual machine
-   * exits normally.
-   *
-   * @exception SecurityException If deleting of the file is not allowed
+   * Add this File to the set of files to be deleted upon normal
+   * termination.
    *
    * @since 1.2 
    */
+  // FIXME: This should use the ShutdownHook API once we implement that.
   public void deleteOnExit ()
   {
     // Check the SecurityManager
     SecurityManager sm = System.getSecurityManager ();
     if (sm != null)
-      sm.checkDelete(path);
+      sm.checkDelete (getName ());
 
-    // Sounds like we need to do some VM specific stuff here. We could delete
-    // the file in finalize() and set FinalizeOnExit to true, but delete on
-    // finalize != delete on exit and we should not be setting up system
-    // parameters without the user's knowledge.
-    // FIXME: ********IMPLEMENT ME!!!!!!***************
-    return;
+    FileDeleter.add (this);
   }
 
   private void writeObject (ObjectOutputStream oos) throws IOException
