--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/BufferedReader.java	2003-06-16 02:23:52.000000000 -0600
+++ java/io/BufferedReader.java	2003-12-29 02:18:04.000000000 -0700
@@ -106,10 +106,14 @@
    *
    * @param in The subordinate stream to read from
    * @param size The buffer size to use
+   *
+   * @exception IllegalArgumentException if size &lt;&eq; 0
    */
   public BufferedReader(Reader in, int size)
   {
     super(in.lock);
+    if (size <= 0)
+      throw new IllegalArgumentException("Illegal buffer size: " + size);
     this.in = in;
     buffer = new char[size];
   }
@@ -161,11 +165,12 @@
    *        becomes invalid
    *
    * @exception IOException If an error occurs
+   * @exception IllegalArgumentException if readLimit is negative.
    */
   public void mark(int readLimit) throws IOException
   {
     if (readLimit < 0)
-      throw new IllegalArgumentException();
+      throw new IllegalArgumentException("Read-ahead limit is negative");
 
     synchronized (lock)
       {
@@ -280,9 +285,14 @@
    * @return The actual number of chars read, or -1 if end of stream.
    *
    * @exception IOException If an error occurs.
+   * @exception IndexOutOfBoundsException If offset and count are not
+   * valid regarding buf.
    */
   public int read(char[] buf, int offset, int count) throws IOException
   {
+    if (offset < 0 || offset + count > buf.length || count < 0)
+      throw new IndexOutOfBoundsException();
+
     synchronized (lock)
       {
 	checkStatus();
@@ -450,12 +460,19 @@
     boolean eof = false;
     for (;;)
       {
-	int ch = read();
-	if (ch < 0)
+	// readLine should block. So we must not return until a -1 is reached.
+	if (pos >= limit)
 	  {
-	    eof = true;
-	    break;
+	    // here count == 0 isn't sufficient to give a failure.
+	    int count = fill();
+	    if (count < 0)
+	      {
+		eof = true;
+		break;
+	      }
+	    continue;
 	  }
+	int ch = buffer[pos++];
 	if (ch == '\n' || ch == '\r')
 	  {
 	    // Check here if a '\r' was the last char in the buffer; if so,
@@ -487,14 +504,17 @@
    *
    * @return The actual number of chars skipped.
    *
-   * @exception IOException If an error occurs
+   * @exception IOException If an error occurs.
+   * @exception IllegalArgumentException If count is negative.
    */
   public long skip(long count) throws IOException
   {
     synchronized (lock)
       {
 	checkStatus();
-	if (count <= 0)
+	if (count < 0)
+	  throw new IllegalArgumentException("skip value is negative");
+	if (count == 0)
 	  return 0;
 	// Yet again, we need to handle the special case of a readLine
 	// that has a '\r' at the end of the buffer.  In this case, we need
