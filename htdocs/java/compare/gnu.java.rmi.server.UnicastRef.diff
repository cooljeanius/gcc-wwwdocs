--- /home/tromey/gnu/Nightly/classpath/classpath/gnu/java/rmi/server/UnicastRef.java	2003-08-12 02:19:43.000000000 -0600
+++ gnu/java/rmi/server/UnicastRef.java	2002-12-10 19:20:23.000000000 -0700
@@ -37,24 +37,32 @@
 
 package gnu.java.rmi.server;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutput;
-import java.io.ObjectOutputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.rmi.Remote;
 import java.rmi.RemoteException;
-import java.rmi.server.ObjID;
-import java.rmi.server.Operation;
+import java.rmi.server.RemoteRef;
+import java.rmi.server.RMISocketFactory;
 import java.rmi.server.RMIClientSocketFactory;
-import java.rmi.server.RemoteCall;
+import java.rmi.server.RMIServerSocketFactory;
 import java.rmi.server.RemoteObject;
-import java.rmi.server.RemoteRef;
+import java.rmi.server.RemoteCall;
+import java.rmi.server.UnicastRemoteObject;
+import java.rmi.server.Operation;
+import java.rmi.server.ObjID;
 import java.rmi.server.UID;
+import java.lang.reflect.Method;
+import java.io.ObjectOutput;
+import java.io.ObjectInput;
+import java.io.IOException;
+import java.net.Socket;
+import java.net.InetAddress;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+
+import java.lang.reflect.InvocationTargetException;
 
 public class UnicastRef
 	implements RemoteRef, ProtocolConstants {
@@ -65,9 +73,8 @@
 /**
  * Used by serialization, and let subclass capable of having default constructor
  */
-// must be public otherwise java.rmi.RemoteObject cannot instantiate this class
-// -- iP
-public UnicastRef() {
+//private 
+UnicastRef() {
 }
 
 public UnicastRef(ObjID objid, String host, int port, RMIClientSocketFactory csf) {
@@ -83,10 +90,7 @@
     // Check if client and server are in the same VM, then local call can be used to
     // replace remote call, but it's somewhat violating remote semantic.
     Object svrobj = manager.serverobj;
-    
-    // Make sure that the server object is compatible. It could be loaded from a different
-    // classloader --iP
-    if(svrobj != null && method.getDeclaringClass().isInstance(svrobj)){
+    if(svrobj != null){
         //local call
 		Object ret = null;
 		try{
