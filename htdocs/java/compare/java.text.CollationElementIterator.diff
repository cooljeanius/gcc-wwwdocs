--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/CollationElementIterator.java	2004-01-08 02:20:41.000000000 -0700
+++ java/text/CollationElementIterator.java	2004-01-29 02:18:51.000000000 -0700
@@ -38,11 +38,6 @@
 
 package java.text;
 
-import java.util.Vector;
-import java.util.NoSuchElementException;
-import java.util.Map;
-import java.util.SortedMap;
-
 /* Written using "Java Class Libraries", 2nd edition, plus online
  * API docs for JDK 1.2 from http://www.javasoft.com.
  * Status: Believed complete and correct to JDK 1.1.
@@ -79,20 +74,13 @@
   String text;
 
   /**
-   * This is the index into the collation decomposition where we are currently scanning.
-   */
-  int index;
-
-  /**
    * This is the index into the String where we are currently scanning.
    */
   int textIndex;
 
-  /**
-   * Array containing the collation decomposition of the
-   * text given to the constructor.
-   */
-  private Object[] text_decomposition;
+  // A piece of lookahead.
+  boolean lookahead_set;
+  int lookahead;
 
   /**
    * This method initializes a new instance of <code>CollationElementIterator</code>
@@ -109,33 +97,6 @@
     setText (text);    
   }
 
-  RuleBasedCollator.CollationElement nextBlock()
-  {
-    if (index >= text_decomposition.length)
-      return null;
-    
-    RuleBasedCollator.CollationElement e =
-      (RuleBasedCollator.CollationElement) text_decomposition[index++];
-    
-    textIndex += e.key.length();
-
-    return e;
-  }
-
-  RuleBasedCollator.CollationElement previousBlock()
-  {
-    if (index == 0)
-      return null;
-    
-    index--;
-    RuleBasedCollator.CollationElement e =
-      (RuleBasedCollator.CollationElement) text_decomposition[index];
-
-    textIndex -= e.key.length();
-    
-    return e;
-  }
-
   /**
    * This method returns the collation ordering value of the next character sequence
    * in the string (it may be an extended character following collation rules).
@@ -146,29 +107,10 @@
    */
   public int next()
   {
-    RuleBasedCollator.CollationElement e = nextBlock();
-
-    if (e == null)
+    if (textIndex == text.length())
       return NULLORDER;
-    
-    return e.getValue();
-  }
-
-  /**
-   * This method returns the collation ordering value of the previous character
-   * in the string.  This method will return <code>NULLORDER</code> if the
-   * beginning of the string was reached.
-   *
-   * @return The collation ordering value.
-   */
-  public int previous()
-  {
-    RuleBasedCollator.CollationElement e = previousBlock();
 
-    if (e == null)
-      return NULLORDER;
-    
-    return e.getValue();
+    return collator.ceiNext (this);
   }
 
   /**
@@ -191,7 +133,6 @@
    */
   public void reset()
   {
-    index = 0;
     textIndex = 0;
   }
 
@@ -233,66 +174,10 @@
    */
   public void setText(String text)
   {
-    int idx = 0;
-
     this.text = text;
-    this.index = 0;
-
-    String work_text = text.intern();
-
-    Vector v = new Vector();
-    // Build element collection ordered as they come in "text".
-    while (idx < work_text.length())
-      {
-	String key, key_old;
-
-	Object object = null;
-	int p = 1;
-	
-	// IMPROVE: use a TreeMap with a prefix-ordering rule.
-	key_old = key = null;
-	do
-	  {
-	    if (object != null)
-	      key_old = key;
-	    key = work_text.substring (idx, idx+p);
-	    object = collator.prefix_tree.get (key);
-	    p++;
-	  }
-	while (idx+p <= work_text.length());
-	
-	if (object == null)
-	  key = key_old;
-	
-	RuleBasedCollator.CollationElement prefix =
-	  (RuleBasedCollator.CollationElement) collator.prefix_tree.get (key);
-	
-	if (prefix == null)
-	  {
-	    RuleBasedCollator.CollationElement e =
-	      collator.getDefaultElement(work_text.charAt (idx));
-	    
-	    v.add (e);
-	    idx++;
-	    continue;
-	  }
-
-	if (prefix.expansion != null)
-	  {
-	    work_text = prefix.expansion
-	      + work_text.substring (idx+prefix.key.length());
-	    idx = 0;
-	    v.add (prefix);
-	  }
-	else
-	  {
-	    if (!prefix.ignore)
-	      v.add (prefix);
-	    idx += prefix.key.length();
-	  }
-      }
-    
-    text_decomposition = v.toArray();
+    this.textIndex = 0;
+    this.lookahead_set = false;
+    this.lookahead = 0;
   }
 
   /**
@@ -328,50 +213,4 @@
   {
     return textIndex;
   }
-
-  /**
-   * This method sets the iteration index position into the current
-   * <code>String</code> to the specified value.  This value must not
-   * be negative and must not be greater than the last index position
-   * in the <code>String</code>.
-   *
-   * @param offset The new iteration index position.
-   *
-   * @exception IllegalArgumentException If the new offset is not valid.
-   */
-  public void setOffset(int offset)
-  {
-    if (offset < 0)
-      throw new IllegalArgumentException("Negative offset: " + offset);
-
-    if ((text.length() > 0) && (offset > 0))
-      throw new IllegalArgumentException("Offset too large: " + offset);
-    else if (offset > (text.length() - 1))
-      throw new IllegalArgumentException("Offset too large: " + offset);
-
-    textIndex = 0;
-    for (int i=0;i<text_decomposition.length;i++)
-      {
-	RuleBasedCollator.CollationElement e =
-	  (RuleBasedCollator.CollationElement) text_decomposition[i];
-	int idx = textIndex + e.key.length();
-	
-	if (idx > offset)
-	  break;
-	textIndex = idx;
-      }
-  }
-
-  /**
-   * This method returns the maximum length of any expansion sequence that
-   * ends with the specified collation order value.  (Whatever that means).
-   *
-   * @param value The collation order value
-   *
-   * @param The maximum length of an expansion sequence.
-   */
-  public int getMaxExpansion(int value)
-  {
-    return 1;
-  }
 }
