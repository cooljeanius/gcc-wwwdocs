--- /home/tromey/gnu/classpath/classpath/gnu/java/rmi/server/UnicastConnectionManager.java	Thu Oct 31 12:43:09 2002
+++ gnu/java/rmi/server/UnicastConnectionManager.java	Mon Sep 30 16:13:22 2002
@@ -1,5 +1,5 @@
 /*
-  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
+  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -41,25 +41,18 @@
 import java.rmi.server.RMIServerSocketFactory;
 import java.rmi.server.RMIClientSocketFactory;
 import java.rmi.RemoteException;
+import gnu.java.rmi.server.UnicastConnection;
+import java.util.Hashtable;
+import java.net.Socket;
+import java.net.ServerSocket;
 import java.io.IOException;
 import java.io.ObjectOutput;
 import java.io.ObjectInput;
-import java.io.DataInputStream;
 import java.lang.Thread;
 import java.lang.Runnable;
 import java.net.InetAddress;
-import java.net.Socket;
-import java.net.ServerSocket;
 import java.net.UnknownHostException;
 
-import java.util.ArrayList;
-import java.util.ConcurrentModificationException;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Iterator;
-
-import gnu.java.rmi.server.UnicastConnection;
-
 public class UnicastConnectionManager
 	implements Runnable, ProtocolConstants {
 
@@ -67,33 +60,15 @@
 // use different maps for server/client type UnicastConnectionManager
 private static Hashtable servers = new Hashtable();
 private static Hashtable clients = new Hashtable();
-private ArrayList connections; //client connection pool
 
 // make serverThread volatile for poll
 private volatile Thread serverThread;
 private ServerSocket ssock;
 String serverName;
 int serverPort;
-
-static private Thread scavenger;
-
-// If client and server are in the same VM, serverobj represents server
-Object serverobj;
-
-private static RMISocketFactory defaultSocketFactory = RMISocketFactory.getSocketFactory();
 private RMIServerSocketFactory serverFactory;
 private RMIClientSocketFactory clientFactory;
 
-// The following is for debug
-private static int ncsock = 0;    //count of client socket
-private static int nssock = 0;    //count of server socket
-private static int ncmanager = 0; //count of client manager
-private static int nsmanager = 0; //count of server manager
-
-private static final boolean debug = false;
-
-private static final Object GLOBAL_LOCK = new Object();
-
 static {
         try {
                 //Use host address instead of host name to avoid name resolving issues
@@ -103,73 +78,16 @@
         catch (UnknownHostException _) {
                 localhost = "localhost";
         }
-        
-        
-}
-
-//Only one scavenger thread running globally
-private static void startScavenger(){
-    scavenger = new Thread(new Runnable(){
-        public void run(){
-            if (debug) System.out.println("************* start scavenger.");
-            boolean liveon = true;
-            while (liveon){
-                // Sleep for the expire timeout
-                try{
-                    Thread.sleep(UnicastConnection.CONNECTION_TIMEOUT);
-                }catch(InterruptedException _ie){
-                    break;
-                }
-                liveon = false;
-                // Scavenge all clients' connections that're expired
-                Iterator iter = clients.values().iterator();
-                long l = System.currentTimeMillis();
-                try{
-                    while(iter.hasNext()){
-                        UnicastConnectionManager man = (UnicastConnectionManager)iter.next();
-                        ArrayList conns = man.connections;
-                        synchronized(conns) { // is the lock a little coarser?
-                            for (int last = conns.size() - 1;
-                                 last >= 0;
-                                 --last)
-                            {
-                                UnicastConnection conn = (UnicastConnection)conns.get(last);
-                                if (UnicastConnection.isExpired(conn, l)){
-                                    conns.remove(last);
-                                    conn.disconnect();
-                                    conn = null;   
-                                }else
-                                    liveon = true; //there're still live connections
-                            }
-                        }
-                    }
-                }catch(ConcurrentModificationException cme) {
-                    // handle it lazily
-                    liveon = true;
-                }
-            }
-            scavenger = null;
-            if (debug) System.out.println("************* exit scavenger.");
-        }
-    });
-    scavenger.start();
 }
 
-/**
-  * Client UnicastConnectionManager constructor
-  */
 private UnicastConnectionManager(String host, int port, RMIClientSocketFactory csf) {
 	ssock = null;
 	serverName = host;
 	serverPort = port;
 	serverFactory = null;
 	clientFactory = csf;
-    connections = new ArrayList();
 }
 
-/**
-  * Server UnicastConnectionManager constructor
-  */
 private UnicastConnectionManager(int port, RMIServerSocketFactory ssf) {
 	try {
 		ssock = ssf.createServerSocket(port);
@@ -197,7 +115,7 @@
 public static synchronized UnicastConnectionManager getInstance(String host, int port, RMIClientSocketFactory csf) {
 //System.out.println("getInstance: " + host + "," + port + "," + csf);
 	if (csf == null) {
-        csf = defaultSocketFactory;
+		csf = RMISocketFactory.getSocketFactory();
 	}
 	// change host name to host address to avoid name resolving issues
 	try{
@@ -208,17 +126,7 @@
 	UnicastConnectionManager man = (UnicastConnectionManager)clients.get(key);
 	if (man == null) {
 		man = new UnicastConnectionManager(host, port, csf);
-        if (debug) {
-            ncmanager++;
-            System.out.println("\n\n ====== " + ncmanager + " client managers.\n\n");
-        }
 		clients.put(key, man);
-        
-        // Detect if client and server are in the same VM, i.e., their keys are equal
-        UnicastConnectionManager svrman = (UnicastConnectionManager)servers.get(key);
-        if(svrman != null){ // server and client are in the same VM
-            man.serverobj = svrman.serverobj;
-        }
 	}
 	return (man);
 }
@@ -230,16 +138,12 @@
 public static synchronized UnicastConnectionManager getInstance(int port, RMIServerSocketFactory ssf) {
 //System.out.println("getInstance: " + port + "," + ssf);
 	if (ssf == null) {
-        ssf = defaultSocketFactory;
+		ssf = RMISocketFactory.getSocketFactory();
 	}
 	TripleKey key = new TripleKey(localhost, port, ssf);
 	UnicastConnectionManager man = (UnicastConnectionManager)servers.get(key);
 	if (man == null) {
 		man = new UnicastConnectionManager(port, ssf);
-        if (debug) {
-            nsmanager++;
-            System.out.println("\n\n ****** " + nsmanager + " server managers.\n\n");
-        }
 		// The provided port might not be the set port.
 		key.port = man.serverPort;
 		servers.put(key, man);
@@ -264,14 +168,9 @@
  */
 private UnicastConnection getServerConnection() throws IOException {
 	Socket sock = ssock.accept();
-    sock.setTcpNoDelay(true); //??
 	UnicastConnection conn = new UnicastConnection(this, sock);
 	conn.acceptConnection();
-    if (debug){
-        nssock++;
-        System.out.println("\n\n ****** " + nssock + " server socks.\n\n");
-    }
-    //System.out.println("Server connection " + sock);
+//System.out.println("Server connection " + conn);
 	return (conn);
 }
 
@@ -279,38 +178,10 @@
  * Make a conection from this client to the server.
  */
 private UnicastConnection getClientConnection() throws IOException {
-    ArrayList conns = connections;
-    UnicastConnection conn;
-    
-    synchronized(conns) {
-        int nconn = conns.size() - 1;
-    
-        // if there're free connections in connection pool
-        if(nconn >= 0) {
-            conn = (UnicastConnection)conns.get(nconn);
-            //Should we check if conn is alive using Ping??
-            conns.remove(nconn);
-            
-            // Check if the connection is already expired
-            long l = System.currentTimeMillis();
-            if (!UnicastConnection.isExpired(conn, l)){
-                return conn;
-            }else {
-                conn.disconnect();
-                conn = null;   
-            }
-        }
-    }
-    
 	Socket sock = clientFactory.createSocket(serverName, serverPort);
-    conn = new UnicastConnection(this, sock);
+	UnicastConnection conn = new UnicastConnection(this, sock);
 	conn.makeConnection(DEFAULT_PROTOCOL);
-    
-    if (debug) {
-        ncsock++;
-        System.out.println("\n\n ====== " + ncsock + " client socks.\n\n");
-    }
-
+//System.out.println("Client connection " + conn);
 	return (conn);
 }
 
@@ -320,19 +191,7 @@
  */
 public void discardConnection(UnicastConnection conn) {
 //System.out.println("Discarding connection " + conn);
-    //conn.disconnect();
-    if (ssock != null) //server connection
 	conn.disconnect();
-    else {
-        // To client connection, we'd like to return back to pool
-        UnicastConnection.resetTime(conn);
-        //Ensure there're only one scavenger globally
-        synchronized(GLOBAL_LOCK) {
-            connections.add(conn); //borrow this lock to garantee thread safety 
-            if (scavenger == null)
-                startScavenger();
-        }
-    }
 }
 
 /**
@@ -345,8 +204,6 @@
 			return;
 		}
 		serverThread = new Thread(this);
-        // The following is not necessary when java.lang.Thread's constructor do this.
-        // serverThread.setContextClassLoader(Thread.currentThread().getContextClassLoader());
 	}
 	serverThread.start();
 }
@@ -374,11 +231,11 @@
 //System.out.println("Waiting for connection on " + serverPort);
 			UnicastConnection conn = getServerConnection();
 			// use a thread pool to improve performance
-            //ConnectionRunnerPool.dispatchConnection(conn);
-            (new Thread(conn)).start();
+			// (new Thread(conn)).start();
+			ConnectionRunnerPool.dispatchConnection(conn);
 		}
 		catch (Exception e) {
-            e.printStackTrace();
+			// e.printStackTrace();
 		}
 	}
 }
@@ -397,9 +254,8 @@
 static UnicastConnectionManager read(ObjectInput in) throws IOException {
         String host = in.readUTF();
         int port = in.readInt();
-        //RMIClientSocketFactory csf = ((RMIObjectInputStream)in).manager.clientFactory;
-        //return (getInstance(host, port, csf));
-        return (getInstance(host, port, null));
+	RMIClientSocketFactory csf = ((RMIObjectInputStream)in).manager.clientFactory;
+        return (getInstance(host, port, csf));
 }
 
 }
@@ -432,7 +288,7 @@
 		TripleKey other = (TripleKey)obj;
 		if (this.host.equals(other.host) &&
 		    this.other == other.other &&
-            (this.port == other.port /* || this.port == 0 || other.port == 0*/)) {
+		    (this.port == other.port || this.port == 0 || other.port == 0)) {
 			return (true);
 		}
 	}
