--- /home/tromey/gnu/egcs/classpath/classpath/java/lang/Byte.java	Sat Mar  2 12:13:10 2002
+++ java/lang/Byte.java	Tue Jan 22 16:01:33 2002
@@ -1,5 +1,5 @@
 /* Byte.java -- object wrapper for byte
-   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -48,310 +48,267 @@
  * @author Paul Fisher
  * @author John Keiser
  * @author Per Bothner
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.1
- * @status updated to 1.4
+ * @since JDK 1.0
  */
-public final class Byte extends Number implements Comparable
+public final class Byte extends Number implements Comparable 
 {
-  /**
-   * Compatible with JDK 1.1+.
-   */
-  private static final long serialVersionUID = -7183698231559129828L;
+  static final long serialVersionUID = -7183698231559129828L;
 
   /**
-   * The minimum value a <code>byte</code> can represent is -128 (or
-   * -2<sup>7</sup>).
+   * The minimum value a <code>byte</code> can represent is -128.
    */
   public static final byte MIN_VALUE = -128;
 
   /**
-   * The maximum value a <code>byte</code> can represent is 127 (or
-   * 2<sup>7</sup> - 1).
+   * The maximum value a <code>byte</code> can represent is 127.
    */
   public static final byte MAX_VALUE = 127;
 
   /**
-   * The primitive type <code>byte</code> is represented by this
+   * The primitive type <code>byte</code> is represented by this 
    * <code>Class</code> object.
    */
   public static final Class TYPE = VMClassLoader.getPrimitiveClass('B');
 
   /**
    * The immutable value of this Byte.
-   *
-   * @serial the wrapped byte
    */
   private final byte value;
 
   /**
-   * Create a <code>Byte</code> object representing the value of the
+   * Create a <code>Byte</code> object representing the value of the 
    * <code>byte</code> argument.
    *
    * @param value the value to use
-   */
-  public Byte(byte value)
+   */     
+  public Byte(byte value) 
   {
     this.value = value;
   }
 
   /**
-   * Create a <code>Byte</code> object representing the value specified
-   * by the <code>String</code> argument
+   * Create a <code>Byte</code> object representing the value specified 
+   * by the <code>String</code> argument.
    *
-   * @param s the string to convert
-   * @throws NumberFormatException if the String does not contain a byte
-   * @see #valueOf(String)
+   * @param s the string to convert.
    */
-  public Byte(String s)
+  public Byte(String s) throws NumberFormatException 
   {
     value = parseByte(s, 10);
   }
 
   /**
-   * Converts the <code>byte</code> to a <code>String</code> and assumes
-   * a radix of 10.
+   * Return a hashcode representing this Object.
+   *
+   * <code>Byte</code>'s hash code is calculated by simply returning its
+   * value.
    *
-   * @param b the <code>byte</code> to convert to <code>String</code>
-   * @return the <code>String</code> representation of the argument
+   * @return this Object's hash code.
    */
-  public static String toString(byte b)
+  public int hashCode() 
   {
-    return String.valueOf(b);
+    return value;
   }
 
   /**
-   * Converts the specified <code>String</code> into a <code>byte</code>.
-   * This function assumes a radix of 10.
-   *
-   * @param s the <code>String</code> to convert
-   * @return the <code>byte</code> value of <code>s</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>byte</code>
-   * @see #parseByte(String)
-   */
-  public static byte parseByte(String s)
+   * Returns <code>true</code> if <code>obj</code> is an instance of
+   * <code>Byte</code> and represents the same byte value.
+   * @return whether these Objects are semantically equal.
+   */    
+  public boolean equals(Object obj) 
   {
-    return parseByte(s, 10);
+    return ((obj instanceof Byte) && (value == ((Byte)obj).byteValue()));
   }
 
   /**
-   * Converts the specified <code>String</code> into an <code>int</code>
-   * using the specified radix (base). The string must not be <code>null</code>
-   * or empty. It may begin with an optional '-', which will negate the answer,
-   * provided that there are also valid digits. Each digit is parsed as if by
-   * <code>Character.digit(d, radix)</code>, and must be in the range
-   * <code>0</code> to <code>radix - 1</code>. Finally, the result must be
-   * within <code>MIN_VALUE</code> to <code>MAX_VALUE</code>, inclusive.
-   * Unlike Double.parseDouble, you may not have a leading '+'.
-   *
-   * @param s the <code>String</code> to convert
-   * @param radix the radix (base) to use in the conversion
-   * @return the <code>String</code> argument converted to </code>byte</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>byte</code>
+   * Converts the <code>byte</code> to a <code>String</code> and assumes
+   * a radix of 10.
+   * @param i the <code>byte</code> to convert to <code>String</code>
+   * @return the <code>String</code> representation of the argument.
+   */    
+  public static String toString(byte i) 
+  {
+    return Integer.toString ((int) i);
+  }
+
+  /**
+   * Converts the <code>Byte</code> value to a <code>String</code> and
+   * assumes a radix of 10.
+   * @return the <code>String</code> representation of this <code>Byte</code>.
+   */    
+  public String toString() 
+  {
+    return Integer.toString ((int) value);
+  }
+    
+  /**
+   * Creates a new <code>Byte</code> object using the <code>String</code>,
+   * assuming a radix of 10.
+   * @param s the <code>String</code> to convert.
+   * @return the new <code>Byte</code>.
+   * @see #Byte(java.lang.String)
+   * @see #parseByte(java.lang.String)
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>byte</code>.
    */
-  public static byte parseByte(String s, int radix)
+  public static Byte valueOf(String s) throws NumberFormatException 
   {
-    int i = Integer.parseInt(s, radix, false);
-    if ((byte) i != i)
-      throw new NumberFormatException();
-    return (byte) i;
+    return new Byte(parseByte(s));
   }
 
   /**
    * Creates a new <code>Byte</code> object using the <code>String</code>
    * and specified radix (base).
-   *
-   * @param s the <code>String</code> to convert
-   * @param radix the radix (base) to convert with
-   * @return the new <code>Byte</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>byte</code>
-   * @see #parseByte(String, int)
+   * @param s the <code>String</code> to convert.
+   * @param radix the radix (base) to convert with.
+   * @return the new <code>Byte</code>.
+   * @see #parseByte(java.lang.String,int)
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>byte</code>.
    */
-  public static Byte valueOf(String s, int radix)
+  public static Byte valueOf(String s, int radix) 
+    throws NumberFormatException 
   {
     return new Byte(parseByte(s, radix));
   }
 
   /**
-   * Creates a new <code>Byte</code> object using the <code>String</code>,
-   * assuming a radix of 10.
+   * Converts the specified <code>String</code> into a <code>byte</code>.
+   * This function assumes a radix of 10.
    *
    * @param s the <code>String</code> to convert
-   * @return the new <code>Byte</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>byte</code>
-   * @see #Byte(String)
-   * @see #parseByte(String)
+   * @return the <code>byte</code> value of the <code>String</code>
+   *         argument.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>byte</code>.
    */
-  public static Byte valueOf(String s)
+  public static byte parseByte(String s) throws NumberFormatException 
   {
-    return new Byte(parseByte(s, 10));
+    return parseByte(s, 10);
   }
 
   /**
-   * Convert the specified <code>String</code> into a <code>Byte</code>.
-   * The <code>String</code> may represent decimal, hexadecimal, or
-   * octal numbers.
-   *
-   * <p>The extended BNF grammar is as follows:<br>
-   * <pre>
-   * <em>DecodableString</em>:
-   *      ( [ <code>-</code> ] <em>DecimalNumber</em> )
-   *    | ( [ <code>-</code> ] ( <code>0x</code> | <code>0X</code>
-   *              | <code>#</code> ) { <em>HexDigit</em> }+ )
-   *    | ( [ <code>-</code> ] <code>0</code> { <em>OctalDigit</em> } )
-   * <em>DecimalNumber</em>:
-   *        <em>DecimalDigit except '0'</em> { <em>DecimalDigit</em> }
-   * <em>DecimalDigit</em>:
-   *        <em>Character.digit(d, 10) has value 0 to 9</em>
-   * <em>OctalDigit</em>:
-   *        <em>Character.digit(d, 8) has value 0 to 7</em>
-   * <em>DecimalDigit</em>:
-   *        <em>Character.digit(d, 16) has value 0 to 15</em>
-   * </pre>
-   * Finally, the value must be in the range <code>MIN_VALUE</code> to
-   * <code>MAX_VALUE</code>, or an exception is thrown.
+   * Converts the specified <code>String</code> into a <code>byte</code>
+   * using the specified radix (base).
    *
-   * @param s the <code>String</code> to interpret
-   * @return the value of the String as a <code>Byte</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>byte</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @see Integer#decode(String)
+   * @param str the <code>String</code> to convert
+   * @param radix the radix (base) to use in the conversion
+   * @return the <code>String</code> argument converted to </code>byte</code>.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>byte</code>.    
    */
-  public static Byte decode(String s)
+  public static byte parseByte(String str, int radix) 
+    throws NumberFormatException 
   {
-    int i = Integer.parseInt(s, 10, true);
-    if ((byte) i != i)
+    int i = Integer.parseInt(str, radix);
+    if (i < MIN_VALUE || i > MAX_VALUE)
       throw new NumberFormatException();
-    return new Byte((byte) i);
+    return (byte) i;
   }
 
   /**
-   * Return the value of this <code>Byte</code>.
+   * Convert the specified <code>String</code> into a <code>Byte</code>.
+   * The <code>String</code> may represent decimal, hexadecimal, or 
+   * octal numbers.
    *
-   * @return the byte value
+   * The <code>String</code> argument is interpreted based on the leading
+   * characters.  Depending on what the String begins with, the base will be
+   * interpreted differently:
+   *
+   * <table>
+   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>
+   * <tr><td>#</td><td>16</td></tr>
+   * <tr><td>0x</td><td>16</td></tr>
+   * <tr><td>0X</td><td>16</td></tr>
+   * <tr><td>0</td><td>8</td></tr>
+   * <tr><td>Anything<br>Else</td><td>10</td></tr>
+   * </table>
+   *
+   * @param str the <code>String</code> to interpret.
+   * @return the value of the String as a <code>Byte</code>.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>byte</code>.    
    */
+  public static Byte decode(String str) throws NumberFormatException 
+  {
+    int i = (Integer.decode(str)).intValue();
+    if (i < MIN_VALUE || i > MAX_VALUE)
+      throw new NumberFormatException();
+    return new Byte((byte) i);
+  }
+    
+  /** Return the value of this <code>Byte</code> as an <code>short</code>.
+   ** @return the value of this <code>Byte</code> as an <code>short</code>.
+   **/
   public byte byteValue()
   {
     return value;
   }
 
-  /**
-   * Return the value of this <code>Byte</code> as a <code>short</code>.
-   *
-   * @return the short value
-   */
+  /** Return the value of this <code>Byte</code> as an <code>short</code>.
+   ** @return the value of this <code>Byte</code> as an <code>short</code>.
+   **/
   public short shortValue()
   {
     return value;
   }
 
-  /**
-   * Return the value of this <code>Byte</code> as an <code>int</code>.
-   *
-   * @return the int value
-   */
+  /** Return the value of this <code>Byte</code> as an <code>int</code>.
+   ** @return the value of this <code>Byte</code> as an <code>int</code>.
+   **/
   public int intValue()
   {
     return value;
   }
 
-  /**
-   * Return the value of this <code>Byte</code> as a <code>long</code>.
-   *
-   * @return the long value
-   */
+  /** Return the value of this <code>Byte</code> as a <code>long</code>.
+   ** @return the value of this <code>Byte</code> as a <code>long</code>.
+   **/
   public long longValue()
   {
     return value;
   }
 
-  /**
-   * Return the value of this <code>Byte</code> as a <code>float</code>.
-   *
-   * @return the float value
-   */
+  /** Return the value of this <code>Byte</code> as a <code>float</code>.
+   ** @return the value of this <code>Byte</code> as a <code>float</code>.
+   **/
   public float floatValue()
   {
     return value;
   }
 
-  /**
-   * Return the value of this <code>Byte</code> as a <code>double</code>.
-   *
-   * @return the double value
-   */
+  /** Return the value of this <code>Byte</code> as a <code>double</code>.
+   ** @return the value of this <code>Byte</code> as a <code>double</code>.
+   **/
   public double doubleValue()
   {
     return value;
   }
-
-  /**
-   * Converts the <code>Byte</code> value to a <code>String</code> and
-   * assumes a radix of 10.
-   *
-   * @return the <code>String</code> representation of this <code>Byte</code>
-   * @see Integer#toString()
-   */
-  public String toString()
-  {
-    return String.valueOf(value);
-  }
-
-  /**
-   * Return a hashcode representing this Object. <code>Byte</code>'s hash
-   * code is simply its value.
-   *
-   * @return this Object's hash code
-   */
-  public int hashCode()
-  {
-    return value;
-  }
-
-  /**
-   * Returns <code>true</code> if <code>obj</code> is an instance of
-   * <code>Byte</code> and represents the same byte value.
-   *
-   * @param obj the object to compare
-   * @return whether these Objects are semantically equal
-   */
-  public boolean equals(Object obj)
-  {
-    return obj instanceof Byte && value == ((Byte) obj).value;
-  }
-
+    
   /**
-   * Compare two Bytes numerically by comparing their <code>byte</code> values.
-   * The result is positive if the first is greater, negative if the second
-   * is greater, and 0 if the two are equal.
-   *
-   * @param b the Byte to compare
-   * @return the comparison
-   * @since 1.2
+   * Compare two Bytes numerically by comparing their
+   * <code>byte</code> values.
+   * @return a positive value if this <code>Byte</code> is greater
+   * in value than the argument <code>Byte</code>; a negative value
+   * if this <code>Byte</code> is smaller in value than the argument
+   * <code>Byte</code>; and <code>0</code>, zero, if this
+   * <code>Byte</code> is equal in value to the argument
+   * <code>Byte</code>.  
    */
   public int compareTo(Byte b)
   {
-    return value - b.value;
+    return (int)(value - b.byteValue());
   }
-
+    
   /**
-   * Behaves like <code>compareTo(Byte)</code> unless the Object
-   * is not a <code>Byte</code>.
-   *
-   * @param o the object to compare
-   * @return the comparison
-   * @throws ClassCastException if the argument is not a <code>Byte</code>
-   * @see #compareTo(Byte)
-   * @see Comparable
-   * @since 1.2
+   * Behaves like <code>compareTo(java.lang.Byte)</code> unless the Object
+   * is not a <code>Byte</code>.  Then it throws a 
+   * <code>ClassCastException</code>.
+   * @exception ClassCastException if the argument is not a
+   * <code>Byte</code>.  
    */
   public int compareTo(Object o)
   {
-    return compareTo((Byte) o);
+    return compareTo((Byte)o);
   }
 }
