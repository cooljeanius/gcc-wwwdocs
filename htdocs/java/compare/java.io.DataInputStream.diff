--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/DataInputStream.java	2003-04-08 02:23:45.000000000 -0600
+++ java/io/DataInputStream.java	2003-03-24 02:17:53.000000000 -0700
@@ -129,16 +129,10 @@
    * @exception EOFException If end of file is reached before reading
    * the boolean
    * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeBoolean
    */
   public final boolean readBoolean() throws IOException
   {
-    int b = in.read();
-    if (b < 0)
-      throw new EOFException();
-    else
-      return(b != 0);
+    return convertToBoolean(in.read());
   }
 
   /**
@@ -154,38 +148,11 @@
    * @exception EOFException If end of file is reached before reading the byte
    * @exception IOException If any other error occurs
    *
-   * @see DataOutput#writeByte
+   * @see DataOutput
    */
   public final byte readByte() throws IOException
   {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (byte) i;
-  }
-
-  /**
-   * This method reads 8 unsigned bits into a Java <code>int</code>
-   * value from the stream. The value returned is in the range of 0 to
-   * 255.
-   * <p>
-   * This method can read an unsigned byte written by an object
-   * implementing the <code>writeByte()</code> method in the
-   * <code>DataOutput</code> interface.
-   *
-   * @return The unsigned bytes value read as a Java <code>int</code>.
-   *
-   * @exception EOFException If end of file is reached before reading the value
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeByte
-   */
-  public final int readUnsignedByte() throws IOException
-  {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (i & 0xFF);
+    return convertToByte(in.read());
   }
 
   /**
@@ -211,156 +178,12 @@
    * @exception EOFException If end of file is reached before reading the char
    * @exception IOException If any other error occurs
    *
-   * @see DataOutput#writeChar
-   */
-  public synchronized final char readChar() throws IOException
-  {
-    readFully (buf, 0, 2);
-    return (char) ((buf[0] << 8) | (buf[1] & 0xff));
-  }
-
-  /**
-   * This method reads a signed 16-bit value into a Java in from the
-   * stream.  It operates by reading two bytes from the stream and
-   * converting them to a single 16-bit Java <code>short</code>.  The
-   * two bytes are stored most significant byte first (i.e., "big
-   * endian") regardless of the native host byte ordering.
-   * <p>
-   * As an example, if <code>byte1</code> and <code>byte2</code>
-   * represent the first and second byte read from the stream
-   * respectively, they will be transformed to a <code>short</code>. in
-   * the following manner:
-   * <p>
-   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF))</code>
-   * <p>
-   * The value returned is in the range of -32768 to 32767.
-   * <p>
-   * This method can read a <code>short</code> written by an object
-   * implementing the <code>writeShort()</code> method in the
-   * <code>DataOutput</code> interface.
-   *
-   * @return The <code>short</code> value read
-   *
-   * @exception EOFException If end of file is reached before reading the value
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeShort
+   * @see DataOutput
    */
-  public synchronized final short readShort() throws IOException
+  public final char readChar() throws IOException
   {
     readFully (buf, 0, 2);
-    return (short) ((buf[0] << 8) | (buf[1] & 0xff));
-  }
-
-  /**
-   * This method reads 16 unsigned bits into a Java int value from the stream.
-   * It operates by reading two bytes from the stream and converting them to 
-   * a single Java <code>int</code>  The two bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering. 
-   * <p>
-   * As an example, if <code>byte1</code> and <code>byte2</code>
-   * represent the first and second byte read from the stream
-   * respectively, they will be transformed to an <code>int</code> in
-   * the following manner:
-   * <p>
-   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>
-   * <p>
-   * The value returned is in the range of 0 to 65535.
-   * <p>
-   * This method can read an unsigned short written by an object
-   * implementing the <code>writeShort()</code> method in the
-   * <code>DataOutput</code> interface.
-   *
-   * @return The unsigned short value read as a Java <code>int</code>
-   *
-   * @exception EOFException If end of file is reached before reading the value
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeShort
-   */
-  public final synchronized int readUnsignedShort() throws IOException
-  {
-    readFully (buf, 0, 2);
-    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));
-  }
-
-  /**
-   * This method reads a Java <code>int</code> value from an input stream
-   * It operates by reading four bytes from the stream and converting them to
-   * a single Java <code>int</code>.  The bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering.
-   * <p>
-   * As an example, if <code>byte1</code> through <code>byte4</code> represent
-   * the first four bytes read from the stream, they will be
-   * transformed to an <code>int</code> in the following manner:
-   * <p>
-   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) +
-   * ((byte3 & 0xFF)<< 8) + (byte4 & 0xFF)))</code>
-   * <p>
-   * The value returned is in the range of -2147483648 to 2147483647.
-   * <p>
-   * This method can read an <code>int</code> written by an object
-   * implementing the <code>writeInt()</code> method in the
-   * <code>DataOutput</code> interface.
-   *
-   * @return The <code>int</code> value read
-   *
-   * @exception EOFException If end of file is reached before reading the int
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeInt
-   */
-  public synchronized final int readInt() throws IOException
-  {
-    readFully (buf, 0, 4);
-    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
-            ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));
-  }
-
-  /**
-   * This method reads a Java <code>long</code> value from an input stream
-   * It operates by reading eight bytes from the stream and converting them to
-   * a single Java <code>long</code>.  The bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering.
-   * <p>
-   * As an example, if <code>byte1</code> through <code>byte8</code> represent
-   * the first eight bytes read from the stream, they will be
-   * transformed to an <code>long</code> in the following manner:
-   * <p>
-   * <code>(long)(((byte1 & 0xFF) << 56) + ((byte2 & 0xFF) << 48) +
-   * ((byte3 & 0xFF) << 40) + ((byte4 & 0xFF) << 32) +
-   * ((byte5 & 0xFF) << 24) + ((byte6 & 0xFF) << 16) +
-   * ((byte7 & 0xFF) << 8) + (byte8 & 0xFF)))
-   * </code>
-   * <p>
-   * The value returned is in the range of -9223372036854775808 to
-   * 9223372036854775807.
-   * <p>
-   * This method can read an <code>long</code> written by an object
-   * implementing the <code>writeLong()</code> method in the
-   * <code>DataOutput</code> interface.
-   *
-   * @return The <code>long</code> value read
-   *
-   * @exception EOFException If end of file is reached before reading the long
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput#writeLong
-   */
-  public synchronized final long readLong() throws IOException
-  {
-    readFully (buf, 0, 8);
-    return (((long)(buf[0] & 0xff) << 56) |
-            ((long)(buf[1] & 0xff) << 48) |
-            ((long)(buf[2] & 0xff) << 40) |
-            ((long)(buf[3] & 0xff) << 32) |
-            ((long)(buf[4] & 0xff) << 24) |
-            ((long)(buf[5] & 0xff) << 16) |
-            ((long)(buf[6] & 0xff) <<  8) |
-            ((long)(buf[7] & 0xff)));
+    return convertToChar(buf);
   }
 
   /**
@@ -381,8 +204,8 @@
    * the double
    * @exception IOException If any other error occurs
    *
-   * @see DataOutput#writeDouble
-   * @see java.lang.Double#longBitsToDouble
+   * @see java.lang.Double
+   * @see DataOutput
    */
   public final double readDouble() throws IOException
   {
@@ -398,7 +221,7 @@
    * in the class <code>java.lang.Float</code>
    * <p>
    * This method can read a <code>float</code> written by an object
-   * implementing the <code>writeFloat()</code> method in the
+   * implementing the * <code>writeFloat()</code> method in the
    * <code>DataOutput</code> interface.
    *
    * @return The <code>float</code> value read
@@ -406,9 +229,8 @@
    * @exception EOFException If end of file is reached before reading the float
    * @exception IOException If any other error occurs
    *
-   * @see DataOutput#writeFloat 
-   * @see java.lang.Float#intBitsToFloat
-   */
+   * @see java.lang.Float
+   * @see DataOutput */
   public final float readFloat() throws IOException
   {
     return Float.intBitsToFloat(readInt());
@@ -418,38 +240,32 @@
    * This method reads raw bytes into the passed array until the array is
    * full.  Note that this method blocks until the data is available and
    * throws an exception if there is not enough data left in the stream to
-   * fill the buffer.  Note also that zero length buffers are permitted.
-   * In this case, the method will return immediately without reading any
-   * bytes from the stream.
+   * fill the buffer
    *
-   * @param buf The buffer into which to read the data
+   * @param b The buffer into which to read the data
    *
-   * @exception EOFException If end of file is reached before filling the
-   * buffer
-   * @exception IOException If any other error occurs
-   */
+   * @exception EOFException If end of file is reached before filling
+   * the buffer
+   * @exception IOException If any other error occurs */
   public final void readFully(byte[] b) throws IOException
   {
     readFully(b, 0, b.length);
   }
 
   /**
-   * This method reads raw bytes into the passed array <code>buf</code>
-   * starting
-   * <code>offset</code> bytes into the buffer.  The number of bytes read
-   * will be
-   * exactly <code>len</code>.  Note that this method blocks until the data is
-   * available and throws an exception if there is not enough data left in
-   * the stream to read <code>len</code> bytes.  Note also that zero length
-   * buffers are permitted.  In this case, the method will return immediately
-   * without reading any bytes from the stream.
+   * This method reads raw bytes into the passed array
+   * <code>buf</code> starting <code>offset</code> bytes into the
+   * buffer.  The number of bytes read will be exactly
+   * <code>len</code> Note that this method blocks until the data is
+   * available and * throws an exception if there is not enough data
+   * left in the stream to read <code>len</code> bytes.
    *
    * @param buf The buffer into which to read the data
    * @param offset The offset into the buffer to start storing data
    * @param len The number of bytes to read into the buffer
    *
-   * @exception EOFException If end of file is reached before filling the
-   * buffer
+   * @exception EOFException If end of file is reached before filling
+   * the buffer
    * @exception IOException If any other error occurs
    */
   public final void readFully(byte[] b, int off, int len) throws IOException
@@ -466,6 +282,39 @@
   }
 
   /**
+   * This method reads a Java <code>int</code> value from an input
+   * stream It operates by reading four bytes from the stream and
+   * converting them to a single Java <code>int</code> The bytes are
+   * stored most significant byte first (i.e., "big endian")
+   * regardless of the native host byte ordering.
+   * <p>
+   * As an example, if <code>byte1</code> through <code>byte4</code>
+   * represent the first four bytes read from the stream, they will be
+   * transformed to an <code>int</code> in the following manner:
+   * <p>
+   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + 
+   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>
+   * <p>
+   * The value returned is in the range of 0 to 65535.
+   * <p>
+   * This method can read an <code>int</code> written by an object
+   * implementing the <code>writeInt()</code> method in the
+   * <code>DataOutput</code> interface.
+   *
+   * @return The <code>int</code> value read
+   *
+   * @exception EOFException If end of file is reached before reading the int
+   * @exception IOException If any other error occurs
+   *
+   * @see DataOutput
+   */
+  public final int readInt() throws IOException
+  {
+    readFully (buf, 0, 4);
+    return convertToInt(buf);
+  }
+
+  /**
    * This method reads the next line of text data from an input
    * stream.  It operates by reading bytes and converting those bytes
    * to <code>char</code> values by treating the byte read as the low
@@ -480,11 +329,15 @@
    * <code>\r\n</code>.  These termination charaters are discarded and
    * are not returned as part of the string.
    * <p>
+   * This method can read data that was written by an object implementing the
+   * <code>writeLine()</code> method in <code>DataOutput</code>.
    *
    * @return The line read as a <code>String</code>
    *
    * @exception IOException If an error occurs
    *
+   * @see DataOutput
+   *
    * @deprecated
    */
   public final String readLine() throws IOException
@@ -575,6 +428,126 @@
   }
 
   /**
+   * This method reads a Java long value from an input stream
+   * It operates by reading eight bytes from the stream and converting them to 
+   * a single Java <code>long</code>  The bytes are stored most
+   * significant byte first (i.e., "big endian") regardless of the native
+   * host byte ordering. 
+   * <p>
+   * As an example, if <code>byte1</code> through <code>byte8</code>
+   * represent the first eight bytes read from the stream, they will
+   * be transformed to an <code>long</code> in the following manner:
+   * <p>
+   * <code>(long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + 
+   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + 
+   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + 
+   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>
+   * <p>
+   * The value returned is in the range of 0 to 65535.
+   * <p>
+   * This method can read an <code>long</code> written by an object
+   * implementing the <code>writeLong()</code> method in the
+   * <code>DataOutput</code> interface.
+   *
+   * @return The <code>long</code> value read
+   *
+   * @exception EOFException If end of file is reached before reading the long
+   * @exception IOException If any other error occurs
+   *
+   * @see DataOutput
+   */
+  public final long readLong() throws IOException
+  {
+    readFully (buf, 0, 8);
+    return convertToLong(buf);
+  }
+
+  /**
+   * This method reads a signed 16-bit value into a Java in from the
+   * stream.  It operates by reading two bytes from the stream and
+   * converting them to a single 16-bit Java <code>short</code>.  The
+   * two bytes are stored most significant byte first (i.e., "big
+   * endian") regardless of the native host byte ordering.
+   * <p>
+   * As an example, if <code>byte1</code> and <code>byte2</code>
+   * represent the first and second byte read from the stream
+   * respectively, they will be transformed to a <code>short</code>. in
+   * the following manner:
+   * <p>
+   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>
+   * <p>
+   * The value returned is in the range of -32768 to 32767.
+   * <p>
+   * This method can read a <code>short</code> written by an object
+   * implementing the <code>writeShort()</code> method in the
+   * <code>DataOutput</code> interface.
+   *
+   * @return The <code>short</code> value read
+   *
+   * @exception EOFException If end of file is reached before reading the value
+   * @exception IOException If any other error occurs
+   *
+   * @see DataOutput
+   */
+  public final short readShort() throws IOException
+  {
+    readFully (buf, 0, 2);
+    return convertToShort(buf);
+  }
+
+  /**
+   * This method reads 8 unsigned bits into a Java <code>int</code>
+   * value from the stream. The value returned is in the range of 0 to
+   * 255.
+   * <p>
+   * This method can read an unsigned byte written by an object
+   * implementing the <code>writeUnsignedByte()</code> method in the
+   * <code>DataOutput</code> interface.
+   *
+   * @return The unsigned bytes value read as a Java <code>int</code>.
+   *
+   * @exception EOFException If end of file is reached before reading the value
+   * @exception IOException If any other error occurs
+   *
+   * @see DataOutput
+   */
+  public final int readUnsignedByte() throws IOException
+  {
+    return convertToUnsignedByte(in.read());
+  }
+
+  /**
+   * This method reads 16 unsigned bits into a Java int value from the stream.
+   * It operates by reading two bytes from the stream and converting them to 
+   * a single Java <code>int</code>  The two bytes are stored most
+   * significant byte first (i.e., "big endian") regardless of the native
+   * host byte ordering. 
+   * <p>
+   * As an example, if <code>byte1</code> and <code>byte2</code>
+   * represent the first and second byte read from the stream
+   * respectively, they will be transformed to an <code>int</code> in
+   * the following manner:
+   * <p>
+   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>
+   * <p>
+   * The value returned is in the range of 0 to 65535.
+   * <p>
+   * This method can read an unsigned short written by an object
+   * implementing the <code>writeUnsignedShort()</code> method in the
+   * <code>DataOutput</code> interface.
+   *
+   * @return The unsigned short value read as a Java <code>int</code>
+   *
+   * @exception EOFException If end of file is reached before reading the value
+   * @exception IOException If any other error occurs
+   */
+  public final int readUnsignedShort() throws IOException
+  {
+    readFully (buf, 0, 2);
+    return convertToUnsignedShort(buf);
+  }
+
+  /**
    * This method reads a <code>String</code> from an input stream that
    * is encoded in a modified UTF-8 format.  This format has a leading
    * two byte sequence that contains the remaining number of bytes to
@@ -643,24 +616,11 @@
    * @exception UTFDataFormatException If the data is not in UTF-8 format
    * @exception IOException If any other error occurs
    *
-   * @see DataOutput#writeUTF
+   * @see DataOutput
    */
   public final String readUTF() throws IOException
   {
-    int UTFlen = readUnsignedShort();
-    byte[] buf = new byte[UTFlen];
-
-    // This blocks until the entire string is available rather than
-    // doing partial processing on the bytes that are available and then
-    // blocking.  An advantage of the latter is that Exceptions
-    // could be thrown earlier.  The former is a bit cleaner.
-    readFully(buf, 0, UTFlen);
-
-    // FIXME: This should probably be replaced with something like
-    // new String(buf, "UTF-8"), however that might take a performance
-    // due to time looking up encoders.  But having a private UTF
-    // converter may not be the way to go either.
-    return (convertFromUTF(buf));
+    return readUTF(this);
   }
 
   /**
@@ -672,8 +632,6 @@
    * @return The String read from the source
    *
    * @exception IOException If an error occurs
-   *
-   * @see DataInput#readUTF
    */
   public final static String readUTF(DataInput in) throws IOException
   {
@@ -695,10 +653,8 @@
    * This method will not skip any bytes if passed a negative number of bytes 
    * to skip. 
    *
-   * @param numBytes The requested number of bytes to skip.
-   *
+   * @param n The requested number of bytes to skip.
    * @return The requested number of bytes to skip.
-   *
    * @exception IOException If an error occurs.
    * @specnote The JDK docs claim that this returns the number of bytes 
    *  actually skipped. The JCL claims that this method can throw an 
@@ -720,10 +676,60 @@
     return n;
   }
   
-  // FIXME: This method should be re-thought.  I suspect we have multiple
-  // UTF-8 decoders floating around.  We should use the standard charset
-  // converters, maybe and adding a direct call into one of the new
-  // NIO converters for a super-fast UTF8 decode.
+  static boolean convertToBoolean(int b) throws EOFException
+  {
+    if (b < 0)
+      throw new EOFException();    
+    return (b != 0);
+  }
+
+  static byte convertToByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (byte) i;
+  }
+
+  static int convertToUnsignedByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (i & 0xFF);
+  }
+
+  static char convertToChar(byte[] buf)
+  {
+    return (char) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static short convertToShort(byte[] buf)
+  {
+    return (short) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static int convertToUnsignedShort(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));  
+  }
+
+  static int convertToInt(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
+	    ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));  
+  }
+
+  static long convertToLong(byte[] buf)
+  {
+    return (((long)(buf[0] & 0xff) << 56) |
+	    ((long)(buf[1] & 0xff) << 48) |
+	    ((long)(buf[2] & 0xff) << 40) |
+	    ((long)(buf[3] & 0xff) << 32) |
+	    ((long)(buf[4] & 0xff) << 24) |
+	    ((long)(buf[5] & 0xff) << 16) |
+	    ((long)(buf[6] & 0xff) <<  8) |
+	    ((long)(buf[7] & 0xff)));  
+  }
+
   static String convertFromUTF(byte[] buf) 
     throws EOFException, UTFDataFormatException
   {
