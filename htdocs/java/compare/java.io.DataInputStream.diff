--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/DataInputStream.java	2003-05-10 02:20:34.000000000 -0600
+++ java/io/DataInputStream.java	2003-05-06 02:19:22.000000000 -0600
@@ -134,11 +134,7 @@
    */
   public final boolean readBoolean() throws IOException
   {
-    int b = in.read();
-    if (b < 0)
-      throw new EOFException();
-    else
-      return(b != 0);
+    return convertToBoolean(in.read());
   }
 
   /**
@@ -158,10 +154,7 @@
    */
   public final byte readByte() throws IOException
   {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (byte) i;
+    return convertToByte(in.read());
   }
 
   /**
@@ -189,10 +182,10 @@
    *
    * @see DataOutput#writeChar
    */
-  public synchronized final char readChar () throws IOException
+  public final char readChar() throws IOException
   {
     readFully (buf, 0, 2);
-    return (char) ((buf[0] << 8) | (buf[1] & 0xff));
+    return convertToChar(buf);
   }
 
   /**
@@ -324,13 +317,10 @@
    *
    * @see DataOutput#writeInt
    */
-  public synchronized final int readInt () throws IOException
+  public final int readInt() throws IOException
   {
     readFully (buf, 0, 4);
-    return (((buf[0] & 0xff) << 24) |
-            ((buf[1] & 0xff) << 16) |
-            ((buf[2] & 0xff) << 8) |
-            (buf[3] & 0xff));
+    return convertToInt(buf);
   }
 
   /**
@@ -477,17 +467,10 @@
    *
    * @see DataOutput#writeLong
    */
-  public synchronized final long readLong () throws IOException
+  public final long readLong() throws IOException
   {
     readFully (buf, 0, 8);
-    return (((long)(buf[0] & 0xff) << 56) |
-            ((long)(buf[1] & 0xff) << 48) |
-            ((long)(buf[2] & 0xff) << 40) |
-            ((long)(buf[3] & 0xff) << 32) |
-            ((long)(buf[4] & 0xff) << 24) |
-            ((long)(buf[5] & 0xff) << 16) |
-            ((long)(buf[6] & 0xff) <<  8) |
-            ((long)(buf[7] & 0xff)));
+    return convertToLong(buf);
   }
 
   /**
@@ -517,10 +500,10 @@
    *
    * @see DataOutput#writeShort
    */
-  public synchronized final short readShort() throws IOException
+  public final short readShort() throws IOException
   {
     readFully (buf, 0, 2);
-    return (short) ((buf[0] << 8) | (buf[1] & 0xff));
+    return convertToShort(buf);
   }
   
   /**
@@ -541,51 +524,7 @@
    */
   public final int readUnsignedByte() throws IOException
   {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (i & 0xFF);
-  }
-
-  // FIXME: This method should be re-thought.  I suspect we have multiple
-  // UTF-8 decoders floating around.  We should use the standard charset
-  // converters, maybe and adding a direct call into one of the new
-  // NIO converters for a super-fast UTF8 decode.
-  static String convertFromUTF(byte[] buf) 
-    throws EOFException, UTFDataFormatException
-  {
-    // Give StringBuffer an initial estimated size to avoid 
-    // enlarge buffer frequently
-    StringBuffer strbuf = new StringBuffer(buf.length/2 + 2);
-
-    for (int i = 0; i < buf.length; )
-      {
-	if ((buf[i] & 0x80) == 0)		// bit pattern 0xxxxxxx
-	  strbuf.append((char) (buf[i++] & 0xFF));
-	else if ((buf[i] & 0xE0) == 0xC0)	// bit pattern 110xxxxx
-	  {
-	    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)
-	      throw new UTFDataFormatException();
-
-	    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |
-				  (buf[i++] & 0x3F)));
-	  }
-	else if ((buf[i] & 0xF0) == 0xE0)	// bit pattern 1110xxxx
-	  {
-	    if (i + 2 >= buf.length ||
-		(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)
-	      throw new UTFDataFormatException();
-
-	    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |
-				  ((buf[i++] & 0x3F) << 6) |
-				  (buf[i++] & 0x3F)));
-	  }
-	else // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)
-	  throw new UTFDataFormatException();	// bit patterns 1111xxxx or
-						// 		10xxxxxx
-      }
-
-    return strbuf.toString();
+    return convertToUnsignedByte(in.read());
   }
 
   /**
@@ -615,10 +554,10 @@
    *
    * @see DataOutput#writeShort
    */
-  public final synchronized int readUnsignedShort() throws IOException
+  public final int readUnsignedShort() throws IOException
   {
     readFully (buf, 0, 2);
-    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));
+    return convertToUnsignedShort(buf);
   }
 
   /**
@@ -694,20 +633,7 @@
    */
   public final String readUTF() throws IOException
   {
-    int UTFlen = readUnsignedShort();
-    byte[] buf = new byte[UTFlen];
-
-    // This blocks until the entire string is available rather than
-    // doing partial processing on the bytes that are available and then
-    // blocking.  An advantage of the latter is that Exceptions
-    // could be thrown earlier.  The former is a bit cleaner.
-    readFully(buf, 0, UTFlen);
-
-    // FIXME: This should probably be replaced with something like
-    // new String(buf, "UTF-8"), however that might take a performance
-    // due to time looking up encoders.  But having a private UTF
-    // converter may not be the way to go either.
-    return (convertFromUTF(buf));
+    return readUTF(this);
   }
 
   /**
@@ -766,4 +692,95 @@
       }         
     return n;
   }
+  
+  static boolean convertToBoolean(int b) throws EOFException
+  {
+    if (b < 0)
+      throw new EOFException();    
+    return (b != 0);
+  }
+
+  static byte convertToByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (byte) i;
+  }
+
+  static int convertToUnsignedByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (i & 0xFF);
+  }
+
+  static char convertToChar(byte[] buf)
+  {
+    return (char) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static short convertToShort(byte[] buf)
+  {
+    return (short) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static int convertToUnsignedShort(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));  
+  }
+
+  static int convertToInt(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
+	    ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));  
+  }
+
+  static long convertToLong(byte[] buf)
+  {
+    return (((long)(buf[0] & 0xff) << 56) |
+	    ((long)(buf[1] & 0xff) << 48) |
+	    ((long)(buf[2] & 0xff) << 40) |
+	    ((long)(buf[3] & 0xff) << 32) |
+	    ((long)(buf[4] & 0xff) << 24) |
+	    ((long)(buf[5] & 0xff) << 16) |
+	    ((long)(buf[6] & 0xff) <<  8) |
+	    ((long)(buf[7] & 0xff)));  
+  }
+
+  static String convertFromUTF(byte[] buf) 
+    throws EOFException, UTFDataFormatException
+  {
+    // Give StringBuffer an initial estimated size to avoid 
+    // enlarge buffer frequently
+    StringBuffer strbuf = new StringBuffer(buf.length/2 + 2);
+
+    for (int i = 0; i < buf.length; )
+      {
+	if ((buf[i] & 0x80) == 0)		// bit pattern 0xxxxxxx
+	  strbuf.append((char) (buf[i++] & 0xFF));
+	else if ((buf[i] & 0xE0) == 0xC0)	// bit pattern 110xxxxx
+	  {
+	    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)
+	      throw new UTFDataFormatException();
+
+	    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |
+				  (buf[i++] & 0x3F)));
+	  }
+	else if ((buf[i] & 0xF0) == 0xE0)	// bit pattern 1110xxxx
+	  {
+	    if (i + 2 >= buf.length ||
+		(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)
+	      throw new UTFDataFormatException();
+
+	    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |
+				  ((buf[i++] & 0x3F) << 6) |
+				  (buf[i++] & 0x3F)));
+	  }
+	else // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)
+	  throw new UTFDataFormatException();	// bit patterns 1111xxxx or
+						// 		10xxxxxx
+      }
+
+    return strbuf.toString();
+  }
 }
