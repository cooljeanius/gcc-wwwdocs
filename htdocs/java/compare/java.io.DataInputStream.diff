--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/DataInputStream.java	2003-05-06 02:20:37.000000000 -0600
+++ java/io/DataInputStream.java	2003-05-06 02:19:22.000000000 -0600
@@ -134,11 +134,7 @@
    */
   public final boolean readBoolean() throws IOException
   {
-    int b = in.read();
-    if (b < 0)
-      throw new EOFException();
-    else
-      return(b != 0);
+    return convertToBoolean(in.read());
   }
 
   /**
@@ -158,10 +154,7 @@
    */
   public final byte readByte() throws IOException
   {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (byte) i;
+    return convertToByte(in.read());
   }
 
   /**
@@ -189,10 +182,10 @@
    *
    * @see DataOutput#writeChar
    */
-  public synchronized final char readChar() throws IOException
+  public final char readChar() throws IOException
   {
     readFully (buf, 0, 2);
-    return (char) ((buf[0] << 8) | (buf[1] & 0xff));
+    return convertToChar(buf);
   }
 
   /**
@@ -254,7 +247,7 @@
    * In this case, the method will return immediately without reading any
    * bytes from the stream.
    *
-   * @param buf The buffer into which to read the data
+   * @param b The buffer into which to read the data
    *
    * @exception EOFException If end of file is reached before filling the
    * buffer
@@ -324,11 +317,10 @@
    *
    * @see DataOutput#writeInt
    */
-  public synchronized final int readInt() throws IOException
+  public final int readInt() throws IOException
   {
     readFully (buf, 0, 4);
-    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
-            ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));
+    return convertToInt(buf);
   }
 
   /**
@@ -346,11 +338,15 @@
    * <code>\r\n</code>.  These termination charaters are discarded and
    * are not returned as part of the string.
    * <p>
+   * This method can read data that was written by an object implementing the
+   * <code>writeLine()</code> method in <code>DataOutput</code>.
    *
    * @return The line read as a <code>String</code>
    *
    * @exception IOException If an error occurs
    *
+   * @see DataOutput
+   *
    * @deprecated
    */
   public final String readLine() throws IOException
@@ -471,17 +467,10 @@
    *
    * @see DataOutput#writeLong
    */
-  public synchronized final long readLong() throws IOException
+  public final long readLong() throws IOException
   {
     readFully (buf, 0, 8);
-    return (((long)(buf[0] & 0xff) << 56) |
-            ((long)(buf[1] & 0xff) << 48) |
-            ((long)(buf[2] & 0xff) << 40) |
-            ((long)(buf[3] & 0xff) << 32) |
-            ((long)(buf[4] & 0xff) << 24) |
-            ((long)(buf[5] & 0xff) << 16) |
-            ((long)(buf[6] & 0xff) <<  8) |
-            ((long)(buf[7] & 0xff)));
+    return convertToLong(buf);
   }
 
   /**
@@ -511,10 +500,10 @@
    *
    * @see DataOutput#writeShort
    */
-  public synchronized final short readShort() throws IOException
+  public final short readShort() throws IOException
   {
     readFully (buf, 0, 2);
-    return (short) ((buf[0] << 8) | (buf[1] & 0xff));
+    return convertToShort(buf);
   }
   
   /**
@@ -523,7 +512,7 @@
    * 255.
    * <p>
    * This method can read an unsigned byte written by an object
-   * implementing the <code>writeByte()</code> method in the
+   * implementing the <code>writeUnsignedByte()</code> method in the
    * <code>DataOutput</code> interface.
    *
    * @return The unsigned bytes value read as a Java <code>int</code>.
@@ -535,51 +524,7 @@
    */
   public final int readUnsignedByte() throws IOException
   {
-    int i = in.read();
-    if (i < 0)
-      throw new EOFException();
-    return (i & 0xFF);
-  }
-
-  // FIXME: This method should be re-thought.  I suspect we have multiple
-  // UTF-8 decoders floating around.  We should use the standard charset
-  // converters, maybe and adding a direct call into one of the new
-  // NIO converters for a super-fast UTF8 decode.
-  static String convertFromUTF(byte[] buf) 
-    throws EOFException, UTFDataFormatException
-  {
-    // Give StringBuffer an initial estimated size to avoid 
-    // enlarge buffer frequently
-    StringBuffer strbuf = new StringBuffer(buf.length/2 + 2);
-
-    for (int i = 0; i < buf.length; )
-      {
-	if ((buf[i] & 0x80) == 0)		// bit pattern 0xxxxxxx
-	  strbuf.append((char) (buf[i++] & 0xFF));
-	else if ((buf[i] & 0xE0) == 0xC0)	// bit pattern 110xxxxx
-	  {
-	    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)
-	      throw new UTFDataFormatException();
-
-	    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |
-				  (buf[i++] & 0x3F)));
-	  }
-	else if ((buf[i] & 0xF0) == 0xE0)	// bit pattern 1110xxxx
-	  {
-	    if (i + 2 >= buf.length ||
-		(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)
-	      throw new UTFDataFormatException();
-
-	    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |
-				  ((buf[i++] & 0x3F) << 6) |
-				  (buf[i++] & 0x3F)));
-	  }
-	else // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)
-	  throw new UTFDataFormatException();	// bit patterns 1111xxxx or
-						// 		10xxxxxx
-      }
-
-    return strbuf.toString();
+    return convertToUnsignedByte(in.read());
   }
 
   /**
@@ -599,7 +544,7 @@
    * The value returned is in the range of 0 to 65535.
    * <p>
    * This method can read an unsigned short written by an object
-   * implementing the <code>writeShort()</code> method in the
+   * implementing the <code>writeUnsignedShort()</code> method in the
    * <code>DataOutput</code> interface.
    *
    * @return The unsigned short value read as a Java <code>int</code>
@@ -609,10 +554,10 @@
    *
    * @see DataOutput#writeShort
    */
-  public final synchronized int readUnsignedShort() throws IOException
+  public final int readUnsignedShort() throws IOException
   {
     readFully (buf, 0, 2);
-    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));
+    return convertToUnsignedShort(buf);
   }
 
   /**
@@ -688,20 +633,7 @@
    */
   public final String readUTF() throws IOException
   {
-    int UTFlen = readUnsignedShort();
-    byte[] buf = new byte[UTFlen];
-
-    // This blocks until the entire string is available rather than
-    // doing partial processing on the bytes that are available and then
-    // blocking.  An advantage of the latter is that Exceptions
-    // could be thrown earlier.  The former is a bit cleaner.
-    readFully(buf, 0, UTFlen);
-
-    // FIXME: This should probably be replaced with something like
-    // new String(buf, "UTF-8"), however that might take a performance
-    // due to time looking up encoders.  But having a private UTF
-    // converter may not be the way to go either.
-    return (convertFromUTF(buf));
+    return readUTF(this);
   }
 
   /**
@@ -736,7 +668,7 @@
    * This method will not skip any bytes if passed a negative number of bytes 
    * to skip. 
    *
-   * @param numBytes The requested number of bytes to skip.
+   * @param n The requested number of bytes to skip.
    *
    * @return The requested number of bytes to skip.
    *
@@ -760,4 +692,95 @@
       }         
     return n;
   }
+  
+  static boolean convertToBoolean(int b) throws EOFException
+  {
+    if (b < 0)
+      throw new EOFException();    
+    return (b != 0);
+  }
+
+  static byte convertToByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (byte) i;
+  }
+
+  static int convertToUnsignedByte(int i) throws EOFException
+  {
+    if (i < 0)
+      throw new EOFException();
+    return (i & 0xFF);
+  }
+
+  static char convertToChar(byte[] buf)
+  {
+    return (char) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static short convertToShort(byte[] buf)
+  {
+    return (short) ((buf[0] << 8) | (buf[1] & 0xff));  
+  }  
+
+  static int convertToUnsignedShort(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));  
+  }
+
+  static int convertToInt(byte[] buf)
+  {
+    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
+	    ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));  
+  }
+
+  static long convertToLong(byte[] buf)
+  {
+    return (((long)(buf[0] & 0xff) << 56) |
+	    ((long)(buf[1] & 0xff) << 48) |
+	    ((long)(buf[2] & 0xff) << 40) |
+	    ((long)(buf[3] & 0xff) << 32) |
+	    ((long)(buf[4] & 0xff) << 24) |
+	    ((long)(buf[5] & 0xff) << 16) |
+	    ((long)(buf[6] & 0xff) <<  8) |
+	    ((long)(buf[7] & 0xff)));  
+  }
+
+  static String convertFromUTF(byte[] buf) 
+    throws EOFException, UTFDataFormatException
+  {
+    // Give StringBuffer an initial estimated size to avoid 
+    // enlarge buffer frequently
+    StringBuffer strbuf = new StringBuffer(buf.length/2 + 2);
+
+    for (int i = 0; i < buf.length; )
+      {
+	if ((buf[i] & 0x80) == 0)		// bit pattern 0xxxxxxx
+	  strbuf.append((char) (buf[i++] & 0xFF));
+	else if ((buf[i] & 0xE0) == 0xC0)	// bit pattern 110xxxxx
+	  {
+	    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)
+	      throw new UTFDataFormatException();
+
+	    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |
+				  (buf[i++] & 0x3F)));
+	  }
+	else if ((buf[i] & 0xF0) == 0xE0)	// bit pattern 1110xxxx
+	  {
+	    if (i + 2 >= buf.length ||
+		(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)
+	      throw new UTFDataFormatException();
+
+	    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |
+				  ((buf[i++] & 0x3F) << 6) |
+				  (buf[i++] & 0x3F)));
+	  }
+	else // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)
+	  throw new UTFDataFormatException();	// bit patterns 1111xxxx or
+						// 		10xxxxxx
+      }
+
+    return strbuf.toString();
+  }
 }
