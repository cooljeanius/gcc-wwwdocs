--- /home/tromey/gnu/egcs/classpath/classpath/java/lang/reflect/Modifier.java	Sun Oct 21 10:39:27 2001
+++ java/lang/reflect/Modifier.java	Fri Oct  5 08:35:35 2001
@@ -27,6 +27,12 @@
 
 package java.lang.reflect;
 
+/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
+ * "The Java Language Specification", ISBN 0-201-63451-1
+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status: Believed complete and correct to version 1.2.
+ */
+
 /**
  * Modifier is a helper class with static methods to determine whether an
  * int returned from getModifiers() represents static, public, protected,
@@ -40,13 +46,12 @@
  *
  * @author John Keiser
  * @author Tom Tromey <tromey@cygnus.com>
- * @author Eric Blake <ebb9@email.byu.edu>
+ *
  * @see Member#getModifiers()
  * @see Method#getModifiers()
  * @see Field#getModifiers()
  * @see Constructor#getModifiers()
  * @see Class#getModifiers()
- * @since 1.1
  */
 public class Modifier
 {
@@ -55,267 +60,226 @@
    * worthless.  However, this function is in the 1.1 spec, so it is added
    * for completeness.</STRONG>
    */
-  public Modifier()
-  {
-  }
+  public Modifier() {}
 
-  /**
-   * Public: accessible from any other class.
-   */
+  /** Public: accessible from any other class. **/
   public static final int PUBLIC = 0x0001;
 
-  /**
-   * Private: accessible only from the same enclosing class.
-   */
+  /** Private: accessible only from the declaring class. **/
   public static final int PRIVATE = 0x0002;
 
-  /**
-   * Protected: accessible only to subclasses, or within the package.
-   */
+  /** Protected: accessible only to subclasses. **/
   public static final int PROTECTED = 0x0004;
 
-  /**
-   * Static:<br><ul>
-   * <li>Class: no enclosing instance for nested class.</li>
-   * <li>Field or Method: can be accessed or invoked without an
-   *     instance of the declaring class.</li>
-   * </ul>
-   */
+  /** Static: field or method - can be accessed or invoked without an
+      instance of the declaring class. **/
   public static final int STATIC = 0x0008;
 
-  /**
-   * Final:<br><ul>
-   * <li>Class: no subclasses allowed.</li>
-   * <li>Field: cannot be changed.</li>
-   * <li>Method: cannot be overriden.</li>
-   * </ul>
+  /** Final:<BR>
+   * <UL>
+   * <LI> Class: no subclasses allowed. </LI>
+   * <LI> Field: cannot be changed. </LI>
+   * <LI> Method: cannot be overriden. </LI>
+   * </UL>
    */
   public static final int FINAL = 0x0010;
 
-  /**
-   * Synchronized: Method: lock the class while calling this method.
-   */
+  /** Synchronized: lock the class while calling this method. **/
   public static final int SYNCHRONIZED = 0x0020;
 
-  /**
-   * Volatile: Field: cannot be cached.
-   */
+  /** Volatile: cannot be cached.<P> **/
   public static final int VOLATILE = 0x0040;
 
-  /**
-   * Transient: Field: not serialized or deserialized.
-   */
+  /** Transient: not serialized or deserialized. **/
   public static final int TRANSIENT = 0x0080;
 
-  /**
-   * Native: Method: use JNI to call this method.
-   */
+  /** Native: use JNI to call this method. **/
   public static final int NATIVE = 0x0100;
 
-  /**
-   * Interface: Class: is an interface.
-   */
+  /** Interface: is an interface. **/
   public static final int INTERFACE = 0x0200;
 
-  /**
-   * Abstract:<br><ul>
-   * <li>Class: may not be instantiated.</li>
-   * <li>Method: may not be called.</li>
-   * </ul>
-   */
+  /** Abstract: class - may not be instantiated;
+      method - may not be called. **/
   public static final int ABSTRACT = 0x0400;
 
-  /**
-   * Strictfp: Method: expressions are FP-strict.<p>
-   * Also used as a modifier for classes, to mean that all initializers
-   * and constructors are FP-strict, but does not show up in
-   * Class.getModifiers.
-   */
+  /** Class or method - expressions are FP-strict. **/
   public static final int STRICT = 0x0800;
 
 
-  /**
-   * Super - treat invokespecial as polymorphic so that super.foo() works
-   * according to the JLS. This is a reuse of the synchronized constant
-   * to patch a hole in JDK 1.0. *shudder*.
-   */
-  static final int SUPER = 0x0020;
+  /* NOTE: THIS IS HERE BECAUSE IT IS IN THE VM SPEC.
+     I INCLUDE IT FOR COMPLETENESS.  IT ATTACHES TO A CLASS AND MEANS
+     "Treat superclasses specially in invokespecial". Note that it is the
+     same as synchronized.  Reuse of the constant.  *shudder* */
+  private static final int SUPER = 0x0020;
 
-  /**
-   * All the flags, only used by code in this package.
-   */
+  // This can only used by other code in this package, so it is not public.
   static final int ALL_FLAGS = 0xfff;
 
-  /**
-   * Check whether the given modifier is abstract.
+  /** Check whether the given modifier is abstract.
    * @param mod the modifier.
    * @return <code>true</code> if abstract, <code>false</code> otherwise.
    */
-  public static boolean isAbstract(int mod)
+  public static boolean isAbstract (int mod)
   {
     return (mod & ABSTRACT) != 0;
   }
 
-  /**
-   * Check whether the given modifier is final.
+  /** Check whether the given modifier is final.
    * @param mod the modifier.
    * @return <code>true</code> if final, <code>false</code> otherwise.
    */
-  public static boolean isFinal(int mod)
+  public static boolean isFinal (int mod)
   {
     return (mod & FINAL) != 0;
   }
 
-  /**
-   * Check whether the given modifier is an interface.
+  /** Check whether the given modifier is an interface.
    * @param mod the modifier.
    * @return <code>true</code> if an interface, <code>false</code> otherwise.
    */
-  public static boolean isInterface(int mod)
+  public static boolean isInterface (int mod)
   {
     return (mod & INTERFACE) != 0;
   }
 
-  /**
-   * Check whether the given modifier is native.
+  /** Check whether the given modifier is native.
    * @param mod the modifier.
    * @return <code>true</code> if native, <code>false</code> otherwise.
    */
-  public static boolean isNative(int mod)
+  public static boolean isNative (int mod)
   {
     return (mod & NATIVE) != 0;
   }
 
-  /**
-   * Check whether the given modifier is private.
+  /** Check whether the given modifier is private.
    * @param mod the modifier.
    * @return <code>true</code> if private, <code>false</code> otherwise.
    */
-  public static boolean isPrivate(int mod)
+  public static boolean isPrivate (int mod)
   {
     return (mod & PRIVATE) != 0;
   }
 
-  /**
-   * Check whether the given modifier is protected.
+  /** Check whether the given modifier is protected.
    * @param mod the modifier.
    * @return <code>true</code> if protected, <code>false</code> otherwise.
    */
-  public static boolean isProtected(int mod)
+  public static boolean isProtected (int mod)
   {
     return (mod & PROTECTED) != 0;
   }
 
-  /**
-   * Check whether the given modifier is public.
+  /** Check whether the given modifier is public.
    * @param mod the modifier.
    * @return <code>true</code> if public, <code>false</code> otherwise.
    */
-  public static boolean isPublic(int mod)
+  public static boolean isPublic (int mod)
   {
     return (mod & PUBLIC) != 0;
   }
 
-  /**
-   * Check whether the given modifier is static.
+  /** Check whether the given modifier is static.
    * @param mod the modifier.
    * @return <code>true</code> if static, <code>false</code> otherwise.
    */
-  public static boolean isStatic(int mod)
+  public static boolean isStatic (int mod)
   {
     return (mod & STATIC) != 0;
   }
 
-  /**
-   * Check whether the given modifier is strictfp.
+  /** Check whether the given modifier is strictfp.
    * @param mod the modifier.
    * @return <code>true</code> if strictfp, <code>false</code> otherwise.
    */
-  public static boolean isStrict(int mod)
+  public static boolean isStrict (int mod)
   {
     return (mod & STRICT) != 0;
   }
 
-  /**
-   * Check whether the given modifier is synchronized.
+  /** Check whether the given modifier is synchronized.
    * @param mod the modifier.
    * @return <code>true</code> if synchronized, <code>false</code> otherwise.
    */
-  public static boolean isSynchronized(int mod)
+  public static boolean isSynchronized (int mod)
   {
     return (mod & SYNCHRONIZED) != 0;
   }
 
-  /**
-   * Check whether the given modifier is transient.
+  /** Check whether the given modifier is transient.
    * @param mod the modifier.
    * @return <code>true</code> if transient, <code>false</code> otherwise.
    */
-  public static boolean isTransient(int mod)
+  public static boolean isTransient (int mod)
   {
     return (mod & TRANSIENT) != 0;
   }
 
-  /**
-   * Check whether the given modifier is volatile.
+  /** Check whether the given modifier is volatile.
    * @param mod the modifier.
    * @return <code>true</code> if volatile, <code>false</code> otherwise.
    */
-  public static boolean isVolatile(int mod)
+  public static boolean isVolatile (int mod)
   {
     return (mod & VOLATILE) != 0;
   }
 
-  /**
-   * Get a string representation of all the modifiers represented by the
-   * given int. The keywords are printed in this order:
+  /** Get a string representation of all the modifiers represented by the
+   * given int.
+   * The keywords are printed in this order:
    * <code>&lt;public|private|protected&gt; abstract static final transient
-   * volatile native synchronized interface strictfp</code>.
+   * volatile native synchronized interface strictfp</code><P>
+   *
+   * <STRONG>This is, near as I can tell, the "canonical order" of modifiers
+   * mentioned by Sun in the reference implementation.  I have inferred this
+   * from the order of printing in the Field, Method and Constructor
+   * classes.</STRONG>
    *
    * @param mod the modifier.
    * @return the String representing the modifiers.
    */
-  public static String toString(int mod)
+  public static String toString (int mod)
   {
-    return toString(mod, new StringBuffer()).toString();
+    StringBuffer r = new StringBuffer ();
+    toString(mod, r);
+    return r.toString();
   }
 
   /**
-   * Package helper method that can take a StringBuffer.
+   * Package private helper toString() method that can take a StringBuffer.
    * @param mod the modifier
    * @param r the StringBuffer to which the String representation is appended
-   * @return r, with information appended
    */
-  static StringBuffer toString(int mod, StringBuffer r)
+  static void toString (int mod, StringBuffer r)
   {
-    if (isPublic(mod))
+    if (isPublic (mod))
       r.append("public ");
-    if (isPrivate(mod))
-      r.append("private ");
-    if (isProtected(mod))
+    if (isProtected (mod))
       r.append("protected ");
-    if (isAbstract(mod))
+    if (isPrivate (mod))
+      r.append("private ");
+    if (isAbstract (mod))
       r.append("abstract ");
-    if (isStatic(mod))
+    if (isStatic (mod))
       r.append("static ");
-    if (isFinal(mod))
+    if (isFinal (mod))
       r.append("final ");
-    if (isTransient(mod))
+    if (isTransient (mod))
       r.append("transient ");
-    if (isVolatile(mod))
+    if (isVolatile (mod))
       r.append("volatile ");
-    if (isNative(mod))
+    if (isNative (mod))
       r.append("native ");
-    if (isSynchronized(mod))
+    if (isSynchronized (mod))
       r.append("synchronized ");
-    if (isInterface(mod))
+    if (isInterface (mod))
       r.append("interface ");
-    if (isStrict(mod))
+    if (isStrict (mod))
       r.append("strictfp ");
     
     // Trim trailing space.
-    if ((mod & ALL_FLAGS) != 0)
-      r.setLength(r.length() - 1);
-    return r;
+    int l = r.length();
+    if (l > 0)
+      r.setLength(l - 1);
   }
 }
