--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/event/EventListenerList.java	2004-01-07 02:20:41.000000000 -0700
+++ javax/swing/event/EventListenerList.java	2003-03-31 02:17:51.000000000 -0700
@@ -1,5 +1,5 @@
 /* EventListenerList.java --
-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   Copyright (C) 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,266 +37,206 @@
 
 package javax.swing.event;
 
+// Imports
 import java.io.Serializable;
-import java.lang.reflect.Array;
 import java.util.EventListener;
 
-
 /**
- * A utility class for keeping track of {@link EventListener}s.
- *
- * <p><b>Example for using this class:</b>
- *
- * <blockquote><pre> import java.util.EventListener;
- * import javax.swing.event.EventListenerList;
- *
- * class Foo
- * {
- *   protected final EventListenerList listeners = new EventListenerList();
- *   protected BarClosedEvent barClosedEvent = null;
- *
- *   public void addBarListener(BarListener l)
- *   {
- *     listeners.<a href="#add(java.lang.Class, java.util.EventListener)"
- *               >add</a>(BarListener.class, l);
- *   }
- *
- *   public void removeBarListener(BarListener l)
- *   {
- *     listeners.<a href="#remove(java.lang.Class, java.util.EventListener)"
- *               >remove</a>(BarListener.class, l);
- *   }
- *
- *   protected void fireBarClosedEvent()
- *   {
- *     Object[] l = listeners.<a href="#getListenerList()"
- *                            >getListenerList()</a>;
- *
- *     for (int i = l.length - 2; i >= 0; i -= 2)
- *       if (l[i] == BarListener.class)
- *         {
- *           // Create the event on demand, when it is needed the first time.
- *           if (barClosedEvent == null)
- *             barClosedEvent = new BarClosedEvent(this);
- *
- *           ((BarClosedListener) l[i + 1]).barClosed(barClosedEvent);
- *         }
- *   }
- * }</pre></blockquote>
- *
- * @author <a href="mailto:aselkirk@sympatico.ca">Andrew Selkirk</a>
- * @author <a href="mailto:brawer@dandelis.ch">Sascha Brawer</a>
+ * EventListenerList
+ * @author Andrew Selkirk
  */
-public class EventListenerList
-  implements Serializable
+public class EventListenerList extends Object implements Serializable
 {
-  /**
-   * An ID for serializing instances of this class; verified with the
-   * serialver tool of Sun J2SE 1.4.1_01.
-   */
   static final long serialVersionUID = -5677132037850737084L;
 
+	//-------------------------------------------------------------
+	// Variables --------------------------------------------------
+	//-------------------------------------------------------------
+	
+	/**
+	 * Listener list
+	 */
+	protected	Object[]	listenerList	= null;
+
+
+	//-------------------------------------------------------------
+	// Initialization ---------------------------------------------
+	//-------------------------------------------------------------
+	
+	/**
+	 * EventListenerList constructor
+	 */
+	public EventListenerList() {
+		listenerList = new Object[0];
+	} // EventListenerList()
+
+	
+	//-------------------------------------------------------------
+	// Methods ----------------------------------------------------
+	//-------------------------------------------------------------
+
+	/**
+	 * Add Listener
+	 * @param t Class type
+	 * @param listener Listener to add
+	 */
+	public void add(Class t, EventListener listener) {
+
+		// Variables
+		Object[]		list;
+		int				index;
+		Class			checkClass;
+		EventListener	checkListener;
+
+		// Create New list in anticipation that listener is not present
+		list = new Object[listenerList.length + 2];
+
+		// Search through list looking for listener
+		for (index = 0; index < listenerList.length; index += 2) {
+			checkClass = (Class) listenerList[index];
+			checkListener = (EventListener) listenerList[index + 1];
+			if (checkClass.equals(t) == true &&
+				checkListener.equals(listener) == true) {
+				return;
+			} // if
+		} // for
+
+		// Add Listener
+		list[listenerList.length] = t;
+		list[listenerList.length + 1] = listener;
+
+		// Replace Listener List
+		listenerList = list;
+
+	} // add()
+
+	/**
+	 * Get the total number of listeners
+	 * @return Count of listeners
+	 */
+	public int getListenerCount() {
+		return (int) listenerList.length / 2;
+	} // getListenerCount
+
+	/**
+	 * Get the number of listeners of a particular type
+	 * @param t Class type to count
+	 * @returns Count of the specified listeners
+	 */
+	public int getListenerCount(Class t) {
+
+		// Variables
+		int		index;
+		int		count;
+		String	name;
+
+		// Loop through entire list
+		count = 0;
+		name  = t.getName();
+		for (index = 0; index < listenerList.length; index += 2) {
+			if (((Class) listenerList[index]).getName().equals(name) == true) {
+				count += 1;
+			}
+		} // for: index
+
+		// Return Count
+		return count;
+
+	} // getListenerCount()
+
+	/**
+	 * Get a list of listenerType/listener pairs
+	 * @returns Listener list
+	 */
+	public Object[] getListenerList() {
+		return listenerList;
+	} // getListenerList()
+
+	/**
+	 * Get list of listeners of a particular type
+	 * @param c Class type
+	 * @returns List of listeners of the specified type
+	 */
+	public EventListener[] getListeners(Class c) {
+
+		// Variables
+		int					count;
+		EventListener[]		list;
+		String				name;
+		int					index;
+
+		// Get count of listeners
+		count = getListenerCount(c);
+
+		// Create Event Listener list
+		list = new EventListener[count];
+
+		// Construct List
+		count = 0;
+		name  = c.getName();
+		for (index = 0; index < listenerList.length; index += 2) {
+			if (((Class) listenerList[index]).getName().equals(name) == true) {
+				list[count] = (EventListener) listenerList[index];
+				count += 1;
+			} // if
+		} // for: index
+
+		// Return List
+		return list;
+
+	} // getListeners()
+
+	/**
+	 * Remove a listener
+	 * @param t Class type
+	 * @param listener Listener to be removed
+	 */
+	public void remove(Class t, EventListener listener) {
+
+		// Variables
+		Object[]		list;
+		int				index;
+		Class			checkClass;
+		EventListener	checkListener;
+		int				pointer;
+		boolean			found;
+
+		// Create New list in anticipation that listener is not present
+		if (listenerList.length == 0) {
+			return;
+		} // if
+		list = new Object[listenerList.length - 2];
+
+		// Search through list looking for listener
+		pointer = 0;
+		found = false;
+		for (index = 0; index < listenerList.length - 2; index += 2) {
+			checkClass = (Class) listenerList[index];
+			checkListener = (EventListener) listenerList[index + 1];
+			if (checkClass.equals(t) == false ||
+				checkListener.equals(listener) == false) {
+				list[pointer] = checkClass;
+				list[pointer + 1] = checkListener;
+				pointer += 2;
+			} else {
+				found = true;
+			} // if
+		} // for
+
+		// Replace Listener List
+		if (found == true) {
+			listenerList = list;
+		} // if
+
+	} // remove()
+
+	/**
+	 * Get a string representation
+	 * @returns String representation
+	 */
+	public String toString() {
+		return null; // TODO
+	} // toString()
+
 
-  /**
-   * An empty array that is shared by all instances of this class that
-   * have no listeners.
-   */
-  private static final Object[] NO_LISTENERS = new Object[0];
-  
-  
-  /**
-   * An array with all currently registered listeners.  The array has
-   * twice as many elements as there are listeners.  For an even
-   * integer <code>i</code>, <code>listenerList[i]</code> indicates
-   * the registered class, and <code>listenerList[i+1]</code> is the
-   * listener.
-   */
-  protected transient Object[] listenerList = NO_LISTENERS;
-
-  
-  /**
-   * EventListenerList constructor
-   */
-  public EventListenerList()
-  {
-  }
-
-
-  /**
-   * Registers a listener of a specific type.
-   *
-   * @param t the type of the listener.
-   *
-   * @param listener the listener to add, which must be an instance of
-   * <code>t</code>, or of a subclass of <code>t</code>.
-   *
-   * @throws IllegalArgumentException if <code>listener</code> is not
-   * an instance of <code>t</code> (or a subclass thereof).
-   *
-   * @throws Exception if <code>t</code> is <code>null</code>.
-   */
-  public void add(Class t, EventListener listener)
-  {
-    int oldLength;
-    Object[] newList;
-
-    if (listener == null)
-      return;
-
-    if (!t.isInstance(listener))
-      throw new IllegalArgumentException();
-
-    oldLength = listenerList.length;
-    newList = new Object[oldLength + 2];
-    if (oldLength > 0)
-      System.arraycopy(listenerList, 0, newList, 0, oldLength);
-
-    newList[oldLength] = t;
-    newList[oldLength + 1] = listener;
-    listenerList = newList;
-  }
-
-
-  /**
-   * Determines the number of listeners.
-   */
-  public int getListenerCount()
-  {
-    return listenerList.length / 2;
-  }
-
-
-  /**
-   * Determines the number of listeners of a particular class.
-   *
-   * @param t the type of listeners to be counted. In order to get
-   * counted, a subscribed listener must be exactly of class
-   * <code>t</code>. Thus, subclasses of <code>t</code> will not be
-   * counted.
-   */
-  public int getListenerCount(Class t)
-  {
-    int result = 0;
-    for (int i = 0; i < listenerList.length; i += 2)
-      if (t == listenerList[i])
-        ++result;
-
-    return result;
-  }
-
-
-  /**
-   * Get a list of listenerType/listener pairs
-   * @returns Listener list
-   */
-  public Object[] getListenerList()
-  {
-    return listenerList;
-  }
-
-
-  /**
-   * Retrieves the currently subscribed listeners of a particular
-   * type.  For a listener to be returned, it must have been
-   * registered with exactly the type <code>c</code>; subclasses are
-   * not considered equal.
-   *
-   * <p>The returned array can always be cast to <code>c[]</code>.
-   * Since it is a newly allocated copy, the caller may arbitrarily
-   * modify the array.
-   *
-   * @param c the class which was passed to {@link #add}.
-   *
-   * @throws ClassCastException if <code>c</code> does not implement
-   * the {@link EventListener} interface.
-   *
-   * @throws NullPointerException if <code>c</code> is
-   * <code>null</code>.
-   *
-   * @returns an array of <code>c</code> whose elements are the
-   * currently subscribed listeners of the specified type.  If there
-   * are no such listeners, an empty array is returned.
-   *
-   * @since 1.3
-   */
-  public EventListener[] getListeners(Class c)
-  {
-    int count, f;
-    EventListener[] result;
-
-    count = getListenerCount(c);
-    result = (EventListener[]) Array.newInstance(c, count);
-    f = 0;
-    for (int i = 0; i < listenerList.length; i += 2)
-      if (listenerList[i] == c)
-        result[f++] = (EventListener) listenerList[i + 1];
-    
-    return result;
-  }
-
-
-  /**
-   * Removes a listener of a specific type.
-   *
-   * @param t the type of the listener.
-   *
-   * @param listener the listener to remove, which must be an instance
-   * of <code>t</code>, or of a subclass of <code>t</code>.
-   *
-   * @throws IllegalArgumentException if <code>listener</code> is not
-   * an instance of <code>t</code> (or a subclass thereof).
-   *
-   * @throws Exception if <code>t</code> is <code>null</code>.
-   */
-  public void remove(Class t, EventListener listener)
-  {
-    Object[] oldList, newList;
-    int oldLength;
-
-    if (listener == null)
-      return;
-
-    if (!t.isInstance(listener))
-      throw new IllegalArgumentException();
-
-    oldList = listenerList;
-    oldLength = oldList.length;
-    for (int i = 0; i < oldLength; i += 2)
-      if (oldList[i] == t && oldList[i + 1] == listener)
-        {
-          if (oldLength == 2)
-            newList = NO_LISTENERS;
-          else
-            {
-              newList = new Object[oldLength - 2];
-              if (i > 0)
-                System.arraycopy(oldList, 0, newList, 0, i);
-              if (i < oldLength - 2)
-                System.arraycopy(oldList, i + 2, newList, i,
-                                 oldLength - 2 - i);
-            }
-          listenerList = newList;
-          return;
-        }
-  }
-
-
-  /**
-   * Returns a string representation of this object that may be useful
-   * for debugging purposes.
-   */
-  public String toString()
-  {
-    StringBuffer buf = new StringBuffer("EventListenerList: ");
-    buf.append(listenerList.length / 2);
-    buf.append(" listeners: ");
-    for (int i = 0; i < listenerList.length; i += 2)
-      {
-        buf.append(" type ");
-        buf.append(((Class) listenerList[i]).getName());
-        buf.append(" listener ");
-        buf.append(listenerList[i + 1]);
-      }
-    return buf.toString();
-  }
-}
+} // EventListenerList
