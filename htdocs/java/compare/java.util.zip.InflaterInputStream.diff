--- /home/tromey/gnu/Nightly/classpath/classpath/java/util/zip/InflaterInputStream.java	2003-07-19 02:19:45.000000000 -0600
+++ java/util/zip/InflaterInputStream.java	2003-06-20 02:21:15.000000000 -0600
@@ -1,5 +1,5 @@
-/* java.util.zip.InflaterInputStream
-   Copyright (C) 2001 Free Software Foundation, Inc.
+/* InflaterInputStream.java - Input stream filter for decompressing
+   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -42,195 +42,136 @@
 import java.io.IOException;
 
 /**
- * This filter stream is used to decompress data compressed in the "deflate"
- * format. The "deflate" format is described in RFC 1951.
- *
- * This stream may form the basis for other decompression filters, such
- * as the <code>GZIPInputStream</code>.
- *
- * @author John Leuner
- * @since 1.1
+ * @author Tom Tromey
+ * @date May 17, 1999
  */
-public class InflaterInputStream extends FilterInputStream
-{
-  /**
-   * Decompressor for this filter 
-   */
-  protected Inflater inf;
-
-  /**
-   * Byte array used as a buffer 
-   */
-  protected byte[] buf;
 
-  /**
-   * Size of buffer   
-   */
-  protected int len;
-
-
-  /*
-   * We just use this if we are decoding one byte at a time with the read() call
-   */
-  private byte[] onebytebuffer = new byte[1];
-
-  /**
-   * Create an InflaterInputStream with the default decompresseor
-   * and a default buffer size.
-   *
-   * @param in the InputStream to read bytes from
-   */
-  public InflaterInputStream(InputStream in) 
-  {
-    this(in, new Inflater(), 4096);
-  }
-
-  /**
-   * Create an InflaterInputStream with the specified decompresseor
-   * and a default buffer size.
-   *
-   * @param in the InputStream to read bytes from
-   * @param inf the decompressor used to decompress data read from in
-   */
-  public InflaterInputStream(InputStream in, Inflater inf) 
-  {
-    this(in, inf, 4096);
-  }
-
-  /**
-   * Create an InflaterInputStream with the specified decompresseor
-   * and a specified buffer size.
-   *
-   * @param in the InputStream to read bytes from
-   * @param inf the decompressor used to decompress data read from in
-   * @param size size of the buffer to use
-   */
-  public InflaterInputStream(InputStream in, Inflater inf, int size) 
-  {
-    super(in);
-    this.inf = inf;
-    this.len = 0;
-    
-    if (size <= 0)
-      throw new IllegalArgumentException("size <= 0");
-    buf = new byte[size]; //Create the buffer
+/* Written using on-line Java Platform 1.2 API Specification
+ * and JCL book.
+ * Believed complete and correct.
+ */
 
-    if (in == null)
-      throw new NullPointerException("InputStream null");
-    if (inf == null)
-      throw new NullPointerException("Inflater null");
+public class InflaterInputStream extends FilterInputStream
+{
+  protected void fill () throws IOException
+  {
+    len = in.read(buf, 0, buf.length);
+    if (len != -1)
+      inf.setInput(buf, 0, len);
   }
 
-  /**
-   * Returns 0 once the end of the stream (EOF) has been reached.
-   * Otherwise returns 1.
-   */
-  public int available() throws IOException
+  public InflaterInputStream (InputStream in)
   {
-    return inf.finished() ? 0 : 1;
+    this (in, new Inflater (), 512);
   }
 
-  /**
-   * Closes the input stream
-   */
-  public void close() throws IOException
+  public InflaterInputStream (InputStream in, Inflater infl)
   {
-    in.close();
-    in = null;
+    this (in, infl, 512);
   }
 
-  /**
-   * Fills the buffer with more data to decompress.
-   */
-  protected void fill() throws IOException
+  public InflaterInputStream (InputStream in, Inflater infl, int bufsize)
   {
-    if (in == null)
-      throw new ZipException ("InflaterInputStream is closed");
-    
-    len = in.read(buf, 0, buf.length);
+    super (in);
 
-    if (len < 0)
-      throw new ZipException("Deflated stream ends early.");
+    if (in == null)
+      throw new NullPointerException();
     
-    inf.setInput(buf, 0, len);
+    this.inf = infl;
+    this.buf = new byte[bufsize];
   }
 
-  /**
-   * Reads one byte of decompressed data.
-   *
-   * The byte is in the lower 8 bits of the int.
-   */
-  public int read() throws IOException
-  { 
-    int nread = read(onebytebuffer, 0, 1); //read one byte
-    
-    if (nread > 0)
-      return onebytebuffer[0] & 0xff;
-    
-    return -1;
+  public int read () throws IOException
+  {
+    byte[] buf = new byte[1];
+    int r = read (buf, 0, 1);
+    if (r != -1)
+      r = buf[0] & 0xff;
+    return r;
   }
 
-  /**
-   * Decompresses data into the byte array
-   *
-   * @param b the array to read and decompress data into
-   * @param off the offset indicating where the data should be placed
-   * @param len the number of bytes to decompress
-   */
-  public int read(byte[] b, int off, int len) throws IOException
+  public int read (byte[] buf, int off, int len) throws IOException
   {
-    if (len == 0) return 0;
+    if (inf == null)
+      throw new IOException ("stream closed");
+    if (len == 0)
+      return 0;
+    if (inf.finished())
+      return -1;
 
-    for (;;)
+    int count = 0;
+    while (count == 0)
       {
-	int count;
+	if (inf.needsInput())
+	  fill ();
 	try
 	  {
-	    count = inf.inflate(b, off, len);
-	  } 
-	catch (DataFormatException dfe) 
+	    count = inf.inflate(buf, off, len);	
+	    if (count == 0)
+	      {
+		if (this.len == -1)
+		  {
+		    // Couldn't get any more data to feed to the Inflater
+		    return -1;
+		  }
+		if (inf.needsDictionary())
+		  throw new ZipException ("Inflater needs Dictionary");
+	      }
+	  }
+	catch (DataFormatException dfe)
 	  {
-	    throw new ZipException(dfe.getMessage());
+	    throw new ZipException (dfe.getMessage());
 	  }
-
-	if (count > 0)
-	  return count;
-	
-	if (inf.needsDictionary()
-	    | inf.finished())
-	  return -1;
-	else if (inf.needsInput())
-	  fill();
-	else
-	  throw new InternalError("Don't know what to do");
       }
+    return count;
+  }
+
+  public void close () throws IOException
+  {
+    inf = null;
+    super.close ();
   }
 
-  /**
-   * Skip specified number of bytes of uncompressed data
-   *
-   * @param n number of bytes to skip
-   */
-  public long skip(long n) throws IOException
-  {
-    if (n < 0)
-      throw new IllegalArgumentException();
-    int len = 2048;
-    if (n < len)
-      len = (int) n;
-    byte[] tmp = new byte[len];
-    return (long) read(tmp);
-  }
-
-  /**
-   * Since this stream tends to buffer large (unpredictable?) amounts
-   * of stuff, it causes problems to the mark/reset mechanism.  Hence,
-   * it claims not to support mark.
-   *
-   * @return false
-   */
-  public boolean markSupported()
+  public int available () throws IOException
   {
-    return false;
+    // According to the JDK 1.2 docs, this should only ever return 0
+    // or 1 and should not be relied upon by Java programs.
+    if (inf == null)
+      throw new IOException ("stream closed");
+    return inf.finished () ? 0 : 1;
   }
+
+  public long skip (long n) throws IOException
+  {
+    if (inf == null)
+      throw new IOException ("stream closed");
+
+    if (n == 0)
+      return 0;
+
+    int min = (int) Math.min(n, 1024);
+    byte[] buf = new byte[min];
+
+    long s = 0;
+    while (n > 0)
+      {
+	int r = read (buf, 0, min);
+	if (r == -1)
+	  break;
+	n -= r;
+	s += r;
+	min = (int) Math.min(n, 1024);
+      }
+
+    return s;
+  }
+
+  // Buffer for delivering uncompressed data to inflater.
+  protected byte[] buf;
+
+  // Inflater used to decompress data.
+  protected Inflater inf;
+
+  // Number of read bytes in buf.
+  protected int len;
 }
