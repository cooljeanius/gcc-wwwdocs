--- /home/tromey/gnu/Nightly/classpath/classpath/java/util/zip/InflaterInputStream.java	2004-05-01 02:25:04.000000000 -0600
+++ java/util/zip/InflaterInputStream.java	2004-06-08 02:19:57.000000000 -0600
@@ -70,10 +70,12 @@
    */
   protected int len;
 
-  /*
-   * We just use this if we are decoding one byte at a time with the read() call
-   */
-  private byte[] onebytebuffer = new byte[1];
+  protected void fill () throws IOException
+  {
+    len = in.read(buf, 0, buf.length);
+    if (len != -1)
+      inf.setInput(buf, 0, len);
+  }
 
   /**
    * Create an InflaterInputStream with the default decompresseor
@@ -83,7 +85,7 @@
    */
   public InflaterInputStream(InputStream in) 
   {
-    this(in, new Inflater(), 4096);
+    this (in, new Inflater (), 512);
   }
 
   /**
@@ -95,7 +97,7 @@
    */
   public InflaterInputStream(InputStream in, Inflater inf) 
   {
-    this(in, inf, 4096);
+    this (in, inf, 512);
   }
 
   /**
@@ -109,7 +111,6 @@
   public InflaterInputStream(InputStream in, Inflater inf, int size) 
   {
     super(in);
-    this.len = 0;
 
     if (in == null)
       throw new NullPointerException ("in may not be null");
@@ -122,57 +123,15 @@
     this.buf = new byte [size];
   }
 
-  /**
-   * Returns 0 once the end of the stream (EOF) has been reached.
-   * Otherwise returns 1.
-   */
-  public int available() throws IOException
+  public int read () throws IOException
   {
-    // According to the JDK 1.2 docs, this should only ever return 0
-    // or 1 and should not be relied upon by Java programs.
-    return inf.finished() ? 0 : 1;
-  }
-
-  /**
-   * Closes the input stream
-   */
-  public synchronized void close() throws IOException
-  {
-    if (in != null)
-      in.close();
-    in = null;
-  }
-
-  /**
-   * Fills the buffer with more data to decompress.
-   */
-  protected void fill() throws IOException
-  {
-    if (in == null)
-      throw new ZipException ("InflaterInputStream is closed");
-    
-    len = in.read(buf, 0, buf.length);
-
-    if (len < 0)
-      throw new ZipException("Deflated stream ends early.");
-    
-    inf.setInput(buf, 0, len);
+    byte[] buf = new byte[1];
+    int r = read (buf, 0, 1);
+    if (r != -1)
+      r = buf[0] & 0xff;
+    return r;
   }
 
-  /**
-   * Reads one byte of decompressed data.
-   *
-   * The byte is in the lower 8 bits of the int.
-   */
-  public int read() throws IOException
-  { 
-    int nread = read(onebytebuffer, 0, 1); //read one byte
-    
-    if (nread > 0)
-      return onebytebuffer[0] & 0xff;
-    
-    return -1;
-  }
 
   /**
    * Decompresses data into the byte array
@@ -183,33 +142,54 @@
    */
   public int read(byte[] b, int off, int len) throws IOException
   {
+    if (inf == null)
+      throw new IOException ("stream closed");
     if (len == 0)
       return 0;
+    if (inf.finished())
+      return -1;
 
-    for (;;)
+    int count = 0;
+    while (count == 0)
       {
-	int count;
+	if (inf.needsInput())
+	  fill ();
 	
 	try
 	  {
 	    count = inf.inflate(b, off, len);
+	    if (count == 0)
+	      {
+		if (this.len == -1)
+		  {
+		    // Couldn't get any more data to feed to the Inflater
+		    return -1;
+		  }
+		if (inf.needsDictionary())
+		  throw new ZipException ("Inflater needs Dictionary");
+	      }
 	  } 
 	catch (DataFormatException dfe) 
 	  {
 	    throw new ZipException(dfe.getMessage());
 	  }
-
-	if (count > 0)
-	  return count;
-	
-	if (inf.needsDictionary()
-	    | inf.finished())
-	  return -1;
-	else if (inf.needsInput())
-	  fill();
-	else
-	  throw new InternalError("Don't know what to do");
       }
+    return count;
+  }
+
+  public void close () throws IOException
+  {
+    inf = null;
+    super.close ();
+  }
+
+  public int available () throws IOException
+  {
+    // According to the JDK 1.2 docs, this should only ever return 0
+    // or 1 and should not be relied upon by Java programs.
+    if (inf == null)
+      throw new IOException ("stream closed");
+    return inf.finished () ? 0 : 1;
   }
 
   /**
@@ -219,27 +199,26 @@
    */
   public long skip(long n) throws IOException
   {
-    if (n < 0)
-      throw new IllegalArgumentException();
+    if (inf == null)
+      throw new IOException ("stream closed");
 
     if (n == 0)
       return 0;
 
-    // Implementation copied from InputStream
-    // Throw away n bytes by reading them into a temp byte[].
-    // Limit the temp array to 2Kb so we don't grab too much memory.
-    final int buflen = n > 2048 ? 2048 : (int) n;
-    byte[] tmpbuf = new byte[buflen];
-    final long origN = n;
+    int min = (int) Math.min(n, 1024);
+    byte[] buf = new byte[min];
 
-    while (n > 0L)
+    long s = 0;
+    while (n > 0)
       {
-	int numread = read(tmpbuf, 0, n > buflen ? buflen : (int) n);
-	if (numread <= 0)
+	int r = read (buf, 0, min);
+	if (r == -1)
 	  break;
-	n -= numread;
+	n -= r;
+	s += r;
+	min = (int) Math.min(n, 1024);
       }
 
-    return origN - n;
+    return s;
  }
 }
