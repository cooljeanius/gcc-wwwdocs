--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/RandomAccessFile.java	Sat Mar 29 02:18:37 2003
+++ java/io/RandomAccessFile.java	Sat Mar 29 02:17:51 2003
@@ -62,18 +62,13 @@
 
   // The underlying file.
   private FileDescriptor fd;
+  // The corresponding input and output streams.
+  private DataOutputStream out;
+  private DataInputStream in;
   
   private FileChannel ch; /* cached associated file-channel */
   
   /**
-   * Whether or not this file is open in read only mode
-   */
-  private boolean readOnly;
-  
-  // Used for DataOutput methods writing values to the underlying file
-  private byte[] buf = new byte[8];
-  
-  /**
    * This method initializes a new instance of <code>RandomAccessFile</code>
    * to read from the specified <code>File</code> object with the specified 
    * access mode.   The access mode is either "r" for read only access or "rw" 
@@ -125,28 +120,27 @@
         !mode.equals("rwd"))
       throw new IllegalArgumentException("Bad mode value: " + mode);
   
+    int fdmode;
+    if (mode.compareTo ("r") == 0)
+      fdmode = FileDescriptor.READ;
+    else if (mode.compareTo ("rw") == 0)
+      fdmode = FileDescriptor.READ | FileDescriptor.WRITE;
+    else
+      throw new IllegalArgumentException ("invalid mode: " + mode);
+
     // The obligatory SecurityManager stuff
     SecurityManager s = System.getSecurityManager();
     if (s != null)
       {
         s.checkRead(fileName);
 
-        if (!mode.equals("r"))
+        if ((fdmode & FileDescriptor.WRITE) != 0)
           s.checkWrite(fileName);
       }
-  
-    if (mode.equals("r"))
-      readOnly = true;
-  
-    fd = new FileDescriptor();
-    try
-      {
-        fd.open(fileName, mode);
-      }
-    catch(IOException e)
-      {
-        throw new FileNotFoundException(e.getMessage()); 
-      }
+
+    fd = new FileDescriptor (fileName, fdmode);
+    out = new DataOutputStream (new FileOutputStream (fd));
+    in = new DataInputStream (new FileInputStream (fd));
   }
 
   /**
@@ -203,12 +197,9 @@
    *
    * @exception IOException If an error occurs
    */
-  public void setLength(long newlen) throws IOException
+  public void setLength (long pos) throws IOException
   {
-    if (readOnly)
-      throw new IOException("File is open read only");
-  
-    fd.setLength(newlen);
+    fd.setLength(pos);
   }
 
   /**
@@ -220,7 +211,7 @@
    */
   public long length () throws IOException
   {
-    return fd.getLength();
+    return fd.length();
   }
 
   /**
@@ -233,7 +224,7 @@
    */
   public int read () throws IOException
   {
-    return fd.read();
+    return in.read();
   }
 
   /**
@@ -249,7 +240,7 @@
    */
   public int read (byte[] buffer) throws IOException
   {
-    return read (buffer, 0, buffer.length);
+    return in.read (buffer);
   }
 
   /**
@@ -266,7 +257,7 @@
    */
   public int read (byte[] buffer, int offset, int len) throws IOException
   {
-    return fd.read (buffer, offset, len);
+    return in.read (buffer, offset, len);
   }
 
   /**
@@ -288,12 +279,7 @@
    */
   public final boolean readBoolean () throws IOException
   {
-    int byte_read = read();
-  
-    if (byte_read == -1)
-      throw new EOFException("Unexpected end of stream");
-  
-    return byte_read != 0;
+    return in.readBoolean ();
   }
 
   /**
@@ -313,41 +299,10 @@
    */
   public final byte readByte () throws IOException
   {
-    int byte_read = read ();
-  
-    if (byte_read == -1)
-      throw new EOFException ("Unexpected end of stream");
-  
-    return (byte) byte_read;
+    return in.readByte ();
   }
 
   /**
-   * This method reads 8 unsigned bits into a Java <code>int</code> value 
-   * from the 
-   * stream. The value returned is in the range of 0 to 255.
-   * <p>
-   * This method can read an unsigned byte written by an object implementing 
-   * the <code>writeUnsignedByte()</code> method in the 
-   * <code>DataOutput</code> interface.
-   *
-   * @return The unsigned bytes value read as a Java <code>int</code>
-   *
-   * @exception EOFException If end of file is reached before reading the value
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput
-   */
-  public final int readUnsignedByte () throws IOException
-  {
-    int byte_read = read ();
-  
-    if (byte_read == -1)
-      throw new EOFException ("Unexpected end of stream");
-  
-    return byte_read & 0xFF;
-  }
-  
-  /**
    * This method reads a Java <code>char</code> value from an input stream.  
    * It operates by reading two bytes from the stream and converting them to 
    * a single 16-bit Java <code>char</code>  The two bytes are stored most
@@ -372,162 +327,39 @@
    *
    * @see DataOutput
    */
-  public final synchronized char readChar () throws IOException
+  public final char readChar () throws IOException
   {
-    readFully (buf, 0, 2);
-  
-    return (char) ((buf[0] << 8) | (buf[1] & 0xff));
+    return in.readChar();
   }
 
   /**
-   * This method reads a signed 16-bit value into a Java in from the stream.
-   * It operates by reading two bytes from the stream and converting them to 
-   * a single 16-bit Java <code>short</code>  The two bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering. 
-   * <p>
-   * As an example, if <code>byte1</code> and code{byte2</code> 
-   * represent the first
-   * and second byte read from the stream respectively, they will be
-   * transformed to a <code>short</code> in the following manner:
-   * <p>
-   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>
-   * <p>
-   * The value returned is in the range of -32768 to 32767.
+   * This method reads a Java double value from an input stream.  It operates
+   * by first reading a <code>logn</code> value from the stream by calling the
+   * <code>readLong()</code> method in this interface, then 
+   * converts that <code>long</code>
+   * to a <code>double</code> using the <code>longBitsToDouble</code> 
+   * method in the class <code>java.lang.Double</code>
    * <p>
-   * This method can read a <code>short</code> written by an object 
+   * This method can read a <code>double</code> written by an object 
    * implementing the
-   * <code>writeShort()</code> method in the <code>DataOutput</code> interface.
+   * <code>writeDouble()</code> method in the <code>DataOutput</code> 
+   * interface.
    *
-   * @return The <code>short</code> value read
+   * @return The <code>double</code> value read
    *
-   * @exception EOFException If end of file is reached before reading the value
+   * @exception EOFException If end of file is reached before reading 
+   * the double
    * @exception IOException If any other error occurs
    *
+   * @see java.lang.Double
    * @see DataOutput
    */
-  public final synchronized short readShort () throws IOException
+  public final double readDouble () throws IOException
   {
-    readFully (buf, 0, 2);
-    
-    return (short) ((buf[0] << 8) | (buf[1] & 0xff));
+    return in.readDouble ();
   }
 
   /**
-   * This method reads 16 unsigned bits into a Java int value from the stream.
-   * It operates by reading two bytes from the stream and converting them to 
-   * a single Java <code>int</code>  The two bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering. 
-   * <p>
-   * As an example, if <code>byte1</code> and <code>byte2</code> 
-   * represent the first
-   * and second byte read from the stream respectively, they will be
-   * transformed to an <code>int</code> in the following manner:
-   * <p>
-   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>
-   * <p>
-   * The value returned is in the range of 0 to 65535.
-   * <p>
-   * This method can read an unsigned short written by an object implementing
-   * the <code>writeUnsignedShort()</code> method in the 
-   * <code>DataOutput</code> interface.
-   *
-   * @return The unsigned short value read as a Java <code>int</code>
-   *
-   * @exception EOFException If end of file is reached before reading the value
-   * @exception IOException If any other error occurs
-   */
-  public final synchronized int readUnsignedShort() 
-    throws IOException
-  {
-    readFully(buf, 0, 2);
-    
-    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));
-  }
-  
-  /**
-   * This method reads a Java <code>int</code> value from an input stream
-   * It operates by reading four bytes from the stream and converting them to 
-   * a single Java <code>int</code>  The bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering. 
-   * <p>
-   * As an example, if <code>byte1</code> through <code>byte4</code> 
-   * represent the first
-   * four bytes read from the stream, they will be
-   * transformed to an <code>int</code> in the following manner:
-   * <p>
-   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + 
-   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>
-   * <p>
-   * The value returned is in the range of 0 to 65535.
-   * <p>
-   * This method can read an <code>int</code> written by an object 
-   * implementing the
-   * <code>writeInt()</code> method in the <code>DataOutput</code> interface.
-   *
-   * @return The <code>int</code> value read
-   *
-   * @exception EOFException If end of file is reached before reading the int
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput
-   */
-  public final synchronized int readInt() throws IOException
-  {
-    readFully(buf, 0, 4);
-  
-    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |
-            ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));
-  }
-  
-  /**
-   * This method reads a Java long value from an input stream
-   * It operates by reading eight bytes from the stream and converting them to 
-   * a single Java <code>long</code>  The bytes are stored most
-   * significant byte first (i.e., "big endian") regardless of the native
-   * host byte ordering. 
-   * <p>
-   * As an example, if <code>byte1</code> through <code>byte8</code> 
-   * represent the first
-   * eight bytes read from the stream, they will be
-   * transformed to an <code>long</code> in the following manner:
-   * <p>
-   * <code>
-   * (long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + 
-   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + 
-   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + 
-   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>
-   * <p>
-   * The value returned is in the range of 0 to 65535.
-   * <p>
-   * This method can read an <code>long</code> written by an object 
-   * implementing the
-   * <code>writeLong()</code> method in the <code>DataOutput</code> interface.
-   *
-   * @return The <code>long</code> value read
-   *
-   * @exception EOFException If end of file is reached before reading the long
-   * @exception IOException If any other error occurs
-   *
-   * @see DataOutput
-   */
-  public final synchronized long readLong() throws IOException
-  {
-    readFully(buf, 0, 8);
-  
-    return (((long)(buf[0] & 0xff) << 56) |
-            ((long)(buf[1] & 0xff) << 48) |
-            ((long)(buf[2] & 0xff) << 40) |
-            ((long)(buf[3] & 0xff) << 32) |
-            ((long)(buf[4] & 0xff) << 24) |
-            ((long)(buf[5] & 0xff) << 16) |
-            ((long)(buf[6] & 0xff) <<  8) |
-            ((long)(buf[7] & 0xff)));
-  }
-  
-  /**
    * This method reads a Java float value from an input stream.  It operates
    * by first reading an <code>int</code> value from the stream by calling the
    * <code>readInt()</code> method in this interface, then converts 
@@ -547,11 +379,9 @@
    * @see java.lang.Float
    * @see DataOutput
    */
-  public final float readFloat() throws IOException
+  public final float readFloat () throws IOException
   {
-    int val = readInt();
-  
-    return Float.intBitsToFloat(val);
+    return in.readFloat();
   }
 
   /**
@@ -566,9 +396,9 @@
    * buffer
    * @exception IOException If any other error occurs
    */
-  public final void readFully (byte[] buf) throws IOException
+  public final void readFully (byte[] buffer) throws IOException
   {
-    readFully (buf, 0, buf.length);
+    in.readFully(buffer);
   }
 
   /**
@@ -588,48 +418,43 @@
    * the buffer
    * @exception IOException If any other error occurs
    */
-  public synchronized final void readFully (byte[] buf, int offset, int len) 
+  public final void readFully (byte[] buffer, int offset, int count)
     throws IOException
   {
-    int total_read = 0;
-  
-    while (total_read < len)
-      {
-        int bytes_read = read(buf, offset + total_read, len - total_read);
-        if (bytes_read == -1)
-          throw new EOFException("Unexpected end of stream");
-  
-        total_read += bytes_read;
-      }
+    in.readFully (buffer, offset, count);
   }
 
   /**
-   * This method reads a Java double value from an input stream.  It operates
-   * by first reading a <code>logn</code> value from the stream by calling the
-   * <code>readLong()</code> method in this interface, then 
-   * converts that <code>long</code>
-   * to a <code>double</code> using the <code>longBitsToDouble</code> 
-   * method in the class <code>java.lang.Double</code>
+   * This method reads a Java <code>int</code> value from an input stream
+   * It operates by reading four bytes from the stream and converting them to 
+   * a single Java <code>int</code>  The bytes are stored most
+   * significant byte first (i.e., "big endian") regardless of the native
+   * host byte ordering. 
    * <p>
-   * This method can read a <code>double</code> written by an object 
+   * As an example, if <code>byte1</code> through <code>byte4</code> 
+   * represent the first
+   * four bytes read from the stream, they will be
+   * transformed to an <code>int</code> in the following manner:
+   * <p>
+   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) + 
+   * ((byte3 & 0xFF) << 8) + (byte4 & 0xFF)))</code>
+   * <p>
+   * The value returned is in the range of 0 to 65535.
+   * <p>
+   * This method can read an <code>int</code> written by an object 
    * implementing the
-   * <code>writeDouble()</code> method in the <code>DataOutput</code> 
-   * interface.
+   * <code>writeInt()</code> method in the <code>DataOutput</code> interface.
    *
-   * @return The <code>double</code> value read
+   * @return The <code>int</code> value read
    *
-   * @exception EOFException If end of file is reached before reading 
-   * the double
+   * @exception EOFException If end of file is reached before reading the int
    * @exception IOException If any other error occurs
    *
-   * @see java.lang.Double
    * @see DataOutput
    */
-  public final double readDouble() throws IOException
+  public final int readInt () throws IOException
   {
-    long val = readLong();
-  
-    return Double.longBitsToDouble(val);
+    return in.readInt();
   }
 
   /**
@@ -659,398 +484,144 @@
    *
    * @deprecated
    */
-  public synchronized final String readLine() throws IOException
+  public final String readLine () throws IOException
   {
-    StringBuffer sb = new StringBuffer("");
-  
-    for (;;)
-      {
-        int byte_read = read();
-   
-        if (byte_read == -1)
-          return(sb.toString());
-  
-        char c = (char)byte_read;
-  
-        if (c == '\r')
-          {
-            byte_read = read();
-            if (((char)byte_read) != '\n')
-              seek(getFilePointer() - 1);
-  
-            return(sb.toString());
-          }
-  
-        if (c == '\n')
-          return(sb.toString());
-  
-        sb.append(c);
-      }
+    return in.readLine ();
   }
 
   /**
-   * This method reads a <code>String</code> from an input stream that 
-   * is encoded in
-   * a modified UTF-8 format.  This format has a leading two byte sequence
-   * that contains the remaining number of bytes to read.  This two byte
-   * sequence is read using the <code>readUnsignedShort()</code> method of this
-   * interface.
-   * <p>
-   * After the number of remaining bytes have been determined, these bytes
-   * are read an transformed into <code>char</code> values.  
-   * These <code>char</code> values
-   * are encoded in the stream using either a one, two, or three byte format.
-   * The particular format in use can be determined by examining the first
-   * byte read.  
-   * <p>
-   * If the first byte has a high order bit of 0 then
-   * that character consists on only one byte.  This character value consists
-   * of seven bits that are at positions 0 through 6 of the byte.  As an
-   * example, if <code>byte1</code> is the byte read from the stream, it would
-   * be converted to a <code>char</code> like so:
-   * <p>
-   * <code>(char)byte1</code>
-   * <p>
-   * If the first byte has <code>110</code> as its high order bits, then the 
-   * character consists of two bytes.  The bits that make up the character
-   * value are in positions 0 through 4 of the first byte and bit positions
-   * 0 through 5 of the second byte.  (The second byte should have 
-   * 10 as its high order bits).  These values are in most significant
-   * byte first (i.e., "big endian") order.
-   * <p>
-   * As an example, if <code>byte1</code> and <code>byte2</code> 
-   * are the first two bytes
-   * read respectively, and the high order bits of them match the patterns
-   * which indicate a two byte character encoding, then they would be
-   * converted to a Java <code>char</code> like so:
-   * <p>
-   * <code>(char)(((byte1 & 0x1F) << 6) | (byte2 & 0x3F))</code>
-   * <p>
-   * If the first byte has a <code>1110</code> as its high order bits, then the
-   * character consists of three bytes.  The bits that make up the character
-   * value are in positions 0 through 3 of the first byte and bit positions
-   * 0 through 5 of the other two bytes.  (The second and third bytes should
-   * have <code>10</code> as their high order bits).  These values are in most
-   * significant byte first (i.e., "big endian") order.
+   * This method reads a Java long value from an input stream
+   * It operates by reading eight bytes from the stream and converting them to 
+   * a single Java <code>long</code>  The bytes are stored most
+   * significant byte first (i.e., "big endian") regardless of the native
+   * host byte ordering. 
    * <p>
-   * As an example, if <code>byte1</code> <code>byte2</code> 
-   * and <code>byte3</code> are the
-   * three bytes read, and the high order bits of them match the patterns
-   * which indicate a three byte character encoding, then they would be
-   * converted to a Java <code>char</code> like so:
+   * As an example, if <code>byte1</code> through <code>byte8</code> 
+   * represent the first
+   * eight bytes read from the stream, they will be
+   * transformed to an <code>long</code> in the following manner:
    * <p>
-   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | 
-   * (byte3 & 0x3F))</code>
+   * <code>
+   * (long)((((long)byte1 & 0xFF) << 56) + (((long)byte2 & 0xFF) << 48) + 
+   * (((long)byte3 & 0xFF) << 40) + (((long)byte4 & 0xFF) << 32) + 
+   * (((long)byte5 & 0xFF) << 24) + (((long)byte6 & 0xFF) << 16) + 
+   * (((long)byte7 & 0xFF) << 8) + ((long)byte9 & 0xFF)))</code>
    * <p>
-   * Note that all characters are encoded in the method that requires the
-   * fewest number of bytes with the exception of the character with the
-   * value of <code>&#92;u0000</code> which is encoded as two bytes.  This is 
-   * a  modification of the UTF standard used to prevent C language style
-   * <code>NUL</code> values from appearing in the byte stream.
+   * The value returned is in the range of 0 to 65535.
    * <p>
-   * This method can read data that was written by an object implementing the
-   * <code>writeUTF()</code> method in <code>DataOutput</code>
-   * 
-   * @return The <code>String</code> read
+   * This method can read an <code>long</code> written by an object 
+   * implementing the
+   * <code>writeLong()</code> method in the <code>DataOutput</code> interface.
    *
-   * @exception EOFException If end of file is reached before reading the 
-   * String
-   * @exception UTFDataFormatException If the data is not in UTF-8 format
+   * @return The <code>long</code> value read
+   *
+   * @exception EOFException If end of file is reached before reading the long
    * @exception IOException If any other error occurs
    *
    * @see DataOutput
    */
-  public synchronized final String readUTF() 
-    throws IOException
+  public final long readLong () throws IOException
   {
-    StringBuffer sb = new StringBuffer("");
-  
-    int num_bytes = readUnsignedShort();
-    byte[] buf = new byte[num_bytes];
-    readFully(buf);
-  
-    // FIXME: Look to migrate to new String(buf, "UTF-8") if performance ok
-    return DataInputStream.convertFromUTF(buf);
+    return in.readLong();
   }
-  
-  /**
-   * This method sets the current file position to the specified offset 
-   * from the beginning of the file.  Note that some operating systems will
-   * allow the file pointer to be set past the current end of the file.
-   *
-   * @param pos The offset from the beginning of the file at which to set 
-   * the file pointer
-   *
-   * @exception IOException If an error occurs
-   */
-  public void seek(long pos) throws IOException
+
+  public final short readShort () throws IOException
   {
-    fd.seek(pos, fd.SET, false);
+    return in.readShort();
   }
-  
-  /**
-   * This method attempts to skip and discard the specified number of bytes 
-   * in the input stream.  It may actually skip fewer bytes than requested. 
-   * The actual number of bytes skipped is returned.  This method will not
-   * skip any bytes if passed a negative number of bytes to skip.
-   *
-   * @param numBytes The requested number of bytes to skip.
-   *
-   * @return The number of bytes actually skipped.
-   *
-   * @exception IOException If an error occurs.
-   */
-  public int skipBytes(int numBytes) throws IOException
+
+  public final int readUnsignedByte () throws IOException
   {
-    if (numBytes < 0)
-      throw new IllegalArgumentException("Can't skip negative bytes: " +
-                                         numBytes);
+    return in.readUnsignedByte();
+  }
 
-    if (numBytes == 0)
-      return(0);
+  public final int readUnsignedShort () throws IOException
+  {
+    return in.readUnsignedShort();
+  }
 
-    long curPos = fd.getFilePointer();
-    long newPos = fd.seek(numBytes, fd.CUR, true);
+  public final String readUTF () throws IOException
+  {
+    return in.readUTF();
+  }
 
-    return((int)(newPos-curPos));
+  public void seek (long pos) throws IOException
+  {
+    fd.seek(pos, FileDescriptor.SET, false);
   }
-  
-  /**
-   * This method writes a single byte of data to the file. The file must
-   * be open for read-write in order for this operation to succeed.
-   *
-   * @param The byte of data to write, passed as an int.
-   *
-   * @exception IOException If an error occurs
-   */
-  public void write(int b) throws IOException
+
+  public int skipBytes (int count) throws IOException
   {
-    if (readOnly)
-      throw new IOException("File is open read only");
-  
-    fd.write(b);
+    if (count <= 0)
+      return 0;
+    long startPos = fd.getFilePointer();
+    long endPos = fd.seek(count, FileDescriptor.CUR, true);
+    return (int) (endPos - startPos);
   }
-  
-  /**
-   * This method writes all the bytes in the specified array to the file.
-   * The file must be open read-write in order for this operation to succeed.
-   *
-   * @param buf The array of bytes to write to the file
-   */
-  public void write(byte[] buf) throws IOException
+
+  public void write (int oneByte) throws IOException
   {
-    write(buf, 0, buf.length);
+    out.write(oneByte);
   }
-    
-  /**
-   * This method writes <code>len</code> bytes to the file from the specified
-   * array starting at index <code>offset</code> into the array.
-   *
-   * @param buf The array of bytes to write to the file
-   * @param offset The index into the array to start writing file
-   * @param len The number of bytes to write
-   *
-   * @exception IOException If an error occurs
-   */
-  public void write(byte[] buf, int offset, int len) throws IOException
+
+  public void write (byte[] buffer) throws IOException
   {
-    if (readOnly)
-      throw new IOException("File is open read only");
-  
-    fd.write(buf, offset, len);
+    out.write(buffer);
   }
-  
-  /**
-   * This method writes a Java <code>boolean</code> to the underlying output 
-   * stream. For a value of <code>true</code>, 1 is written to the stream.
-   * For a value of <code>false</code>, 0 is written.
-   *
-   * @param b The <code>boolean</code> value to write to the stream
-   *
-   * @exception IOException If an error occurs
-   */
-  public final void writeBoolean (boolean b) throws IOException
+
+  public void write (byte[] buffer, int offset, int count) throws IOException
   {
-    write (b ? 1 : 0);
+    out.write(buffer, offset, count);
   }
-  
-  /**
-   * This method writes a Java <code>byte</code> value to the underlying
-   * output stream.
-   *
-   * @param b The <code>byte</code> to write to the stream, passed 
-   * as an <code>int</code>.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final void writeByte(int b) throws IOException
+
+  public final void writeBoolean (boolean val) throws IOException
   {
-    write (b & 0xFF);
+    out.writeBoolean(val);
   }
-  
-  /**
-   * This method writes all the bytes in a <code>String</code> out to the
-   * stream.  One byte is written for each character in the <code>String</code>.
-   * The high eight bits of each character are discarded.
-   *
-   * @param s The <code>String</code> to write to the stream
-   *
-   * @exception IOException If an error occurs
-   */
-  public final void writeBytes (String s) throws IOException
+
+  public final void writeByte (int v) throws IOException
   {
-    int len = s.length();
+    out.writeByte(v);
+  }
 
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len];
-  
-    for (int i = 0; i < len; i++)
-      buf[i] = (byte)(s.charAt(i) & 0xFF);
-  
-    write(buf);
+  public final void writeShort (int v) throws IOException
+  {
+    out.writeShort(v);
   }
-  
-  /**
-   * This method writes a single <code>char</code> value to the stream,
-   * high byte first.
-   *
-   * @param c The <code>char</code> value to write, passed as 
-   * an <code>int</code>.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final synchronized void writeChar(int c) throws IOException
+
+  public final void writeChar (int v) throws IOException
   {
-    buf[0] = (byte)((c & 0xFF00) >> 8);
-    buf[1] = (byte)((int)c & 0x00FF);
-  
-    write(buf, 0, 2);
+    out.writeChar(v);
   }
-  
-  /**
-   * This method writes all the characters in a <code>String</code> to the
-   * stream.  There will be two bytes for each character value.  The high
-   * byte of the character will be written first.
-   *
-   * @param s The <code>String</code> to write to the stream.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final void writeChars(String s) throws IOException
+
+  public final void writeInt (int v) throws IOException
   {
-    int len = s.length();
-    if (len == 0)
-      return;
-  
-    byte[] buf = new byte[len * 2];
-  
-    for (int i = 0; i < len; i++)
-      {
-        buf[i * 2] = (byte)((s.charAt(i) & 0xFF00) >> 8);
-        buf[(i * 2) + 1] = (byte)(s.charAt(i) & 0x00FF);
-      }
-  
-    write(buf, 0, buf.length);
+    out.writeInt(v);
   }
-  
-  /**
-   * This method writes a Java <code>short</code> to the stream, high byte
-   * first.  This method requires two bytes to encode the value.
-   *
-   * @param s The <code>short</code> value to write to the stream, 
-   * passed as an <code>int</code>.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final synchronized void writeShort(int s) throws IOException
+
+  public final void writeLong (long v) throws IOException
   {
-    buf[0] = (byte)((s & 0xFF00) >> 8);
-    buf[1] = (byte)(s & 0x00FF);
-  
-    write(buf, 0, 2);
+    out.writeLong(v);
   }
-  
-  /**
-   * This method writes a Java <code>int</code> to the stream, high bytes
-   * first.  This method requires four bytes to encode the value.
-   *
-   * @param i The <code>int</code> value to write to the stream.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final synchronized void writeInt(int i) throws IOException
+
+  public final void writeFloat (float v) throws IOException
   {
-    buf[0] = (byte)((i & 0xFF000000) >> 24);
-    buf[1] = (byte)((i & 0x00FF0000) >> 16);
-    buf[2] = (byte)((i & 0x0000FF00) >> 8);
-    buf[3] = (byte)(i & 0x000000FF);
-  
-    write(buf, 0, 4);
+    out.writeFloat(v);
   }
-  
-  /**
-   * This method writes a Java <code>long</code> to the stream, high bytes
-   * first.  This method requires eight bytes to encode the value.
-   *
-   * @param l The <code>long</code> value to write to the stream.
-   *
-   * @exception IOException If an error occurs
-   */
-  public final synchronized void writeLong(long l) throws IOException
+
+  public final void writeDouble (double v) throws IOException
   {
-    buf[0] = (byte)((l & 0xFF00000000000000L) >> 56);
-    buf[1] = (byte)((l & 0x00FF000000000000L) >> 48);
-    buf[2] = (byte)((l & 0x0000FF0000000000L) >> 40);
-    buf[3] = (byte)((l & 0x000000FF00000000L) >> 32);
-    buf[4] = (byte)((l & 0x00000000FF000000L) >> 24);
-    buf[5] = (byte)((l & 0x0000000000FF0000L) >> 16);
-    buf[6] = (byte)((l & 0x000000000000FF00L) >> 8);
-    buf[7] = (byte)(l & 0x00000000000000FFL);
-  
-    write(buf, 0, 8);
+    out.writeDouble(v);
   }
-  
-  /**
-   * This method writes a Java <code>float</code> value to the stream.  This
-   * value is written by first calling the method 
-   * <code>Float.floatToIntBits</code>
-   * to retrieve an <code>int</code> representing the floating point number,
-   * then writing this <code>int</code> value to the stream exactly the same
-   * as the <code>writeInt()</code> method does.
-   *
-   * @param f The floating point number to write to the stream.
-   *
-   * @exception IOException If an error occurs
-   *
-   * @see #writeInt(int)
-   */
-  public final void writeFloat(float f) throws IOException
+
+  public final void writeBytes (String s) throws IOException
   {
-    int i = Float.floatToIntBits(f);
-    writeInt(i);
+    out.writeBytes(s);
   }
-  
-  /**
-   * This method writes a Java <code>double</code> value to the stream.  This
-   * value is written by first calling the method 
-   * <code>Double.doubleToLongBits</code>
-   * to retrieve an <code>long</code> representing the floating point number,
-   * then writing this <code>long</code> value to the stream exactly the same
-   * as the <code>writeLong()</code> method does.
-   *
-   * @param d The double precision floating point number to write to the 
-   * stream.
-   *
-   * @exception IOException If an error occurs
-   *
-   * @see #writeLong(long)
-   */
-  public final void writeDouble(double d) throws IOException
+
+  public final void writeChars (String s) throws IOException
   {
-    long l = Double.doubleToLongBits(d);
-    writeLong(l);
+    out.writeChars(s);
   }
   
   /**
@@ -1084,11 +655,7 @@
    */
   public final void writeUTF(String s) throws IOException
   {
-    // FIXME:  Look to migrate to s.getBytes("UTF-8") if performance ok
-    byte[] buf = DataOutputStream.convertToUTF(s);
-  
-    writeShort(buf.length);
-    write(buf);
+    out.writeUTF(s);
   }
   
   /**
@@ -1100,7 +667,7 @@
   public synchronized FileChannel getChannel() 
   {
     if (ch == null)
-      ch = new FileChannelImpl ((int) (fd.getNativeFd() & 0xFFFF), this);
+      ch = new FileChannelImpl (fd, true, this);
 
     return ch;
   }
