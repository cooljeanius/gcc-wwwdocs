--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/OutputStreamWriter.java	Mon Mar 10 02:19:32 2003
+++ java/io/OutputStreamWriter.java	Sun Mar 23 02:18:02 2003
@@ -1,5 +1,5 @@
 /* OutputStreamWriter.java -- Writer that converts chars to bytes
-   Copyright (C) 1998, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,181 +37,171 @@
 
 
 package java.io;
-
-import gnu.java.io.EncodingManager;
-import gnu.java.io.encode.Encoder;
+import gnu.gcj.convert.UnicodeToBytes;
 
 /**
-  * This class writes characters to an output stream that is byte oriented
-  * It converts the chars that are written to bytes using an encoding layer,
-  * which is specific to a particular encoding standard.  The desired
-  * encoding can either be specified by name, or if no encoding is specified,
-  * the system default encoding will be used.  The system default encoding
-  * name is determined from the system property <code>file.encoding</code>.
-  * The only encodings that are guaranteed to be available are "8859_1"
-  * (the Latin-1 character set) and "UTF8".  Unfortunately, Java does not
-  * provide a mechanism for listing the encodings that are supported in
-  * a given implementation.
-  * <p>
-  * Here is a list of standard encoding names that may be available:
-  * <p>
-  * <ul>
-  * <li>8859_1 (ISO-8859-1/Latin-1)
-  * <li>8859_2 (ISO-8859-2/Latin-2)
-  * <li>8859_3 (ISO-8859-3/Latin-3)
-  * <li>8859_4 (ISO-8859-4/Latin-4)
-  * <li>8859_5 (ISO-8859-5/Latin-5)
-  * <li>8859_6 (ISO-8859-6/Latin-6)
-  * <li>8859_7 (ISO-8859-7/Latin-7)
-  * <li>8859_8 (ISO-8859-8/Latin-8)
-  * <li>8859_9 (ISO-8859-9/Latin-9)
-  * <li>ASCII (7-bit ASCII)
-  * <li>UTF8 (UCS Transformation Format-8)
-  * <li>More Later
-  * </ul>
-  *
-  * @author Aaron M. Renn (arenn@urbanophile.com)
-  */
+ * @author Per Bothner <bothner@cygnus.com>
+ * @date April 17, 1998.  
+ */
+/* Written using "Java Class Libraries", 2nd edition, plus online
+ * API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status:  Believed complete and correct, but only supports 8859_1.
+ */
+
 public class OutputStreamWriter extends Writer
 {
-  /**
-    * This is the byte-character encoder class that does the writing and
-    * translation of characters to bytes before writing to the underlying
-    * class.
-    */
-  private Encoder out;
-
-  /*************************************************************************/
-
-  /*
-   * Constructors
-   */
-
-  /**
-    * This method initializes a new instance of <code>OutputStreamWriter</code>
-    * to write to the specified stream using the default encoding.
-    *
-    * @param out The <code>OutputStream</code> to write to
-    */
-  public OutputStreamWriter(OutputStream out)
-  {
-    this.out = EncodingManager.getEncoder(out);
-  }
+  BufferedOutputStream out;
 
-  /*************************************************************************/
+  UnicodeToBytes converter;
 
-  /**
-    * This method initializes a new instance of <code>OutputStreamWriter</code>
-    * to write to the specified stream using a caller supplied character
-    * encoding scheme.  Note that due to a deficiency in the Java language
-    * design, there is no way to determine which encodings are supported.
-    *
-    * @param out The <code>OutputStream</code> to write to
-    * @param encoding_scheme The name of the encoding scheme to use for 
-    * character to byte translation
-    *
-    * @exception UnsupportedEncodingException If the named encoding is 
-    * not available.
-    */
-  public OutputStreamWriter(OutputStream out, String encoding_scheme) 
-    throws UnsupportedEncodingException
-  {
-    this.out = EncodingManager.getEncoder(out, encoding_scheme);
-  }
-
-  /*************************************************************************/
-
-  /*
-   * Instance Methods
-   */
-
-  /**
-    * This method closes this stream, and the underlying 
-    * <code>OutputStream</code>
-    *
-    * @exception IOException If an error occurs
-    */
-  public void close() throws IOException
+  /* Temporary buffer. */
+  private char[] work;
+  private int wcount;
+
+  public String getEncoding()
   {
-    out.close();
+    return out != null ? converter.getName() : null;
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method flushes any buffered bytes to the underlying output sink.
-    *
-    * @exception IOException If an error occurs
-    */
-  public void flush() throws IOException
+  private OutputStreamWriter(OutputStream out, UnicodeToBytes encoder)
   {
-    out.flush();
+    this.out = out instanceof BufferedOutputStream 
+	       ? (BufferedOutputStream) out
+	       : new BufferedOutputStream(out, 250);
+    /* Don't need to call super(out) here as long as the lock gets set. */
+    this.lock = out;
+    this.converter = encoder;
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method returns the name of the character encoding scheme currently
-    * in use by this stream.  If the stream has been closed, then this method
-    * may return <code>null</code>.
-    *
-    * @return The encoding scheme name
-    */
-  public String getEncoding()
+  public OutputStreamWriter(OutputStream out, String enc)
+   throws UnsupportedEncodingException
   {
-    return(out.getSchemeName());
+    this(out, UnicodeToBytes.getEncoder(enc));
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method writes a single character to the output stream.
-    *
-    * @param c The char to write, passed as an int.
-    *
-    * @exception IOException If an error occurs
-    */
-  public void write(int c) throws IOException
+  public OutputStreamWriter(OutputStream out)
   {
-    out.write(c);
+    this(out, UnicodeToBytes.getDefaultEncoder());
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method writes <code>len</code> characters from the specified
-    * array to the output stream starting at position <code>offset</code>
-    * into the array.
-    *
-    * @param buf The array of character to write from
-    * @param offset The offset into the array to start writing chars from
-    * @param len The number of chars to write.
-    *
-    * @exception IOException If an error occurs
-    */
-  public void write(char[] buf, int offset, int len) throws IOException
+  public void close() throws IOException
   {
-    out.write(buf, offset, len);
+    synchronized (lock)
+      {
+	if (out != null)
+	  {
+	    flush();
+	    out.close();
+	    out = null;
+	  }
+	work = null;
+      }
   }
 
-  /*************************************************************************/
-
-  /**
-    * This method writes <code>len</code> bytes from the specified 
-    * <code>String</code> starting at position <code>offset</code> into the
-    * <code>String</code>.
-    *
-    * @param str The <code>String</code> to write chars from
-    * @param offset The position in the <code>String</code> to start 
-    * writing chars from
-    * @param len The number of chars to write
-    *
-    * @exception IOException If an error occurs
-    */
-  public void write(String str, int offset, int len) throws IOException
+  public void flush() throws IOException
   {
-    out.write(str, offset, len);
+    synchronized (lock)
+      {
+	if (out == null)
+	  throw new IOException("Stream closed");
+
+	if (wcount > 0)
+	  {
+	    writeChars(work, 0, wcount);
+	    wcount = 0;
+	  }
+	out.flush();
+      }
+  }
+
+  public void write(char[] buf, int offset, int count)
+     throws IOException
+  {
+    synchronized (lock)
+      {
+	if (out == null)
+	  throw new IOException("Stream closed");
+
+	if (wcount > 0)
+	  {
+	    writeChars(work, 0, wcount);
+	    wcount = 0;
+	  }
+	writeChars(buf, offset, count);
+      }
+  }
+
+  /** Writes characters through to the inferior BufferedOutputStream.
+   * Ignores wcount and the work buffer. */
+  private void writeChars(char[] buf, int offset, int count)
+    throws IOException
+  {
+    while (count > 0)
+      {
+	// We must flush if out.count == out.buf.length.
+	// It is probably a good idea to flush if out.buf is almost full.
+	// This test is an approximation for "almost full".
+	if (out.count + count >= out.buf.length)
+	  {
+	    out.flush();
+	    if (out.count != 0)
+	      throw new IOException("unable to flush output byte buffer");
+	  }
+	converter.setOutput(out.buf, out.count);
+	int converted = converter.write(buf, offset, count);
+	offset += converted;
+	count -= converted;
+	out.count = converter.count;
+      }
+  }
+
+  public void write(String str, int offset, int count)
+     throws IOException
+  {
+    synchronized (lock)
+      {
+	if (out == null)
+	  throw new IOException("Stream closed");
+
+	if (work == null)
+	  work = new char[100];
+	int wlength = work.length;
+	while (count > 0)
+	  {
+	    int size = count;
+	    if (wcount + size > wlength)
+	      {
+		if (2*wcount > wlength)
+		  {
+		    writeChars(work, 0, wcount);
+		    wcount = 0;
+		  }
+		if (wcount + size > wlength)
+		  size = wlength - wcount;
+	      }
+	    str.getChars(offset, offset+size, work, wcount);
+	    offset += size;
+	    count -= size;
+	    wcount += size;
+	  }
+      }
+  }
+
+  public void write(int ch) throws IOException
+  {
+    synchronized (lock)
+      {
+	if (out == null)
+	  throw new IOException("Stream closed");
+
+	if (work == null)
+	  work = new char[100];
+	if (wcount >= work.length)
+	  {
+	    writeChars(work, 0, wcount);
+	    wcount = 0;
+	  }
+	work[wcount++] = (char) ch;
+      }
   }
-
-} // class OutputStreamWriter
-
+}
