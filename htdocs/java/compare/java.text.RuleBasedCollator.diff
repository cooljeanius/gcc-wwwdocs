--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2003-05-01 02:23:14.000000000 -0600
+++ java/text/RuleBasedCollator.java	2003-05-01 02:21:57.000000000 -0600
@@ -1,6 +1,6 @@
 /* RuleBasedCollator.java -- Concrete Collator Class
-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
 
+/* Copyright (C) 1999, 2000, 2001  Free Software Foundation
 This file is part of GNU Classpath.
 
 GNU Classpath is free software; you can redistribute it and/or modify
@@ -38,471 +38,364 @@
 
 package java.text;
 
+import java.util.Enumeration;
+import java.util.Hashtable;
 import java.util.Vector;
 
+/* Written using "Java Class Libraries", 2nd edition, plus online
+ * API docs for JDK 1.2 from http://www.javasoft.com.
+ * Status: Believed complete and correct
+ */
+
 /**
- * This class is a concrete subclass of <code>Collator</code> suitable
- * for string collation in a wide variety of languages.  An instance of
- * this class is normally returned by the <code>getInstance</code> method
- * of <code>Collator</code> with rules predefined for the requested
- * locale.  However, an instance of this class can be created manually
- * with any desired rules.
- * <p>
- * Rules take the form of a <code>String</code> with the following syntax
- * <ul>
- * <li> Modifier: '@' 
- * <li> Relation: '<' | ';' | ',' | '=' : <text>
- * <li> Reset: '&' : <text>
- * </ul>
- * The modifier character indicates that accents sort backward as is the
- * case with French.  The relational operators specify how the text 
- * argument relates to the previous term.  The relation characters have
- * the following meanings:
- * <ul>
- * <li>'<' - The text argument is greater than the prior term at the primary
- * difference level.
- * <li>';' - The text argument is greater than the prior term at the secondary
- * difference level.
- * <li>',' - The text argument is greater than the prior term at the tertiary
- * difference level.
- * <li>'=' - The text argument is equal to the prior term
- * </ul>
- * <p>
- * As for the text argument itself, this is any sequence of Unicode
- * characters not in the following ranges: 0x0009-0x000D, 0x0020-0x002F,
- * 0x003A-0x0040, 0x005B-0x0060, and 0x007B-0x007E. If these characters are 
- * desired, they must be enclosed in single quotes.  If any whitespace is 
- * encountered, it is ignored.  (For example, "a b" is equal to "ab").  
- * <p>
- * The reset operation inserts the following rule at the point where the
- * text argument to it exists in the previously declared rule string.  This
- * makes it easy to add new rules to an existing string by simply including
- * them in a reset sequence at the end.  Note that the text argument, or
- * at least the first character of it, must be present somewhere in the
- * previously declared rules in order to be inserted properly.  If this
- * is not satisfied, a <code>ParseException</code> will be thrown. 
- * <p>
- * This system of configuring <code>RuleBasedCollator</code> is needlessly
- * complex and the people at Taligent who developed it (along with the folks
- * at Sun who accepted it into the Java standard library) deserve a slow
- * and agonizing death.
- * <p>
- * Here are a couple of example of rule strings:
- * <p>
- * "< a < b < c" - This string says that a is greater than b which is 
- * greater than c, with all differences being primary differences.
- * <p>
- * "< a,A < b,B < c,C" - This string says that 'A' is greater than 'a' with
- * a tertiary strength comparison.  Both 'b' and 'B' are greater than 'a' and
- * 'A' during a primary strength comparison.  But 'B' is greater than 'b'
- * under a tertiary strength comparison.
- * <p>
- * "< a < c & a < b " - This sequence is identical in function to the 
- * "< a < b < c" rule string above.  The '&' reset symbol indicates that
- * the rule "< b" is to be inserted after the text argument "a" in the
- * previous rule string segment.
- * <p>
- * "< a < b & y < z" - This is an error.  The character 'y' does not appear
- * anywhere in the previous rule string segment so the rule following the
- * reset rule cannot be inserted.
- * <p>
- * For a description of the various comparison strength types, see the
- * documentation for the <code>Collator</code> class.
- * <p>
- * As an additional complication to this already overly complex rule scheme,
- * if any characters precede the first rule, these characters are considered
- * ignorable.  They will be treated as if they did not exist during 
- * comparisons.  For example, "- < a < b ..." would make '-' an ignorable
- * character such that the strings "high-tech" and "hightech" would
- * be considered identical.
- * <p>
- * A <code>ParseException</code> will be thrown for any of the following
- * conditions:
- * <ul>
- * <li>Unquoted punctuation characters in a text argument.
- * <li>A relational or reset operator not followed by a text argument
- * <li>A reset operator where the text argument is not present in
- * the previous rule string section.
- * </ul>
- *
- * @author Aaron M. Renn (arenn@urbanophile.com)
+ * @author Tom Tromey <tromey@cygnus.com>
+ * @date March 25, 1999
  */
-public class RuleBasedCollator extends Collator
+
+final class RBCElement
 {
-  class CollationElement
+  String key;
+  char relation;
+
+  RBCElement (String key, char relation)
   {
-    String char_seq;
-    int primary;
-    short secondary;
-    short tertiary;
-
-    CollationElement(String char_seq, int primary, short secondary, short tertiary)
-    {
-      this.char_seq = char_seq;
-      this.primary = primary;
-      this.secondary = secondary;
-      this.tertiary = tertiary;
-    }
- 
-  } // inner class CollationElement
+    this.key = key;
+    this.relation = relation;
+  }
+}
+
+public class RuleBasedCollator extends Collator
+{
+  // True if we are using French-style accent ordering.
+  private boolean frenchAccents;
 
   /**
    * This the the original rule string.
    */
   private String rules;
 
-  /**
-   * This is the table of collation element values
-   */
-  private Object[] ce_table;
+  // This maps strings onto collation values.
+  private Hashtable map;
+  
+  // An entry in this hash means that more lookahead is required for
+  // the prefix string.
+  private Hashtable prefixes;
+  
+  public Object clone ()
+  {
+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();
+    c.map = (Hashtable) map.clone ();
+    c.prefixes = (Hashtable) map.clone ();
+    return c;
+  }
 
-  /**
-   * This method initializes a new instance of <code>RuleBasedCollator</code>
-   * with the specified collation rules.  Note that an application normally
-   * obtains an instance of <code>RuleBasedCollator</code> by calling the
-   * <code>getInstance</code> method of <code>Collator</code>.  That method
-   * automatically loads the proper set of rules for the desired locale.
-   *
-   * @param rules The collation rule string.
-   *
-   * @exception ParseException If the rule string contains syntax errors.
-   */
-  public RuleBasedCollator(String rules) throws ParseException
+  // A helper for CollationElementIterator.next().
+  int ceiNext (CollationElementIterator cei)
   {
-    this.rules = rules;
+    if (cei.lookahead_set)
+      {
+	cei.lookahead_set = false;
+	return cei.lookahead;
+      }
 
-    if (rules.equals(""))
-      throw new IllegalArgumentException("Empty rule set");
+    int save = cei.index;
+    int max = cei.text.length();
+    String s = null;
+
+    // It is possible to have a case where `abc' has a mapping, but
+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as
+    // nothing special.
+    boolean found = false;
 
-    Vector v = new Vector();
-    boolean ignore_chars = true;
-    int primary_seq = 0;
-    short secondary_seq = 0;
-    short tertiary_seq = 0;
-    StringBuffer sb = new StringBuffer("");
-    for (int i = 0; i < rules.length(); i++)
+    int i;
+    for (i = save + 1; i <= max; ++i)
       {
-        char c = rules.charAt(i);
+	s = cei.text.substring(save, i);
+	if (prefixes.get(s) == null)
+	  break;
+	found = true;
+      }
+    // Assume s != null.
+
+    Object obj = map.get(s);
+    // The special case.
+    while (found && obj == null && s.length() > 1)
+      {
+	--i;
+	s = cei.text.substring(save, i);
+	obj = map.get(s);
+      }
 
-        // Check if it is a whitespace character
-        if (((c >= 0x09) && (c <= 0x0D)) || (c == 0x20))
-          continue;
-
-        // Primary difference
-        if (c == '<')
-          {
-            ignore_chars = false;
-            secondary_seq = 0;
-            tertiary_seq = 0;
-            ++primary_seq;
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Secondary difference
-        if (c == ';')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            ++secondary_seq;
-            tertiary_seq = 0;
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Tertiary difference
-        if (c == ',')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            ++tertiary_seq;
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Is equal to
-        if (c == '=')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Sort accents backwards
-        if (c == '@')
-          {
-            throw new ParseException("French style accents not implemented yet", 0);
-          }
-
-        // Reset command
-        if (c == '&')
-          {
-            throw new ParseException("Reset not implemented yet", 0);
-          }
-
-        // See if we are still reading characters to skip
-        if (ignore_chars == true)
-          {
-            CollationElement e = new CollationElement(c + "", 0, (short)0, 
-                                                      (short)0);
-            v.add(e);
-            continue;
-          }
+    // Update state.
+    cei.index = i;
 
-        sb.append(c);
+    if (obj == null)
+      {
+	// This idea, and the values, come from JDK.
+	// assert (s.length() == 1)
+	cei.lookahead_set = true;
+	cei.lookahead = s.charAt(0) << 8;
+	return 0x7fff << 16;
       }
 
-    ce_table = v.toArray();
+    return ((Integer) obj).intValue();
   }
 
-  /**
-   * This method returns a <code>String</code> containing the collation rules
-   * for this object.
-   *
-   * @return The collation rules for this object.
-   */
-  public String getRules()
+  // A helper for compareTo() that returns the next character that has
+  // a nonzero ordering at the indicated strength.  This is also used
+  // in CollationKey.
+  static final int next (CollationElementIterator iter, int strength)
   {
-    return(rules);
+    while (true)
+      {
+	int os = iter.next();
+	if (os == CollationElementIterator.NULLORDER)
+	  return os;
+	int c = 0;
+	switch (strength)
+	  {
+	  case PRIMARY:
+	    c = os & ~0xffff;
+	    break;
+	  case SECONDARY:
+	    c = os & ~0x00ff;
+	    break;
+	  case TERTIARY:
+	  case IDENTICAL:
+	    c = os;
+	    break;
+	  }
+	if (c != 0)
+	  return c;
+      }
   }
 
-  /**
-   * This method calculates the collation element value for the specified
-   * character(s).
-   */
-  int getCollationElementValue(String str)
+  public int compare (String source, String target)
   {
-    CollationElement e = null;
+    CollationElementIterator cs, ct;
 
-    // The table is sorted.  Change to a binary search later.
-    for (int i = 0; i < ce_table.length; i++) 
-      if (((CollationElement)ce_table[i]).char_seq.equals(str))
-        {
-          e = (CollationElement)ce_table[i];
-          break;
-        }
+    cs = new CollationElementIterator (source, this);
+    ct = new CollationElementIterator (target, this);
 
-    if (e == null)
-      e = new CollationElement(str, 0xFFFF, (short)0xFF, (short)0xFF);
+    while (true)
+      {
+	int os = next (cs, strength);
+	int ot = next (ct, strength);
 
-    int retval = (e.primary << 16) + (e.secondary << 8) + e.tertiary;
+	if (os == CollationElementIterator.NULLORDER
+	    && ot == CollationElementIterator.NULLORDER)
+	  break;
+	else if (os == CollationElementIterator.NULLORDER)
+	  {
+	    // Source string is shorter, so return "less than".
+	    return -1;
+	  }
+	else if (ot == CollationElementIterator.NULLORDER)
+	  {
+	    // Target string is shorter, so return "greater than".
+	    return 1;
+	  }
+
+	if (os != ot)
+	  return os - ot;
+      }
 
-    return(retval);
+    return 0;
   }
 
-  /**
-   * This method returns an instance for <code>CollationElementIterator</code>
-   * for the specified <code>String</code> under the collation rules for this
-   * object.
-   *
-   * @param str The <code>String</code> to return the <code>CollationElementIterator</code> instance for.
-   *
-   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
-   */
-  public CollationElementIterator getCollationElementIterator(String str)
+  public boolean equals (Object obj)
   {
-    return(new CollationElementIterator(this, str));
-  }  
+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))
+      return false;
+    RuleBasedCollator rbc = (RuleBasedCollator) obj;
+    // FIXME: this is probably wrong.  Instead we should compare maps
+    // directly.
+    return (frenchAccents == rbc.frenchAccents
+	    && rules.equals(rbc.rules));
+  }
 
-  /**
-   * This method returns an instance of <code>CollationElementIterator</code>
-   * for the <code>String</code> represented by the specified
-   * <code>CharacterIterator</code>.
-   *
-   * @param ci The <code>CharacterIterator</code> with the desired <code>String</code>.
-   *
-   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
-   */
-  public CollationElementIterator getCollationElementIterator(CharacterIterator ci)
+  public CollationElementIterator getCollationElementIterator (String source)
   {
-    StringBuffer sb = new StringBuffer("");
-
-    // Right now we assume that we will read from the beginning of the string.
-    char c = ci.first();
-    while (c != CharacterIterator.DONE) 
-      {
-        sb.append(c);
-        c = ci.next();
-      }
-
-    return(getCollationElementIterator(sb.toString()));
+    StringBuffer expand = new StringBuffer (source.length());
+    int max = source.length();
+    for (int i = 0; i < max; ++i)
+      decomposeCharacter (source.charAt(i), expand);
+    return new CollationElementIterator (expand.toString(), this);
   }
 
-  /**
-   * This method returns an integer which indicates whether the first
-   * specified <code>String</code> is less than, greater than, or equal to
-   * the second.  The value depends not only on the collation rules in
-   * effect, but also the strength and decomposition settings of this object.
-   *
-   * @param s1 The first <code>String</code> to compare.
-   * @param s2 A second <code>String</code> to compare to the first.
-   *
-   * @return A negative integer if s1 &lt; s2, a positive integer
-   * if s1 &gt; s2, or 0 if s1 == s2.
-   */
-  public int compare(String s1, String s2)
+  public CollationElementIterator getCollationElementIterator (CharacterIterator source)
   {
-    CollationElementIterator cei1 = getCollationElementIterator(s1);
-    CollationElementIterator cei2 = getCollationElementIterator(s2);
+    StringBuffer expand = new StringBuffer ();
+    for (char c = source.first ();
+	 c != CharacterIterator.DONE;
+	 c = source.next ())
+      decomposeCharacter (c, expand);
 
-    for(;;)
-      {
-        int ord1 = cei1.next(); 
-        int ord2 = cei2.next(); 
-  
-        // Check for end of string
-        if (ord1 == CollationElementIterator.NULLORDER)
-          if (ord2 == CollationElementIterator.NULLORDER)
-            return(0);
-          else
-            return(-1);
-        else if (ord2 == CollationElementIterator.NULLORDER)
-          return(1);
-
-        // We know chars are totally equal, so skip
-        if (ord1 == ord2)
-          continue;
-
-        // Check for primary strength differences
-        int prim1 = cei1.primaryOrder(ord1); 
-        int prim2 = cei2.primaryOrder(ord2); 
-
-        if (prim1 < prim2)
-          return(-1);
-        else if (prim1 > prim2)
-          return(1);
-        else if (getStrength() == PRIMARY)
-          continue;
-
-        // Check for secondary strength differences
-        int sec1 = cei1.secondaryOrder(ord1);
-        int sec2 = cei2.secondaryOrder(ord2);
-
-        if (sec1 < sec2)
-          return(-1);
-        else if (sec1 > sec2)
-          return(1);
-        else if (getStrength() == SECONDARY)
-          continue;
-
-        // Check for tertiary differences
-        int tert1 = cei1.tertiaryOrder(ord1);
-        int tert2 = cei2.tertiaryOrder(ord1);
-
-        if (tert1 < tert2)
-          return(-1);
-        else if (tert1 > tert2)
-          return(1);
-      }
+    return new CollationElementIterator (expand.toString(), this);
   }
 
-  /**
-   * This method returns an instance of <code>CollationKey</code> for the
-   * specified <code>String</code>.  The object returned will have a
-   * more efficient mechanism for its comparison function that could
-   * provide speed benefits if multiple comparisons are performed, such
-   * as during a sort.
-   *
-   * @param str The <code>String</code> to create a <code>CollationKey</code> for.
-   *
-   * @return A <code>CollationKey</code> for the specified <code>String</code>.
-   */
-  public CollationKey getCollationKey(String str)
+  public CollationKey getCollationKey (String source)
   {
-    CollationElementIterator cei = getCollationElementIterator(str);
-    Vector vect = new Vector(25);
-
-    int ord = cei.next();
-    while (ord != CollationElementIterator.NULLORDER)
-      {
-        switch (getStrength())
-          {
-            case PRIMARY:
-               ord = cei.primaryOrder(ord);
-               break;
-
-            case SECONDARY:
-               ord = cei.secondaryOrder(ord);
-
-            default:
-               break;
-          }
-
-        vect.add(new Integer(ord)); 
-      }
-
-    Object[] objarr = vect.toArray();
-    byte[] key = new byte[objarr.length * 4];
+    return new CollationKey (getCollationElementIterator (source), source,
+			     strength);
+  }
 
-    for (int i = 0; i < key.length; i++)
-      {
-        int j = ((Integer)objarr[i]).intValue();
-        key[i++] = (byte)((j & 0xFF000000) >> 24);
-        key[i++] = (byte)((j & 0x00FF0000) >> 16);
-        key[i++] = (byte)((j & 0x0000FF00) >> 8);
-        key[i++] = (byte)(j & 0x000000FF);
-      }
+  public String getRules ()
+  {
+    return rules;
+  }
 
-    return(new CollationKey(this, str, key));
+  public int hashCode ()
+  {
+    return (frenchAccents ? 1231 : 1237
+	    ^ rules.hashCode()
+	    ^ map.hashCode()
+	    ^ prefixes.hashCode());
   }
 
-  /**
-   * This method tests this object for equality against the specified 
-   * object.  This will be true if and only if the specified object is
-   * another reference to this object.
-   *
-   * @param obj The <code>Object</code> to compare against this object.
-   *
-   * @return <code>true</code> if the specified object is equal to this object, <code>false</code> otherwise.
-   */
-  public boolean equals(Object obj)
+  private final boolean is_special (char c)
   {
-    if (obj == this)
-      return(true);
-    else
-      return(false);
+    // Rules from JCL book.
+    return ((c >= 0x0009 && c <= 0x000d)
+	    || (c >= 0x0020 && c <= 0x002f)
+	    || (c >= 0x003a && c <= 0x0040)
+	    || (c >= 0x005b && c <= 0x0060)
+	    || (c >= 0x007b && c <= 0x007e));
   }
 
-  /**
-   * This method returns a hash value for this object.
-   *
-   * @return A hash value for this object.
-   */
-  public int hashCode()
+  private final int text_argument (String rules, int index,
+				   StringBuffer result)
   {
-    return(System.identityHashCode(this));
+    result.setLength(0);
+    int len = rules.length();
+    while (index < len)
+      {
+	char c = rules.charAt(index);
+	if (c == '\'' && index + 2 < len
+	    && rules.charAt(index + 2) == '\''
+	    && is_special (rules.charAt(index + 1)))
+	  index += 2;
+	else if (is_special (c) || Character.isWhitespace(c))
+	  return index;
+	result.append(c);
+	++index;
+      }
+    return index;
   }
 
-  /**
-   * This method creates a copy of this object.
-   *
-   * @return A copy of this object.
-   */
-  public Object clone()
+  public RuleBasedCollator (String rules) throws ParseException
   {
-    return super.clone();
+    this.rules = rules;
+    this.frenchAccents = false;
+
+    // We keep each rule in order in a vector.  At the end we traverse
+    // the vector and compute collation values from it.
+    int insertion_index = 0;
+    Vector vec = new Vector ();
+
+    StringBuffer argument = new StringBuffer ();
+
+    int len = rules.length();
+    for (int index = 0; index < len; ++index)
+      {
+	char c = rules.charAt(index);
+
+	// Just skip whitespace.
+	if (Character.isWhitespace(c))
+	  continue;
+
+	// Modifier.
+	if (c == '@')
+	  {
+	    frenchAccents = true;
+	    continue;
+	  }
+
+	// Check for relation or reset operator.
+	if (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))
+	  throw new ParseException ("invalid character", index);
+
+	++index;
+	while (index < len)
+	  {
+	    if (! Character.isWhitespace(rules.charAt(index)))
+	      break;
+	    ++index;
+	  }
+	if (index == len)
+	  throw new ParseException ("missing argument", index);
+
+	int save = index;
+	index = text_argument (rules, index, argument);
+	if (argument.length() == 0)
+	  throw new ParseException ("invalid character", save);
+	String arg = argument.toString();
+	int item_index = vec.indexOf(arg);
+	if (c != '&')
+	  {
+	    // If the argument already appears in the vector, then we
+	    // must remove it in order to re-order.
+	    if (item_index != -1)
+	      {
+		vec.removeElementAt(item_index);
+		if (insertion_index >= item_index)
+		  --insertion_index;
+	      }
+	    RBCElement r = new RBCElement (arg, c);
+	    vec.insertElementAt(r, insertion_index);
+	    ++insertion_index;
+	  }
+	else
+	  {
+	    // Reset.
+	    if (item_index == -1)
+	      throw
+		new ParseException ("argument to reset not previously seen",
+				    save);
+	    insertion_index = item_index + 1;
+	  }
+
+	// Ugly: in this case the resulting INDEX comes from
+	// text_argument, which returns the index of the next
+	// character we should examine.
+	--index;
+      }
+
+    // Now construct a hash table that maps strings onto their
+    // collation values.
+    int primary = 0;
+    int secondary = 0;
+    int tertiary = 0;
+    this.map = new Hashtable ();
+    this.prefixes = new Hashtable ();
+    Enumeration e = vec.elements();
+    while (e.hasMoreElements())
+      {
+	RBCElement r = (RBCElement) e.nextElement();
+	switch (r.relation)
+	  {
+	  case '<':
+	    ++primary;
+	    secondary = 0;
+	    tertiary = 0;
+	    break;
+	  case ';':
+	    ++secondary;
+	    tertiary = 0;
+	    break;
+	  case ',':
+	    ++tertiary;
+	    break;
+	  case '=':
+	    break;
+	  }
+	// This must match CollationElementIterator.
+	map.put(r.key, new Integer (primary << 16
+				    | secondary << 8 | tertiary));
+
+	// Make a map of all lookaheads we might need.
+	for (int i = r.key.length() - 1; i >= 1; --i)
+	  prefixes.put(r.key.substring(0, i), Boolean.TRUE);
+      }
   }
 }
