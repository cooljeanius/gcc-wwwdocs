--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2004-01-03 02:20:34.000000000 -0700
+++ java/text/RuleBasedCollator.java	2003-10-21 02:18:05.000000000 -0600
@@ -38,10 +38,9 @@
 
 package java.text;
 
-import java.util.Vector;
 import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Comparator;
+import java.util.Hashtable;
+import java.util.Vector;
 
 /* Written using "Java Class Libraries", 2nd edition, plus online
  * API docs for JDK 1.2 from http://www.javasoft.com.
@@ -63,10 +62,7 @@
  * <li> Reset: '&amp;' : <text>
  * </ul>
  * The modifier character indicates that accents sort backward as is the
- * case with French.  The modifier applies to all rules <b>after</b>
- * the modifier but before the next primary sequence. If placed at the end
- * of the sequence if applies to all unknown accented character.
- * The relational operators specify how the text 
+ * case with French.  The relational operators specify how the text 
  * argument relates to the previous term.  The relation characters have
  * the following meanings:
  * <ul>
@@ -117,9 +113,6 @@
  * anywhere in the previous rule string segment so the rule following the
  * reset rule cannot be inserted.
  * <p>
- * "&lt; a &amp; A @ &lt e &amp; E &lt f&amp; F" - This sequence is equivalent to the following
- * "&lt; a &amp; A &lt E &amp; e &lt f &amp; F".
- * <p>
  * For a description of the various comparison strength types, see the
  * documentation for the <code>Collator</code> class.
  * <p>
@@ -141,591 +134,338 @@
  *
  * @author Aaron M. Renn <arenn@urbanophile.com>
  * @author Tom Tromey <tromey@cygnus.com>
- * @author Guilhem Lavaux <guilhem@kaffe.org>
+ * @date March 25, 1999
  */
+
 public class RuleBasedCollator extends Collator
 {
-  /**
-   * This class describes what rank has a character (or a sequence of characters) 
-   * in the lexicographic order. Each element in a rule has a collation element.
-   */
   final class CollationElement
   {
-    String char_seq;
-    int primary;
-    short secondary;
-    short tertiary;
-    short equality;
-    boolean ignore;
-    String expansion;
+    String key;
+    char relation;
 
-    CollationElement(String char_seq, int primary, short secondary, short tertiary,
-		     short equality, String expansion)
-    {
-      this.char_seq = char_seq;
-      this.primary = primary;
-      this.secondary = secondary;
-      this.tertiary = tertiary;
-      this.equality = equality;
-      this.ignore = false;
-      this.expansion = expansion;
-    }
-    
-    CollationElement(String char_seq)
+    CollationElement (String key, char relation)
     {
-      this.char_seq = char_seq;
-      this.ignore = true;
-    }
-
-    final int getValue()
-    {
-      return (primary << 16) + (secondary << 8) + tertiary;
+      this.key = key;
+      this.relation = relation;
     }
 
   } // inner class CollationElement
 
-  /**
-   * Basic collation instruction (internal format) to build the series of
-   * collation elements. It contains an instruction which specifies the new
-   * state of the generator. The sequence of instruction should not contain
-   * RESET (it is used by
-   * {@link #mergeRules(int,java.lang.String,java.util.Vector,java.util.Vector)})
-   * as a temporary state while merging two sets of instructions.
-   */
-  final class CollationSorter
-  {
-    static final int GREATERP = 0;
-    static final int GREATERS = 1;
-    static final int GREATERT = 2;
-    static final int EQUAL = 3;
-    static final int RESET = 4;
-    static final int IGNORE = 5;
-    static final int INVERSE_SECONDARY = 6;
-    
-    int comparisonType;
-    String textElement;
-    int hashText;
-    int offset;
-
-    String expansionOrdering;
-  }
+  // True if we are using French-style accent ordering.
+  private boolean frenchAccents;
 
   /**
-   * This method returns the number of common characters at the beginning
-   * of the string of the two parameters.
-   *
-   * @param prefix A string considered as a prefix to test against
-   * the other string.
-   * @param s A string to test the prefix against.
-   * @return The number of common characters.
+   * This the the original rule string.
    */
-  static int findPrefixLength(String prefix, String s)
-  {
-    int i;
-
-    for (i = 0; i < prefix.length() && i < s.length(); i++)
-      {
-	if (prefix.charAt(i) != s.charAt(i))
-	  return i;
-      }
-    return i;
-  }
+  private String rules;
 
+  // This maps strings onto collation values.
+  private Hashtable map;
+  
+  // An entry in this hash means that more lookahead is required for
+  // the prefix string.
+  private Hashtable prefixes;
+  
   /**
-   * Here we are merging two sets of sorting instructions: 'patch' into 'main'. This methods
-   * checks whether it is possible to find an anchor point for the rules to be merged and
-   * then insert them at that precise point.
-   *
-   * @param offset Offset in the string containing rules of the beginning of the rules
-   * being merged in.
-   * @param starter Text of the rules being merged.
-   * @param main Repository of all already parsed rules.
-   * @param patch Rules to be merged into the repository.
-   * @throws ParseException if it is impossible to find an anchor point for the new rules.
+   * This method initializes a new instance of <code>RuleBasedCollator</code>
+   * with the specified collation rules.  Note that an application normally
+   * obtains an instance of <code>RuleBasedCollator</code> by calling the
+   * <code>getInstance</code> method of <code>Collator</code>.  That method
+   * automatically loads the proper set of rules for the desired locale.
+   *
+   * @param rules The collation rule string.
+   *
+   * @exception ParseException If the rule string contains syntax errors.
    */
-  private void mergeRules(int offset, String starter, Vector main, Vector patch)
-    throws ParseException 
+  public RuleBasedCollator (String rules) throws ParseException
   {
-    Enumeration elements = main.elements();
-    int insertion_point = -1;
-    int max_length = 0;
-    
-    /* We must check that no rules conflict with another already present. If it
-     * is the case delete the old rule. 
-     */
+    if (rules.equals (""))
+      throw new ParseException ("empty rule set", 0);
     
-    /* For the moment good old O(N^2) algorithm.
-     */
-    for (int i = 0; i < patch.size(); i++)
-      {
-	int j = 0;
-	
-	while (j < main.size())
-	  {
-	    CollationSorter rule1 = (CollationSorter) patch.elementAt(i);
-	    CollationSorter rule2 = (CollationSorter) main.elementAt(j);
-	    
-	    if (rule1.textElement.equals(rule2.textElement))
-	      main.removeElementAt(j);
-	    else
-	      j++;
-	  }
-      }
-
-    // Find the insertion point... O(N)
-    for (int i = 0; i < main.size(); i++)
-      {
-	CollationSorter sorter = (CollationSorter) main.elementAt(i);
-	int length = findPrefixLength(starter, sorter.textElement);
-		
-	if (length > max_length)
-	  {
-	    max_length = length;
-	    insertion_point = i+1;
-	  }
-      }
-
-    if (insertion_point < 0)
-      throw new ParseException("no insertion point found for " + starter, offset);
+    this.rules = rules;
+    this.frenchAccents = false;
 
-    if (max_length < starter.length())
-      {
-	/*
-	 * We need to expand the first entry. It must be sorted
-	 * like if it was the reference key itself (like the spec
-	 * said. So the first entry is special: the element is
-	 * replaced by the specified text element for the sorting.
-	 * This text replace the old one for comparisons. However
-	 * to preserve the behaviour we replace the first key (corresponding
-	 * to the found prefix) by a new code rightly ordered in the
-	 * sequence. The rest of the subsequence must be appended
-	 * to the end of the sequence.
-	 */
-	CollationSorter sorter = (CollationSorter) patch.elementAt(0);
-	CollationSorter expansionPrefix =
-	  (CollationSorter) main.elementAt(insertion_point-1);
-	
-	sorter.expansionOrdering = starter.substring(max_length); // Skip the first good prefix element
-	
-	main.insertElementAt(sorter, insertion_point);
-	
-	/*
-	 * This is a new set of rules. Append to the list.
-	 */
-	patch.removeElementAt(0);
-	insertion_point = main.size();
-      }
+    // We keep each rule in order in a vector.  At the end we traverse
+    // the vector and compute collation values from it.
+    int insertion_index = 0;
+    Vector vec = new Vector ();
 
-    // Now insert all elements of patch at the insertion point.
-    for (int i = 0; i < patch.size(); i++)
-      main.insertElementAt(patch.elementAt(i), i+insertion_point);
-  }
+    StringBuffer argument = new StringBuffer ();
 
-  /**
-   * This method parses a string and build a set of sorting instructions. The parsing
-   * may only be partial on the case the rules are to be merged sometime later.
-   * 
-   * @param stop_on_reset If this parameter is true then the parser stops when it
-   * encounters a reset instruction. In the other case, it tries to parse the subrules
-   * and merged it in the same repository.
-   * @param v Output vector for the set of instructions.
-   * @param base_offset Offset in the string to begin parsing.
-   * @param rules Rules to be parsed.
-   * @return -1 if the parser reached the end of the string, an integer representing the
-   * offset in the string at which it stopped parsing. 
-   * @throws ParseException if something turned wrong during the parsing. To get details
-   * decode the message.
-   */
-  private int subParseString(boolean stop_on_reset, Vector v,
-			     int base_offset, String rules)
-    throws ParseException
-  {
-    boolean ignoreChars = (base_offset == 0);
-    int operator = -1;
-    StringBuffer sb = new StringBuffer("");
-    boolean doubleQuote = false;
-    boolean eatingChars = false;
-    boolean nextIsModifier = false;
-    boolean isModifier = false;
-    int i;
-    
-main_parse_loop:
-    for (i = 0; i < rules.length(); i++)
+    int len = rules.length();
+    for (int index = 0; index < len; ++index)
       {
-	char c = rules.charAt(i);
-	int type = -1;
-	
-	if (!eatingChars &&
-	    ((c >= 0x09 && c <= 0x0D) || (c == 0x20)))
-	      continue;
+	char c = rules.charAt(index);
 
-	isModifier = nextIsModifier;
-	nextIsModifier = false;
+	// Just skip whitespace.
+	if (Character.isWhitespace(c))
+	  continue;
 
-	if (eatingChars && c != '\'')
-	  {
-	    doubleQuote = false;
-	    sb.append(c);
-	    continue;
-	  }
-	if (doubleQuote && eatingChars)
+	// Modifier.
+	if (c == '@')
 	  {
-	    sb.append(c);
-	    doubleQuote = false;
+	    frenchAccents = true;
 	    continue;
 	  }
 
-	switch (c) {
-	case '!':
-	  throw new ParseException
-	    ("Modifier '!' is not yet supported by Classpath", i+base_offset);
-	case '<':
-	  ignoreChars = false;
-	  type = CollationSorter.GREATERP;
-	  break;
-	case ';':
-	  if (!ignoreChars)
-	    type = CollationSorter.GREATERS;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case ',':
-	  if (!ignoreChars)
-	    type = CollationSorter.GREATERT;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case '=':
-	  if (!ignoreChars)
-	    type = CollationSorter.EQUAL;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case '\'':
-	  eatingChars = !eatingChars;
-	  doubleQuote = true;
-	  break;
-	case '@':
-	  if (ignoreChars)
-	    throw new ParseException
-	      ("comparison list has not yet been started. You may only use"
-	       + "(<,;=&)", i+base_offset);
-	  // Inverse the order of secondaries from now on.
-	  nextIsModifier = true;
-	  type = CollationSorter.INVERSE_SECONDARY;
-	  break;
-	case '&':
-	  type = CollationSorter.RESET;
-	  if (stop_on_reset)
-	    break main_parse_loop;
-	  break;
-	default:
-	  if (operator < 0)
-	    throw new ParseException
-	      ("operator missing at " + (i+base_offset), i+base_offset);
-	  if (!eatingChars &&
-	      ((c >= 0x21 && c <= 0x2F) 
-	       || (c >= 0x3A && c <= 0x40)
-	       || (c >= 0x5B && c <= 0x60)
-	       || (c >= 0x7B && c <= 0x7E)))
-	    throw new ParseException
-	      ("unquoted punctuation character '"+c+"'", i+base_offset);
-
-	  //type = ignoreChars ? CollationSorter.IGNORE : -1;
-	  sb.append(c);
-	  break;
-	}
+	// Check for relation or reset operator.
+	if (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))
+	  throw new ParseException ("invalid character", index);
 
-	if (type  < 0)
-	  continue;
-
-	if (operator < 0)
+	++index;
+	while (index < len)
 	  {
-	    operator = type;
-	    continue;
+	    if (! Character.isWhitespace(rules.charAt(index)))
+	      break;
+	    ++index;
 	  }
+	if (index == len)
+	  throw new ParseException ("missing argument", index);
 
-	if (sb.length() == 0 && !isModifier)
-	  throw new ParseException
-	    ("text element empty at " + (i+base_offset), i+base_offset);
+	int save = index;
+	index = text_argument (rules, index, argument);
+	if (argument.length() == 0)
+	  throw new ParseException ("invalid character", save);
+	String arg = argument.toString();
+	int item_index = -1;
+        
+        for (int j = 0; j < vec.size(); ++j)
+          {
+            CollationElement e = (CollationElement) vec.elementAt (j);
 
-	if (operator == CollationSorter.RESET)
+            if (arg.equals (e.key))
+              {
+                item_index = j;
+                break;
+              }
+          }
+	
+	if (c != '&')
 	  {
-	    /* Reposition in the sorting list at the position
-	     * indicated by the text element.
-	     */
-	    String subrules = rules.substring(i);
-	    Vector sorted_rules = new Vector();
-	    int idx;
-
-	    // Parse the subrules but do not iterate through all
-	    // sublist. This is the priviledge of the first call.
-	    idx = subParseString(true, sorted_rules, base_offset+i, subrules);
-    
-	    // Merge new parsed rules into the list.
-	    mergeRules(base_offset+i, sb.toString(), v, sorted_rules);
-	    sb.setLength(0);
-	    
-	    // Reset state to none.
-	    operator = -1;
-	    type = -1;
-	    // We have found a new subrule at 'idx' but it has not been parsed.
-	    if (idx >= 0)
+	    // If the argument already appears in the vector, then we
+	    // must remove it in order to re-order.
+	    if (item_index != -1)
 	      {
-		i += idx-1;
-		continue main_parse_loop;
+		vec.removeElementAt(item_index);
+		if (insertion_index >= item_index)
+		  --insertion_index;
 	      }
-	    else
-		// No more rules.
-		break main_parse_loop;
+	    CollationElement r = new CollationElement (arg, c);
+	    vec.insertElementAt(r, insertion_index);
+	    ++insertion_index;
+	  }
+	else
+	  {
+	    // Reset.
+	    if (item_index == -1)
+	      throw
+		new ParseException ("argument to reset not previously seen",
+				    save);
+	    insertion_index = item_index + 1;
 	  }
 
-	CollationSorter sorter = new CollationSorter();
-	
-	sorter.comparisonType = operator;
-	sorter.textElement = sb.toString();
-	sorter.hashText = sorter.textElement.hashCode();
-	sorter.offset = base_offset+rules.length();
-	sb.setLength(0);
-
-	v.add(sorter);
-	operator = type;
-      }
-
-    if (operator >= 0)
+	// Ugly: in this case the resulting INDEX comes from
+	// text_argument, which returns the index of the next
+	// character we should examine.
+	--index;
+      }
+
+    // Now construct a hash table that maps strings onto their
+    // collation values.
+    int primary = 0;
+    int secondary = 0;
+    int tertiary = 0;
+    this.map = new Hashtable ();
+    this.prefixes = new Hashtable ();
+    Enumeration e = vec.elements();
+    while (e.hasMoreElements())
       {
-	CollationSorter sorter = new CollationSorter();
-	int pos = rules.length() + base_offset;
-
-	if ((sb.length() != 0 && nextIsModifier)
-	    || (sb.length() == 0 && !nextIsModifier && !eatingChars))
-	  throw new ParseException("text element empty at " + pos, pos);
-
-	sorter.comparisonType = operator;
-	sorter.textElement = sb.toString();
- 	sorter.hashText = sorter.textElement.hashCode();
-	sorter.offset = base_offset+pos;
-	v.add(sorter);
+	CollationElement r = (CollationElement) e.nextElement();
+	switch (r.relation)
+	  {
+	  case '<':
+	    ++primary;
+	    secondary = 0;
+	    tertiary = 0;
+	    break;
+	  case ';':
+	    ++secondary;
+	    tertiary = 0;
+	    break;
+	  case ',':
+	    ++tertiary;
+	    break;
+	  case '=':
+	    break;
+	  }
+	// This must match CollationElementIterator.
+	map.put(r.key, new Integer (primary << 16
+				    | secondary << 8 | tertiary));
+
+	// Make a map of all lookaheads we might need.
+	for (int i = r.key.length() - 1; i >= 1; --i)
+	  prefixes.put(r.key.substring(0, i), Boolean.TRUE);
       }
-
-    if (i == rules.length())
-      return -1;
-    else
-      return i;
   }
 
   /**
-   * This method completely parses a string 'rules' containing sorting rules.
+   * This method creates a copy of this object.
    *
-   * @param rules String containing the rules to be parsed. 
-   * @return A set of sorting instructions stored in a Vector.
-   * @throws ParseException if something turned wrong during the parsing. To get details
-   * decode the message.
+   * @return A copy of this object.
    */
-  private Vector parseString(String rules) 
-    throws ParseException
+  public Object clone()
   {
-    Vector v = new Vector();
-
-    // result of the first subParseString is not absolute (may be -1 or a
-    // positive integer). But we do not care.
-    subParseString(false, v, 0, rules);
-    
-    return v;
+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();
+    c.map = (Hashtable) map.clone ();
+    c.prefixes = (Hashtable) map.clone ();
+    return c;
   }
 
-  /**
-   * This the the original rule string.
-   */
-  private String rules;
-
-  /**
-   * This is the table of collation element values
-   */
-  private Object[] ce_table;
-
-  /**
-   * Quick-prefix finder.
-   */
-  HashMap prefix_tree;
-
-  /**
-   * This is the value of the last sequence entered into
-   * <code>ce_table</code>. It is used to compute the
-   * ordering value of unspecified character.
-   */
-  private int last_primary_value;
-
-  /**
-   * This variable is true if accents need to be sorted
-   * in the other direction.
-   */
-  private boolean inverseAccentComparison;
-
-  /**
-   * This method uses the sorting instructions built by {@link #parseString}
-   * to build collation elements which can be directly used to sort strings.
-   *
-   * @param parsedElements Parsed instructions stored in a Vector.
-   * @throws ParseException if the order of the instructions are not valid.
-   */
-  private void buildCollationVector(Vector parsedElements)
-    throws ParseException
+  // A helper for CollationElementIterator.next().
+  int ceiNext (CollationElementIterator cei)
   {
-    int primary_seq = 0;
-    short secondary_seq = 0;
-    short tertiary_seq = 0;
-    short equality_seq = 0;
-    boolean inverseComparisons = false;
-    final boolean DECREASING = false;
-    final boolean INCREASING = true;
-    boolean secondaryType = INCREASING;
-    Vector v = new Vector();
-
-    // elts is completely sorted.
-element_loop:
-    for (int i = 0; i < parsedElements.size(); i++)
+    if (cei.lookahead_set)
       {
-	CollationSorter elt = (CollationSorter) parsedElements.elementAt(i);
-	boolean ignoreChar = false;
+	cei.lookahead_set = false;
+	return cei.lookahead;
+      }
 
-	switch (elt.comparisonType)
-	  {
-	  case CollationSorter.GREATERP:
-	    primary_seq++;
-	    if (inverseComparisons)
-	      {
-		secondary_seq = Short.MAX_VALUE;
-		secondaryType = DECREASING;
-	      }
-	    else
-	      {
-		secondary_seq = 0;
-		secondaryType = INCREASING;
-	      }
-	    tertiary_seq = 0;
-	    equality_seq = 0;
-	    inverseComparisons = false;
-	    break;
-	  case CollationSorter.GREATERS:
-	    if (secondaryType == DECREASING)
-	      secondary_seq--;
-	    else
-	      secondary_seq++;
-	    tertiary_seq = 0;
-	    equality_seq = 0;
-	    break;
-	  case CollationSorter.INVERSE_SECONDARY:
-	    inverseComparisons = true;
-	    continue element_loop;
-	  case CollationSorter.GREATERT:
-	    tertiary_seq++;
-	    equality_seq = 0;
-	    break;
-	  case CollationSorter.IGNORE:
-	    ignoreChar = true;
-	  case CollationSorter.EQUAL:
-	    equality_seq++;
-	    break;
-	  case CollationSorter.RESET:
-	    throw new ParseException
-	      ("Invalid reached state 'RESET'. Internal error", elt.offset);
-	  default:
-	    throw new ParseException
-	      ("Invalid unknown state '" + elt.comparisonType + "'", elt.offset);
-	  }
+    int save = cei.index;
+    int max = cei.text.length();
+    String s = null;
 
-	CollationElement e;
+    // It is possible to have a case where `abc' has a mapping, but
+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as
+    // nothing special.
+    boolean found = false;
 
-	if (!ignoreChar)
-	  {
-	    e = new CollationElement(elt.textElement, primary_seq,
-				     secondary_seq, tertiary_seq,
-				     equality_seq, elt.expansionOrdering);
-	  }
-	else
-	  e = new CollationElement(elt.textElement);
+    int i;
+    for (i = save + 1; i <= max; ++i)
+      {
+	s = cei.text.substring(save, i);
+	if (prefixes.get(s) == null)
+	  break;
+	found = true;
+      }
+    // Assume s != null.
 
-	v.add(e);
+    Object obj = map.get(s);
+    // The special case.
+    while (found && obj == null && s.length() > 1)
+      {
+	--i;
+	s = cei.text.substring(save, i);
+	obj = map.get(s);
       }
 
-    this.inverseAccentComparison = inverseComparisons; 
+    // Update state.
+    cei.index = i;
 
-    ce_table = v.toArray();
+    if (obj == null)
+      {
+	// This idea, and the values, come from JDK.
+	// assert (s.length() == 1)
+	cei.lookahead_set = true;
+	cei.lookahead = s.charAt(0) << 8;
+	return 0x7fff << 16;
+      }
 
-    last_primary_value = primary_seq+1;
+    return ((Integer) obj).intValue();
   }
 
-  /**
-   * Build a tree where all keys are the texts of collation elements and data is
-   * the collation element itself. The tree is used when extracting all prefix
-   * for a given text.
-   */
-  private void buildPrefixAccess()
+  // A helper for compareTo() that returns the next character that has
+  // a nonzero ordering at the indicated strength.  This is also used
+  // in CollationKey.
+  static final int next (CollationElementIterator iter, int strength)
   {
-    prefix_tree = new HashMap();
-
-    for (int i = 0; i < ce_table.length; i++)
+    while (true)
       {
-	CollationElement e = (CollationElement) ce_table[i];
-
-	prefix_tree.put(e.char_seq, e);
+	int os = iter.next();
+	if (os == CollationElementIterator.NULLORDER)
+	  return os;
+	int c = 0;
+	switch (strength)
+	  {
+	  case PRIMARY:
+	    c = os & ~0xffff;
+	    break;
+	  case SECONDARY:
+	    c = os & ~0x00ff;
+	    break;
+	  case TERTIARY:
+	  case IDENTICAL:
+	    c = os;
+	    break;
+	  }
+	if (c != 0)
+	  return c;
       }
   }
 
   /**
-   * This method initializes a new instance of <code>RuleBasedCollator</code>
-   * with the specified collation rules.  Note that an application normally
-   * obtains an instance of <code>RuleBasedCollator</code> by calling the
-   * <code>getInstance</code> method of <code>Collator</code>.  That method
-   * automatically loads the proper set of rules for the desired locale.
+   * This method returns an integer which indicates whether the first
+   * specified <code>String</code> is less than, greater than, or equal to
+   * the second.  The value depends not only on the collation rules in
+   * effect, but also the strength and decomposition settings of this object.
    *
-   * @param rules The collation rule string.
+   * @param s1 The first <code>String</code> to compare.
+   * @param s2 A second <code>String</code> to compare to the first.
    *
-   * @exception ParseException If the rule string contains syntax errors.
+   * @return A negative integer if s1 &lt; s2, a positive integer
+   * if s1 &gt; s2, or 0 if s1 == s2.
    */
-  public RuleBasedCollator(String rules) throws ParseException
+  public int compare (String source, String target)
   {
-    this.rules = rules;
+    CollationElementIterator cs, ct;
 
-    if (rules.equals(""))
-      throw new ParseException("Empty rule set", 0);
+    cs = new CollationElementIterator (source, this);
+    ct = new CollationElementIterator (target, this);
 
-    buildCollationVector(parseString(rules));
-    buildPrefixAccess();
-  }
+    while (true)
+      {
+	int os = next (cs, strength);
+	int ot = next (ct, strength);
 
-  /**
-   * This method returns a <code>String</code> containing the collation rules
-   * for this object.
-   *
-   * @return The collation rules for this object.
-   */
-  public String getRules()
-  {
-    return rules;
+	if (os == CollationElementIterator.NULLORDER
+	    && ot == CollationElementIterator.NULLORDER)
+	  break;
+	else if (os == CollationElementIterator.NULLORDER)
+	  {
+	    // Source string is shorter, so return "less than".
+	    return -1;
+	  }
+	else if (ot == CollationElementIterator.NULLORDER)
+	  {
+	    // Target string is shorter, so return "greater than".
+	    return 1;
+	  }
+
+	if (os != ot)
+	  return os - ot;
+      }
+
+    return 0;
   }
 
   /**
-   * This method builds a default collation element without invoking
-   * the database created from the rules passed to the constructor.
+   * This method tests this object for equality against the specified 
+   * object.  This will be true if and only if the specified object is
+   * another reference to this object.
+   *
+   * @param obj The <code>Object</code> to compare against this object.
    *
-   * @param c Character which needs a collation element.
-   * @return A valid brand new CollationElement instance.
+   * @return <code>true</code> if the specified object is equal to this object, <code>false</code> otherwise.
    */
-  CollationElement getDefaultElement(char c)
+  public boolean equals (Object obj)
   {
-    int v;
-
-    // Preliminary support for generic accent sorting inversion (I don't know if all
-    // characters in the range should be sorted backward). This is the place
-    // to fix this if needed.
-    if (inverseAccentComparison && (c >= 0x02B9 && c <= 0x0361))
-      v = 0x0361 - ((int)c - 0x02B9);
-    else
-      v = (short)c;
-    return new CollationElement(""+c, last_primary_value + v,
-				(short)0, (short)0, (short) 0, null);
+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))
+      return false;
+    RuleBasedCollator rbc = (RuleBasedCollator) obj;
+    // FIXME: this is probably wrong.  Instead we should compare maps
+    // directly.
+    return (frenchAccents == rbc.frenchAccents
+	    && rules.equals(rbc.rules));
   }
 
   /**
@@ -737,10 +477,14 @@
    *
    * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
    */
-  public CollationElementIterator getCollationElementIterator(String str)
+  public CollationElementIterator getCollationElementIterator (String source)
   {
-    return new CollationElementIterator(this, str);
-  }  
+    StringBuffer expand = new StringBuffer (source.length());
+    int max = source.length();
+    for (int i = 0; i < max; ++i)
+      decomposeCharacter (source.charAt(i), expand);
+    return new CollationElementIterator (expand.toString(), this);
+  }
 
   /**
    * This method returns an instance of <code>CollationElementIterator</code>
@@ -751,104 +495,15 @@
    *
    * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
    */
-  public CollationElementIterator getCollationElementIterator(CharacterIterator ci)
+  public CollationElementIterator getCollationElementIterator (CharacterIterator source)
   {
-    StringBuffer sb = new StringBuffer("");
+    StringBuffer expand = new StringBuffer ();
+    for (char c = source.first ();
+	 c != CharacterIterator.DONE;
+	 c = source.next ())
+      decomposeCharacter (c, expand);
 
-    // Right now we assume that we will read from the beginning of the string.
-    char c = ci.first();
-    while (c != CharacterIterator.DONE) 
-      {
-        sb.append(c);
-        c = ci.next();
-      }
-
-    return getCollationElementIterator(sb.toString());
-  }
-
-  /**
-   * This method returns an integer which indicates whether the first
-   * specified <code>String</code> is less than, greater than, or equal to
-   * the second.  The value depends not only on the collation rules in
-   * effect, but also the strength and decomposition settings of this object.
-   *
-   * @param s1 The first <code>String</code> to compare.
-   * @param s2 A second <code>String</code> to compare to the first.
-   *
-   * @return A negative integer if s1 &lt; s2, a positive integer
-   * if s1 &gt; s2, or 0 if s1 == s2.
-   */
-  public int compare(String s1, String s2)
-  {
-    CollationElementIterator cei1 = getCollationElementIterator(s1);
-    CollationElementIterator cei2 = getCollationElementIterator(s2);
-
-    for(;;)
-      {
-        CollationElement ord1block = cei1.nextBlock(); 
-        CollationElement ord2block = cei2.nextBlock(); 
-	int ord1;
-	int ord2;
-
-	if (ord1block != null)
-	  ord1 = ord1block.getValue();
-	else
-	  {
-	    if (ord2block == null)
-	      return 0;
-	    return -1;
-	  }
-
-	if (ord2block == null)
-	  return 1;
-	
-	ord2 = ord2block.getValue();
-	
-	// We know chars are totally equal, so skip
-        if (ord1 == ord2)
-	  {
-	    if (getStrength() == IDENTICAL)
-	      if (!ord1block.char_seq.equals(ord2block.char_seq))
-		return ord1block.char_seq.compareTo(ord2block.char_seq);
-	    continue;
-	  }
-
-        // Check for primary strength differences
-        int prim1 = cei1.primaryOrder(ord1); 
-        int prim2 = cei2.primaryOrder(ord2); 
-
-        if (prim1 < prim2)
-          return -1;
-        else if (prim1 > prim2)
-          return 1;
-        else if (getStrength() == PRIMARY)
-          continue;
-
-        // Check for secondary strength differences
-        int sec1 = cei1.secondaryOrder(ord1);
-        int sec2 = cei2.secondaryOrder(ord2);
-
-        if (sec1 < sec2)
-          return -1;
-        else if (sec1 > sec2)
-          return 1;
-        else if (getStrength() == SECONDARY)
-          continue;
-
-        // Check for tertiary differences
-        int tert1 = cei1.tertiaryOrder(ord1);
-        int tert2 = cei2.tertiaryOrder(ord2);
-
-        if (tert1 < tert2)
-          return -1;
-        else if (tert1 > tert2)
-          return 1;
-	else if (getStrength() == TERTIARY)
-	  continue;
-
-	// Apparently JDK does this (at least for my test case).
-	return ord1block.char_seq.compareTo(ord2block.char_seq);    
-      }
+    return new CollationElementIterator (expand.toString(), this);
   }
 
   /**
@@ -862,63 +517,21 @@
    *
    * @return A <code>CollationKey</code> for the specified <code>String</code>.
    */
-  public CollationKey getCollationKey(String str)
+  public CollationKey getCollationKey (String source)
   {
-    CollationElementIterator cei = getCollationElementIterator(str);
-    Vector vect = new Vector(25);
-
-    int ord = cei.next();
-    cei.reset(); //set to start of string
-
-    while (ord != CollationElementIterator.NULLORDER)
-      {
-        switch (getStrength())
-          {
-            case PRIMARY:
-               ord = cei.primaryOrder(ord);
-               break;
-
-            case SECONDARY:
-               ord = cei.secondaryOrder(ord);
-
-            default:
-               break;
-          }
-
-        vect.add(new Integer(ord)); 
-	ord = cei.next(); //increment to next key
-      }
-
-    Object[] objarr = vect.toArray();
-    byte[] key = new byte[objarr.length * 4];
-
-    for (int i = 0; i < objarr.length; i++)
-      {
-        int j = ((Integer)objarr[i]).intValue();
-        key [i * 4] = (byte)((j & 0xFF000000) >> 24);
-        key [i * 4 + 1] = (byte)((j & 0x00FF0000) >> 16);
-        key [i * 4 + 2] = (byte)((j & 0x0000FF00) >> 8);
-        key [i * 4 + 3] = (byte)(j & 0x000000FF);
-      }
-
-    return new CollationKey(this, str, key);
+    return new CollationKey (getCollationElementIterator (source), source,
+			     strength);
   }
 
   /**
-   * This method tests this object for equality against the specified 
-   * object.  This will be true if and only if the specified object is
-   * another reference to this object.
-   *
-   * @param obj The <code>Object</code> to compare against this object.
+   * This method returns a <code>String</code> containing the collation rules
+   * for this object.
    *
-   * @return <code>true</code> if the specified object is equal to this object, <code>false</code> otherwise.
+   * @return The collation rules for this object.
    */
-  public boolean equals(Object obj)
+  public String getRules()
   {
-    if (obj == this)
-      return true;
-    else
-      return false;
+    return rules;
   }
 
   /**
@@ -928,16 +541,44 @@
    */
   public int hashCode()
   {
-    return System.identityHashCode(this);
+    return (frenchAccents ? 1231 : 1237
+	    ^ rules.hashCode()
+	    ^ map.hashCode()
+	    ^ prefixes.hashCode());
   }
 
-  /**
-   * This method creates a copy of this object.
-   *
-   * @return A copy of this object.
-   */
-  public Object clone()
+  private final boolean is_special (char c)
   {
-    return super.clone();
+    // Rules from JCL book.
+    return ((c >= 0x0021 && c <= 0x002f)
+	    || (c >= 0x003a && c <= 0x0040)
+	    || (c >= 0x005b && c <= 0x0060)
+	    || (c >= 0x007b && c <= 0x007e));
   }
+
+  private final int text_argument (String rules, int index,
+				   StringBuffer result)
+  {
+    result.setLength(0);
+    int len = rules.length();
+    while (index < len)
+      {
+	char c = rules.charAt (index);
+	if (c == '\''
+            && index + 2 < len
+	    && rules.charAt (index + 2) == '\'')
+          {
+            result.append (rules.charAt (index + 1));
+            index += 2;
+          }
+	else if (is_special (c))
+	  return index;
+        else if (!Character.isWhitespace (c))
+          result.append (c);
+        
+        ++index;
+      }
+    return index;
+  }
+
 }
