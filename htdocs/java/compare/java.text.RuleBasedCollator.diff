--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2003-06-28 02:19:20.000000000 -0600
+++ java/text/RuleBasedCollator.java	2003-06-13 02:27:40.000000000 -0600
@@ -38,6 +38,8 @@
 
 package java.text;
 
+import java.util.Enumeration;
+import java.util.Hashtable;
 import java.util.Vector;
 
 /* Written using "Java Class Libraries", 2nd edition, plus online
@@ -134,392 +136,351 @@
  * @author Tom Tromey <tromey@cygnus.com>
  * @date March 25, 1999
  */
-public class RuleBasedCollator extends Collator
+
+final class RBCElement
 {
-  class CollationElement
+  String key;
+  char relation;
+
+  RBCElement (String key, char relation)
   {
-    String char_seq;
-    int primary;
-    short secondary;
-    short tertiary;
-
-    CollationElement(String char_seq, int primary, short secondary, short tertiary)
-    {
-      this.char_seq = char_seq;
-      this.primary = primary;
-      this.secondary = secondary;
-      this.tertiary = tertiary;
-    }
- 
-  } // inner class CollationElement
+    this.key = key;
+    this.relation = relation;
+  }
+}
+
+public class RuleBasedCollator extends Collator
+{
+  // True if we are using French-style accent ordering.
+  private boolean frenchAccents;
 
   /**
    * This the the original rule string.
    */
   private String rules;
 
-  /**
-   * This is the table of collation element values
-   */
-  private Object[] ce_table;
+  // This maps strings onto collation values.
+  private Hashtable map;
+  
+  // An entry in this hash means that more lookahead is required for
+  // the prefix string.
+  private Hashtable prefixes;
+  
+  public Object clone ()
+  {
+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();
+    c.map = (Hashtable) map.clone ();
+    c.prefixes = (Hashtable) map.clone ();
+    return c;
+  }
 
-  /**
-   * This method initializes a new instance of <code>RuleBasedCollator</code>
-   * with the specified collation rules.  Note that an application normally
-   * obtains an instance of <code>RuleBasedCollator</code> by calling the
-   * <code>getInstance</code> method of <code>Collator</code>.  That method
-   * automatically loads the proper set of rules for the desired locale.
-   *
-   * @param rules The collation rule string.
-   *
-   * @exception ParseException If the rule string contains syntax errors.
-   */
-  public RuleBasedCollator(String rules) throws ParseException
+  // A helper for CollationElementIterator.next().
+  int ceiNext (CollationElementIterator cei)
   {
-    this.rules = rules;
+    if (cei.lookahead_set)
+      {
+	cei.lookahead_set = false;
+	return cei.lookahead;
+      }
 
-    if (rules.equals(""))
-      throw new IllegalArgumentException("Empty rule set");
+    int save = cei.index;
+    int max = cei.text.length();
+    String s = null;
+
+    // It is possible to have a case where `abc' has a mapping, but
+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as
+    // nothing special.
+    boolean found = false;
 
-    Vector v = new Vector();
-    boolean ignore_chars = true;
-    int primary_seq = 0;
-    short secondary_seq = 0;
-    short tertiary_seq = 0;
-    StringBuffer sb = new StringBuffer("");
-    for (int i = 0; i < rules.length(); i++)
+    int i;
+    for (i = save + 1; i <= max; ++i)
       {
-        char c = rules.charAt(i);
-
-        // Check if it is a whitespace character
-        if (((c >= 0x09) && (c <= 0x0D)) || (c == 0x20))
-          continue;
-
-        // Primary difference
-        if (c == '<')
-          {
-            ignore_chars = false;
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            secondary_seq = 0;
-            tertiary_seq = 0;
-            ++primary_seq;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Secondary difference
-        if (c == ';')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            ++secondary_seq;
-            tertiary_seq = 0;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Tertiary difference
-        if (c == ',')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            ++tertiary_seq;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Is equal to
-        if (c == '=')
-          {
-            if (primary_seq == 0)
-              throw new ParseException(rules, i);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Sort accents backwards
-        if (c == '@')
-          {
-            throw new ParseException("French style accents not implemented yet", 0);
-          }
-
-        // Reset command
-        if (c == '&')
-          {
-            throw new ParseException("Reset not implemented yet", 0);
-          }
-
-        // See if we are still reading characters to skip
-        if (ignore_chars == true)
-          {
-            CollationElement e = new CollationElement(c + "", 0, (short)0, 
-                                                      (short)0);
-            v.add(e);
-            continue;
-          }
+	s = cei.text.substring(save, i);
+	if (prefixes.get(s) == null)
+	  break;
+	found = true;
+      }
+    // Assume s != null.
 
-        sb.append(c);
+    Object obj = map.get(s);
+    // The special case.
+    while (found && obj == null && s.length() > 1)
+      {
+	--i;
+	s = cei.text.substring(save, i);
+	obj = map.get(s);
       }
 
-    if (sb.length() > 0)
+    // Update state.
+    cei.index = i;
+
+    if (obj == null)
       {
-	CollationElement e = new CollationElement (sb.toString(), primary_seq,
-						   secondary_seq, tertiary_seq);
-	v.add (e);
+	// This idea, and the values, come from JDK.
+	// assert (s.length() == 1)
+	cei.lookahead_set = true;
+	cei.lookahead = s.charAt(0) << 8;
+	return 0x7fff << 16;
       }
 
-    ce_table = v.toArray();
+    return ((Integer) obj).intValue();
   }
 
-  /**
-   * This method returns a <code>String</code> containing the collation rules
-   * for this object.
-   *
-   * @return The collation rules for this object.
-   */
-  public String getRules()
+  // A helper for compareTo() that returns the next character that has
+  // a nonzero ordering at the indicated strength.  This is also used
+  // in CollationKey.
+  static final int next (CollationElementIterator iter, int strength)
   {
-    return(rules);
+    while (true)
+      {
+	int os = iter.next();
+	if (os == CollationElementIterator.NULLORDER)
+	  return os;
+	int c = 0;
+	switch (strength)
+	  {
+	  case PRIMARY:
+	    c = os & ~0xffff;
+	    break;
+	  case SECONDARY:
+	    c = os & ~0x00ff;
+	    break;
+	  case TERTIARY:
+	  case IDENTICAL:
+	    c = os;
+	    break;
+	  }
+	if (c != 0)
+	  return c;
+      }
   }
 
-  /**
-   * This method calculates the collation element value for the specified
-   * character(s).
-   */
-  int getCollationElementValue(String str)
+  public int compare (String source, String target)
   {
-    CollationElement e = null;
+    CollationElementIterator cs, ct;
 
-    // The table is sorted.  Change to a binary search later.
-    for (int i = 0; i < ce_table.length; i++) 
-      if (((CollationElement)ce_table[i]).char_seq.equals(str))
-        {
-          e = (CollationElement)ce_table[i];
-          break;
-        }
+    cs = new CollationElementIterator (source, this);
+    ct = new CollationElementIterator (target, this);
 
-    if (e == null)
-      e = new CollationElement(str, 0xFFFF, (short)0xFF, (short)0xFF);
+    while (true)
+      {
+	int os = next (cs, strength);
+	int ot = next (ct, strength);
+
+	if (os == CollationElementIterator.NULLORDER
+	    && ot == CollationElementIterator.NULLORDER)
+	  break;
+	else if (os == CollationElementIterator.NULLORDER)
+	  {
+	    // Source string is shorter, so return "less than".
+	    return -1;
+	  }
+	else if (ot == CollationElementIterator.NULLORDER)
+	  {
+	    // Target string is shorter, so return "greater than".
+	    return 1;
+	  }
 
-    int retval = (e.primary << 16) + (e.secondary << 8) + e.tertiary;
+	if (os != ot)
+	  return os - ot;
+      }
 
-    return(retval);
+    return 0;
   }
 
-  /**
-   * This method returns an instance for <code>CollationElementIterator</code>
-   * for the specified <code>String</code> under the collation rules for this
-   * object.
-   *
-   * @param str The <code>String</code> to return the <code>CollationElementIterator</code> instance for.
-   *
-   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
-   */
-  public CollationElementIterator getCollationElementIterator(String str)
+  public boolean equals (Object obj)
   {
-    return(new CollationElementIterator(this, str));
-  }  
+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))
+      return false;
+    RuleBasedCollator rbc = (RuleBasedCollator) obj;
+    // FIXME: this is probably wrong.  Instead we should compare maps
+    // directly.
+    return (frenchAccents == rbc.frenchAccents
+	    && rules.equals(rbc.rules));
+  }
 
-  /**
-   * This method returns an instance of <code>CollationElementIterator</code>
-   * for the <code>String</code> represented by the specified
-   * <code>CharacterIterator</code>.
-   *
-   * @param ci The <code>CharacterIterator</code> with the desired <code>String</code>.
-   *
-   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
-   */
-  public CollationElementIterator getCollationElementIterator(CharacterIterator ci)
+  public CollationElementIterator getCollationElementIterator (String source)
+  {
+    StringBuffer expand = new StringBuffer (source.length());
+    int max = source.length();
+    for (int i = 0; i < max; ++i)
+      decomposeCharacter (source.charAt(i), expand);
+    return new CollationElementIterator (expand.toString(), this);
+  }
+
+  public CollationElementIterator getCollationElementIterator (CharacterIterator source)
   {
-    StringBuffer sb = new StringBuffer("");
+    StringBuffer expand = new StringBuffer ();
+    for (char c = source.first ();
+	 c != CharacterIterator.DONE;
+	 c = source.next ())
+      decomposeCharacter (c, expand);
 
-    // Right now we assume that we will read from the beginning of the string.
-    char c = ci.first();
-    while (c != CharacterIterator.DONE) 
-      {
-        sb.append(c);
-        c = ci.next();
-      }
+    return new CollationElementIterator (expand.toString(), this);
+  }
 
-    return(getCollationElementIterator(sb.toString()));
+  public CollationKey getCollationKey (String source)
+  {
+    return new CollationKey (getCollationElementIterator (source), source,
+			     strength);
   }
 
-  /**
-   * This method returns an integer which indicates whether the first
-   * specified <code>String</code> is less than, greater than, or equal to
-   * the second.  The value depends not only on the collation rules in
-   * effect, but also the strength and decomposition settings of this object.
-   *
-   * @param s1 The first <code>String</code> to compare.
-   * @param s2 A second <code>String</code> to compare to the first.
-   *
-   * @return A negative integer if s1 &lt; s2, a positive integer
-   * if s1 &gt; s2, or 0 if s1 == s2.
-   */
-  public int compare(String s1, String s2)
+  public String getRules ()
   {
-    CollationElementIterator cei1 = getCollationElementIterator(s1);
-    CollationElementIterator cei2 = getCollationElementIterator(s2);
+    return rules;
+  }
 
-    for(;;)
+  public int hashCode ()
+  {
+    return (frenchAccents ? 1231 : 1237
+	    ^ rules.hashCode()
+	    ^ map.hashCode()
+	    ^ prefixes.hashCode());
+  }
+
+  private final boolean is_special (char c)
+  {
+    // Rules from JCL book.
+    return ((c >= 0x0009 && c <= 0x000d)
+	    || (c >= 0x0020 && c <= 0x002f)
+	    || (c >= 0x003a && c <= 0x0040)
+	    || (c >= 0x005b && c <= 0x0060)
+	    || (c >= 0x007b && c <= 0x007e));
+  }
+
+  private final int text_argument (String rules, int index,
+				   StringBuffer result)
+  {
+    result.setLength(0);
+    int len = rules.length();
+    while (index < len)
       {
-        int ord1 = cei1.next(); 
-        int ord2 = cei2.next(); 
-  
-        // Check for end of string
-        if (ord1 == CollationElementIterator.NULLORDER)
-          if (ord2 == CollationElementIterator.NULLORDER)
-            return(0);
-          else
-            return(-1);
-        else if (ord2 == CollationElementIterator.NULLORDER)
-          return(1);
-
-        // We know chars are totally equal, so skip
-        if (ord1 == ord2)
-          continue;
-
-        // Check for primary strength differences
-        int prim1 = cei1.primaryOrder(ord1); 
-        int prim2 = cei2.primaryOrder(ord2); 
-
-        if (prim1 < prim2)
-          return(-1);
-        else if (prim1 > prim2)
-          return(1);
-        else if (getStrength() == PRIMARY)
-          continue;
-
-        // Check for secondary strength differences
-        int sec1 = cei1.secondaryOrder(ord1);
-        int sec2 = cei2.secondaryOrder(ord2);
-
-        if (sec1 < sec2)
-          return(-1);
-        else if (sec1 > sec2)
-          return(1);
-        else if (getStrength() == SECONDARY)
-          continue;
-
-        // Check for tertiary differences
-        int tert1 = cei1.tertiaryOrder(ord1);
-        int tert2 = cei2.tertiaryOrder(ord1);
-
-        if (tert1 < tert2)
-          return(-1);
-        else if (tert1 > tert2)
-          return(1);
+	char c = rules.charAt(index);
+	if (c == '\'' && index + 2 < len
+	    && rules.charAt(index + 2) == '\''
+	    && is_special (rules.charAt(index + 1)))
+	  index += 2;
+	else if (is_special (c) || Character.isWhitespace(c))
+	  return index;
+	result.append(c);
+	++index;
       }
+    return index;
   }
 
-  /**
-   * This method returns an instance of <code>CollationKey</code> for the
-   * specified <code>String</code>.  The object returned will have a
-   * more efficient mechanism for its comparison function that could
-   * provide speed benefits if multiple comparisons are performed, such
-   * as during a sort.
-   *
-   * @param str The <code>String</code> to create a <code>CollationKey</code> for.
-   *
-   * @return A <code>CollationKey</code> for the specified <code>String</code>.
-   */
-  public CollationKey getCollationKey(String str)
+  public RuleBasedCollator (String rules) throws ParseException
   {
-    CollationElementIterator cei = getCollationElementIterator(str);
-    Vector vect = new Vector(25);
+    this.rules = rules;
+    this.frenchAccents = false;
+
+    // We keep each rule in order in a vector.  At the end we traverse
+    // the vector and compute collation values from it.
+    int insertion_index = 0;
+    Vector vec = new Vector ();
 
-    int ord = cei.next();
-    cei.reset(); //set to start of string
+    StringBuffer argument = new StringBuffer ();
 
-    while (ord != CollationElementIterator.NULLORDER)
+    int len = rules.length();
+    for (int index = 0; index < len; ++index)
       {
-        switch (getStrength())
-          {
-            case PRIMARY:
-               ord = cei.primaryOrder(ord);
-               break;
-
-            case SECONDARY:
-               ord = cei.secondaryOrder(ord);
-
-            default:
-               break;
-          }
+	char c = rules.charAt(index);
 
-        vect.add(new Integer(ord)); 
-	ord = cei.next(); //increment to next key
+	// Just skip whitespace.
+	if (Character.isWhitespace(c))
+	  continue;
+
+	// Modifier.
+	if (c == '@')
+	  {
+	    frenchAccents = true;
+	    continue;
+	  }
+
+	// Check for relation or reset operator.
+	if (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))
+	  throw new ParseException ("invalid character", index);
+
+	++index;
+	while (index < len)
+	  {
+	    if (! Character.isWhitespace(rules.charAt(index)))
+	      break;
+	    ++index;
+	  }
+	if (index == len)
+	  throw new ParseException ("missing argument", index);
+
+	int save = index;
+	index = text_argument (rules, index, argument);
+	if (argument.length() == 0)
+	  throw new ParseException ("invalid character", save);
+	String arg = argument.toString();
+	int item_index = vec.indexOf(arg);
+	if (c != '&')
+	  {
+	    // If the argument already appears in the vector, then we
+	    // must remove it in order to re-order.
+	    if (item_index != -1)
+	      {
+		vec.removeElementAt(item_index);
+		if (insertion_index >= item_index)
+		  --insertion_index;
+	      }
+	    RBCElement r = new RBCElement (arg, c);
+	    vec.insertElementAt(r, insertion_index);
+	    ++insertion_index;
+	  }
+	else
+	  {
+	    // Reset.
+	    if (item_index == -1)
+	      throw
+		new ParseException ("argument to reset not previously seen",
+				    save);
+	    insertion_index = item_index + 1;
+	  }
+
+	// Ugly: in this case the resulting INDEX comes from
+	// text_argument, which returns the index of the next
+	// character we should examine.
+	--index;
       }
 
-    Object[] objarr = vect.toArray();
-    byte[] key = new byte[objarr.length * 4];
-
-    for (int i = 0; i < objarr.length; i++)
+    // Now construct a hash table that maps strings onto their
+    // collation values.
+    int primary = 0;
+    int secondary = 0;
+    int tertiary = 0;
+    this.map = new Hashtable ();
+    this.prefixes = new Hashtable ();
+    Enumeration e = vec.elements();
+    while (e.hasMoreElements())
       {
-        int j = ((Integer)objarr[i]).intValue();
-        key [i * 4] = (byte)((j & 0xFF000000) >> 24);
-        key [i * 4 + 1] = (byte)((j & 0x00FF0000) >> 16);
-        key [i * 4 + 2] = (byte)((j & 0x0000FF00) >> 8);
-        key [i * 4 + 3] = (byte)(j & 0x000000FF);
+	RBCElement r = (RBCElement) e.nextElement();
+	switch (r.relation)
+	  {
+	  case '<':
+	    ++primary;
+	    secondary = 0;
+	    tertiary = 0;
+	    break;
+	  case ';':
+	    ++secondary;
+	    tertiary = 0;
+	    break;
+	  case ',':
+	    ++tertiary;
+	    break;
+	  case '=':
+	    break;
+	  }
+	// This must match CollationElementIterator.
+	map.put(r.key, new Integer (primary << 16
+				    | secondary << 8 | tertiary));
+
+	// Make a map of all lookaheads we might need.
+	for (int i = r.key.length() - 1; i >= 1; --i)
+	  prefixes.put(r.key.substring(0, i), Boolean.TRUE);
       }
-
-    return(new CollationKey(this, str, key));
-  }
-
-  /**
-   * This method tests this object for equality against the specified 
-   * object.  This will be true if and only if the specified object is
-   * another reference to this object.
-   *
-   * @param obj The <code>Object</code> to compare against this object.
-   *
-   * @return <code>true</code> if the specified object is equal to this object, <code>false</code> otherwise.
-   */
-  public boolean equals(Object obj)
-  {
-    if (obj == this)
-      return(true);
-    else
-      return(false);
-  }
-
-  /**
-   * This method returns a hash value for this object.
-   *
-   * @return A hash value for this object.
-   */
-  public int hashCode()
-  {
-    return(System.identityHashCode(this));
-  }
-
-  /**
-   * This method creates a copy of this object.
-   *
-   * @return A copy of this object.
-   */
-  public Object clone()
-  {
-    return super.clone();
   }
 }
