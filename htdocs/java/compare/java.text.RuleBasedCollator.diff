--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2003-10-16 02:19:34.000000000 -0600
+++ java/text/RuleBasedCollator.java	2003-10-16 02:17:56.000000000 -0600
@@ -38,6 +38,8 @@
 
 package java.text;
 
+import java.util.Enumeration;
+import java.util.Hashtable;
 import java.util.Vector;
 
 /* Written using "Java Class Libraries", 2nd edition, plus online
@@ -134,34 +136,36 @@
  * @author Tom Tromey <tromey@cygnus.com>
  * @date March 25, 1999
  */
+
 public class RuleBasedCollator extends Collator
 {
   final class CollationElement
   {
-    String char_seq;
-    int primary;
-    short secondary;
-    short tertiary;
+    String key;
+    char relation;
 
-    CollationElement(String char_seq, int primary, short secondary, short tertiary)
+    CollationElement (String key, char relation)
     {
-      this.char_seq = char_seq;
-      this.primary = primary;
-      this.secondary = secondary;
-      this.tertiary = tertiary;
+      this.key = key;
+      this.relation = relation;
     }
 
   } // inner class CollationElement
 
+  // True if we are using French-style accent ordering.
+  private boolean frenchAccents;
+
   /**
    * This the the original rule string.
    */
   private String rules;
 
-  /**
-   * This is the table of collation element values
-   */
-  private Object[] ce_table;
+  // This maps strings onto collation values.
+  private Hashtable map;
+  
+  // An entry in this hash means that more lookahead is required for
+  // the prefix string.
+  private Hashtable prefixes;
   
   /**
    * This method initializes a new instance of <code>RuleBasedCollator</code>
@@ -177,121 +181,117 @@
   public RuleBasedCollator (String rules) throws ParseException
   {
     this.rules = rules;
+    this.frenchAccents = false;
+
+    // We keep each rule in order in a vector.  At the end we traverse
+    // the vector and compute collation values from it.
+    int insertion_index = 0;
+    Vector vec = new Vector ();
 
-    if (rules.equals(""))
-      throw new IllegalArgumentException("Empty rule set");
+    StringBuffer argument = new StringBuffer ();
 
-    Vector v = new Vector();
-    boolean ignore_chars = true;
-    int primary_seq = 0;
-    short secondary_seq = 0;
-    short tertiary_seq = 0;
-    StringBuffer sb = new StringBuffer("");
     int len = rules.length();
-    
     for (int index = 0; index < len; ++index)
       {
-	char c = rules.charAt (index);
+	char c = rules.charAt(index);
 
 	// Just skip whitespace.
-	if (Character.isWhitespace (c))
-          continue;
+	if (Character.isWhitespace(c))
+	  continue;
 
-        // Primary difference
-        if (c == '<')
-          {
-            ignore_chars = false;
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            secondary_seq = 0;
-            tertiary_seq = 0;
-            ++primary_seq;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Secondary difference
-        if (c == ';')
-          {
-            if (primary_seq == 0)
-              throw new ParseException (rules, index);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            ++secondary_seq;
-            tertiary_seq = 0;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Tertiary difference
-        if (c == ',')
-          {
-            if (primary_seq == 0)
-              throw new ParseException (rules, index);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            ++tertiary_seq;
-
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Is equal to
-        if (c == '=')
-          {
-            if (primary_seq == 0)
-              throw new ParseException (rules, index);
-
-            CollationElement e = new CollationElement(sb.toString(), primary_seq,
-                                                      secondary_seq,
-                                                      tertiary_seq);
-            v.add(e);
-            sb.setLength(0);
-            continue;
-          }
-
-        // Sort accents backwards
-        if (c == '@')
-          {
-            throw new ParseException("French style accents not implemented yet", 0);
-          }
-
-        // Reset command
-        if (c == '&')
-          {
-            throw new ParseException("Reset not implemented yet", 0);
-          }
-
-        // See if we are still reading characters to skip
-        if (ignore_chars == true)
-          {
-            CollationElement e = new CollationElement(c + "", 0, (short)0, 
-                                                      (short)0);
-            v.add(e);
-            continue;
-          }
-
-        sb.append(c);
+	// Modifier.
+	if (c == '@')
+	  {
+	    frenchAccents = true;
+	    continue;
+	  }
+
+	// Check for relation or reset operator.
+	if (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))
+	  throw new ParseException ("invalid character", index);
+
+	++index;
+	while (index < len)
+	  {
+	    if (! Character.isWhitespace(rules.charAt(index)))
+	      break;
+	    ++index;
+	  }
+	if (index == len)
+	  throw new ParseException ("missing argument", index);
+
+	int save = index;
+	index = text_argument (rules, index, argument);
+	if (argument.length() == 0)
+	  throw new ParseException ("invalid character", save);
+	String arg = argument.toString();
+	int item_index = vec.indexOf(arg);
+	if (c != '&')
+	  {
+	    // If the argument already appears in the vector, then we
+	    // must remove it in order to re-order.
+	    if (item_index != -1)
+	      {
+		vec.removeElementAt(item_index);
+		if (insertion_index >= item_index)
+		  --insertion_index;
+	      }
+	    CollationElement r = new CollationElement (arg, c);
+	    vec.insertElementAt(r, insertion_index);
+	    ++insertion_index;
+	  }
+	else
+	  {
+	    // Reset.
+	    if (item_index == -1)
+	      throw
+		new ParseException ("argument to reset not previously seen",
+				    save);
+	    insertion_index = item_index + 1;
+	  }
+
+	// Ugly: in this case the resulting INDEX comes from
+	// text_argument, which returns the index of the next
+	// character we should examine.
+	--index;
       }
 
-    if (sb.length() > 0)
+    // Now construct a hash table that maps strings onto their
+    // collation values.
+    int primary = 0;
+    int secondary = 0;
+    int tertiary = 0;
+    this.map = new Hashtable ();
+    this.prefixes = new Hashtable ();
+    Enumeration e = vec.elements();
+    while (e.hasMoreElements())
       {
-	CollationElement e = new CollationElement (sb.toString(), primary_seq,
-						   secondary_seq, tertiary_seq);
-	v.add (e);
+	CollationElement r = (CollationElement) e.nextElement();
+	switch (r.relation)
+	  {
+	  case '<':
+	    ++primary;
+	    secondary = 0;
+	    tertiary = 0;
+	    break;
+	  case ';':
+	    ++secondary;
+	    tertiary = 0;
+	    break;
+	  case ',':
+	    ++tertiary;
+	    break;
+	  case '=':
+	    break;
+	  }
+	// This must match CollationElementIterator.
+	map.put(r.key, new Integer (primary << 16
+				    | secondary << 8 | tertiary));
+
+	// Make a map of all lookaheads we might need.
+	for (int i = r.key.length() - 1; i >= 1; --i)
+	  prefixes.put(r.key.substring(0, i), Boolean.TRUE);
       }
-
-    ce_table = v.toArray();
   }
 
   /**
@@ -301,7 +301,91 @@
    */
   public Object clone()
   {
-    return super.clone();
+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();
+    c.map = (Hashtable) map.clone ();
+    c.prefixes = (Hashtable) map.clone ();
+    return c;
+  }
+
+  // A helper for CollationElementIterator.next().
+  int ceiNext (CollationElementIterator cei)
+  {
+    if (cei.lookahead_set)
+      {
+	cei.lookahead_set = false;
+	return cei.lookahead;
+      }
+
+    int save = cei.index;
+    int max = cei.text.length();
+    String s = null;
+
+    // It is possible to have a case where `abc' has a mapping, but
+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as
+    // nothing special.
+    boolean found = false;
+
+    int i;
+    for (i = save + 1; i <= max; ++i)
+      {
+	s = cei.text.substring(save, i);
+	if (prefixes.get(s) == null)
+	  break;
+	found = true;
+      }
+    // Assume s != null.
+
+    Object obj = map.get(s);
+    // The special case.
+    while (found && obj == null && s.length() > 1)
+      {
+	--i;
+	s = cei.text.substring(save, i);
+	obj = map.get(s);
+      }
+
+    // Update state.
+    cei.index = i;
+
+    if (obj == null)
+      {
+	// This idea, and the values, come from JDK.
+	// assert (s.length() == 1)
+	cei.lookahead_set = true;
+	cei.lookahead = s.charAt(0) << 8;
+	return 0x7fff << 16;
+      }
+
+    return ((Integer) obj).intValue();
+  }
+
+  // A helper for compareTo() that returns the next character that has
+  // a nonzero ordering at the indicated strength.  This is also used
+  // in CollationKey.
+  static final int next (CollationElementIterator iter, int strength)
+  {
+    while (true)
+      {
+	int os = iter.next();
+	if (os == CollationElementIterator.NULLORDER)
+	  return os;
+	int c = 0;
+	switch (strength)
+	  {
+	  case PRIMARY:
+	    c = os & ~0xffff;
+	    break;
+	  case SECONDARY:
+	    c = os & ~0x00ff;
+	    break;
+	  case TERTIARY:
+	  case IDENTICAL:
+	    c = os;
+	    break;
+	  }
+	if (c != 0)
+	  return c;
+      }
   }
 
   /**
@@ -310,66 +394,43 @@
    * the second.  The value depends not only on the collation rules in
    * effect, but also the strength and decomposition settings of this object.
    *
-   * @param source The first <code>String</code> to compare.
-   * @param target A second <code>String</code> to compare to the first.
+   * @param s1 The first <code>String</code> to compare.
+   * @param s2 A second <code>String</code> to compare to the first.
    *
-   * @return A negative integer if source &lt; target, a positive integer
-   * if source &gt; target, or 0 if source == target.
+   * @return A negative integer if s1 &lt; s2, a positive integer
+   * if s1 &gt; s2, or 0 if s1 == s2.
    */
   public int compare (String source, String target)
   {
-    CollationElementIterator cei1 = getCollationElementIterator (source);
-    CollationElementIterator cei2 = getCollationElementIterator (target);
+    CollationElementIterator cs, ct;
 
-    for(;;)
+    cs = new CollationElementIterator (source, this);
+    ct = new CollationElementIterator (target, this);
+
+    while (true)
       {
-        int ord1 = cei1.next(); 
-        int ord2 = cei2.next(); 
-  
-        // Check for end of string
-        if (ord1 == CollationElementIterator.NULLORDER)
-          if (ord2 == CollationElementIterator.NULLORDER)
-            return(0);
-          else
-            return(-1);
-        else if (ord2 == CollationElementIterator.NULLORDER)
-          return(1);
-
-        // We know chars are totally equal, so skip
-        if (ord1 == ord2)
-          continue;
-
-        // Check for primary strength differences
-        int prim1 = cei1.primaryOrder(ord1); 
-        int prim2 = cei2.primaryOrder(ord2); 
-
-        if (prim1 < prim2)
-          return(-1);
-        else if (prim1 > prim2)
-          return(1);
-        else if (getStrength() == PRIMARY)
-          continue;
-
-        // Check for secondary strength differences
-        int sec1 = cei1.secondaryOrder(ord1);
-        int sec2 = cei2.secondaryOrder(ord2);
-
-        if (sec1 < sec2)
-          return(-1);
-        else if (sec1 > sec2)
-          return(1);
-        else if (getStrength() == SECONDARY)
-          continue;
-
-        // Check for tertiary differences
-        int tert1 = cei1.tertiaryOrder(ord1);
-        int tert2 = cei2.tertiaryOrder(ord1);
-
-        if (tert1 < tert2)
-          return(-1);
-        else if (tert1 > tert2)
-          return(1);
+	int os = next (cs, strength);
+	int ot = next (ct, strength);
+
+	if (os == CollationElementIterator.NULLORDER
+	    && ot == CollationElementIterator.NULLORDER)
+	  break;
+	else if (os == CollationElementIterator.NULLORDER)
+	  {
+	    // Source string is shorter, so return "less than".
+	    return -1;
+	  }
+	else if (ot == CollationElementIterator.NULLORDER)
+	  {
+	    // Target string is shorter, so return "greater than".
+	    return 1;
+	  }
+
+	if (os != ot)
+	  return os - ot;
       }
+
+    return 0;
   }
 
   /**
@@ -383,10 +444,13 @@
    */
   public boolean equals (Object obj)
   {
-    if (obj == this)
-      return(true);
-    else
-      return(false);
+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))
+      return false;
+    RuleBasedCollator rbc = (RuleBasedCollator) obj;
+    // FIXME: this is probably wrong.  Instead we should compare maps
+    // directly.
+    return (frenchAccents == rbc.frenchAccents
+	    && rules.equals(rbc.rules));
   }
 
   /**
@@ -394,35 +458,37 @@
    * for the specified <code>String</code> under the collation rules for this
    * object.
    *
-   * @param source The <code>String</code> to return the <code>CollationElementIterator</code> instance for.
+   * @param str The <code>String</code> to return the <code>CollationElementIterator</code> instance for.
    *
    * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
    */
   public CollationElementIterator getCollationElementIterator (String source)
   {
-    return new CollationElementIterator (source, this);
-  }  
+    StringBuffer expand = new StringBuffer (source.length());
+    int max = source.length();
+    for (int i = 0; i < max; ++i)
+      decomposeCharacter (source.charAt(i), expand);
+    return new CollationElementIterator (expand.toString(), this);
+  }
 
   /**
    * This method returns an instance of <code>CollationElementIterator</code>
    * for the <code>String</code> represented by the specified
    * <code>CharacterIterator</code>.
    *
-   * @param source The <code>CharacterIterator</code> with the desired <code>String</code>.
+   * @param ci The <code>CharacterIterator</code> with the desired <code>String</code>.
    *
    * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.
    */
   public CollationElementIterator getCollationElementIterator (CharacterIterator source)
   {
-    StringBuffer sb = new StringBuffer("");
+    StringBuffer expand = new StringBuffer ();
+    for (char c = source.first ();
+	 c != CharacterIterator.DONE;
+	 c = source.next ())
+      decomposeCharacter (c, expand);
 
-    // Right now we assume that we will read from the beginning of the string.
-    for (char c = source.first(); c != CharacterIterator.DONE; c = source.next()) 
-      {
-        sb.append (c);
-      }
-
-    return getCollationElementIterator (sb.toString());
+    return new CollationElementIterator (expand.toString(), this);
   }
 
   /**
@@ -432,50 +498,14 @@
    * provide speed benefits if multiple comparisons are performed, such
    * as during a sort.
    *
-   * @param source The <code>String</code> to create a <code>CollationKey</code> for.
+   * @param str The <code>String</code> to create a <code>CollationKey</code> for.
    *
    * @return A <code>CollationKey</code> for the specified <code>String</code>.
    */
   public CollationKey getCollationKey (String source)
   {
-    CollationElementIterator cei = getCollationElementIterator (source);
-    Vector vect = new Vector(25);
-
-    int ord = cei.next();
-    cei.reset(); //set to start of string
-
-    while (ord != CollationElementIterator.NULLORDER)
-      {
-        switch (getStrength())
-          {
-            case PRIMARY:
-               ord = cei.primaryOrder(ord);
-               break;
-
-            case SECONDARY:
-               ord = cei.secondaryOrder(ord);
-
-            default:
-               break;
-          }
-
-        vect.add(new Integer(ord)); 
-	ord = cei.next(); //increment to next key
-      }
-
-    Object[] objarr = vect.toArray();
-    byte[] key = new byte[objarr.length * 4];
-
-    for (int i = 0; i < objarr.length; i++)
-      {
-        int j = ((Integer)objarr[i]).intValue();
-        key [i * 4] = (byte)((j & 0xFF000000) >> 24);
-        key [i * 4 + 1] = (byte)((j & 0x00FF0000) >> 16);
-        key [i * 4 + 2] = (byte)((j & 0x0000FF00) >> 8);
-        key [i * 4 + 3] = (byte)(j & 0x000000FF);
-      }
-
-    return new CollationKey (this, source, key);
+    return new CollationKey (getCollationElementIterator (source), source,
+			     strength);
   }
 
   /**
@@ -496,31 +526,40 @@
    */
   public int hashCode()
   {
-    return System.identityHashCode (this);
+    return (frenchAccents ? 1231 : 1237
+	    ^ rules.hashCode()
+	    ^ map.hashCode()
+	    ^ prefixes.hashCode());
   }
 
-  /**
-   * This method calculates the collation element value for the specified
-   * character(s).
-   */
-  int getCollationElementValue (String source)
+  private final boolean is_special (char c)
   {
-    CollationElement e = null;
-
-    // The table is sorted.  Change to a binary search later.
-    for (int i = 0; i < ce_table.length; i++) 
-      if (((CollationElement) ce_table [i]).char_seq.equals (source))
-        {
-          e = (CollationElement) ce_table [i];
-          break;
-        }
-
-    if (e == null)
-      e = new CollationElement (source, 0xFFFF, (short)0xFF, (short)0xFF);
-
-    int retval = (e.primary << 16) + (e.secondary << 8) + e.tertiary;
+    // Rules from JCL book.
+    return ((c >= 0x0009 && c <= 0x000d)
+	    || (c >= 0x0020 && c <= 0x002f)
+	    || (c >= 0x003a && c <= 0x0040)
+	    || (c >= 0x005b && c <= 0x0060)
+	    || (c >= 0x007b && c <= 0x007e));
+  }
 
-    return retval;
+  private final int text_argument (String rules, int index,
+				   StringBuffer result)
+  {
+    result.setLength(0);
+    int len = rules.length();
+    while (index < len)
+      {
+	char c = rules.charAt(index);
+	if (c == '\'' && index + 2 < len
+	    && rules.charAt(index + 2) == '\''
+	    && is_special (rules.charAt(index + 1)))
+	  index += 2;
+	else if (is_special (c) || Character.isWhitespace(c))
+	  return index;
+	result.append(c);
+	++index;
+      }
+    return index;
   }
 
-} // class RuleBaseCollator
+}
