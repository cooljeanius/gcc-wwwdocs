--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2004-05-21 02:26:38.000000000 -0600
+++ java/text/RuleBasedCollator.java	2004-05-05 02:18:55.000000000 -0600
@@ -38,7 +38,7 @@
 package java.text;
 
 import java.util.Enumeration;
-import java.util.HashMap;
+import java.util.Hashtable;
 import java.util.Vector;
 
 /* Written using "Java Class Libraries", 2nd edition, plus online
@@ -147,110 +147,32 @@
    * This class describes what rank has a character (or a sequence of characters) 
    * in the lexicographic order. Each element in a rule has a collation element.
    */
-  final static class CollationElement
+  final class CollationElement
   {
     String key;
-    int primary;
-    short secondary;
-    short tertiary;
-    short equality;
-    boolean ignore;
-    String expansion;
+    char relation;
 
-    CollationElement(String key, int primary, short secondary, short tertiary,
-		     short equality, String expansion)
+    CollationElement(String key, char relation)
     {
       this.key = key;
-      this.primary = primary;
-      this.secondary = secondary;
-      this.tertiary = tertiary;
-      this.equality = equality;
-      this.ignore = false;
-      this.expansion = expansion;
-    }
-    
-    CollationElement(String key)
-    {
-      this.key = key;
-      this.ignore = true;
-    }
-
-    final int getValue()
-    {
-      return (primary << 16) + (secondary << 8) + tertiary;
+      this.relation = relation;
     }
   }
 
-  /**
-   * Basic collation instruction (internal format) to build the series of
-   * collation elements. It contains an instruction which specifies the new
-   * state of the generator. The sequence of instruction should not contain
-   * RESET (it is used by
-   * {@link #mergeRules(int,java.lang.String,java.util.Vector,java.util.Vector)})
-   * as a temporary state while merging two sets of instructions.
-   */
-  final static class CollationSorter
-  {
-    static final int GREATERP = 0;
-    static final int GREATERS = 1;
-    static final int GREATERT = 2;
-    static final int EQUAL = 3;
-    static final int RESET = 4;
-    static final int IGNORE = 5;
-    static final int INVERSE_SECONDARY = 6;
-    
-    int comparisonType;
-    String textElement;
-    int hashText;
-    int offset;
-
-    String expansionOrdering;
-  }
+  // True if we are using French-style accent ordering.
+  private boolean frenchAccents;
 
   /**
    * This the the original rule string.
    */
   private String rules;
 
-  /**
-   * This is the table of collation element values
-   */
-  private Object[] ce_table;
-
-  /**
-   * Quick-prefix finder.
-   */
-  HashMap prefix_tree;
-
-  /**
-   * This is the value of the last sequence entered into
-   * <code>ce_table</code>. It is used to compute the
-   * ordering value of unspecified character.
-   */
-  private int last_primary_value;
-
-  /**
-   * This is the value of the last secondary sequence of the
-   * primary 0, entered into
-   * <code>ce_table</code>. It is used to compute the
-   * ordering value of an unspecified accented character.
-   */
-  private int last_tertiary_value;
-
-  /**
-   * This variable is true if accents need to be sorted
-   * in the other direction.
-   */
-  private boolean inverseAccentComparison;
-
-  /**
-   * This collation element is special to unknown sequence.
-   * The JDK uses it to mark and sort the characters which has
-   * no collation rules.
-   */
-  static final CollationElement SPECIAL_UNKNOWN_SEQ = 
-    new CollationElement("", (short) 32767, (short) 0, (short) 0,
-			 (short) 0, null);
+  // This maps strings onto collation values.
+  private Hashtable map;
+  
+  // An entry in this hash means that more lookahead is required for
+  // the prefix string.
+  private Hashtable prefixes;
   
   /**
    * This method initializes a new instance of <code>RuleBasedCollator</code>
@@ -270,315 +192,128 @@
     
     this.rules = rules;
 
-    buildCollationVector(parseString(rules));
-    buildPrefixAccess();
-  }
+    // We keep each rule in order in a vector.  At the end we traverse
+    // the vector and compute collation values from it.
+    int insertion_index = 0;
+    Vector vec = new Vector ();
 
-  /**
-   * This method returns the number of common characters at the beginning
-   * of the string of the two parameters.
-   *
-   * @param prefix A string considered as a prefix to test against
-   * the other string.
-   * @param s A string to test the prefix against.
-   * @return The number of common characters.
-   */
-  static int findPrefixLength(String prefix, String s)
-  {
     int index;
-    int len = prefix.length();
-
-    for (index = 0; index < len && index < s.length(); ++index)
-      {
-	if (prefix.charAt(index) != s.charAt(index))
-	  return index;
-      }
-
+    StringBuffer argument = new StringBuffer();
+    int len = rules.length();
 
-    return index;
-  }
-
-  /**
-   * Here we are merging two sets of sorting instructions: 'patch' into 'main'. This methods
-   * checks whether it is possible to find an anchor point for the rules to be merged and
-   * then insert them at that precise point.
-   *
-   * @param offset Offset in the string containing rules of the beginning of the rules
-   * being merged in.
-   * @param starter Text of the rules being merged.
-   * @param main Repository of all already parsed rules.
-   * @param patch Rules to be merged into the repository.
-   * @throws ParseException if it is impossible to find an anchor point for the new rules.
-   */
-  private void mergeRules(int offset, String starter, Vector main, Vector patch)
-    throws ParseException 
-  {
-    Enumeration elements = main.elements();
-    int insertion_point = -1;
-    int max_length = 0;
-    
-    /* We must check that no rules conflict with another already present. If it
-     * is the case delete the old rule. 
-     */
-    
-    /* For the moment good old O(N^2) algorithm.
-     */
-    for (int i = 0; i < patch.size(); i++)
+    for (index = 0; index < len; ++index)
       {
-	int j = 0;
-	
-	while (j < main.size())
-	  {
-	    CollationSorter rule1 = (CollationSorter) patch.elementAt(i);
-	    CollationSorter rule2 = (CollationSorter) main.elementAt(j);
-	    
-	    if (rule1.textElement.equals(rule2.textElement))
-	      main.removeElementAt(j);
-	    else
-	      j++;
-	  }
-      }
+	char c = rules.charAt(index);
 
-    // Find the insertion point... O(N)
-    for (int i = 0; i < main.size(); i++)
-      {
-	CollationSorter sorter = (CollationSorter) main.elementAt(i);
-	int length = findPrefixLength(starter, sorter.textElement);
-		
-	if (length > max_length)
-	  {
-	    max_length = length;
-	    insertion_point = i+1;
-	  }
-      }
-
-    if (insertion_point < 0)
-      throw new ParseException("no insertion point found for " + starter, offset);
-
-    if (max_length < starter.length())
-      {
-	/*
-	 * We need to expand the first entry. It must be sorted
-	 * like if it was the reference key itself (like the spec
-	 * said. So the first entry is special: the element is
-	 * replaced by the specified text element for the sorting.
-	 * This text replace the old one for comparisons. However
-	 * to preserve the behaviour we replace the first key (corresponding
-	 * to the found prefix) by a new code rightly ordered in the
-	 * sequence. The rest of the subsequence must be appended
-	 * to the end of the sequence.
-	 */
-	CollationSorter sorter = (CollationSorter) patch.elementAt(0);
-	CollationSorter expansionPrefix =
-	  (CollationSorter) main.elementAt(insertion_point-1);
-	
-	sorter.expansionOrdering = starter.substring(max_length); // Skip the first good prefix element
-		
-	main.insertElementAt(sorter, insertion_point);
-	
-	/*
-	 * This is a new set of rules. Append to the list.
-	 */
-	patch.removeElementAt(0);
-	insertion_point++;
-      }
-
-    // Now insert all elements of patch at the insertion point.
-    for (int i = 0; i < patch.size(); i++)
-      main.insertElementAt(patch.elementAt(i), i+insertion_point);
-  }
-
-  /**
-   * This method parses a string and build a set of sorting instructions. The parsing
-   * may only be partial on the case the rules are to be merged sometime later.
-   * 
-   * @param stop_on_reset If this parameter is true then the parser stops when it
-   * encounters a reset instruction. In the other case, it tries to parse the subrules
-   * and merged it in the same repository.
-   * @param v Output vector for the set of instructions.
-   * @param base_offset Offset in the string to begin parsing.
-   * @param rules Rules to be parsed.
-   * @return -1 if the parser reached the end of the string, an integer representing the
-   * offset in the string at which it stopped parsing. 
-   * @throws ParseException if something turned wrong during the parsing. To get details
-   * decode the message.
-   */
-  private int subParseString(boolean stop_on_reset, Vector v,
-			     int base_offset, String rules)
-    throws ParseException
-  {
-    boolean ignoreChars = (base_offset == 0);
-    int operator = -1;
-    StringBuffer sb = new StringBuffer();
-    boolean doubleQuote = false;
-    boolean eatingChars = false;
-    boolean nextIsModifier = false;
-    boolean isModifier = false;
-    int i;
-    
-main_parse_loop:
-    for (i = 0; i < rules.length(); i++)
-      {
-	char c = rules.charAt(i);
-	int type = -1;
-	
-	if (!eatingChars &&
-	    ((c >= 0x09 && c <= 0x0D) || (c == 0x20)))
-	      continue;
-
-	isModifier = nextIsModifier;
-	nextIsModifier = false;
+	// Just skip whitespace.
+	if (Character.isWhitespace(c))
+	  continue;
 
-	if (eatingChars && c != '\'')
-	  {
-	    doubleQuote = false;
-	    sb.append(c);
-	    continue;
-	  }
-	if (doubleQuote && eatingChars)
+	// Modifier.
+	if (c == '@')
 	  {
-	    sb.append(c);
-	    doubleQuote = false;
+	    frenchAccents = true;
 	    continue;
 	  }
 
-	switch (c) {
-	case '!':
-	  throw new ParseException
-	    ("Modifier '!' is not yet supported by Classpath", i+base_offset);
-	case '<':
-	  ignoreChars = false;
-	  type = CollationSorter.GREATERP;
-	  break;
-	case ';':
-	  if (!ignoreChars)
-	    type = CollationSorter.GREATERS;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case ',':
-	  if (!ignoreChars)
-	    type = CollationSorter.GREATERT;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case '=':
-	  if (!ignoreChars)
-	    type = CollationSorter.EQUAL;
-	  else
-	    type = CollationSorter.IGNORE;
-	  break;
-	case '\'':
-	  eatingChars = !eatingChars;
-	  doubleQuote = true;
-	  break;
-	case '@':
-	  if (ignoreChars)
-	    throw new ParseException
-	      ("comparison list has not yet been started. You may only use"
-	       + "(<,;=&)", i+base_offset);
-	  // Inverse the order of secondaries from now on.
-	  nextIsModifier = true;
-	  type = CollationSorter.INVERSE_SECONDARY;
-	  break;
-	case '&':
-	  type = CollationSorter.RESET;
-	  if (stop_on_reset)
-	    break main_parse_loop;
-	  break;
-	default:
-	  if (operator < 0)
-	    throw new ParseException
-	      ("operator missing at " + (i+base_offset), i+base_offset);
-	  if (!eatingChars &&
-	      ((c >= 0x21 && c <= 0x2F) 
-	       || (c >= 0x3A && c <= 0x40)
-	       || (c >= 0x5B && c <= 0x60)
-	       || (c >= 0x7B && c <= 0x7E)))
-	    throw new ParseException
-	      ("unquoted punctuation character '"+c+"'", i+base_offset);
-
-	  //type = ignoreChars ? CollationSorter.IGNORE : -1;
-	  sb.append(c);
-	  break;
-	}
+	// Check for relation or reset operator.
+	if (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))
+	  throw new ParseException ("invalid character", index);
 
-	if (type  < 0)
-	  continue;
-
-	if (operator < 0)
+	++index;
+	while (index < len)
 	  {
-	    operator = type;
-	    continue;
+	    if (! Character.isWhitespace(rules.charAt(index)))
+	      break;
+	    ++index;
 	  }
+	if (index == len)
+	  throw new ParseException ("missing argument", index);
 
-	if (sb.length() == 0 && !isModifier)
-	  throw new ParseException
-	    ("text element empty at " + (i+base_offset), i+base_offset);
+	int save = index;
+	index = text_argument (rules, index, argument);
+	if (argument.length() == 0)
+	  throw new ParseException ("invalid character", save);
+	String arg = argument.toString();
+	int item_index = -1;
+        
+        for (int j = 0; j < vec.size(); ++j)
+          {
+            CollationElement e = (CollationElement) vec.elementAt (j);
 
-	if (operator == CollationSorter.RESET)
+            if (arg.equals (e.key))
+              {
+                item_index = j;
+                break;
+              }
+          }
+	
+	if (c != '&')
 	  {
-	    /* Reposition in the sorting list at the position
-	     * indicated by the text element.
-	     */
-	    String subrules = rules.substring(i);
-	    Vector sorted_rules = new Vector();
-	    int idx;
-
-	    // Parse the subrules but do not iterate through all
-	    // sublist. This is the priviledge of the first call.
-	    idx = subParseString(true, sorted_rules, base_offset+i, subrules);
-    
-	    // Merge new parsed rules into the list.
-	    mergeRules(base_offset+i, sb.toString(), v, sorted_rules);
-	    sb.setLength(0);
-	    
-	    // Reset state to none.
-	    operator = -1;
-	    type = -1;
-	    // We have found a new subrule at 'idx' but it has not been parsed.
-	    if (idx >= 0)
+	    // If the argument already appears in the vector, then we
+	    // must remove it in order to re-order.
+	    if (item_index != -1)
 	      {
-		i += idx-1;
-		continue main_parse_loop;
+		vec.removeElementAt(item_index);
+		if (insertion_index >= item_index)
+		  --insertion_index;
 	      }
-	    else
-		// No more rules.
-		break main_parse_loop;
+	    CollationElement r = new CollationElement (arg, c);
+	    vec.insertElementAt(r, insertion_index);
+	    ++insertion_index;
 	  }
-
-	CollationSorter sorter = new CollationSorter();
-	
-	sorter.comparisonType = operator;
-	sorter.textElement = sb.toString();
-	sorter.hashText = sorter.textElement.hashCode();
-	sorter.offset = base_offset+rules.length();
-	sb.setLength(0);
-
-	v.add(sorter);
-	operator = type;
-      }
-
-    if (operator >= 0)
-      {
-	CollationSorter sorter = new CollationSorter();
-	int pos = rules.length() + base_offset;
-
-	if ((sb.length() != 0 && nextIsModifier)
-	    || (sb.length() == 0 && !nextIsModifier && !eatingChars))
-	  throw new ParseException("text element empty at " + pos, pos);
-
-	sorter.comparisonType = operator;
-	sorter.textElement = sb.toString();
- 	sorter.hashText = sorter.textElement.hashCode();
-	sorter.offset = base_offset+pos;
-	v.add(sorter);
+	else
+	  {
+	    // Reset.
+	    if (item_index == -1)
+	      throw
+		new ParseException ("argument to reset not previously seen",
+				    save);
+	    insertion_index = item_index + 1;
+	  }
+
+	// Ugly: in this case the resulting INDEX comes from
+	// text_argument, which returns the index of the next
+	// character we should examine.
+	--index;
+      }
+
+    // Now construct a hash table that maps strings onto their
+    // collation values.
+    int primary = 0;
+    int secondary = 0;
+    int tertiary = 0;
+    this.map = new Hashtable ();
+    this.prefixes = new Hashtable ();
+    Enumeration e = vec.elements();
+    while (e.hasMoreElements())
+      {
+	CollationElement r = (CollationElement) e.nextElement();
+	switch (r.relation)
+	  {
+	  case '<':
+	    ++primary;
+	    secondary = 0;
+	    tertiary = 0;
+	    break;
+	  case ';':
+	    ++secondary;
+	    tertiary = 0;
+	    break;
+	  case ',':
+	    ++tertiary;
+	    break;
+	  case '=':
+	    break;
+	  }
+	// This must match CollationElementIterator.
+	map.put(r.key, new Integer (primary << 16
+				    | secondary << 8 | tertiary));
+
+	// Make a map of all lookaheads we might need.
+	for (int i = r.key.length() - 1; i >= 1; --i)
+	  prefixes.put(r.key.substring(0, i), Boolean.TRUE);
       }
-
-    if (i == rules.length())
-      return -1;
-    else
-      return i;
   }
 
   /**
@@ -588,141 +323,90 @@
    */
   public Object clone()
   {
-    return super.clone();
+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();
+    c.map = (Hashtable) map.clone ();
+    c.prefixes = (Hashtable) map.clone ();
+    return c;
   }
 
-  /**
-   * This method completely parses a string 'rules' containing sorting rules.
-   *
-   * @param rules String containing the rules to be parsed. 
-   * @return A set of sorting instructions stored in a Vector.
-   * @throws ParseException if something turned wrong during the parsing. To get details
-   * decode the message.
-   */
-  private Vector parseString(String rules) 
-    throws ParseException
+  // A helper for CollationElementIterator.next().
+  int ceiNext (CollationElementIterator cei)
   {
-    Vector v = new Vector();
-
-    // result of the first subParseString is not absolute (may be -1 or a
-    // positive integer). But we do not care.
-    subParseString(false, v, 0, rules);
-    
-    return v;
-  }
-
-  /**
-   * This method uses the sorting instructions built by {@link #parseString}
-   * to build collation elements which can be directly used to sort strings.
-   *
-   * @param parsedElements Parsed instructions stored in a Vector.
-   * @throws ParseException if the order of the instructions are not valid.
-   */
-  private void buildCollationVector(Vector parsedElements)
-    throws ParseException
-  {
-    int primary_seq = 0;
-    int last_tertiary_seq = 0;
-    short secondary_seq = 0;
-    short tertiary_seq = 0;
-    short equality_seq = 0;
-    boolean inverseComparisons = false;
-    final boolean DECREASING = false;
-    final boolean INCREASING = true;
-    boolean secondaryType = INCREASING;
-    Vector v = new Vector();
-
-    // elts is completely sorted.
-element_loop:
-    for (int i = 0; i < parsedElements.size(); i++)
+    if (cei.lookahead_set)
       {
-	CollationSorter elt = (CollationSorter) parsedElements.elementAt(i);
-	boolean ignoreChar = false;
+	cei.lookahead_set = false;
+	return cei.lookahead;
+      }
 
-	switch (elt.comparisonType)
-	  {
-	  case CollationSorter.GREATERP:
-	    primary_seq++;
-	    if (inverseComparisons)
-	      {
-		secondary_seq = Short.MAX_VALUE;
-		secondaryType = DECREASING;
-	      }
-	    else
-	      {
-		secondary_seq = 0;
-		secondaryType = INCREASING;
-	      }
-	    tertiary_seq = 0;
-	    equality_seq = 0;
-	    inverseComparisons = false;
-	    break;
-	  case CollationSorter.GREATERS:
-	    if (secondaryType == DECREASING)
-	      secondary_seq--;
-	    else
-	      secondary_seq++;
-	    tertiary_seq = 0;
-	    equality_seq = 0;
-	    break;
-	  case CollationSorter.INVERSE_SECONDARY:
-	    inverseComparisons = true;
-	    continue element_loop;
-	  case CollationSorter.GREATERT:
-	    tertiary_seq++;
-	    if (primary_seq == 0)
-	      last_tertiary_seq = tertiary_seq;
-	    equality_seq = 0;
-	    break;
-	  case CollationSorter.IGNORE:
-	    ignoreChar = true;
-	  case CollationSorter.EQUAL:
-	    equality_seq++;
-	    break;
-	  case CollationSorter.RESET:
-	    throw new ParseException
-	      ("Invalid reached state 'RESET'. Internal error", elt.offset);
-	  default:
-	    throw new ParseException
-	      ("Invalid unknown state '" + elt.comparisonType + "'", elt.offset);
-	  }
+    int save = cei.textIndex;
+    int max = cei.text.length();
+    String s = null;
 
-	CollationElement e;
+    // It is possible to have a case where `abc' has a mapping, but
+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as
+    // nothing special.
+    boolean found = false;
 
-	if (!ignoreChar)
-	  {
-	    e = new CollationElement(elt.textElement, primary_seq,
-				     secondary_seq, tertiary_seq,
-				     equality_seq, elt.expansionOrdering);
-	  }
-	else
-	  e = new CollationElement(elt.textElement);
+    int i;
+    for (i = save + 1; i <= max; ++i)
+      {
+	s = cei.text.substring(save, i);
+	if (prefixes.get(s) == null)
+	  break;
+	found = true;
+      }
+    // Assume s != null.
 
-	v.add(e);
+    Object obj = map.get(s);
+    // The special case.
+    while (found && obj == null && s.length() > 1)
+      {
+	--i;
+	s = cei.text.substring(save, i);
+	obj = map.get(s);
       }
 
-    this.inverseAccentComparison = inverseComparisons; 
+    // Update state.
+    cei.textIndex = i;
 
-    ce_table = v.toArray();
+    if (obj == null)
+      {
+	// This idea, and the values, come from JDK.
+	// assert (s.length() == 1)
+	cei.lookahead_set = true;
+	cei.lookahead = s.charAt(0) << 8;
+	return 0x7fff << 16;
+      }
 
-    last_primary_value = primary_seq+1;
-    last_tertiary_value = last_tertiary_seq+1;
+    return ((Integer) obj).intValue();
   }
 
-  /**
-   * Build a tree where all keys are the texts of collation elements and data is
-   * the collation element itself. The tree is used when extracting all prefix
-   * for a given text.
-   */
-  private void buildPrefixAccess()
+  // A helper for compareTo() that returns the next character that has
+  // a nonzero ordering at the indicated strength.  This is also used
+  // in CollationKey.
+  static final int next (CollationElementIterator iter, int strength)
   {
-    prefix_tree = new HashMap();
-
-    for (int i = 0; i < ce_table.length; i++)
+    while (true)
       {
-	CollationElement e = (CollationElement) ce_table[i];
-
-	prefix_tree.put(e.key, e);
+	int os = iter.next();
+	if (os == CollationElementIterator.NULLORDER)
+	  return os;
+	int c = 0;
+	switch (strength)
+	  {
+	  case PRIMARY:
+	    c = os & ~0xffff;
+	    break;
+	  case SECONDARY:
+	    c = os & ~0x00ff;
+	    break;
+	  case TERTIARY:
+	  case IDENTICAL:
+	    c = os;
+	    break;
+	  }
+	if (c != 0)
+	  return c;
       }
   }
 
@@ -742,86 +426,33 @@
   {
     CollationElementIterator cs, ct;
 
-    cs = getCollationElementIterator(source);
-    ct = getCollationElementIterator(target);
+    cs = new CollationElementIterator(this, source);
+    ct = new CollationElementIterator(this, target);
 
     for(;;)
       {
-        CollationElement ord1block = cs.nextBlock(); 
-        CollationElement ord2block = ct.nextBlock(); 
-	int ord1;
-	int ord2;
+	int os = next (cs, strength);
+	int ot = next (ct, strength);
 
-	if (ord1block != null)
-	  ord1 = ord1block.getValue();
-	else
+	if (os == CollationElementIterator.NULLORDER
+	    && ot == CollationElementIterator.NULLORDER)
+	  break;
+	else if (os == CollationElementIterator.NULLORDER)
 	  {
-	    if (ord2block == null)
-	      return 0;
+	    // Source string is shorter, so return "less than".
 	    return -1;
 	  }
-
-	if (ord2block == null)
-	  return 1;
-	
-	ord2 = ord2block.getValue();
-	
-	// We know chars are totally equal, so skip
-        if (ord1 == ord2)
+	else if (ot == CollationElementIterator.NULLORDER)
 	  {
-	    if (getStrength() == IDENTICAL)
-	      if (!ord1block.key.equals(ord2block.key))
-		return ord1block.key.compareTo(ord2block.key);
-	    continue;
+	    // Target string is shorter, so return "greater than".
+	    return 1;
 	  }
 
-        // Check for primary strength differences
-        int prim1 = CollationElementIterator.primaryOrder(ord1); 
-        int prim2 = CollationElementIterator.primaryOrder(ord2); 
-	
-	if (prim1 == 0 && getStrength() < TERTIARY)
-	  {
-	    ct.previousBlock();
-	    continue;
-	  }
-	else if (prim2 == 0 && getStrength() < TERTIARY)
-	  {
-	    cs.previousBlock();
-	    continue;
-	  }
-
-        if (prim1 < prim2)
-          return -1;
-        else if (prim1 > prim2)
-          return 1;
-        else if (getStrength() == PRIMARY)
-          continue;
-
-        // Check for secondary strength differences
-        int sec1 = CollationElementIterator.secondaryOrder(ord1);
-        int sec2 = CollationElementIterator.secondaryOrder(ord2);
-
-	if (sec1 < sec2)
-          return -1;
-        else if (sec1 > sec2)
-          return 1;
-        else if (getStrength() == SECONDARY)
-          continue;
-
-        // Check for tertiary differences
-        int tert1 = CollationElementIterator.tertiaryOrder(ord1);
-        int tert2 = CollationElementIterator.tertiaryOrder(ord2);
-
-        if (tert1 < tert2)
-          return -1;
-        else if (tert1 > tert2)
-          return 1;
-	else if (getStrength() == TERTIARY)
-	  continue;
-
-	// Apparently JDK does this (at least for my test case).
-	return ord1block.key.compareTo(ord2block.key);    
+	if (os != ot)
+	  return os - ot;
       }
+
+    return 0;
   }
 
   /**
@@ -836,54 +467,13 @@
    */
   public boolean equals(Object obj)
   {
-    if (obj == this)
-      return true;
-    else
+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))
       return false;
-  }
-
-  /**
-   * This method builds a default collation element without invoking
-   * the database created from the rules passed to the constructor.
-   *
-   * @param c Character which needs a collation element.
-   * @return A valid brand new CollationElement instance.
-   */
-  CollationElement getDefaultElement(char c)
-  {
-    int v;
-
-    // Preliminary support for generic accent sorting inversion (I don't know if all
-    // characters in the range should be sorted backward). This is the place
-    // to fix this if needed.
-    if (inverseAccentComparison && (c >= 0x02B9 && c <= 0x0361))
-      v = 0x0361 - ((int) c - 0x02B9);
-    else
-      v = (short) c;
-    return new CollationElement("" + c, last_primary_value + v,
-				(short) 0, (short) 0, (short) 0, null);
-  }
-
-  /**
-   * This method builds a default collation element for an accented character
-   * without invoking the database created from the rules passed to the constructor.
-   *
-   * @param c Character which needs a collation element.
-   * @return A valid brand new CollationElement instance.
-   */
-  CollationElement getDefaultAccentedElement(char c)
-  {
-    int v;
-
-    // Preliminary support for generic accent sorting inversion (I don't know if all
-    // characters in the range should be sorted backward). This is the place
-    // to fix this if needed.
-    if (inverseAccentComparison && (c >= 0x02B9 && c <= 0x0361))
-      v = 0x0361 - ((int) c - 0x02B9);
-    else
-      v = (short) c;
-    return new CollationElement("" + c, (short) 0,
-				(short) 0, (short) (last_tertiary_value + v), (short) 0, null);
+    RuleBasedCollator rbc = (RuleBasedCollator) obj;
+    // FIXME: this is probably wrong.  Instead we should compare maps
+    // directly.
+    return (frenchAccents == rbc.frenchAccents
+	    && rules.equals(rbc.rules));
   }
 
   /**
@@ -899,7 +489,13 @@
    */
   public CollationElementIterator getCollationElementIterator(String source)
   {
-    return new CollationElementIterator(this, source);
+    int len = source.length();
+    StringBuffer expand = new StringBuffer(len);
+    
+    for (int index = 0; index < len; ++index)
+      decomposeCharacter(source.charAt(index), expand);
+    
+    return new CollationElementIterator(this, expand.toString());
   }
 
   /**
@@ -921,7 +517,7 @@
 	 c = source.next())
       decomposeCharacter(c, expand);
 
-    return getCollationElementIterator(expand.toString());
+    return new CollationElementIterator(this, expand.toString());
   }
 
   /**
@@ -937,45 +533,8 @@
    */
   public CollationKey getCollationKey(String source)
   {
-    CollationElementIterator cei = getCollationElementIterator(source);
-    Vector vect = new Vector(25);
-
-    int ord = cei.next();
-    cei.reset(); //set to start of string
-
-    while (ord != CollationElementIterator.NULLORDER)
-      {
-        switch (getStrength())
-          {
-            case PRIMARY:
-	      ord = CollationElementIterator.primaryOrder(ord);
-	      break;
-	      
-            case SECONDARY:
-	      ord = CollationElementIterator.primaryOrder(ord) << 8;
-	      ord |= CollationElementIterator.secondaryOrder(ord);
-
-            default:
-               break;
-          }
-
-        vect.add(new Integer(ord)); 
-	ord = cei.next(); //increment to next key
-      }
-
-    Object[] objarr = vect.toArray();
-    byte[] key = new byte[objarr.length * 4];
-
-    for (int i = 0; i < objarr.length; i++)
-      {
-        int j = ((Integer) objarr[i]).intValue();
-        key [i * 4] = (byte) ((j & 0xFF000000) >> 24);
-        key [i * 4 + 1] = (byte) ((j & 0x00FF0000) >> 16);
-        key [i * 4 + 2] = (byte) ((j & 0x0000FF00) >> 8);
-        key [i * 4 + 3] = (byte) (j & 0x000000FF);
-      }
-
-    return new CollationKey(this, source, key);
+    return new CollationKey(this, getCollationElementIterator(source), source,
+			    strength);
   }
 
   /**
@@ -996,6 +555,44 @@
    */
   public int hashCode()
   {
-    return System.identityHashCode(this);
+    return (frenchAccents ? 1231 : 1237
+	    ^ rules.hashCode()
+	    ^ map.hashCode()
+	    ^ prefixes.hashCode());
   }
+
+  private final boolean is_special (char c)
+  {
+    // Rules from JCL book.
+    return ((c >= 0x0021 && c <= 0x002f)
+	    || (c >= 0x003a && c <= 0x0040)
+	    || (c >= 0x005b && c <= 0x0060)
+	    || (c >= 0x007b && c <= 0x007e));
+  }
+
+  private final int text_argument (String rules, int index,
+				   StringBuffer result)
+  {
+    result.setLength(0);
+    int len = rules.length();
+    while (index < len)
+      {
+	char c = rules.charAt (index);
+	if (c == '\''
+            && index + 2 < len
+	    && rules.charAt (index + 2) == '\'')
+          {
+            result.append (rules.charAt (index + 1));
+            index += 2;
+          }
+	else if (is_special (c))
+	  return index;
+        else if (!Character.isWhitespace (c))
+          result.append (c);
+        
+        ++index;
+      }
+    return index;
+  }
+
 }
