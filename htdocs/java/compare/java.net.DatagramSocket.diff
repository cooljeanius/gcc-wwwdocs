--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/DatagramSocket.java	2003-09-22 02:19:32.000000000 -0600
+++ java/net/DatagramSocket.java	2003-11-27 02:18:12.000000000 -0700
@@ -67,12 +67,17 @@
    * This is the user DatagramSocketImplFactory for this class.  If this
    * variable is null, a default factory is used.
    */
-  static DatagramSocketImplFactory factory;
+  private static DatagramSocketImplFactory factory;
 	  
   /**
    * This is the implementation object used by this socket.
    */
-  DatagramSocketImpl impl;
+  private DatagramSocketImpl impl;
+
+  /**
+   * True if socket implementation was created.
+   */
+  private boolean implCreated;
 
   /**
    * This is the address we are "connected" to
@@ -85,9 +90,9 @@
   private int remotePort = -1;
 
   /**
-   * Indicates when the socket is closed.
+   * True if socket is bound.
    */
-  private boolean closed = false;
+  private boolean bound;
 
   /**
    * Creates a <code>DatagramSocket</code> from a specified 
@@ -100,6 +105,9 @@
    */
   protected DatagramSocket (DatagramSocketImpl impl)
   {
+    if (impl == null)
+      throw new NullPointerException("impl may not be null");
+
     this.impl = impl;
     this.remoteAddress = null;
     this.remotePort = -1;
@@ -115,7 +123,7 @@
    */
   public DatagramSocket() throws SocketException
   {
-    this(0, null);
+    this(new InetSocketAddress(0));
   }
 
   /**
@@ -130,7 +138,7 @@
    */
   public DatagramSocket(int port) throws SocketException
   {
-    this(port, null);
+    this(new InetSocketAddress(port));
   }
 
   /**
@@ -138,21 +146,31 @@
    * the specified local port and address.
    *
    * @param port The local port number to bind to.
-   * @param laddr The local address to bind to.
+   * @param addr The local address to bind to.
    *
    * @exception SecurityException If a security manager exists and its
    * checkListen method doesn't allow the operation.
    * @exception SocketException If an error occurs.
    */
-  public DatagramSocket(int port, InetAddress laddr) throws SocketException
+  public DatagramSocket(int port, InetAddress addr) throws SocketException
   {
-    if (port < 0 || port > 65535)
-      throw new IllegalArgumentException("Invalid port: " + port);
-
-    SecurityManager s = System.getSecurityManager();
-    if (s != null)
-      s.checkListen(port);
+    this(new InetSocketAddress(addr, port));
+  }
 
+  /**
+   * Initializes a new instance of <code>DatagramSocket</code> that binds to 
+   * the specified local port and address.
+   *
+   * @param address The local address and port number to bind to.
+   *
+   * @exception SecurityException If a security manager exists and its
+   * <code>checkListen</code> method doesn't allow the operation.
+   * @exception SocketException If an error occurs.
+   *
+   * @since 1.4
+   */
+  public DatagramSocket (SocketAddress address) throws SocketException
+  {
     String propVal = System.getProperty("impl.prefix");
     if (propVal == null || propVal.equals(""))
       impl = new PlainDatagramSocketImpl();
@@ -168,62 +186,52 @@
 	    propVal + "DatagramSocketImpl");
 	  impl = new PlainDatagramSocketImpl();
 	}
-    impl.create();
 
-    if (laddr == null)
-      laddr = InetAddress.ANY_IF;
-    
+    if (address != null)
+      bind(address);
+  }
+  
+  // This needs to be accessible from java.net.MulticastSocket
+  DatagramSocketImpl getImpl()
+    throws SocketException
+  {
     try
       {
-        impl.bind (port, laddr);
-      }
-    catch (SocketException exception)
-      {
-        impl.close ();
-        throw exception;
-      }
-    catch (RuntimeException exception)
-      {
-        impl.close ();
-        throw exception;
+	if (!implCreated)
+	  {
+	    impl.create();
+	    implCreated = true;
+	  }
+
+	return impl;
       }
-    catch (Error error)
+    catch (IOException e)
       {
-        impl.close ();
-        throw error;
+	throw new SocketException(e.getMessage());
       }
   }
-
-  /**
-   * Initializes a new instance of <code>DatagramSocket</code> that binds to 
-   * the specified local port and address.
-   *
-   * @param port The local port number to bind to.
-   * @param laddr The local address to bind to.
-   *
-   * @exception SecurityException If a security manager exists and its
-   * <code>checkListen</code> method doesn't allow the operation.
-   * @exception SocketException If an error occurs.
-   *
-   * @since 1.4
-   */
-  public DatagramSocket (SocketAddress address) throws SocketException
-  {
-    this (((InetSocketAddress) address).getPort (),
-          ((InetSocketAddress) address).getAddress ());
-  }
   
   /**
    * Closes this datagram socket.
    */
   public void close()
   {
-    if (!closed)
+    if (!isClosed())
       {
-        impl.close();
-        remoteAddress = null;
-        remotePort = -1;
-        closed = true;
+	try
+	  {
+	    getImpl().close();
+	  }
+	catch (SocketException e)
+	  {
+	    // Ignore this case, just close the socket in finally clause.
+	  }
+	finally
+	  {
+	    remoteAddress = null;
+	    remotePort = -1;
+	    impl = null;
+	  }
       }
   }
 
@@ -258,19 +266,20 @@
   /**
    * Returns the local address this datagram socket is bound to.
    * 
+   * @return The local address is the socket is bound or null
+   *
    * @since 1.1
    */
   public InetAddress getLocalAddress()
   {
-    if (impl == null
-	|| closed)
+    if (isClosed())
       return null;
     
     InetAddress localAddr;
     
     try
       {
-	localAddr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);
+	localAddr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
 
 	SecurityManager s = System.getSecurityManager();
 	if (s != null)
@@ -282,6 +291,7 @@
       }
     catch (SocketException e)
       {
+	// This cannot happen as we are bound.
         return null;
       }
 
@@ -295,7 +305,18 @@
    */
   public int getLocalPort()
   {
-    return impl.getLocalPort();
+    if (isClosed())
+      return -1;
+	      
+    try
+      {
+	return getImpl().getLocalPort();
+      }
+    catch (SocketException e)
+      {
+	// This cannot happen as we are bound.
+	return 0;
+      }
   }
 
   /**
@@ -310,15 +331,15 @@
    */
   public synchronized int getSoTimeout() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);
+    Object buf = getImpl().getOption(SocketOptions.SO_TIMEOUT);
 
-    if (timeout instanceof Integer) 
-      return ((Integer)timeout).intValue();
-    else
-      return 0;
+    if (buf instanceof Integer) 
+      return ((Integer) buf).intValue();
+
+    throw new SocketException("unexpected type");
   }
 
   /**
@@ -334,10 +355,13 @@
    */
   public synchronized void setSoTimeout(int timeout) throws SocketException
   {
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
     if (timeout < 0)
       throw new IllegalArgumentException("Invalid timeout: " + timeout);
 
-    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));
+    getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));
   }
 
   /**
@@ -353,15 +377,15 @@
    */
   public int getSendBufferSize() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
+    Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);
 
-    Object obj = impl.getOption(SocketOptions.SO_SNDBUF);
+    if (buf instanceof Integer)
+      return ((Integer) buf).intValue();
 
-    if (obj instanceof Integer)
-      return(((Integer)obj).intValue());
-    else
-      throw new SocketException("Unexpected type");
+    throw new SocketException("unexpected type");
   }
 
   /**
@@ -378,10 +402,13 @@
    */
   public void setSendBufferSize(int size) throws SocketException
   {
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
     if (size < 0)
       throw new IllegalArgumentException("Buffer size is less than 0");
   
-    impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));
+    getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));
   }
 
   /**
@@ -397,15 +424,15 @@
    */
   public int getReceiveBufferSize() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    Object obj = impl.getOption(SocketOptions.SO_RCVBUF);
+    Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);
   
-    if (obj instanceof Integer)
-      return(((Integer)obj).intValue());
-    else 
-      throw new SocketException("Unexpected type");
+    if (buf instanceof Integer)
+      return ((Integer) buf).intValue();
+
+    throw new SocketException("unexpected type");
   }
 
   /**
@@ -422,13 +449,13 @@
    */
   public void setReceiveBufferSize(int size) throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
     if (size < 0)
       throw new IllegalArgumentException("Buffer size is less than 0");
 
-    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));
+    getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));
   }
 
   /**
@@ -461,7 +488,7 @@
 
     try
       {
-        impl.connect (address, port);
+        getImpl().connect (address, port);
         remoteAddress = address;
         remotePort = port;
       }
@@ -480,9 +507,22 @@
    */
   public void disconnect()
   {
-    impl.disconnect();
-    remoteAddress = null;
-    remotePort = -1;
+    if (!isConnected())
+      return;
+
+    try
+      {
+	getImpl().disconnect();
+      }
+    catch (SocketException e)
+      {
+	// This cannot happen as we are connected.
+      }
+    finally
+      {
+	remoteAddress = null;
+	remotePort = -1;
+      }
   }
 
   /**
@@ -506,18 +546,19 @@
    */
   public synchronized void receive(DatagramPacket p) throws IOException
   {
-    if (impl == null)
-      throw new IOException ("Cannot initialize Socket implementation");
-
-    if (remoteAddress != null && remoteAddress.isMulticastAddress ())
-      throw new IOException (
-        "Socket connected to a multicast address my not receive");
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
+    if (remoteAddress != null
+        && remoteAddress.isMulticastAddress())
+      throw new IOException
+        ("Socket connected to a multicast address my not receive");
 
     if (getChannel() != null
         && !getChannel().isBlocking ())
       throw new IllegalBlockingModeException ();
 
-    impl.receive(p);
+    getImpl().receive(p);
 
     SecurityManager s = System.getSecurityManager();
     if (s != null && isConnected ())
@@ -541,6 +582,9 @@
    */
   public void send(DatagramPacket p) throws IOException
   {
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
     // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.
     SecurityManager s = System.getSecurityManager();
     if (s != null && !isConnected ())
@@ -567,7 +611,7 @@
         && !getChannel().isBlocking ())
       throw new IllegalBlockingModeException ();
 
-    impl.send(p);
+    getImpl().send(p);
   }
 
   /**
@@ -585,31 +629,64 @@
   public void bind (SocketAddress address)
     throws SocketException
   {
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
     if (! (address instanceof InetSocketAddress))
-      throw new IllegalArgumentException ();
+      throw new IllegalArgumentException("unsupported address type");
 
-    InetSocketAddress tmp = (InetSocketAddress) address;
+    InetAddress addr = ((InetSocketAddress) address).getAddress();
+    int port = ((InetSocketAddress) address).getPort();
+
+    if (port < 0 || port > 65535)
+      throw new IllegalArgumentException("Invalid port: " + port);
 
     SecurityManager s = System.getSecurityManager ();
     if (s != null)
-      s.checkListen(tmp.getPort ());
+      s.checkListen(port);
 
-    impl.bind (tmp.getPort (), tmp.getAddress ());
+    if (addr == null)
+      addr = InetAddress.ANY_IF;
+    
+    try
+      {
+        getImpl().bind(port, addr);
+	bound = true;
+      }
+    catch (SocketException exception)
+      {
+        getImpl().close();
+        throw exception;
+      }
+    catch (RuntimeException exception)
+      {
+        getImpl().close();
+        throw exception;
+      }
+    catch (Error error)
+      {
+        getImpl().close();
+        throw error;
+      }
   }
 
   /**
    * Checks if the datagram socket is closed.
    *
+   * @return True if socket is closed, false otherwise.
+   * 
    * @since 1.4
    */
   public boolean isClosed()
   {
-    return closed;
+    return impl == null;
   }
 
   /**
    * Returns the datagram channel assoziated with this datagram socket.
    * 
+   * @return The associated <code>DatagramChannel</code> object or null
+   * 
    * @since 1.4
    */
   public DatagramChannel getChannel()
@@ -629,36 +706,33 @@
    */
   public void connect (SocketAddress address) throws SocketException
   {
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
     if ( !(address instanceof InetSocketAddress) )
-      throw new IllegalArgumentException (
-		      "SocketAddress is not InetSocketAddress");
+      throw new IllegalArgumentException("unsupported address type");
 
     InetSocketAddress tmp = (InetSocketAddress) address;
-    connect( tmp.getAddress(), tmp.getPort());
+    connect(tmp.getAddress(), tmp.getPort());
   }
   
   /**
    * Returns the binding state of the socket.
    * 
+   * @return True if socket bound, false otherwise.
+   * 
    * @since 1.4
    */
   public boolean isBound()
   {
-    try
-      {
-        Object bindaddr = impl.getOption (SocketOptions.SO_BINDADDR);
-      }
-    catch (SocketException e)
-      {
-        return false;
-      }
-
-    return true;
+    return bound;
   }
 
   /**
    * Returns the connection state of the socket.
    * 
+   * @return True if socket is connected, false otherwise.
+   * 
    * @since 1.4
    */
   public boolean isConnected()
@@ -670,6 +744,8 @@
    * Returns the SocketAddress of the host this socket is conneted to
    * or null if this socket is not connected.
    * 
+   * @return The socket address of the remote host if connected or null
+   * 
    * @since 1.4
    */
   public SocketAddress getRemoteSocketAddress()
@@ -681,25 +757,18 @@
   }
 
   /**
-   * Returns the local SocketAddress this socket is bound to
-   * or null if it is not bound.
+   * Returns the local SocketAddress this socket is bound to.
+   *
+   * @return The local SocketAddress or null if the socket is not bound.
    * 
    * @since 1.4
    */
   public SocketAddress getLocalSocketAddress()
   {
-    InetAddress addr;
+    if (!isBound())
+      return null;
     
-    try
-      {
-        addr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);
-      }
-    catch (SocketException e)
-      {
-        return null;
-      }
-
-    return new InetSocketAddress (addr, impl.localPort);
+    return new InetSocketAddress (getLocalAddress(), getLocalPort());
   }
 
   /**
@@ -713,67 +782,71 @@
    */
   public void setReuseAddress(boolean on) throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));
+    getImpl().setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));
   }
 
   /**
    * Checks if SO_REUSEADDR is enabled.
    *
+   * @return True if SO_REUSEADDR is set on the socket, false otherwise.
+   *
    * @exception SocketException If an error occurs.
    * 
    * @since 1.4
    */
   public boolean getReuseAddress() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    Object obj = impl.getOption (SocketOptions.SO_REUSEADDR);
+    Object buf = getImpl().getOption (SocketOptions.SO_REUSEADDR);
   
-    if (obj instanceof Boolean)
-      return(((Boolean) obj).booleanValue ());
-    else 
-      throw new SocketException ("Unexpected type");
+    if (buf instanceof Boolean)
+      return ((Boolean) buf).booleanValue();
+
+    throw new SocketException("unexpected type");
   }
 
   /**
    * Enables/Disables SO_BROADCAST
    * 
-   * @param on Whether or not to have SO_BROADCAST turned on
+   * @param enable True if SO_BROADCAST should be enabled, false otherwise.
    *
    * @exception SocketException If an error occurs
    *
    * @since 1.4
    */
-  public void setBroadcast(boolean on) throws SocketException
+  public void setBroadcast(boolean enable) throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    impl.setOption (SocketOptions.SO_BROADCAST, new Boolean (on));
+    getImpl().setOption(SocketOptions.SO_BROADCAST, new Boolean(enable));
   }
 
   /**
    * Checks if SO_BROADCAST is enabled
    * 
+   * @return Whether SO_BROADCAST is set
+   *
    * @exception SocketException If an error occurs
    * 
    * @since 1.4
    */
   public boolean getBroadcast() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
-    Object obj = impl.getOption (SocketOptions.SO_BROADCAST);
+    Object buf = getImpl().getOption(SocketOptions.SO_BROADCAST);
   
-    if (obj instanceof Boolean)
-      return ((Boolean) obj).booleanValue ();
-    else 
-      throw new SocketException ("Unexpected type");
+    if (buf instanceof Boolean)
+      return ((Boolean) buf).booleanValue();
+
+    throw new SocketException("unexpected type");
   }
 
   /**
@@ -791,18 +864,20 @@
   public void setTrafficClass(int tc)
     throws SocketException
   {
-    if (impl == null)
-      throw new SocketException ("Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
 
     if (tc < 0 || tc > 255)
       throw new IllegalArgumentException();
 
-    impl.setOption (SocketOptions.IP_TOS, new Integer (tc));
+    getImpl().setOption (SocketOptions.IP_TOS, new Integer (tc));
   }
   
   /**
    * Returns the current traffic class
    * 
+   * @return The current traffic class.
+   *
    * @see DatagramSocket#setTrafficClass(int tc)
    *
    * @exception SocketException If an error occurs
@@ -811,15 +886,15 @@
    */
   public int getTrafficClass() throws SocketException
   {
-    if (impl == null)
-      throw new SocketException( "Cannot initialize Socket implementation");
+    if (isClosed())
+      throw new SocketException("socket is closed");
+    
+    Object buf = getImpl().getOption(SocketOptions.IP_TOS);
 
-    Object obj = impl.getOption(SocketOptions.IP_TOS);
+    if (buf instanceof Integer)
+      return ((Integer) buf).intValue();
 
-    if (obj instanceof Integer)
-      return ((Integer) obj).intValue ();
-    else
-      throw new SocketException ("Unexpected type");
+    throw new SocketException("unexpected type");
   }
   
   /**
