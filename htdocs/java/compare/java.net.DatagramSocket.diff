--- /home/tromey/gnu/classpath/classpath/java/net/DatagramSocket.java	Mon Feb 17 12:05:13 2003
+++ java/net/DatagramSocket.java	Mon Feb 17 11:56:13 2003
@@ -79,11 +79,6 @@
   DatagramChannel ch;
 
   /**
-   * This is the local address which cannot be changed
-   */
-  private InetAddress local_addr;
-
-  /**
    * This is the address we are "connected" to
    */
   private InetAddress remoteAddress;
@@ -94,9 +89,18 @@
   private int remotePort = -1;
 
   /**
-   * Is this a "connected" datagram socket?
+   * Creates a DatagramSocket from a specified DatagramSocketImpl instance
+   *
+   * @param impl The DatagramSocketImpl the socket will be created from
+   * 
+   * @since 1.4
    */
-  private boolean connected = false;
+  protected DatagramSocket (DatagramSocketImpl impl)
+  {
+    this.impl = impl;
+    this.remoteAddress = null;
+    this.remotePort = -1;
+  }
 
   /**
    * Initializes a new instance of <code>DatagramSocket</code> that binds to 
@@ -139,7 +143,38 @@
    */
   public DatagramSocket(int port, InetAddress laddr) throws SocketException
   {
-    this (new InetSocketAddress (laddr != null ? laddr : InetAddress.ANY_IF, port));
+    if (port < 0 || port > 65535)
+      throw new IllegalArgumentException("Invalid port: " + port);
+
+    SecurityManager s = System.getSecurityManager();
+    if (s != null)
+      s.checkListen(port);
+
+    String propVal = System.getProperty("impl.prefix");
+    if (propVal == null || propVal.equals(""))
+      impl = new PlainDatagramSocketImpl();
+    else
+      try
+	{
+          impl = (DatagramSocketImpl) Class.forName
+            ("java.net." + propVal + "DatagramSocketImpl").newInstance();
+	}
+      catch (Exception e)
+	{
+	  System.err.println("Could not instantiate class: java.net." +
+	    propVal + "DatagramSocketImpl");
+	  impl = new PlainDatagramSocketImpl();
+	}
+    impl.create();
+
+    // For multicasting, set the socket to be reused (Stevens pp. 195-6).
+    if (this instanceof MulticastSocket)
+      impl.setOption(SocketOptions.SO_REUSEADDR, new Boolean(true));
+
+    impl.bind(port, laddr == null ? InetAddress.ANY_IF : laddr);
+    
+    remoteAddress = null;
+    remotePort = -1;
   }
 
   /**
@@ -157,21 +192,8 @@
    */
   public DatagramSocket (SocketAddress address) throws SocketException
   {
-    InetSocketAddress tmp = (InetSocketAddress) address;
-
-    SecurityManager s = System.getSecurityManager();
-    if (s != null)
-      s.checkListen(tmp.getPort ());
-  
-    // Why is there no factory for this?
-    impl = new PlainDatagramSocketImpl();
-    impl.create();
-
-    if (address != null)
-      {
-        local_addr = tmp.getAddress ();
-        impl.bind(tmp.getPort (), tmp.getAddress ());
-      }
+    this (((InetSocketAddress) address).getPort (),
+          ((InetSocketAddress) address).getAddress ());
   }
   
   /**
@@ -180,6 +202,8 @@
   public void close()
   {
     impl.close();
+    remoteAddress = null;
+    remotePort = -1;
   }
 
   /**
@@ -193,6 +217,9 @@
    */
   public InetAddress getInetAddress()
   {
+    if (!isConnected ())
+      return null;
+
     return remoteAddress;
   }
 
@@ -207,6 +234,9 @@
    */
   public int getPort()
   {
+    if (!isConnected ())
+      return -1;
+    
     return remotePort;
   }
 
@@ -217,19 +247,39 @@
    */
   public InetAddress getLocalAddress()
   {
-    if (impl == null)
-      return null;
-
-    // FIXME: According to libgcj, checkConnect() is supposed to be called
-    // before performing this operation.  Problems: 1) We don't have the
-    // addr until after we do it, so we do a post check.  2). The docs I
-    // see don't require this in the Socket case, only DatagramSocket, but
-    // we'll assume they mean both.
-    SecurityManager sm = System.getSecurityManager();
-    if (sm != null)
-      sm.checkConnect(local_addr.getHostName(), getLocalPort());
+    // FIXME: JCL p. 510 says this should call checkConnect.  But what
+    // string should be used as the hostname?  Maybe this is just a side
+    // effect of calling InetAddress.getLocalHost.
+    //
+    // And is getOption with SO_BINDADDR the right way to get the address?
+    // Doesn't seem to be since this method doesn't throw a SocketException
+    // and SO_BINADDR can throw one.
+    //
+    // Also see RETURNS section in JCL p. 510 about returning any local
+    // addr "if the current execution context is not allowed to connect to
+    // the network interface that is actually bound to this datagram socket."
+    // How is that done?  via InetAddress.getLocalHost?  But that throws
+    // an UnknownHostException and this method doesn't.
+    //
+    // if (s != null)
+    //   s.checkConnect("localhost", -1);
+    try
+      {
+	return (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);
+      }
+    catch (SocketException ex)
+      {
+      }
 
-    return local_addr;
+    try
+      {
+	return InetAddress.getLocalHost();
+      }
+    catch (UnknownHostException ex)
+      {
+	// FIXME: This should never happen, so how can we avoid this construct?
+	return null;
+      }
   }
 
   /**
@@ -239,6 +289,9 @@
    */
   public int getLocalPort()
   {
+    if (!isBound ())
+      return -1;
+
     return impl.getLocalPort();
   }
 
@@ -262,7 +315,7 @@
     if (timeout instanceof Integer) 
       return ((Integer)timeout).intValue();
     else
-      throw new SocketException("Internal Error");
+      return 0;
   }
 
   /**
@@ -276,7 +329,7 @@
    *
    * @since 1.1
    */
-  public void setSoTimeout(int timeout) throws SocketException
+  public synchronized void setSoTimeout(int timeout) throws SocketException
   {
     if (timeout < 0)
       throw new IllegalArgumentException("Invalid timeout: " + timeout);
@@ -366,6 +419,9 @@
    */
   public void setReceiveBufferSize(int size) throws SocketException
   {
+    if (impl == null)
+      throw new SocketException ("Cannot initialize Socket implementation");
+
     if (size < 0)
       throw new IllegalArgumentException("Buffer size is less than 0");
 
@@ -388,8 +444,7 @@
    *
    * @since 1.2
    */
-  public void connect (InetAddress address, int port)
-    throws SecurityException, IllegalArgumentException
+  public void connect(InetAddress address, int port)
   {
     if (address == null)
       throw new IllegalArgumentException ("Connect address may not be null");
@@ -401,29 +456,27 @@
     if (sm != null)
       sm.checkConnect(address.getHostName(), port);
 
-    this.remoteAddress = address;
-    this.remotePort = port;
-
-    /* FIXME: Shit, we can't do this even though the OS supports it since this 
-       method isn't in DatagramSocketImpl. */
-    //  impl.connect(address, port);
-
-    connected = true;
-  } 
+    try
+      {
+        impl.connect (address, port);
+        remoteAddress = address;
+        remotePort = port;
+      }
+    catch (SocketException e)
+      {
+      }
+  }
 
   /**
-   * This method disconnects this socket from the address/port it was 
-   * connected to.  If the socket was not connected in the first place,
+   * This method disconnects this socket from the address/port it was
+   * conencted to.  If the socket was not connected in the first place,
    * this method does nothing.
    * 
    * @since 1.2
    */
   public void disconnect()
   {
-    // FIXME: See my comments on connect()
-    this.remoteAddress = null;
-    this.remotePort = -1;
-    connected = false;
+    impl.disconnect();
   }
 
   /**
@@ -431,13 +484,32 @@
    * will block until a packet is received from the network.  On return,
    * the passed in <code>DatagramPacket</code> is populated with the data
    * received and all the other information about the packet.
-   *
-   * @param p A <code>DatagramPacket</code> for storing the data
-   *
+   * 
+   * @param p The datagram packet to put the incoming data into.
+   * 
    * @exception IOException If an error occurs.
+   * @exception SocketTimeoutException If setSoTimeout was previously called
+   * and the timeout has expired.
+   * @exception PortUnreachableException If the socket is connected to a
+   * currently unreachable destination. Note, there is no guarantee that the
+   * exception will be thrown.
+   * @exception IllegalBlockingModeException If this socket has an associated
+   * channel, and the channel is in non-blocking mode.
+   * @exception SecurityException If a security manager exists and its
+   * checkAccept ethod doesn't allow the receive.
    */
   public synchronized void receive(DatagramPacket p) throws IOException
   {
+    if (impl == null)
+      throw new IOException ("Cannot initialize Socket implementation");
+
+    if (remoteAddress != null && remoteAddress.isMulticastAddress ())
+      throw new IOException (
+        "Socket connected to a multicast address my not receive");
+
+    if (ch != null && !ch.isBlocking ())
+      throw new IllegalBlockingModeException ();
+
     impl.receive(p);
 
     SecurityManager s = System.getSecurityManager();
@@ -462,21 +534,31 @@
    */
   public void send(DatagramPacket p) throws IOException
   {
-    if (!connected)
+    // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.
+    SecurityManager s = System.getSecurityManager();
+    if (s != null && !isConnected ())
       {
-        SecurityManager s = System.getSecurityManager();
-        if (s != null)
-          {
-             InetAddress addr = p.getAddress();
-             if (addr.isMulticastAddress())
-               s.checkMulticast(addr);
-             else
-               s.checkConnect(addr.getHostAddress(), p.getPort());
-          }
+        InetAddress addr = p.getAddress();
+        if (addr.isMulticastAddress())
+          s.checkMulticast(addr);
+        else
+          s.checkConnect(addr.getHostAddress(), p.getPort());
       }
 
+    if (isConnected ())
+      {
+        if (p.getAddress () != null && (remoteAddress != p.getAddress () ||
+                                        remotePort != p.getPort ()))
+          throw new IllegalArgumentException (
+            "DatagramPacket address does not match remote address" );
+      }
+	    
     // FIXME: if this is a subclass of MulticastSocket,
     // use getTimeToLive for TTL val.
+
+    if (ch != null && !ch.isBlocking ())
+      throw new IllegalBlockingModeException ();
+
     impl.send(p);
   }
 
@@ -508,6 +590,16 @@
   }
 
   /**
+   * Checks if the datagram socket is closed.
+   *
+   * @since 1.4
+   */
+  public boolean isClosed()
+  {
+    return !impl.getFileDescriptor().valid();
+  }
+
+  /**
    * Returns the datagram channel assoziated with this datagram socket.
    * 
    * @since 1.4
