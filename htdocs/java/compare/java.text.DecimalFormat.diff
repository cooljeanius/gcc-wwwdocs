--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/DecimalFormat.java	2004-05-02 02:20:13.000000000 -0600
+++ java/text/DecimalFormat.java	2004-04-21 02:18:11.000000000 -0600
@@ -37,16 +37,12 @@
 
 package java.text;
 
-import gnu.java.text.AttributedFormatBuffer;
-import gnu.java.text.FormatBuffer;
-import gnu.java.text.FormatCharacterIterator;
-import gnu.java.text.StringFormatBuffer;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
 import java.util.Currency;
-import java.util.HashMap;
 import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+import java.io.ObjectInputStream;
+import java.io.IOException;
 
 /**
  * @author Tom Tromey <tromey@cygnus.com>
@@ -62,48 +58,37 @@
 {
   // This is a helper for applyPatternWithSymbols.  It reads a prefix
   // or a suffix.  It can cause some side-effects.
-  private final int scanFix (String pattern, int index, FormatBuffer buf,
+  private final int scanFix (String pattern, int index, StringBuffer buf,
 			     String patChars, DecimalFormatSymbols syms,
 			     boolean is_suffix)
   {
     int len = pattern.length();
-    boolean quoteStarted = false;
-    buf.clear();
-    
+    buf.setLength(0);
     boolean multiplierSet = false;
     while (index < len)
       {
 	char c = pattern.charAt(index);
-
-	if (quoteStarted)
-	  {
-	    if (c == '\'')
-	      quoteStarted = false;
-	    else
-	      buf.append(c);
-	    index++;
-	    continue;
-	  }
-
 	if (c == '\'' && index + 1 < len
 	    && pattern.charAt(index + 1) == '\'')
 	  {
 	    buf.append(c);
-	    index++;
+	    ++index;
 	  }
-	else if (c == '\'')
+	else if (c == '\'' && index + 2 < len
+		 && pattern.charAt(index + 2) == '\'')
 	  {
-	    quoteStarted = true;
+	    buf.append(pattern.charAt(index + 1));
+	    index += 2;
 	  }
 	else if (c == '\u00a4')
 	  {
 	    if (index + 1 < len && pattern.charAt(index + 1) == '\u00a4')
 	      {
-		buf.append(syms.getInternationalCurrencySymbol(), NumberFormat.Field.CURRENCY);
-		index++;
+		buf.append(syms.getInternationalCurrencySymbol());
+		++index;
 	      }
 	    else
-	      buf.append(syms.getCurrencySymbol(), NumberFormat.Field.CURRENCY);
+	      buf.append(syms.getCurrencySymbol());
 	  }
 	else if (c == syms.getPercent())
 	  {
@@ -112,7 +97,7 @@
 						  "- index: " + index);
 	    multiplierSet = true;
 	    multiplier = 100;
-	    buf.append(c, NumberFormat.Field.PERCENT);
+	    buf.append(c);
 	  }
 	else if (c == syms.getPerMill())
 	  {
@@ -121,7 +106,7 @@
 						  "- index: " + index);
 	    multiplierSet = true;
 	    multiplier = 1000;
-	    buf.append(c, NumberFormat.Field.PERMILLE);
+	    buf.append(c);
 	  }
 	else if (patChars.indexOf(c) != -1)
 	  {
@@ -130,12 +115,9 @@
 	  }
 	else
 	  buf.append(c);
-	index++;
+	++index;
       }
 
-    if (quoteStarted)
-      throw new IllegalArgumentException ("pattern is lacking a closing quote");
-
     return index;
   }
 
@@ -277,16 +259,6 @@
 	    useExponentialNotation = true;
 	    minExponentDigits = (byte) zeroCount;
 	  }
-
-	maximumIntegerDigits = groupingSize;
-	groupingSize = 0;
-	if (maximumIntegerDigits > minimumIntegerDigits && maximumIntegerDigits > 0)
-	  {
-	    minimumIntegerDigits = 1;
-	    exponentRound = maximumIntegerDigits;
-	  }
-	else
-	  exponentRound = 1;
       }
 
     return index;
@@ -328,27 +300,21 @@
     useExponentialNotation = false;
     groupingUsed = false;
     maximumFractionDigits = 0;
-    maximumIntegerDigits = MAXIMUM_INTEGER_DIGITS;
+    maximumIntegerDigits = 309;
     minimumFractionDigits = 0;
     minimumIntegerDigits = 1;
 
-    AttributedFormatBuffer buf = new AttributedFormatBuffer ();
+    StringBuffer buf = new StringBuffer ();
     String patChars = patternChars (syms);
 
     int max = pattern.length();
     int index = scanFix (pattern, 0, buf, patChars, syms, false);
-    buf.sync();
-    positivePrefix = buf.getBuffer().toString();
-    positivePrefixRanges = buf.getRanges();
-    positivePrefixAttrs = buf.getAttributes();
+    positivePrefix = buf.toString();
 
     index = scanFormat (pattern, index, patChars, syms, true);
 
     index = scanFix (pattern, index, buf, patChars, syms, true);
-    buf.sync();
-    positiveSuffix = buf.getBuffer().toString();
-    positiveSuffixRanges = buf.getRanges();
-    positiveSuffixAttrs = buf.getAttributes();
+    positiveSuffix = buf.toString();
 
     if (index == pattern.length())
       {
@@ -363,20 +329,14 @@
 					      "expected - index: " + index);
 
 	index = scanFix (pattern, index + 1, buf, patChars, syms, false);
-	buf.sync();
-	negativePrefix = buf.getBuffer().toString();
-	negativePrefixRanges = buf.getRanges();
-	negativePrefixAttrs = buf.getAttributes();
+	negativePrefix = buf.toString();
 
 	// We parse the negative format for errors but we don't let
 	// it side-effect this object.
 	index = scanFormat (pattern, index, patChars, syms, false);
 
 	index = scanFix (pattern, index, buf, patChars, syms, true);
-	buf.sync();
-	negativeSuffix = buf.getBuffer().toString();
-	negativeSuffixRanges = buf.getRanges();
-	negativeSuffixAttrs = buf.getAttributes();
+	negativeSuffix = buf.toString();
 
 	if (index != pattern.length())
 	  throw new IllegalArgumentException ("end of pattern expected " +
@@ -449,43 +409,39 @@
 	    && useExponentialNotation == dup.useExponentialNotation);
   }
 
-  protected void formatInternal (double number, FormatBuffer dest,
-				 FieldPosition fieldPos)
+  public StringBuffer format (double number, StringBuffer dest,
+			      FieldPosition fieldPos)
   {
     // A very special case.
     if (Double.isNaN(number))
       {
 	dest.append(symbols.getNaN());
-	if (fieldPos != null && 
-	    (fieldPos.getField() == INTEGER_FIELD ||
-	     fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))
+	if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)
 	  {
 	    int index = dest.length();
 	    fieldPos.setBeginIndex(index - symbols.getNaN().length());
 	    fieldPos.setEndIndex(index);
 	  }
-	return;
+	return dest;
       }
 
     boolean is_neg = number < 0;
     if (is_neg)
       {
 	if (negativePrefix != null)
-	  dest.append(negativePrefix, negativePrefixRanges, negativePrefixAttrs);
+	  dest.append(negativePrefix);
 	else
 	  {
-	    dest.append(symbols.getMinusSign(), NumberFormat.Field.SIGN);
-	    dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);
+	    dest.append(symbols.getMinusSign());
+	    dest.append(positivePrefix);
 	  }
 	number = - number;
       }
     else
-      dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);
+      dest.append(positivePrefix);
 
     int integerBeginIndex = dest.length();
     int integerEndIndex = 0;
-    int zeroStart = symbols.getZeroDigit() - '0';
-
     if (Double.isInfinite (number))
       {
 	dest.append(symbols.getInfinity());
@@ -501,7 +457,6 @@
 	if (useExponentialNotation)
 	  {
 	    exponent = (long) Math.floor (Math.log(number) / Math.log(10));
-	    exponent = exponent - (exponent % exponentRound);
 	    if (minimumIntegerDigits > 0)
 	      exponent -= minimumIntegerDigits - 1;
 	    baseNumber = (number / Math.pow(10.0, exponent));
@@ -513,57 +468,33 @@
 	baseNumber += 5 * Math.pow(10.0, - maximumFractionDigits - 1);
 
 	int index = dest.length();
-	//double intPart = Math.floor(baseNumber);
-	String intPart = Long.toString((long)Math.floor(baseNumber));
-	int count, groupPosition = intPart.length();
-
-	dest.setDefaultAttribute(NumberFormat.Field.INTEGER);
-
-	for (count = 0; count < minimumIntegerDigits-intPart.length(); count++)
-	  dest.append(symbols.getZeroDigit());
-
-	for (count = 0;
-	     count < maximumIntegerDigits && count < intPart.length();
-	     count++)
+	double intPart = Math.floor(baseNumber);
+	int count = 0;
+	while (count < maximumIntegerDigits
+	       && (intPart > 0 || count < minimumIntegerDigits))
 	  {
-	    int dig = intPart.charAt(count);
+	    long dig = (long) (intPart % 10);
+	    intPart = Math.floor(intPart / 10);
 
 	    // Append group separator if required.
-	    if (groupingUsed && count > 0 && groupingSize != 0 && groupPosition % groupingSize == 0)
-	      {
-		dest.append(symbols.getGroupingSeparator(), NumberFormat.Field.GROUPING_SEPARATOR);
-		dest.setDefaultAttribute(NumberFormat.Field.INTEGER);
-	      }
-	    dest.append((char) (zeroStart + dig));
+	    if (groupingUsed && count > 0 && groupingSize != 0 && count % groupingSize == 0)
+	      dest.insert(index, symbols.getGroupingSeparator());
+
+	    dest.insert(index, (char) (symbols.getZeroDigit() + dig));
 
-	    groupPosition--;
+	    ++count;
 	  }
-	dest.setDefaultAttribute(null);
 
 	integerEndIndex = dest.length();
-	   
+
 	int decimal_index = integerEndIndex;
 	int consecutive_zeros = 0;
 	int total_digits = 0;
 
-	int localMaximumFractionDigits = maximumFractionDigits;
-
-	if (useExponentialNotation)
-	  localMaximumFractionDigits += minimumIntegerDigits - count;
-
 	// Strip integer part from NUMBER.
 	double fracPart = baseNumber - Math.floor(baseNumber);
-	
-	if ( ((fracPart != 0 || minimumFractionDigits > 0) && localMaximumFractionDigits > 0)
-	     || decimalSeparatorAlwaysShown)
-	  {
-	    dest.append (symbols.getDecimalSeparator(), NumberFormat.Field.DECIMAL_SEPARATOR);
-	  }
-
-	int fraction_begin = dest.length();
-	dest.setDefaultAttribute(NumberFormat.Field.FRACTION);
 	for (count = 0;
-	     count < localMaximumFractionDigits
+	     count < maximumFractionDigits
 	       && (fracPart != 0 || count < minimumFractionDigits);
 	     ++count)
 	  {
@@ -586,88 +517,61 @@
 				    total_digits - minimumFractionDigits);
 	if (extra_zeros > 0)
 	  {
-	    dest.cutTail(extra_zeros);
+	    dest.setLength(dest.length() - extra_zeros);
 	    total_digits -= extra_zeros;
-	    if (total_digits == 0 && !decimalSeparatorAlwaysShown)
-	      dest.cutTail(1);
 	  }
 
-	if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)
+	// If required, add the decimal symbol.
+	if (decimalSeparatorAlwaysShown
+	    || total_digits > 0)
 	  {
-	    fieldPos.setBeginIndex(fraction_begin);
-	    fieldPos.setEndIndex(dest.length());
+	    dest.insert(decimal_index, symbols.getDecimalSeparator());
+	    if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)
+	      {
+		fieldPos.setBeginIndex(decimal_index + 1);
+		fieldPos.setEndIndex(dest.length());
+	      }
 	  }
 
 	// Finally, print the exponent.
 	if (useExponentialNotation)
 	  {
-	    dest.append(symbols.getExponential(), NumberFormat.Field.EXPONENT_SYMBOL);	    
+	    dest.append(symbols.getExponential());
 	    if (exponent < 0)
 	      {
-		dest.append (symbols.getMinusSign (), NumberFormat.Field.EXPONENT_SIGN);
+		dest.append (symbols.getMinusSign ());
 		exponent = - exponent;
 	      }
 	    index = dest.length();
-	    dest.setDefaultAttribute(NumberFormat.Field.EXPONENT);
-	    String exponentString = Long.toString ((long) exponent);
-	    
-	    for (count = 0; count < minExponentDigits-exponentString.length();
-		 count++)
-	      dest.append((char) symbols.getZeroDigit());
-
 	    for (count = 0;
-		 count < exponentString.length();
+		 exponent > 0 || count < minExponentDigits;
 		 ++count)
 	      {
-		int dig = exponentString.charAt(count);
-		dest.append((char) (zeroStart + dig));
+		long dig = exponent % 10;
+		exponent /= 10;
+		dest.insert(index, (char) (symbols.getZeroDigit() + dig));
 	      }
 	  }
       }
 
-    if (fieldPos != null && 
-	(fieldPos.getField() == INTEGER_FIELD ||
-	 fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))
+    if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)
       {
 	fieldPos.setBeginIndex(integerBeginIndex);
 	fieldPos.setEndIndex(integerEndIndex);
       }
 
-    if (is_neg && negativeSuffix != null)
-      dest.append(negativeSuffix, negativeSuffixRanges, negativeSuffixAttrs);
-    else
-      dest.append(positiveSuffix, positiveSuffixRanges, positiveSuffixAttrs);
-  }
-
-  public StringBuffer format (double number, StringBuffer dest,
-			      FieldPosition fieldPos)
-  {
-    formatInternal (number, new StringFormatBuffer(dest), fieldPos);
+    dest.append((is_neg && negativeSuffix != null)
+		? negativeSuffix
+		: positiveSuffix);
     return dest;
   }
 
-  public AttributedCharacterIterator formatToCharacterIterator (Object value)
-  {
-    AttributedFormatBuffer sbuf = new AttributedFormatBuffer();
-
-    if (value instanceof Number)
-      formatInternal(((Number) value).doubleValue(), sbuf, null);
-    else
-      throw new IllegalArgumentException 
-	("Cannot format given Object as a Number");
-    
-    sbuf.sync();
-    return new FormatCharacterIterator(sbuf.getBuffer().toString(), 
-				       sbuf.getRanges(), 
-				       sbuf.getAttributes());
-  }
-
   public StringBuffer format (long number, StringBuffer dest,
 			      FieldPosition fieldPos)
   {
     // If using exponential notation, we just format as a double.
     if (useExponentialNotation)
-       return format ((double) number, dest, fieldPos);
+      return format ((double) number, dest, fieldPos);
 
     boolean is_neg = number < 0;
     if (is_neg)
@@ -797,19 +701,14 @@
 
   public Number parse (String str, ParsePosition pos)
   {
-    /*
-     * Our strategy is simple: copy the text into separate buffers: one for the int part,
-     * one for the fraction part and for the exponential part.
-     * We translate or omit locale-specific information.  
-     * If exponential is sufficiently big we merge the fraction and int part and
-     * remove the '.' and then we use Long to convert the number. In the other
-     * case, we use Double to convert the full number.
-     */
+    // Our strategy is simple: copy the text into a buffer,
+    // translating or omitting locale-specific information.  Then
+    // let Double or Long convert the number for us.
 
     boolean is_neg = false;
     int index = pos.getIndex();
-    StringBuffer int_buf = new StringBuffer ();
-        
+    StringBuffer buf = new StringBuffer ();
+
     // We have to check both prefixes, because one might be empty.  We
     // want to pick the longest prefix that matches.
     boolean got_pos = str.startsWith(positivePrefix, index);
@@ -849,17 +748,11 @@
     // FIXME: do we have to respect minimum digits?
     // What about leading zeros?  What about multiplier?
 
-    StringBuffer buf = int_buf;
-    StringBuffer frac_buf = null;
-    StringBuffer exp_buf = null;
     int start_index = index;
     int max = str.length();
-    int exp_index = -1;
-    int last = index + MAXIMUM_INTEGER_DIGITS;
-
+    int last = index + maximumIntegerDigits;
     if (last > 0 && max > last)
       max = last;
-
     char zero = symbols.getZeroDigit();
     int last_group = -1;
     boolean int_part = true;
@@ -878,11 +771,12 @@
 		pos.setErrorIndex(index);
 		return null;
 	      }
-	    last_group = index+1;
+	    last_group = index;
 	  }
 	else if (c >= zero && c <= zero + 9)
 	  {
 	    buf.append((char) (c - zero + '0'));
+	    exp_part = false;
 	  }
 	else if (parseIntegerOnly)
 	  break;
@@ -895,16 +789,14 @@
 		pos.setErrorIndex(index);
 		return null;
 	      }
-	    buf = frac_buf = new StringBuffer();
-	    frac_buf.append('.');
+	    buf.append('.');
 	    int_part = false;
 	  }
 	else if (c == symbols.getExponential())
 	  {
-	    buf = exp_buf = new StringBuffer();
+	    buf.append('E');
 	    int_part = false;
 	    exp_part = true;
-	    exp_index = index+1;
 	  }
 	else if (exp_part
 		 && (c == '+' || c == '-' || c == symbols.getMinusSign()))
@@ -948,111 +840,16 @@
       }
 
     String suffix = is_neg ? ns : positiveSuffix;
-    long multiplier = 1;
-    boolean use_long;
-
     if (is_neg)
-      int_buf.insert(0, '-');
-
-    // Now handle the exponential part if there is one.
-    if (exp_buf != null)
-      {
-	int exponent_value;
-
-	try
-	  {
-	    exponent_value = Integer.parseInt(exp_buf.toString());
-	  }
-	catch (NumberFormatException x1)
-	  {
-	    pos.setErrorIndex(exp_index);
-	    return null;
-	  }
-
-	if (frac_buf == null)
-	  {
-	    // We only have to add some zeros to the int part.
-	    // Build a multiplier.
-	    for (int i = 0; i < exponent_value; i++)
-	      int_buf.append('0');
-	    
-	    use_long = true;
-	  }
-	else
-	  {
-	    boolean long_sufficient;
-
-	    if (exponent_value < frac_buf.length()-1)
-	      {
-		int lastNonNull = -1;
-		/* We have to check the fraction buffer: it may only be full of '0'
-		 * or be sufficiently filled with it to convert the number into Long.
-		 */
-		for (int i = 1; i < frac_buf.length(); i++)
-		  if (frac_buf.charAt(i) != '0')
-		    lastNonNull = i;
+      buf.insert(0, '-');
 
-		long_sufficient = (lastNonNull < 0 || lastNonNull <= exponent_value);
-	      }
-	    else
-	      long_sufficient = true;
-	    
-	    if (long_sufficient)
-	      {
-		for (int i = 1; i < frac_buf.length() && i < exponent_value; i++)
-		  int_buf.append(frac_buf.charAt(i));
-		for (int i = frac_buf.length()-1; i < exponent_value; i++)
-		  int_buf.append('0');
-		use_long = true;
-	      }
-	    else
-	      {
-		/*
-		 * A long type is not sufficient, we build the full buffer to
-		 * be parsed by Double.
-		 */
-		int_buf.append(frac_buf);
-		int_buf.append('E');
-		int_buf.append(exp_buf);
-		use_long = false;
-	      }
-	  }
-      }
-    else
-      {
-	if (frac_buf != null)
-	  {
-	    /* Check whether the fraction buffer contains only '0' */
-	    int i;
-	    for (i = 1; i < frac_buf.length(); i++)
-	      if (frac_buf.charAt(i) != '0')
-		break;
-	   
-	    if (i != frac_buf.length())
-	      {
-		use_long = false;
-		int_buf.append(frac_buf);
-	      }
-	    else
-	      use_long = true;
-	  }
-	else
-	  use_long = true;
-      }
-
-    String t = int_buf.toString();
+    String t = buf.toString();
     Number result = null;
-    if (use_long)
+    try
       {
-	try
-	  {
-	    result = new Long (t);
-	  }
-	catch (NumberFormatException x1)
-	  {
-	  }
+	result = new Long (t);
       }
-    else
+    catch (NumberFormatException x1)
       {
 	try
 	  {
@@ -1167,7 +964,7 @@
     // digits.  Past that we need hash marks up to the grouping
     // separator (and one beyond).
     int total_digits = Math.max(minimumIntegerDigits,
-				groupingUsed ? groupingSize + 1: groupingSize);
+				groupingUsed ? groupingSize + 1: 0);
     for (int i = 0; i < total_digits - minimumIntegerDigits; ++i)
       mainPattern.append(syms.getDigit());
     for (int i = total_digits - minimumIntegerDigits; i < total_digits; ++i)
@@ -1221,22 +1018,15 @@
     return computePattern (nonLocalizedSymbols);
   }
 
-  private static final int MAXIMUM_INTEGER_DIGITS = 309; 
-
   // These names are fixed by the serialization spec.
   private boolean decimalSeparatorAlwaysShown;
   private byte groupingSize;
   private byte minExponentDigits;
-  private int exponentRound;
   private int multiplier;
   private String negativePrefix;
   private String negativeSuffix;
   private String positivePrefix;
   private String positiveSuffix;
-  private int[] negativePrefixRanges, positivePrefixRanges;
-  private HashMap[] negativePrefixAttrs, positivePrefixAttrs;
-  private int[] negativeSuffixRanges, positiveSuffixRanges;
-  private HashMap[] negativeSuffixAttrs, positiveSuffixAttrs;
   private int serialVersionOnStream = 1;
   private DecimalFormatSymbols symbols;
   private boolean useExponentialNotation;
