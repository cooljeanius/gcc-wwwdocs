--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/DecimalFormat.java	2004-04-29 02:24:10.000000000 -0600
+++ java/text/DecimalFormat.java	2004-04-21 02:18:11.000000000 -0600
@@ -37,16 +37,12 @@
 
 package java.text;
 
-import gnu.java.text.AttributedFormatBuffer;
-import gnu.java.text.FormatBuffer;
-import gnu.java.text.FormatCharacterIterator;
-import gnu.java.text.StringFormatBuffer;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
 import java.util.Currency;
-import java.util.HashMap;
 import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+import java.io.ObjectInputStream;
+import java.io.IOException;
 
 /**
  * @author Tom Tromey <tromey@cygnus.com>
@@ -62,48 +58,37 @@
 {
   // This is a helper for applyPatternWithSymbols.  It reads a prefix
   // or a suffix.  It can cause some side-effects.
-  private final int scanFix (String pattern, int index, FormatBuffer buf,
+  private final int scanFix (String pattern, int index, StringBuffer buf,
 			     String patChars, DecimalFormatSymbols syms,
 			     boolean is_suffix)
   {
     int len = pattern.length();
-    boolean quoteStarted = false;
-    buf.clear();
-    
+    buf.setLength(0);
     boolean multiplierSet = false;
     while (index < len)
       {
 	char c = pattern.charAt(index);
-
-	if (quoteStarted)
-	  {
-	    if (c == '\'')
-	      quoteStarted = false;
-	    else
-	      buf.append(c);
-	    index++;
-	    continue;
-	  }
-
 	if (c == '\'' && index + 1 < len
 	    && pattern.charAt(index + 1) == '\'')
 	  {
 	    buf.append(c);
-	    index++;
+	    ++index;
 	  }
-	else if (c == '\'')
+	else if (c == '\'' && index + 2 < len
+		 && pattern.charAt(index + 2) == '\'')
 	  {
-	    quoteStarted = true;
+	    buf.append(pattern.charAt(index + 1));
+	    index += 2;
 	  }
 	else if (c == '\u00a4')
 	  {
 	    if (index + 1 < len && pattern.charAt(index + 1) == '\u00a4')
 	      {
-		buf.append(syms.getInternationalCurrencySymbol(), NumberFormat.Field.CURRENCY);
-		index++;
+		buf.append(syms.getInternationalCurrencySymbol());
+		++index;
 	      }
 	    else
-	      buf.append(syms.getCurrencySymbol(), NumberFormat.Field.CURRENCY);
+	      buf.append(syms.getCurrencySymbol());
 	  }
 	else if (c == syms.getPercent())
 	  {
@@ -112,7 +97,7 @@
 						  "- index: " + index);
 	    multiplierSet = true;
 	    multiplier = 100;
-	    buf.append(c, NumberFormat.Field.PERCENT);
+	    buf.append(c);
 	  }
 	else if (c == syms.getPerMill())
 	  {
@@ -121,7 +106,7 @@
 						  "- index: " + index);
 	    multiplierSet = true;
 	    multiplier = 1000;
-	    buf.append(c, NumberFormat.Field.PERMILLE);
+	    buf.append(c);
 	  }
 	else if (patChars.indexOf(c) != -1)
 	  {
@@ -130,12 +115,9 @@
 	  }
 	else
 	  buf.append(c);
-	index++;
+	++index;
       }
 
-    if (quoteStarted)
-      throw new IllegalArgumentException ("pattern is lacking a closing quote");
-
     return index;
   }
 
@@ -277,16 +259,6 @@
 	    useExponentialNotation = true;
 	    minExponentDigits = (byte) zeroCount;
 	  }
-
-	maximumIntegerDigits = groupingSize;
-	groupingSize = 0;
-	if (maximumIntegerDigits > minimumIntegerDigits && maximumIntegerDigits > 0)
-	  {
-	    minimumIntegerDigits = 1;
-	    exponentRound = maximumIntegerDigits;
-	  }
-	else
-	  exponentRound = 1;
       }
 
     return index;
@@ -332,23 +304,17 @@
     minimumFractionDigits = 0;
     minimumIntegerDigits = 1;
 
-    AttributedFormatBuffer buf = new AttributedFormatBuffer ();
+    StringBuffer buf = new StringBuffer ();
     String patChars = patternChars (syms);
 
     int max = pattern.length();
     int index = scanFix (pattern, 0, buf, patChars, syms, false);
-    buf.sync();
-    positivePrefix = buf.getBuffer().toString();
-    positivePrefixRanges = buf.getRanges();
-    positivePrefixAttrs = buf.getAttributes();
+    positivePrefix = buf.toString();
 
     index = scanFormat (pattern, index, patChars, syms, true);
 
     index = scanFix (pattern, index, buf, patChars, syms, true);
-    buf.sync();
-    positiveSuffix = buf.getBuffer().toString();
-    positiveSuffixRanges = buf.getRanges();
-    positiveSuffixAttrs = buf.getAttributes();
+    positiveSuffix = buf.toString();
 
     if (index == pattern.length())
       {
@@ -363,20 +329,14 @@
 					      "expected - index: " + index);
 
 	index = scanFix (pattern, index + 1, buf, patChars, syms, false);
-	buf.sync();
-	negativePrefix = buf.getBuffer().toString();
-	negativePrefixRanges = buf.getRanges();
-	negativePrefixAttrs = buf.getAttributes();
+	negativePrefix = buf.toString();
 
 	// We parse the negative format for errors but we don't let
 	// it side-effect this object.
 	index = scanFormat (pattern, index, patChars, syms, false);
 
 	index = scanFix (pattern, index, buf, patChars, syms, true);
-	buf.sync();
-	negativeSuffix = buf.getBuffer().toString();
-	negativeSuffixRanges = buf.getRanges();
-	negativeSuffixAttrs = buf.getAttributes();
+	negativeSuffix = buf.toString();
 
 	if (index != pattern.length())
 	  throw new IllegalArgumentException ("end of pattern expected " +
@@ -449,43 +409,39 @@
 	    && useExponentialNotation == dup.useExponentialNotation);
   }
 
-  protected void formatInternal (double number, FormatBuffer dest,
-				 FieldPosition fieldPos)
+  public StringBuffer format (double number, StringBuffer dest,
+			      FieldPosition fieldPos)
   {
     // A very special case.
     if (Double.isNaN(number))
       {
 	dest.append(symbols.getNaN());
-	if (fieldPos != null && 
-	    (fieldPos.getField() == INTEGER_FIELD ||
-	     fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))
+	if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)
 	  {
 	    int index = dest.length();
 	    fieldPos.setBeginIndex(index - symbols.getNaN().length());
 	    fieldPos.setEndIndex(index);
 	  }
-	return;
+	return dest;
       }
 
     boolean is_neg = number < 0;
     if (is_neg)
       {
 	if (negativePrefix != null)
-	  dest.append(negativePrefix, negativePrefixRanges, negativePrefixAttrs);
+	  dest.append(negativePrefix);
 	else
 	  {
-	    dest.append(symbols.getMinusSign(), NumberFormat.Field.SIGN);
-	    dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);
+	    dest.append(symbols.getMinusSign());
+	    dest.append(positivePrefix);
 	  }
 	number = - number;
       }
     else
-      dest.append(positivePrefix, positivePrefixRanges, positivePrefixAttrs);
+      dest.append(positivePrefix);
 
     int integerBeginIndex = dest.length();
     int integerEndIndex = 0;
-    int zeroStart = symbols.getZeroDigit() - '0';
-
     if (Double.isInfinite (number))
       {
 	dest.append(symbols.getInfinity());
@@ -501,7 +457,6 @@
 	if (useExponentialNotation)
 	  {
 	    exponent = (long) Math.floor (Math.log(number) / Math.log(10));
-	    exponent = exponent - (exponent % exponentRound);
 	    if (minimumIntegerDigits > 0)
 	      exponent -= minimumIntegerDigits - 1;
 	    baseNumber = (number / Math.pow(10.0, exponent));
@@ -513,57 +468,33 @@
 	baseNumber += 5 * Math.pow(10.0, - maximumFractionDigits - 1);
 
 	int index = dest.length();
-	//double intPart = Math.floor(baseNumber);
-	String intPart = Long.toString((long)Math.floor(baseNumber));
-	int count, groupPosition = intPart.length();
-
-	dest.setDefaultAttribute(NumberFormat.Field.INTEGER);
-
-	for (count = 0; count < minimumIntegerDigits-intPart.length(); count++)
-	  dest.append(symbols.getZeroDigit());
-
-	for (count = 0;
-	     count < maximumIntegerDigits && count < intPart.length();
-	     count++)
+	double intPart = Math.floor(baseNumber);
+	int count = 0;
+	while (count < maximumIntegerDigits
+	       && (intPart > 0 || count < minimumIntegerDigits))
 	  {
-	    int dig = intPart.charAt(count);
+	    long dig = (long) (intPart % 10);
+	    intPart = Math.floor(intPart / 10);
 
 	    // Append group separator if required.
-	    if (groupingUsed && count > 0 && groupingSize != 0 && groupPosition % groupingSize == 0)
-	      {
-		dest.append(symbols.getGroupingSeparator(), NumberFormat.Field.GROUPING_SEPARATOR);
-		dest.setDefaultAttribute(NumberFormat.Field.INTEGER);
-	      }
-	    dest.append((char) (zeroStart + dig));
+	    if (groupingUsed && count > 0 && groupingSize != 0 && count % groupingSize == 0)
+	      dest.insert(index, symbols.getGroupingSeparator());
+
+	    dest.insert(index, (char) (symbols.getZeroDigit() + dig));
 
-	    groupPosition--;
+	    ++count;
 	  }
-	dest.setDefaultAttribute(null);
 
 	integerEndIndex = dest.length();
-	   
+
 	int decimal_index = integerEndIndex;
 	int consecutive_zeros = 0;
 	int total_digits = 0;
 
-	int localMaximumFractionDigits = maximumFractionDigits;
-
-	if (useExponentialNotation)
-	  localMaximumFractionDigits += minimumIntegerDigits - count;
-
 	// Strip integer part from NUMBER.
 	double fracPart = baseNumber - Math.floor(baseNumber);
-	
-	if ( ((fracPart != 0 || minimumFractionDigits > 0) && localMaximumFractionDigits > 0)
-	     || decimalSeparatorAlwaysShown)
-	  {
-	    dest.append (symbols.getDecimalSeparator(), NumberFormat.Field.DECIMAL_SEPARATOR);
-	  }
-
-
-	dest.setDefaultAttribute(NumberFormat.Field.FRACTION);
 	for (count = 0;
-	     count < localMaximumFractionDigits
+	     count < maximumFractionDigits
 	       && (fracPart != 0 || count < minimumFractionDigits);
 	     ++count)
 	  {
@@ -586,82 +517,61 @@
 				    total_digits - minimumFractionDigits);
 	if (extra_zeros > 0)
 	  {
-	    dest.cutTail(extra_zeros);
+	    dest.setLength(dest.length() - extra_zeros);
 	    total_digits -= extra_zeros;
-	    if (total_digits == 0 && !decimalSeparatorAlwaysShown)
-	      dest.cutTail(1);
+	  }
+
+	// If required, add the decimal symbol.
+	if (decimalSeparatorAlwaysShown
+	    || total_digits > 0)
+	  {
+	    dest.insert(decimal_index, symbols.getDecimalSeparator());
+	    if (fieldPos != null && fieldPos.getField() == FRACTION_FIELD)
+	      {
+		fieldPos.setBeginIndex(decimal_index + 1);
+		fieldPos.setEndIndex(dest.length());
+	      }
 	  }
 
 	// Finally, print the exponent.
 	if (useExponentialNotation)
 	  {
-	    dest.append(symbols.getExponential(), NumberFormat.Field.EXPONENT_SYMBOL);	    
+	    dest.append(symbols.getExponential());
 	    if (exponent < 0)
 	      {
-		dest.append (symbols.getMinusSign (), NumberFormat.Field.EXPONENT_SIGN);
+		dest.append (symbols.getMinusSign ());
 		exponent = - exponent;
 	      }
 	    index = dest.length();
-	    dest.setDefaultAttribute(NumberFormat.Field.EXPONENT);
-	    String exponentString = Long.toString ((long) exponent);
-	    
-	    for (count = 0; count < minExponentDigits-exponentString.length();
-		 count++)
-	      dest.append((char) symbols.getZeroDigit());
-
 	    for (count = 0;
-		 count < exponentString.length();
+		 exponent > 0 || count < minExponentDigits;
 		 ++count)
 	      {
-		int dig = exponentString.charAt(count);
-		dest.append((char) (zeroStart + dig));
+		long dig = exponent % 10;
+		exponent /= 10;
+		dest.insert(index, (char) (symbols.getZeroDigit() + dig));
 	      }
 	  }
       }
 
-    if (fieldPos != null && 
-	(fieldPos.getField() == INTEGER_FIELD ||
-	 fieldPos.getFieldAttribute() == NumberFormat.Field.INTEGER))
+    if (fieldPos != null && fieldPos.getField() == INTEGER_FIELD)
       {
 	fieldPos.setBeginIndex(integerBeginIndex);
 	fieldPos.setEndIndex(integerEndIndex);
       }
 
-    if (is_neg && negativeSuffix != null)
-      dest.append(negativeSuffix, negativeSuffixRanges, negativeSuffixAttrs);
-    else
-      dest.append(positiveSuffix, positiveSuffixRanges, positiveSuffixAttrs);
-  }
-
-  public StringBuffer format (double number, StringBuffer dest,
-			      FieldPosition fieldPos)
-  {
-    formatInternal (number, new StringFormatBuffer(dest), fieldPos);
+    dest.append((is_neg && negativeSuffix != null)
+		? negativeSuffix
+		: positiveSuffix);
     return dest;
   }
 
-  public AttributedCharacterIterator formatToCharacterIterator (Object value)
-  {
-    AttributedFormatBuffer sbuf = new AttributedFormatBuffer();
-
-    if (value instanceof Number)
-      formatInternal(((Number) value).doubleValue(), sbuf, null);
-    else
-      throw new IllegalArgumentException 
-	("Cannot format given Object as a Number");
-    
-    sbuf.sync();
-    return new FormatCharacterIterator(sbuf.getBuffer().toString(), 
-				       sbuf.getRanges(), 
-				       sbuf.getAttributes());
-  }
-
   public StringBuffer format (long number, StringBuffer dest,
 			      FieldPosition fieldPos)
   {
     // If using exponential notation, we just format as a double.
     if (useExponentialNotation)
-       return format ((double) number, dest, fieldPos);
+      return format ((double) number, dest, fieldPos);
 
     boolean is_neg = number < 0;
     if (is_neg)
@@ -1054,7 +964,7 @@
     // digits.  Past that we need hash marks up to the grouping
     // separator (and one beyond).
     int total_digits = Math.max(minimumIntegerDigits,
-				groupingUsed ? groupingSize + 1: groupingSize);
+				groupingUsed ? groupingSize + 1: 0);
     for (int i = 0; i < total_digits - minimumIntegerDigits; ++i)
       mainPattern.append(syms.getDigit());
     for (int i = total_digits - minimumIntegerDigits; i < total_digits; ++i)
@@ -1112,16 +1022,11 @@
   private boolean decimalSeparatorAlwaysShown;
   private byte groupingSize;
   private byte minExponentDigits;
-  private int exponentRound;
   private int multiplier;
   private String negativePrefix;
   private String negativeSuffix;
   private String positivePrefix;
   private String positiveSuffix;
-  private int[] negativePrefixRanges, positivePrefixRanges;
-  private HashMap[] negativePrefixAttrs, positivePrefixAttrs;
-  private int[] negativeSuffixRanges, positiveSuffixRanges;
-  private HashMap[] negativeSuffixAttrs, positiveSuffixAttrs;
   private int serialVersionOnStream = 1;
   private DecimalFormatSymbols symbols;
   private boolean useExponentialNotation;
