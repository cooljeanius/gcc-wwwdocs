--- /home/tromey/gnu/classpath/classpath/java/util/HashMap.java	Wed Nov  6 21:06:25 2002
+++ java/util/HashMap.java	Tue Jun 18 09:39:51 2002
@@ -180,15 +180,6 @@
     }
 
     /**
-     * Called when this entry is accessed via {@link #put(Object, Object)}.
-     * This version does nothing, but in LinkedHashMap, it must do some
-     * bookkeeping for access-traversal mode.
-     */
-    void access()
-    {
-    }
-
-    /**
      * Called when this entry is removed from the map. This version simply
      * returns the value, but in LinkedHashMap, it must also do bookkeeping.
      *
@@ -347,12 +338,8 @@
     while (e != null)
       {
         if (equals(key, e.key))
-          {
-            e.access(); // Must call this for bookkeeping in LinkedHashMap.
-            Object r = e.value;
-            e.value = value;
-            return r;
-          }
+          // Must use this method for necessary bookkeeping in LinkedHashMap.
+          return e.setValue(value);
         else
           e = e.next;
       }
@@ -381,8 +368,8 @@
   public void putAll(Map m)
   {
     Iterator itr = m.entrySet().iterator();
-    int msize = m.size();
-    while (msize-- > 0)
+
+    for (int msize = m.size(); msize > 0; msize--)
       {
         Map.Entry e = (Map.Entry) itr.next();
         // Optimize in case the Entry is one of our own.
@@ -392,7 +379,9 @@
             put(entry.key, entry.value);
           }
         else
-          put(e.getKey(), e.getValue());
+          {
+            put(e.getKey(), e.getValue());
+          }
       }
   }
   
@@ -531,7 +520,7 @@
         public boolean remove(Object o)
         {
           // Test against the size of the HashMap to determine if anything
-          // really got removed. This is necessary because the return value
+          // really got removed. This is neccessary because the return value
           // of HashMap.remove() is ambiguous in the null case.
           int oldsize = size;
           HashMap.this.remove(o);
@@ -645,6 +634,7 @@
   void addEntry(Object key, Object value, int idx, boolean callRemove)
   {
     HashEntry e = new HashEntry(key, value);
+
     e.next = buckets[idx];
     buckets[idx] = e;
   }
@@ -658,18 +648,17 @@
    * @see #entrySet()
    */
   // Package visible, for use in nested classes.
-  final HashEntry getEntry(Object o)
+  HashEntry getEntry(Object o)
   {
-    if (! (o instanceof Map.Entry))
+    if (!(o instanceof Map.Entry))
       return null;
     Map.Entry me = (Map.Entry) o;
-    Object key = me.getKey();
-    int idx = hash(key);
+    int idx = hash(me.getKey());
     HashEntry e = buckets[idx];
     while (e != null)
       {
-        if (equals(e.key, key))
-          return equals(e.value, me.getValue()) ? e : null;
+        if (e.equals(me))
+          return e;
         e = e.next;
       }
     return null;
@@ -710,8 +699,9 @@
   {
     Iterator itr = m.entrySet().iterator();
     int msize = m.size();
-    size = msize;
-    while (msize-- > 0)
+    this.size = msize;
+
+    for (; msize > 0; msize--)
       {
 	Map.Entry e = (Map.Entry) itr.next();
 	Object key = e.getKey();
@@ -752,7 +742,9 @@
                 dest.next = e;
               }
             else
-              buckets[idx] = e;
+              {
+                buckets[idx] = e;
+              }
 
             HashEntry next = e.next;
             e.next = null;
@@ -805,14 +797,13 @@
     // Read the threshold and loadFactor fields.
     s.defaultReadObject();
 
-    // Read and use capacity, followed by key/value pairs.
+    // Read and use capacity.
     buckets = new HashEntry[s.readInt()];
     int len = s.readInt();
-    while (len-- > 0)
-      {
-        Object key = s.readObject();
-        addEntry(key, s.readObject(), hash(key), false);
-      }
+
+    // Read and use key/value pairs.
+    for ( ; len > 0; len--)
+      put(s.readObject(), s.readObject());
   }
 
   /**
