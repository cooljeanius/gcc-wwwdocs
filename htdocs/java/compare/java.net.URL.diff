--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2004-04-28 02:20:16.000000000 -0600
+++ java/net/URL.java	2004-05-04 02:18:23.000000000 -0600
@@ -121,7 +121,7 @@
 public final class URL implements Serializable
 {
   private static final String DEFAULT_SEARCH_PATH =
-    "gnu.java.net.protocol|gnu.inet";
+    "gnu.java.net.protocol|sun.net.www.protocol";
 
   /**
    * The name of the protocol for this URL.
@@ -684,8 +684,7 @@
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. This might be called
    * by the <code>parseURL()</code> method in that class. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL
    * @param host The hostname or IP address for this URL
@@ -696,15 +695,12 @@
   protected void set(String protocol, String host, int port, String file,
                      String ref)
   {
-    URLStreamHandler protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
-      {
-        this.ph = protocolHandler;
-        this.protocol = protocol.toLowerCase();
-      }
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    this.ph = getURLStreamHandler(protocol);
+    this.protocol = protocol.toLowerCase();
     this.authority = "";
     this.port = port;
     this.host = host;
@@ -722,8 +718,7 @@
   /**
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL.
    * @param host The hostname or IP address for this URL.
@@ -739,15 +734,12 @@
   protected void set(String protocol, String host, int port, String authority,
                      String userInfo, String path, String query, String ref)
   {
-    URLStreamHandler protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
-      {
-        this.ph = protocolHandler;
-        this.protocol = protocol.toLowerCase();
-      }
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    this.ph = getURLStreamHandler(protocol);
+    this.protocol = protocol.toLowerCase();
     this.host = host;
     this.userInfo = userInfo;
     this.port = port;
@@ -833,6 +825,24 @@
       {
 	ph = factory.createURLStreamHandler(protocol);
       }
+    else if (protocol.equals("core"))
+      {
+ 	ph = new gnu.java.net.protocol.core.Handler();
+      }
+    else if (protocol.equals("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.java.net.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.java.net.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
