--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2004-08-13 02:34:02.000000000 -0600
+++ java/net/URL.java	2004-07-04 02:18:45.000000000 -0600
@@ -1,6 +1,5 @@
 /* URL.java -- Uniform Resource Locator Class
-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004
-   Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -39,8 +38,6 @@
 package java.net;
 
 import gnu.java.net.URLParseError;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
@@ -124,10 +121,7 @@
 public final class URL implements Serializable
 {
   private static final String DEFAULT_SEARCH_PATH =
-    "gnu.java.net.protocol|gnu.inet";
-
-  // Cached System ClassLoader
-  private static ClassLoader systemClassLoader;
+    "gnu.java.net.protocol|sun.net.www.protocol";
 
   /**
    * The name of the protocol for this URL.
@@ -289,7 +283,7 @@
     this.host = host;
     this.port = port;
     this.authority = (host != null) ? host : "";
-    if (port >= 0 && host != null)
+    if (port >= 0)
 	this.authority += ":" + port;
 
     int hashAt = file.indexOf('#');
@@ -430,8 +424,6 @@
 
       throw new MalformedURLException("Absolute URL required with null context");
 
-    protocol = protocol.trim();
-
     if (ph != null)
       {
 	SecurityManager s = System.getSecurityManager();
@@ -538,8 +530,6 @@
    */
   public String getPath()
   {
-    // The spec says we need to return an empty string, but some
-    // applications depends on receiving null when the path is empty.
     if (file == null)
       return null;
     int quest = file.indexOf('?');
@@ -697,8 +687,7 @@
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. This might be called
    * by the <code>parseURL()</code> method in that class. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL
    * @param host The hostname or IP address for this URL
@@ -709,16 +698,14 @@
   protected void set(String protocol, String host, int port, String file,
                      String ref)
   {
-    URLStreamHandler protocolHandler = null;
-    protocol = protocol.toLowerCase();
-    if (! this.protocol.equals(protocol))
-      protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    protocol = protocol.toLowerCase ();
+    if (! this.protocol.equals (protocol))
       {
-	this.ph = protocolHandler;
+	this.ph = getURLStreamHandler(protocol);
 	this.protocol = protocol;
       }
     this.authority = "";
@@ -738,8 +725,7 @@
   /**
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL.
    * @param host The hostname or IP address for this URL.
@@ -755,16 +741,14 @@
   protected void set(String protocol, String host, int port, String authority,
                      String userInfo, String path, String query, String ref)
   {
-    URLStreamHandler protocolHandler = null;
-    protocol = protocol.toLowerCase();
-    if (! this.protocol.equals(protocol))
-      protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    protocol = protocol.toLowerCase ();
+    if (! this.protocol.equals (protocol))
       {
-	this.ph = protocolHandler;
+	this.ph = getURLStreamHandler(protocol);
 	this.protocol = protocol;
       }
     this.host = host;
@@ -852,6 +836,24 @@
       {
 	ph = factory.createURLStreamHandler(protocol);
       }
+    else if (protocol.equals("core"))
+      {
+ 	ph = new gnu.java.net.protocol.core.Handler();
+      }
+    else if (protocol.equals("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.java.net.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.java.net.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
@@ -873,39 +875,36 @@
 	// Finally loop through our search path looking for a match.
 	StringTokenizer pkgPrefix = new StringTokenizer(ph_search_path, "|");
 
-	// Cache the systemClassLoader
-	if (systemClassLoader == null)
-	  {
-	    systemClassLoader = (ClassLoader) AccessController.doPrivileged
-	      (new PrivilegedAction() {
-		  public Object run() {
-		    return ClassLoader.getSystemClassLoader();
-		  }
-		});
-	  }
-
 	do
 	  {
+	    String clsName =
+	      (pkgPrefix.nextToken() + "." + protocol + ".Handler");
+
 	    try
 	      {
-		// Try to get a class from the system/application
-		// classloader, initialize it, make an instance
-		// and try to cast it to a URLStreamHandler.
-		String clsName =
-		  (pkgPrefix.nextToken() + "." + protocol + ".Handler");
-		Class c = Class.forName(clsName, true, systemClassLoader);
-		ph = (URLStreamHandler) c.newInstance();
+		Object obj = Class.forName(clsName).newInstance();
+
+		if (! (obj instanceof URLStreamHandler))
+		  continue;
+		else
+		  ph = (URLStreamHandler) obj;
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null,
+		// go on to next element.
 	      }
-	    catch (Throwable t) { /* ignored */ }
 	  }
-	 while (ph == null && pkgPrefix.hasMoreTokens());
+	 while ((! (ph instanceof URLStreamHandler))
+	        && pkgPrefix.hasMoreTokens());
       }
 
     // Update the hashtable with the new protocol handler.
     if (ph != null && cache_handlers)
-      ph_cache.put(protocol, ph);
-    else
-      ph = null;
+      if (ph instanceof URLStreamHandler)
+	ph_cache.put(protocol, ph);
+      else
+	ph = null;
 
     return ph;
   }
