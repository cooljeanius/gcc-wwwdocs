--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2003-10-07 02:20:23.000000000 -0600
+++ java/net/URL.java	2003-10-07 02:18:16.000000000 -0600
@@ -119,7 +119,7 @@
 public final class URL implements Serializable
 {
   private static final String DEFAULT_SEARCH_PATH =
-    "gnu.java.net.protocol|sun.net.www.protocol";
+    "gnu.gcj.protocol|sun.net.www.protocol";
   
   /**
    * The name of the protocol for this URL.
@@ -773,6 +773,24 @@
       {
 	ph = factory.createURLStreamHandler (protocol);
       }
+    else if (protocol.equals ("core"))
+      {
+ 	ph = new gnu.gcj.protocol.core.Handler();
+      }
+    else if (protocol.equals ("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.gcj.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.gcj.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
