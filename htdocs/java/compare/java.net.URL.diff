--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2004-10-16 02:22:18.000000000 -0600
+++ java/net/URL.java	2004-09-24 02:16:14.000000000 -0600
@@ -39,14 +39,13 @@
 package java.net;
 
 import gnu.java.net.URLParseError;
-
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.HashMap;
 import java.util.StringTokenizer;
 
@@ -117,8 +116,8 @@
   * done, then the above information is superseded and the behavior of this
   * class in loading protocol handlers is dependent on that factory.
   *
-  * @author Aaron M. Renn (arenn@urbanophile.com)
-  * @author Warren Levy (warrenl@cygnus.com)
+  * @author Aaron M. Renn <arenn@urbanophile.com>
+  * @author Warren Levy <warrenl@cygnus.com>
   *
   * @see URLStreamHandler
   */
@@ -857,6 +856,24 @@
       {
 	ph = factory.createURLStreamHandler(protocol);
       }
+    else if (protocol.equals("core"))
+      {
+ 	ph = new gnu.java.net.protocol.core.Handler();
+      }
+    else if (protocol.equals("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.java.net.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.java.net.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
