--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2003-06-28 02:19:17.000000000 -0600
+++ java/net/URL.java	2003-06-28 02:18:20.000000000 -0600
@@ -98,19 +98,6 @@
   * <p>
   * Please note that a protocol handler must be a subclass of
   * URLStreamHandler.
-  * <p>
-  * Normally, this class caches protocol handlers.  Once it finds a handler
-  * for a particular protocol, it never tries to look up a new handler
-  * again.  However, if the system property
-  * gnu.java.net.nocache_protocol_handlers is set, then this
-  * caching behavior is disabled.  This property is specific to this
-  * implementation.  Sun's JDK may or may not do protocol caching, but it
-  * almost certainly does not examine this property.
-  * <p>
-  * Please also note that an application can install its own factory for
-  * loading protocol handlers (see setURLStreamHandlerFactory).  If this is
-  * done, then the above information is superseded and the behavior of this
-  * class in loading protocol handlers is dependent on that factory.
   *
   * @author Aaron M. Renn <arenn@urbanophile.com>
   * @author Warren Levy <warrenl@cygnus.com>
@@ -177,39 +164,6 @@
   private static final long serialVersionUID = -7627629688361524110L;
 
   /**
-   * This a table where we cache protocol handlers to avoid the overhead
-   * of looking them up each time.
-   */
-  private static Hashtable ph_cache = new Hashtable();
-
-  /**
-   * Whether or not to cache protocol handlers.
-   */
-  private static boolean cache_handlers;
-
-  /**
-   * The search path of packages to search for protocol handlers in.
-   */
-  private static String ph_search_path;
-
-  static
-    {
-      String s = System.getProperty("gnu.java.net.nocache_protocol_handlers");
-      if (s == null)
-        cache_handlers = true;
-      else
-        cache_handlers = false;
-
-      ph_search_path = System.getProperty("java.protocol.handler.pkgs");
-
-      // Tack our default package on at the ends
-      if (ph_search_path != null)
-        ph_search_path = ph_search_path + "|" + "gnu.java.net.protocol";
-      else
-        ph_search_path = "gnu.java.net.protocol";
-    }
-
-  /**
    * Constructs a URL and loads a protocol handler for the values passed as
    * arguments.
    * 
@@ -259,7 +213,7 @@
    * @param port The port number to use, or -1 to use the protocol's default
    * port
    * @param file The "file" portion of the URL.
-   * @param ph The protocol handler to use with this URL.
+   * @param handler The protocol handler to use with this URL.
    *
    * @exception MalformedURLException If no protocol handler can be loaded
    * for the specified protocol.
@@ -268,8 +222,8 @@
    *
    * @since 1.2
    */
-  public URL (String protocol, String host, int port, String file,
-	      URLStreamHandler ph)
+  public URL(String protocol, String host, int port, String file,
+	     URLStreamHandler ph)
     throws MalformedURLException
   {
     if (protocol == null)
@@ -366,7 +320,7 @@
    *
    * @param context The context in which to parse the specification
    * @param spec The string to parse as an URL
-   * @param ph The stream handler for the URL
+   * @param handler The stream handler for the URL
    *
    * @exception MalformedURLException If a protocol handler cannot be found
    * or the URL cannot be parsed
@@ -448,7 +402,7 @@
     // if one exists, otherwise pass the end of the string.
     int hashAt = spec.indexOf('#', colon + 1);
     this.ph.parseURL(this, spec, colon + 1,
-			  hashAt < 0 ? spec.length() : hashAt);
+		     hashAt < 0 ? spec.length() : hashAt);
     if (hashAt >= 0)
       ref = spec.substring(hashAt + 1);
 
@@ -465,7 +419,7 @@
    *
    * @return true if the URL is equal, false otherwise
    */
-  public boolean equals(Object obj)
+  public boolean equals (Object obj)
   {
     if (obj == null || ! (obj instanceof URL))
       return false;
@@ -764,72 +718,75 @@
     return ph.toExternalForm(this);
   }
 
-  /**
-   * This internal method is used in two different constructors to load
-   * a protocol handler for this URL.
-   *
-   * @param protocol The protocol to load a handler for
-   *
-   * @return A URLStreamHandler for this protocol, or null when not found.
-   */
   private static synchronized URLStreamHandler
     getURLStreamHandler (String protocol)
   {
     URLStreamHandler ph;
 
-    // First, see if a protocol handler is in our cache
-    if (cache_handlers)
-      {
-        Class cls = (Class)ph_cache.get(protocol);
-        if (cls != null)
-          {
-            try
-              {
-                ph = (URLStreamHandler)cls.newInstance();
-                return(ph);
-              }
-            catch (Exception e) { ; }
-          }
-      }
+    // See if a handler has been cached for this protocol.
+    if ((ph = (URLStreamHandler) handlers.get(protocol)) != null)
+      return ph;
 
-    // Next check the factory and use that if set
+    // If a non-default factory has been set, use it to find the protocol.
     if (factory != null)
+      ph = factory.createURLStreamHandler(protocol);
+    else if (protocol.equals ("core"))
       {
-        ph = factory.createURLStreamHandler(protocol);
-        if (ph != null)
-          {
-            if (cache_handlers)
-	      ph_cache.put(protocol, ph.getClass());
-
-            return(ph);
-	  }
+ 	ph = new gnu.gcj.protocol.core.Handler ();
+      }
+    else if (protocol.equals ("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.gcj.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.gcj.protocol.file.Handler ();
       }
 
-    // Finally loop through our search path looking for a match
-    StringTokenizer st = new StringTokenizer(ph_search_path, "|");
-    while (st.hasMoreTokens())
+    // Non-default factory may have returned null or a factory wasn't set.
+    // Use the default search algorithm to find a handler for this protocol.
+    if (ph == null)
       {
-        String clsname = st.nextToken() + "." + protocol + ".Handler";
-         
-        try
-          {
-            Class cls = Class.forName(clsname); 
-            Object obj = cls.newInstance();
-            if (!(obj instanceof URLStreamHandler))
-              continue;
-            else
-              ph = (URLStreamHandler)obj;
-
-            if (cache_handlers)
-              ph_cache.put(protocol, cls);
-
-            return(ph);
-          }
-        catch (Exception e) { ; }
+	// Get the list of packages to check and append our default handler
+	// to it, along with the JDK specified default as a last resort.
+	// Except in very unusual environments the JDK specified one shouldn't
+	// ever be needed (or available).
+	String propVal = System.getProperty("java.protocol.handler.pkgs");
+	propVal = (propVal == null) ? "" : (propVal + "|");
+	propVal = propVal + "gnu.gcj.protocol|sun.net.www.protocol";
+
+	StringTokenizer pkgPrefix = new StringTokenizer(propVal, "|");
+	do
+	  {
+	    String facName = pkgPrefix.nextToken() + "." + protocol +
+				".Handler";
+	    try
+	      {
+		ph = (URLStreamHandler) Class.forName(facName).newInstance();
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null, go on to next element.
+	      }
+	  } while ((ph == null ||
+		    ! (ph instanceof URLStreamHandler)) &&
+		   pkgPrefix.hasMoreTokens());
       }
 
-    // Still here, which is bad
-    return null;
+    // Update the hashtable with the new protocol handler.
+    if (ph != null)
+      if (ph instanceof URLStreamHandler)
+	handlers.put(protocol, ph);
+      else
+	ph = null;
+
+    return ph;
   }
 
   private void readObject(ObjectInputStream ois)
