--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2004-04-13 02:20:24.000000000 -0600
+++ java/net/URL.java	2004-01-02 02:18:05.000000000 -0700
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -35,18 +35,18 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package java.net;
 
 import gnu.java.net.URLParseError;
-import java.io.IOException;
 import java.io.InputStream;
+import java.io.IOException;
+import java.io.Serializable;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import java.io.Serializable;
 import java.util.HashMap;
 import java.util.StringTokenizer;
 
-
 /*
  * Written using on-line Java Platform 1.2 API Specification, as well
  * as "The Java Class Libraries", 2nd edition (Addison-Wesley, 1998).
@@ -56,7 +56,7 @@
 /**
   * This final class represents an Internet Uniform Resource Locator (URL).
   * For details on the syntax of URL's and what they can be used for,
-  * refer to RFC 1738, available from <a
+  * refer to RFC 1738, available from <a 
   * href="http://ds.internic.net/rfcs/rfc1738.txt">
   * http://ds.internic.net/rfcs/rfc1738.txt</a>
   * <p>
@@ -74,7 +74,7 @@
   * This chaining is done via the system property java.protocol.handler.pkgs
   * If this property is set, it is assumed to be a "|" separated list of
   * package names in which to attempt locating protocol handlers.  The
-  * protocol handler is searched for by appending the string
+  * protocol handler is searched for by appending the string 
   * ".&lt;protocol&gt;.Handler" to each packed in the list until a hander is
   * found. If a protocol handler is not found in this list of packages, or if
   * the property does not exist, then the default protocol handler of
@@ -87,7 +87,7 @@
   * <p>
   * Here is an example of how URL searches for protocol handlers.  Assume
   * the value of java.protocol.handler.pkgs is "com.foo|com.bar" and the
-  * URL is "news://comp.lang.java.programmer".  URL would looking the
+  * URL is "news://comp.lang.java.programmer".  URL would looking the 
   * following places for protocol handlers:
   * <p><pre>
   * com.foo.news.Handler
@@ -122,7 +122,7 @@
 {
   private static final String DEFAULT_SEARCH_PATH =
     "gnu.java.net.protocol|sun.net.www.protocol";
-
+  
   /**
    * The name of the protocol for this URL.
    * The protocol is always stored in lower case.
@@ -144,7 +144,7 @@
    * The port number of this protocol or -1 if the port number used is
    * the default for this protocol.
    */
-  private int port = -1; // Initialize for constructor using context.
+  private int port = -1;	// Initialize for constructor using context.
 
   /**
    * The "file" portion of the URL. It is defined as <code>path[?query]</code>.
@@ -159,7 +159,7 @@
   /**
    * This is the hashCode for this URL
    */
-  private int hashCode;
+  private int hashCode = 0;
 
   /**
    * The protocol handler in use for this URL
@@ -171,6 +171,7 @@
    * where we keep track of it.
    */
   private static URLStreamHandlerFactory factory;
+
   private static final long serialVersionUID = -7627629688361524110L;
 
   /**
@@ -186,18 +187,18 @@
 
   static
     {
-      String s = System.getProperty("gnu.java.net.nocache_protocol_handlers");
-
+      String s = System.getProperty ("gnu.java.net.nocache_protocol_handlers");
+      
       if (s == null)
-	cache_handlers = true;
+        cache_handlers = true;
       else
-	cache_handlers = false;
+        cache_handlers = false;
     }
 
   /**
    * Constructs a URL and loads a protocol handler for the values passed as
    * arguments.
-   *
+   * 
    * @param protocol The protocol for this URL ("http", "ftp", etc)
    * @param host The hostname or IP address to connect to
    * @param port The port number to use, or -1 to use the protocol's
@@ -230,10 +231,11 @@
     this(protocol, host, -1, file, null);
   }
 
+
   /**
    * This method initializes a new instance of <code>URL</code> with the
    * specified protocol, host, port, and file.  Additionally, this method
-   * allows the caller to specify a protocol handler to use instead of
+   * allows the caller to specify a protocol handler to use instead of 
    * the default.  If this handler is specified, the caller must have
    * the "specifyStreamHandler" permission (see <code>NetPermission</code>)
    * or a <code>SecurityException</code> will be thrown.
@@ -252,8 +254,9 @@
    *
    * @since 1.2
    */
-  public URL(String protocol, String host, int port, String file,
-             URLStreamHandler ph) throws MalformedURLException
+  public URL (String protocol, String host, int port, String file,
+	      URLStreamHandler ph)
+    throws MalformedURLException
   {
     if (protocol == null)
       throw new MalformedURLException("null protocol");
@@ -263,16 +266,16 @@
       {
 	SecurityManager s = System.getSecurityManager();
 	if (s != null)
-	  s.checkPermission(new NetPermission("specifyStreamHandler"));
+	  s.checkPermission (new NetPermission ("specifyStreamHandler"));
 
-	this.ph = ph;
+        this.ph = ph;
       }
     else
       this.ph = getURLStreamHandler(protocol);
 
     if (this.ph == null)
-      throw new MalformedURLException("Protocol handler not found: "
-                                      + protocol);
+      throw new MalformedURLException (
+		      "Protocol handler not found: " + protocol);
 
     this.host = host;
     this.port = port;
@@ -289,7 +292,7 @@
 	this.file = file.substring(0, hashAt);
 	this.ref = file.substring(hashAt + 1);
       }
-    hashCode = hashCode(); // Used for serialization.
+    hashCode = hashCode();			// Used for serialization.
   }
 
   /**
@@ -322,7 +325,7 @@
    * @param context The context on which to parse the specification
    * @param spec The string to parse an URL
    *
-   * @exception MalformedURLException If a protocol handler cannot be found
+   * @exception MalformedURLException If a protocol handler cannot be found 
    * for the URL cannot be parsed
    */
   public URL(URL context, String spec) throws MalformedURLException
@@ -337,7 +340,7 @@
    * not present the URL are inheritied from the context URL.  This allows
    * relative URL's to be easily constructed.  If the context argument is
    * null, then a complete URL must be specified in the URL string.
-   * If the protocol parsed out of the URL is different
+   * If the protocol parsed out of the URL is different 
    * from the context URL's protocol, then then URL String is also
    * expected to be a complete URL.
    * <p>
@@ -369,7 +372,7 @@
      * The relative URL need not specify all the components of a URL.
      * If the protocol, host name, or port number is missing, the value
      * is inherited from the context.  A bare file component is appended
-     * to the context's file.  The optional anchor is not inherited.
+     * to the context's file.  The optional anchor is not inherited. 
      */
 
     // If this is an absolute URL, then ignore context completely.
@@ -377,13 +380,13 @@
     // right after the "://".  The second colon is for an optional port value
     // and implies that the host from the context is used if available.
     int colon;
-    if ((colon = spec.indexOf("://", 1)) > 0
-        && ! spec.regionMatches(colon, "://:", 0, 4))
+    if ((colon = spec.indexOf("://", 1)) > 0 &&
+	! spec.regionMatches(colon, "://:", 0, 4))
       context = null;
 
     int slash;
-    if ((colon = spec.indexOf(':')) > 0
-        && (colon < (slash = spec.indexOf('/')) || slash < 0))
+    if ((colon = spec.indexOf(':')) > 0 &&
+	(colon < (slash = spec.indexOf('/')) || slash < 0))
       {
 	// Protocol specified in spec string.
 	protocol = spec.substring(0, colon).toLowerCase();
@@ -409,27 +412,26 @@
 	file = context.file;
 	if (file == null || file.length() == 0)
 	  file = "/";
-	authority = context.authority;
+        authority = context.authority;
       }
-    else // Protocol NOT specified in spec. and no context available.
-
-
-      throw new MalformedURLException("Absolute URL required with null context");
+    else	// Protocol NOT specified in spec. and no context available.
+      throw new
+	  MalformedURLException("Absolute URL required with null context");
 
     if (ph != null)
       {
-	SecurityManager s = System.getSecurityManager();
+	SecurityManager s = System.getSecurityManager ();
 	if (s != null)
-	  s.checkPermission(new NetPermission("specifyStreamHandler"));
+	  s.checkPermission (new NetPermission ("specifyStreamHandler"));
 
-	this.ph = ph;
+        this.ph = ph;
       }
     else
       this.ph = getURLStreamHandler(protocol);
 
     if (this.ph == null)
       throw new MalformedURLException("Protocol handler not found: "
-                                      + protocol);
+				      + protocol);
 
     // JDK 1.2 doc for parseURL specifically states that any '#' ref
     // is to be excluded by passing the 'limit' as the indexOf the '#'
@@ -439,35 +441,35 @@
     try
       {
 	this.ph.parseURL(this, spec, colon + 1,
-	                 hashAt < 0 ? spec.length() : hashAt);
+			 hashAt < 0 ? spec.length() : hashAt);
       }
     catch (URLParseError e)
       {
 	throw new MalformedURLException(e.getMessage());
       }
-
+    
     if (hashAt >= 0)
       ref = spec.substring(hashAt + 1);
 
-    hashCode = hashCode(); // Used for serialization.
+    hashCode = hashCode();			// Used for serialization.
   }
 
   /**
    * Test another URL for equality with this one.  This will be true only if
-   * the argument is non-null and all of the fields in the URL's match
+   * the argument is non-null and all of the fields in the URL's match 
    * exactly (ie, protocol, host, port, file, and ref).  Overrides
    * Object.equals(), implemented by calling the equals method of the handler.
    *
-   * @param obj The URL to compare with
+   * @param url The URL to compare with
    *
    * @return true if the URL is equal, false otherwise
    */
-  public boolean equals(Object obj)
+  public boolean equals (Object obj)
   {
     if (! (obj instanceof URL))
       return false;
 
-    return ph.equals(this, (URL) obj);
+    return ph.equals (this, (URL) obj);
   }
 
   /**
@@ -480,7 +482,7 @@
    *
    * @since 1.3
    */
-  public Object getContent() throws IOException
+  public final Object getContent() throws IOException
   {
     return openConnection().getContent();
   }
@@ -494,7 +496,7 @@
    *
    * @exception IOException If an error occurs
    */
-  public Object getContent(Class[] classes) throws IOException
+  public final Object getContent (Class[] classes) throws IOException
   {
     // FIXME: implement this
     return getContent();
@@ -517,7 +519,7 @@
    * character.
    *
    * @return The path specified in this URL.
-   *
+   * 
    * @since 1.3
    */
   public String getPath()
@@ -530,7 +532,7 @@
    * Returns the authority of the URL
    *
    * @return The authority specified in this URL.
-   *
+   * 
    * @since 1.3
    */
   public String getAuthority()
@@ -600,7 +602,7 @@
    *
    * @return the user at a particular host or null when no user defined.
    */
-  public String getUserInfo()
+  public String getUserInfo ()
   {
     int at = (host == null) ? -1 : host.indexOf('@');
     return at < 0 ? null : host.substring(0, at);
@@ -612,7 +614,7 @@
    *
    * @return the query part of the file, or null when there is no query part.
    */
-  public String getQuery()
+  public String getQuery ()
   {
     int quest = (file == null) ? -1 : file.indexOf('?');
     return quest < 0 ? null : file.substring(quest + 1, file.length());
@@ -626,9 +628,9 @@
   public int hashCode()
   {
     if (hashCode != 0)
-      return hashCode; // Use cached value if available.
+      return hashCode;		// Use cached value if available.
     else
-      return ph.hashCode(this);
+      return ph.hashCode (this);
   }
 
   /**
@@ -650,10 +652,10 @@
    * from that connection
    *
    * @return An <code>InputStream</code> for this URL.
-   *
+   * 
    * @exception IOException If an error occurs
    */
-  public InputStream openStream() throws IOException
+  public final InputStream openStream() throws IOException
   {
     return openConnection().getInputStream();
   }
@@ -668,9 +670,9 @@
    *
    * @return true if URL matches this URL's file, false otherwise
    */
-  public boolean sameFile(URL url)
+  public boolean sameFile(URL other)
   {
-    return ph.sameFile(this, url);
+    return ph.sameFile(this, other);
   }
 
   /**
@@ -686,7 +688,7 @@
    * @param ref The anchor portion of this URL.
    */
   protected void set(String protocol, String host, int port, String file,
-                     String ref)
+		     String ref)
   {
     // TBD: Theoretically, a poorly written StreamHandler could pass an
     // invalid protocol.  It will cause the handler to be set to null
@@ -699,7 +701,7 @@
     this.host = host;
     this.file = file;
     this.ref = ref;
-    hashCode = hashCode(); // Used for serialization.
+    hashCode = hashCode();			// Used for serialization.
   }
 
   /**
@@ -718,8 +720,9 @@
    *
    * @since 1.3
    */
-  protected void set(String protocol, String host, int port, String authority,
-                     String userInfo, String path, String query, String ref)
+  protected void set(String protocol, String host, int port,
+		     String authority, String userInfo,
+		     String path, String query, String ref)
   {
     // TBD: Theoretically, a poorly written StreamHandler could pass an
     // invalid protocol.  It will cause the handler to be set to null
@@ -737,7 +740,7 @@
     else
       this.file = path + "?" + query;
     this.ref = ref;
-    hashCode = hashCode(); // Used for serialization.
+    hashCode = hashCode();			// Used for serialization.
   }
 
   /**
@@ -751,7 +754,8 @@
    * @exception SecurityException If a security manager exists and its
    * checkSetFactory method doesn't allow the operation
    */
-  public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)
+  public static synchronized void
+	setURLStreamHandlerFactory(URLStreamHandlerFactory fac)
   {
     if (factory != null)
       throw new Error("URLStreamHandlerFactory already set");
@@ -778,7 +782,7 @@
 
   /**
    * Returns a String representing this URL.  Identical to toExternalForm().
-   * The value returned is created by the protocol handler's
+   * The value returned is created by the protocol handler's 
    * toExternalForm method.  Overrides Object.toString()
    *
    * @return A string for this URL
@@ -797,20 +801,41 @@
    *
    * @return A URLStreamHandler for this protocol, or null when not found.
    */
-  private static synchronized URLStreamHandler getURLStreamHandler(String protocol)
+  private static synchronized URLStreamHandler
+    getURLStreamHandler (String protocol)
   {
     URLStreamHandler ph = null;
 
     // First, see if a protocol handler is in our cache.
     if (cache_handlers)
       {
-	if ((ph = (URLStreamHandler) ph_cache.get(protocol)) != null)
-	  return ph;
+        if ((ph = (URLStreamHandler) ph_cache.get (protocol)) != null)
+          return ph;
       }
 
     // If a non-default factory has been set, use it to find the protocol.
     if (factory != null)
-      ph = factory.createURLStreamHandler(protocol);
+      {
+	ph = factory.createURLStreamHandler (protocol);
+      }
+    else if (protocol.equals ("core"))
+      {
+ 	ph = new gnu.java.net.protocol.core.Handler();
+      }
+    else if (protocol.equals ("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.java.net.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.java.net.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
@@ -825,41 +850,42 @@
 
 	// Tack our default package on at the ends.
 	if (ph_search_path != null)
-	  ph_search_path += "|" + DEFAULT_SEARCH_PATH;
+          ph_search_path += "|" + DEFAULT_SEARCH_PATH;
 	else
-	  ph_search_path = DEFAULT_SEARCH_PATH;
+          ph_search_path = DEFAULT_SEARCH_PATH;
 
 	// Finally loop through our search path looking for a match.
-	StringTokenizer pkgPrefix = new StringTokenizer(ph_search_path, "|");
-
+	StringTokenizer pkgPrefix = new StringTokenizer (ph_search_path, "|");
+        
 	do
-	  {
-	    String clsName =
-	      (pkgPrefix.nextToken() + "." + protocol + ".Handler");
-
-	    try
-	      {
-		Object obj = Class.forName(clsName).newInstance();
-
-		if (! (obj instanceof URLStreamHandler))
-		  continue;
-		else
-		  ph = (URLStreamHandler) obj;
-	      }
-	    catch (Exception e)
-	      {
-		// Can't instantiate; handler still null,
+          {
+            String clsName = (pkgPrefix.nextToken() + "."
+			      + protocol + ".Handler");
+         
+            try
+              {
+                Object obj = Class.forName (clsName).newInstance();
+	    
+                if (!(obj instanceof URLStreamHandler))
+                  continue;
+                else
+                  ph = (URLStreamHandler) obj;
+              }
+            catch (Exception e)
+              {
+                // Can't instantiate; handler still null,
 		// go on to next element.
-	      }
-	  }
-	 while ((! (ph instanceof URLStreamHandler))
-	        && pkgPrefix.hasMoreTokens());
+              }
+          }
+	while ((! (ph instanceof URLStreamHandler))
+               && pkgPrefix.hasMoreTokens());
       }
 
     // Update the hashtable with the new protocol handler.
-    if (ph != null && cache_handlers)
+    if (ph != null
+        && cache_handlers)
       if (ph instanceof URLStreamHandler)
-	ph_cache.put(protocol, ph);
+	ph_cache.put (protocol, ph);
       else
 	ph = null;
 
