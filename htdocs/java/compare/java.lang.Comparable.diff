--- /home/tromey/gnu/classpath/classpath/java/lang/Comparable.java	Wed Mar 20 17:01:40 2002
+++ java/lang/Comparable.java	Tue Jan 22 16:01:34 2002
@@ -1,5 +1,5 @@
 /* Comparable.java -- Interface for comparaing objects to obtain an ordering
-   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -38,60 +38,32 @@
 
 package java.lang;
 
-/**
- * Interface for objects that can be ordering among other objects. The
- * ordering can be <em>total</em>, such that two objects only compare equal
- * if they are also equal by the equals method, or <em>partial</em> such
- * that this is not necessarily true. For example, a case-sensitive
- * dictionary order comparison of Strings is total, but if it is
- * case-insensitive it is partial, because "abc" and "ABC" compare as
- * equal even though "abc".equals("ABC") returns false. However, if you use
- * a partial ordering, it is a good idea to document your class as
- * "inconsistent with equals", because the behavior of your class in a
- * SortedMap will be different than in a HashMap.
- *
- * <p>Lists, arrays, and sets of objects that implement this interface can
- * be sorted automatically, without the need for an explicit
- * {@link Comparator}. Note that <code>e1.compareTo(null)</code> should
- * throw an Exception; as should comparison between incompatible classes.
+/* Written using online API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status:  Believed complete and correct.
+ */
+
+/** 
+ * Interface for objects that can be ordering among other
+ * objects. The ordering can be <EM>total</EM>, such that two objects
+ * only compare equal if they are equal by the equals method, or
+ * <EM>partial</EM> such that this is not necessarily true. For
+ * example, a case-sensitive dictionary order comparison of Strings
+ * is total, but if it is case-insensitive it is partial, because
+ * "abc" and "ABC" compare as equal even though "abc".equals("ABC")
+ * returns false.
  *
  * @author Geoff Berry
  * @author Warren Levy <warrenl@cygnus.com>
- * @see Comparator
- * @see Collections#sort(List)
- * @see Arrays#sort(Object[])
- * @see SortedSet
- * @see SortedMap
- * @see TreeSet
- * @see TreeMap
- * @since 1.2
- * @status updated to 1.4
+ *
+ * @since JDK1.2
+ * @see java.util.Comparator
  */
 public interface Comparable
 {
   /**
-   * Compares this object with another, and returns a numerical result based
-   * on the comparison.  If the result is negative, this object sorts less
-   * than the other; if 0, the two are equal, and if positive, this object
-   * sorts greater than the other.  To translate this into boolean, simply
-   * perform <code>o1.compareTo(o2) <em>&lt;op&gt;</em> 0</code>, where op
-   * is one of &lt;, &lt;=, =, !=, &gt;, or &gt;=.
-   *
-   * <p>You must make sure that the comparison is mutual, ie.
-   * <code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code> (where sgn() is
-   * defined as -1, 0, or 1 based on the sign).  This includes throwing an
-   * exception in either direction if the two are not comparable; hence,
-   * <code>compareTo(null)</code> should always throw an Exception.
-   *
-   * <p>You should also ensure transitivity, in two forms:
-   * <code>x.compareTo(y) &gt; 0 && y.compareTo(z) &gt; 0</code> implies
-   * <code>x.compareTo(z) &gt; 0</code>; and <code>x.compareTo(y) == 0</code>
-   * implies <code>x.compareTo(z) == y.compareTo(z)</code>.
-   *
-   * @param o the object to be compared
-   * @return an integer describing the comparison
-   * @throws NullPointerException if o is null
-   * @throws ClassCastException if o cannot be compared
+   * @return a negative integer if this object is less than
+   * <code>o<code>, zero if this object is equal to <code>o</code>, or
+   * a positive integer if this object is greater than <code>o</code>
    */
-  int compareTo(Object o);
+  int compareTo( Object o );
 }
