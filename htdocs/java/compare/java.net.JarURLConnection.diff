--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/JarURLConnection.java	2003-09-22 02:19:32.000000000 -0600
+++ java/net/JarURLConnection.java	2003-09-22 02:18:35.000000000 -0600
@@ -38,11 +38,19 @@
 
 package java.net;
 
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
 import java.io.IOException;
 import java.util.jar.Attributes;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
 import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.Map;
+import java.util.Vector;
+import java.util.Hashtable;
 import java.security.cert.Certificate;
 
 /**
@@ -72,17 +80,19 @@
  */
 public abstract class JarURLConnection extends URLConnection
 {
-  /**
-   * This is the actual URL that points the remote jar file.  This is parsed
-   * out of the jar URL by the constructor.
-   */
-  private URL jarFileURL;
+  // three different ways to say the same thing
+  private final URL jarFileURL;
 
-  /**
-   * This is the jar file "entry name" or portion after the "!/" in the
-   * URL which represents the pathname inside the actual jar file
-   */
-  private String entry_name;
+  /** The connection to the jar file itself. A JarURLConnection
+   *  can represent an entry in a jar file or an entire jar file.  In
+   *  either case this describes just the jar file itself. */
+  protected URLConnection jarFileURLConnection;
+
+  // If this is a connection to a jar file element this is set, otherwise null.
+  private final String element;
+
+  // Cached JarURLConnection's 
+  static Hashtable conn_cache = new Hashtable();
 
   /**
    * Creates a JarURLConnection from an URL object
@@ -93,16 +103,12 @@
    *
    * @specnote This constructor is protected since JDK 1.4
    */
-  protected JarURLConnection(URL url)
+  protected JarURLConnection (URL url)
     throws MalformedURLException
   {
-    super(url);
-
-    if (!url.getProtocol().equals ("jar"))
-      throw new MalformedURLException (url + ": Not jar protocol.");
+    super (url);
 
     String spec = url.getFile();
-
     int bang = spec.indexOf ("!/");
     if (bang == -1)
       throw new MalformedURLException (url + ": No `!/' in spec.");
@@ -111,7 +117,7 @@
     jarFileURL = new URL (spec.substring (0, bang));
 
     // Get the name of the element, if any.
-    entry_name = spec.length() == (bang + 1) ? "" : spec.substring (bang + 2);
+    element = (spec.length() == (bang + 2) ? null : spec.substring (bang + 2));
   }
 
   /**
@@ -134,7 +140,97 @@
    */
   public String getEntryName ()
   {
-    return entry_name;
+    return element;
+  }
+
+  public synchronized void connect() throws IOException
+  {
+    // Call is ignored if already connected.
+    if (connected)
+      return;
+
+    if (getUseCaches())
+      {
+	jarFileURLConnection = (URLConnection) conn_cache.get (jarFileURL);
+
+	if (jarFileURLConnection == null)
+	  {
+	    jarFileURLConnection = jarFileURL.openConnection ();
+	    jarFileURLConnection.setUseCaches (true);
+	    jarFileURLConnection.connect ();
+	    conn_cache.put (jarFileURL, jarFileURLConnection);
+	  }
+      }
+    else
+      {
+	jarFileURLConnection = jarFileURL.openConnection ();
+	jarFileURLConnection.connect ();
+      }
+
+    connected = true;
+  }
+
+  public InputStream getInputStream() throws IOException
+  {
+    if (!connected)
+      connect();
+
+    if (! doInput)
+      throw new ProtocolException("Can't open InputStream if doInput is false");
+
+    if (element == null)
+      {
+	// This is a JarURLConnection for the entire jar file.  
+
+	InputStream jar_is = new BufferedInputStream(
+			jarFileURLConnection.getInputStream ());
+	return new JarInputStream(jar_is);
+      }
+
+    // Reaching this point, we're looking for an element of a jar file.
+
+    JarFile jarfile = null;
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (java.io.IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile != null)
+      {
+	// this is the easy way...
+	ZipEntry entry = jarfile.getEntry(element);
+	if (entry != null)
+	  return jarfile.getInputStream (entry);
+	else
+	  return null;
+      }
+    else
+      {
+	// If the jar file is not local, ...
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		int size = (int)ent.getSize();
+		byte[] data = new byte[size];
+		zis.read (data, 0, size);
+		return new ByteArrayInputStream (data);
+	      }
+	  }
+      }
+
+    return null;
   }
 
   /**
@@ -146,9 +242,46 @@
    */
   public JarEntry getJarEntry () throws IOException
   {
-    JarFile file = getJarFile();
+    JarFile jarfile = null;
+
+    if (element == null)
+      return null;
 
-    return file != null ? file.getJarEntry (entry_name) : null;
+    if (! doInput)
+      throw new ProtocolException("Can't open JarEntry if doInput is false");
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile == null)
+      {
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search for the thing...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		return new JarEntry (ent);
+	      }
+	  }
+      }
+
+    else
+      {
+	return jarfile.getJarEntry (element);
+      }
+
+    return null;
   }
 
   /**
@@ -160,6 +293,131 @@
    */
   public abstract JarFile getJarFile () throws IOException;
 
+  // Steal and borrow from protocol/file/Connection.java
+
+  private Hashtable hdrHash = new Hashtable();
+  private Vector hdrVec = new Vector();
+  private boolean gotHeaders = false;
+
+  // Override default method in URLConnection.
+  public String getHeaderField(String name)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    return (String) hdrHash.get(name.toLowerCase());
+  }
+
+  // Override default method in URLConnection.
+  public Map getHeaderFields()
+  {
+    try
+      {
+        getHeaders();
+      }
+    catch (IOException x)
+      {
+        return null;
+      }
+    return hdrHash;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderField(int n)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getField((String) hdrVec.elementAt(n));
+
+    return null;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderFieldKey(int n)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getKey((String) hdrVec.elementAt(n));
+
+    return null;
+  }
+
+  private String getKey(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(0, index);
+    else
+      return null;
+  }
+
+  private String getField(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(index + 1).trim();
+    else
+      return str;
+  }
+
+  private void getHeaders() throws IOException
+  {
+    if (gotHeaders)
+      return;
+    gotHeaders = true;
+
+    connect();
+
+    // Yes, it is overkill to use the hash table and vector here since
+    // we're only putting one header in the file, but in case we need
+    // to add others later and for consistency, we'll implement it this way.
+
+    // Add the only header we know about right now:  Content-length.
+    long len = -1;
+
+    if (element == null)
+      if (jarFileURLConnection != null)
+	len = jarFileURLConnection.getContentLength ();
+    else
+      {
+	JarEntry entry = getJarEntry();
+	if (entry != null)
+	  len = entry.getSize ();
+      }
+
+    String line = "Content-length: " + len;
+    hdrVec.addElement(line);
+
+    // The key will never be null in this scenario since we build up the
+    // headers ourselves.  If we ever rely on getting a header from somewhere
+    // else, then we may have to check if the result of getKey() is null.
+    String key = getKey(line);
+    hdrHash.put(key.toLowerCase(), Long.toString(len));
+  }
+
   /**
    * Returns an array of Certificate objects for the jar file entry specified
    * by this URL or null if there are none
@@ -170,7 +428,9 @@
    */
   public Certificate[] getCertificates () throws IOException
   {
-    return getJarEntry ().getCertificates ();
+    JarEntry entry = getJarEntry();
+    
+    return entry != null ? entry.getCertificates() : null;
   }
 
   /**
@@ -183,7 +443,9 @@
    */
   public Attributes getMainAttributes () throws IOException
   {
-    return getManifest ().getMainAttributes ();
+    Manifest manifest = getManifest();
+    
+    return manifest != null ? manifest.getMainAttributes() : null;
   }
 
   /**
@@ -198,7 +460,7 @@
   public Attributes getAttributes () throws IOException
   {
     JarEntry entry = getJarEntry();
-    
+
     return entry != null ? entry.getAttributes() : null;
   }
 
