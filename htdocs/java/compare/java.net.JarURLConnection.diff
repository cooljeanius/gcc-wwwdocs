--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/JarURLConnection.java	2003-05-10 02:20:36.000000000 -0600
+++ java/net/JarURLConnection.java	2003-05-09 02:27:01.000000000 -0600
@@ -38,11 +38,19 @@
 
 package java.net;
 
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
 import java.io.IOException;
 import java.util.jar.Attributes;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
 import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.Map;
+import java.util.Vector;
+import java.util.Hashtable;
 import java.security.cert.Certificate;
 
 /**
@@ -72,22 +80,19 @@
  */
 public abstract class JarURLConnection extends URLConnection
 {
-  /**
-   * This is the actual URL that points the remote jar file.  This is parsed
-   * out of the jar URL by the constructor.
-   */
-  private URL real_url;
+  // three different ways to say the same thing
+  private final URL jarFileURL;
 
-  /**
-   * This is the jar file "entry name" or portion after the "!/" in the
-   * URL which represents the pathname inside the actual jar file
-   */
-  private String entry_name;
+  /** The connection to the jar file itself. A JarURLConnection
+   *  can represent an entry in a jar file or an entire jar file.  In
+   *  either case this describes just the jar file itself. */
+  protected URLConnection jarFileURLConnection;
 
-  /**
-   * The JarFile object for the jar file pointed to by the real URL
-   */
-  private JarFile jar_file;
+  // If this is a connection to a jar file element this is set, otherwise null.
+  private final String element;
+
+  // Cached JarURLConnection's 
+  static Hashtable conn_cache = new Hashtable();
 
   /**
    * Creates a JarURLConnection from an URL object
@@ -103,23 +108,16 @@
   {
     super(url);
 
-    // Now, strip off the "jar:" and everything from the "!/" to the end
-    // to get the "real" URL inside
-    String url_string = url.toExternalForm();
+    String spec = url.getFile();
+    int bang = spec.indexOf ("!/", 0);
+    if (bang == -1)
+      throw new MalformedURLException (url + ": No `!/' in spec.");
 
-    if (!url_string.startsWith("jar:"))
-      throw new MalformedURLException(url_string);
+    // Extact the url for the jar itself.
+    jarFileURL = new URL(spec.substring (0, bang));
 
-    if (url_string.indexOf("!/") == -1)
-      throw new MalformedURLException(url_string);
-
-    String real_url_string = url_string.substring(4, url_string.indexOf("!/"));
-
-    real_url = new URL(real_url_string);
-    if (url_string.length() == (url_string.indexOf("!/") + 1))
-      entry_name = "";
-    else
-      entry_name = url_string.substring(url_string.indexOf("!/") + 2);
+    // Get the name of the element, if any.
+    element = (bang+2==spec.length() ? null : spec.substring (bang+2));
   }
 
   /**
@@ -130,7 +128,7 @@
    */
   public URL getJarFileURL ()
   {
-    return real_url;
+    return jarFileURL;
   }
 
   /**
@@ -142,7 +140,97 @@
    */
   public String getEntryName ()
   {
-    return entry_name;
+    return element;
+  }
+
+  public synchronized void connect() throws IOException
+  {
+    // Call is ignored if already connected.
+    if (connected)
+      return;
+
+    if (getUseCaches())
+      {
+	jarFileURLConnection = (URLConnection) conn_cache.get (jarFileURL);
+
+	if (jarFileURLConnection == null)
+	  {
+	    jarFileURLConnection = jarFileURL.openConnection ();
+	    jarFileURLConnection.setUseCaches (true);
+	    jarFileURLConnection.connect ();
+	    conn_cache.put (jarFileURL, jarFileURLConnection);
+	  }
+      }
+    else
+      {
+	jarFileURLConnection = jarFileURL.openConnection ();
+	jarFileURLConnection.connect ();
+      }
+
+    connected = true;
+  }
+
+  public InputStream getInputStream() throws IOException
+  {
+    if (!connected)
+      connect();
+
+    if (! doInput)
+      throw new ProtocolException("Can't open InputStream if doInput is false");
+
+    if (element == null)
+      {
+	// This is a JarURLConnection for the entire jar file.  
+
+	InputStream jar_is = new BufferedInputStream(
+			jarFileURLConnection.getInputStream ());
+	return new JarInputStream(jar_is);
+      }
+
+    // Reaching this point, we're looking for an element of a jar file.
+
+    JarFile jarfile = null;
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (java.io.IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile != null)
+      {
+	// this is the easy way...
+	ZipEntry entry = jarfile.getEntry(element);
+	if (entry != null)
+	  return jarfile.getInputStream (entry);
+	else
+	  return null;
+      }
+    else
+      {
+	// If the jar file is not local, ...
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		int size = (int)ent.getSize();
+		byte[] data = new byte[size];
+		zis.read (data, 0, size);
+		return new ByteArrayInputStream (data);
+	      }
+	  }
+      }
+
+    return null;
   }
 
   /**
@@ -154,10 +242,46 @@
    */
   public JarEntry getJarEntry () throws IOException
   {
-    if (jar_file == null)
-      jar_file = getJarFile();
+    JarFile jarfile = null;
+
+    if (element == null)
+      return null;
+
+    if (! doInput)
+      throw new ProtocolException("Can't open JarEntry if doInput is false");
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile == null)
+      {
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search for the thing...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		return new JarEntry (ent);
+	      }
+	  }
+      }
 
-    return jar_file.getJarEntry(entry_name);
+    else
+      {
+	return jarfile.getJarEntry (element);
+      }
+
+    return null;
   }
 
   /**
@@ -169,6 +293,131 @@
    */
   public abstract JarFile getJarFile () throws IOException;
 
+  // Steal and borrow from protocol/file/Connection.java
+
+  private Hashtable hdrHash = new Hashtable();
+  private Vector hdrVec = new Vector();
+  private boolean gotHeaders = false;
+
+  // Override default method in URLConnection.
+  public String getHeaderField(String name)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    return (String) hdrHash.get(name.toLowerCase());
+  }
+
+  // Override default method in URLConnection.
+  public Map getHeaderFields()
+  {
+    try
+      {
+        getHeaders();
+      }
+    catch (IOException x)
+      {
+        return null;
+      }
+    return hdrHash;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderField(int n)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getField((String) hdrVec.elementAt(n));
+
+    return null;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderFieldKey(int n)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getKey((String) hdrVec.elementAt(n));
+
+    return null;
+  }
+
+  private String getKey(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(0, index);
+    else
+      return null;
+  }
+
+  private String getField(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(index + 1).trim();
+    else
+      return str;
+  }
+
+  private void getHeaders() throws IOException
+  {
+    if (gotHeaders)
+      return;
+    gotHeaders = true;
+
+    connect();
+
+    // Yes, it is overkill to use the hash table and vector here since
+    // we're only putting one header in the file, but in case we need
+    // to add others later and for consistency, we'll implement it this way.
+
+    // Add the only header we know about right now:  Content-length.
+    long len = -1;
+
+    if (element == null)
+      if (jarFileURLConnection != null)
+	len = jarFileURLConnection.getContentLength ();
+    else
+      {
+	JarEntry entry = getJarEntry();
+	if (entry != null)
+	  len = entry.getSize ();
+      }
+
+    String line = "Content-length: " + len;
+    hdrVec.addElement(line);
+
+    // The key will never be null in this scenario since we build up the
+    // headers ourselves.  If we ever rely on getting a header from somewhere
+    // else, then we may have to check if the result of getKey() is null.
+    String key = getKey(line);
+    hdrHash.put(key.toLowerCase(), Long.toString(len));
+  }
+
   /**
    * Returns an array of Certificate objects for the jar file entry specified
    * by this URL or null if there are none
@@ -206,7 +455,8 @@
    */
   public Attributes getAttributes () throws IOException
   {
-    return getJarEntry().getAttributes();
+    // FIXME: implement this
+    return null;
   }
 
   /**
@@ -219,9 +469,8 @@
    */
   public Manifest getManifest () throws IOException
   {
-    if (jar_file == null)
-      jar_file = getJarFile();
+    JarFile file = getJarFile ();
 
-    return jar_file.getManifest();
+    return (file != null) ? file.getManifest() : null;
   }
 }
