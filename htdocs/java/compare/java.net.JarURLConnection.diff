--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/JarURLConnection.java	2003-03-23 02:18:39.000000000 -0700
+++ java/net/JarURLConnection.java	2003-03-23 02:18:02.000000000 -0700
@@ -38,57 +38,50 @@
 
 package java.net;
 
-import java.io.IOException;
-import java.security.cert.Certificate;
+import java.net.*;
+import java.io.*;
 import java.util.jar.*;
+import java.util.zip.*;
+import java.util.Map;
+import java.util.Vector;
+import java.util.Hashtable;
+import java.security.cert.Certificate;
 
 /**
- * This abstract class represents a common superclass for implementations
- * of jar URL's.  A jar URL is a special type of URL that allows JAR
- * files on remote systems to be accessed.  It has the form:
- * <p>
- * jar:<standard URL pointing to jar file>!/file/within/jarfile
- * <p> for example:
- * <p>
- * jar:http://www.urbanophile.com/java/foo.jar!/com/urbanophile/bar.class
- * <p>
- * That example URL points to the file /com/urbanophile/bar.class in the
- * remote JAR file http://www.urbanophile.com/java/foo.jar.  The HTTP
- * protocol is used only as an example.  Any supported remote protocol
- * can be used.
- * <p>
- * This class currently works by retrieving the entire jar file into a
- * local cache file, then performing standard jar operations on it.
- * (At least this is true for the default protocol implementation).
- *
- * @author Aaron M. Renn <arenn@urbanophile.com>
  * @author Kresten Krab Thorup <krab@gnu.org>
- *
  * @since 1.2
+ * @date Aug 10, 1999.
  */
+
+
 public abstract class JarURLConnection extends URLConnection
 {
-  /**
-   * This is the actual URL that points the remote jar file.  This is parsed
-   * out of the jar URL by the constructor.
-   */
-  private URL real_url;
+  // three different ways to say the same thing
+  private final URL jarFileURL;
 
-  /**
-   * This is the jar file "entry name" or portion after the "!/" in the
-   * URL which represents the pathname inside the actual jar file
-   */
-  private String entry_name;
+  /** The connection to the jar file itself. A JarURLConnection
+   *  can represent an entry in a jar file or an entire jar file.  In
+   *  either case this describes just the jar file itself. */
+  protected URLConnection jarFileURLConnection;
 
-  /**
-   * The JarFile object for the jar file pointed to by the real URL
-   */
-  private JarFile jar_file;
+  // If this is a connection to a jar file element this is set, otherwise null.
+  private final String element;
+
+  // Cached JarURLConnection's 
+  static Hashtable conn_cache = new Hashtable();
+
+  public URL getJarFileURL ()
+  {
+    return jarFileURL;
+  }
+
+  public String getEntryName ()
+  {
+    return element;
+  }
 
   /**
-   * Creates a JarURLConnection from a URL objects
-   *
-   * @param URL url The URL object for this connection.
+   * Creates a new JarURLConnection
    *
    * @exception MalformedURLException If url is invalid
    *
@@ -99,70 +92,288 @@
   {
     super(url);
 
-    // Now, strip off the "jar:" and everything from the "!/" to the end
-    // to get the "real" URL inside
-    String url_string = url.toExternalForm();
-
-    if (!url_string.startsWith("jar:"))
-      throw new MalformedURLException(url_string);
+    String spec = url.getFile();
+    int bang = spec.indexOf ("!/", 0);
+    if (bang == -1)
+      throw new MalformedURLException (url + ": No `!/' in spec.");
 
-    if (url_string.indexOf("!/") == -1)
-      throw new MalformedURLException(url_string);
+    // Extact the url for the jar itself.
+    jarFileURL = new URL(spec.substring (0, bang));
 
-    String real_url_string = url_string.substring(4, url_string.indexOf("!/"));
+    // Get the name of the element, if any.
+    element = (bang+2==spec.length() ? null : spec.substring (bang+2));
+  }
 
-    real_url = new URL(real_url_string);
-    if (url_string.length() == (url_string.indexOf("!/") + 1))
-      entry_name = "";
+  public synchronized void connect() throws IOException
+  {
+    // Call is ignored if already connected.
+    if (connected)
+      return;
+
+    if (getUseCaches())
+      {
+	jarFileURLConnection = (URLConnection) conn_cache.get (jarFileURL);
+
+	if (jarFileURLConnection == null)
+	  {
+	    jarFileURLConnection = jarFileURL.openConnection ();
+	    jarFileURLConnection.setUseCaches (true);
+	    jarFileURLConnection.connect ();
+	    conn_cache.put (jarFileURL, jarFileURLConnection);
+	  }
+      }
     else
-      entry_name = url_string.substring(url_string.indexOf("!/") + 2);
+      {
+	jarFileURLConnection = jarFileURL.openConnection ();
+	jarFileURLConnection.connect ();
+      }
+
+    connected = true;
   }
 
-  /**
-   * This method returns the "real" URL where the JarFile is located.
-   * //****Is this right?*****
-   *
-   * @return The remote URL
-   */ 
-  public URL getJarFileURL()
+  public InputStream getInputStream() throws IOException
   {
-    return(real_url);
+    if (!connected)
+      connect();
+
+    if (! doInput)
+      throw new ProtocolException("Can't open InputStream if doInput is false");
+
+    if (element == null)
+      {
+	// This is a JarURLConnection for the entire jar file.  
+
+	InputStream jar_is = new BufferedInputStream(
+			jarFileURLConnection.getInputStream ());
+	return new JarInputStream(jar_is);
+      }
+
+    // Reaching this point, we're looking for an element of a jar file.
+
+    JarFile jarfile = null;
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (java.io.IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile != null)
+      {
+	// this is the easy way...
+	ZipEntry entry = jarfile.getEntry(element);
+	if (entry != null)
+	  return jarfile.getInputStream (entry);
+	else
+	  return null;
+      }
+    else
+      {
+	// If the jar file is not local, ...
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		int size = (int)ent.getSize();
+		byte[] data = new byte[size];
+		zis.read (data, 0, size);
+		return new ByteArrayInputStream (data);
+	      }
+	  }
+      }
+
+    return null;
   }
 
   /**
-   * Returns the "entry name" portion of the jar URL.  This is the portion
-   * after the "!/" in the jar URL that represents the pathname inside the
-   * actual jar file.
+   * Return the JAR entry object for this connection, if any
    *
-   * @return The entry name.
+   * @exception IOException If an error occurs
    */
-  public String getEntryName()
+  public JarEntry getJarEntry () throws IOException
   {
-    return(entry_name);
+    JarFile jarfile = null;
+
+    if (element == null)
+      return null;
+
+    if (! doInput)
+      throw new ProtocolException("Can't open JarEntry if doInput is false");
+
+    try
+      {
+	jarfile = getJarFile ();
+      }
+    catch (IOException x)
+      {
+	/* ignore */
+      }
+    
+    if (jarfile == null)
+      {
+	JarInputStream zis = new JarInputStream(
+			jarFileURLConnection.getInputStream ());
+
+	// This is hideous, we're doing a linear search for the thing...
+	for (ZipEntry ent = zis.getNextEntry (); 
+	     ent != null; 
+	     ent = zis.getNextEntry ())
+	  {
+	    if (element.equals (ent.getName ()))
+	      {
+		return new JarEntry (ent);
+	      }
+	  }
+      }
+
+    else
+      {
+	return jarfile.getJarEntry (element);
+      }
+
+    return null;
   }
 
   /**
-   * Returns a read-only JarFile object for the remote jar file
-   *
-   * @return The JarFile object
+   * Return the JAR file for this connection
    *
    * @exception IOException If an error occurs
    */
   public abstract JarFile getJarFile() throws IOException;
 
-  /**
-   * Returns the entry in this jar file specified by the URL.  
-   * 
-   * @return The jar entry
-   *
-   * @exception IOException If an error occurs
-   */
-  public JarEntry getJarEntry() throws IOException
+
+  // Steal and borrow from protocol/file/Connection.java
+
+  private Hashtable hdrHash = new Hashtable();
+  private Vector hdrVec = new Vector();
+  private boolean gotHeaders = false;
+
+  // Override default method in URLConnection.
+  public String getHeaderField(String name)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    return (String) hdrHash.get(name.toLowerCase());
+  }
+
+  // Override default method in URLConnection.
+  public Map getHeaderFields()
+  {
+    try
+      {
+        getHeaders();
+      }
+    catch (IOException x)
+      {
+        return null;
+      }
+    return hdrHash;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderField(int n)
+  {
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getField((String) hdrVec.elementAt(n));
+
+    return null;
+  }
+
+  // Override default method in URLConnection.
+  public String getHeaderFieldKey(int n)
   {
-    if (jar_file == null)
-      jar_file = getJarFile();
+    try
+      {
+	getHeaders();
+      }
+    catch (IOException x)
+      {
+	return null;
+      }
+    if (n < hdrVec.size())
+      return getKey((String) hdrVec.elementAt(n));
 
-    return jar_file.getJarEntry(entry_name);
+    return null;
+  }
+
+  private String getKey(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(0, index);
+    else
+      return null;
+  }
+
+  private String getField(String str)
+  {
+    if (str == null)
+      return null;
+    int index = str.indexOf(':');
+    if (index >= 0)
+      return str.substring(index + 1).trim();
+    else
+      return str;
+  }
+
+  private void getHeaders() throws IOException
+  {
+    if (gotHeaders)
+      return;
+    gotHeaders = true;
+
+    connect();
+
+    // Yes, it is overkill to use the hash table and vector here since
+    // we're only putting one header in the file, but in case we need
+    // to add others later and for consistency, we'll implement it this way.
+
+    // Add the only header we know about right now:  Content-length.
+    long len = -1;
+
+    if (element == null)
+      if (jarFileURLConnection != null)
+	len = jarFileURLConnection.getContentLength ();
+    else
+      {
+	JarEntry entry = getJarEntry();
+	if (entry != null)
+	  len = entry.getSize ();
+      }
+
+    String line = "Content-length: " + len;
+    hdrVec.addElement(line);
+
+    // The key will never be null in this scenario since we build up the
+    // headers ourselves.  If we ever rely on getting a header from somewhere
+    // else, then we may have to check if the result of getKey() is null.
+    String key = getKey(line);
+    hdrHash.put(key.toLowerCase(), Long.toString(len));
   }
 
   /**
@@ -173,16 +384,13 @@
    *
    * @exception IOException If an error occurs
    */
-  public Certificate[] getCertificates () throws IOException
+  public Certificate[] getCertificates() throws IOException
   {
-    return getJarEntry ().getCertificates ();
+    return getJarEntry().getCertificates();
   }
 
   /**
-   * Returns the main Attributes for the jar file specified in the URL or
-   * null if there are none
-   *
-   * @return The main Attributes
+   * Returns the main Attributes for the JAR file for this connection
    *
    * @exception IOException If an error occurs
    */
@@ -192,31 +400,26 @@
   }
 
   /**
-   * Returns the Attributes for the Jar entry specified by the URL or null
-   * if none
-   *
-   * @return The Attributes
+   * Return the Attributes object for this connection if the URL for it points
+   * to a JAR file entry, null otherwise
    *
    * @exception IOException If an error occurs
    */
   public Attributes getAttributes () throws IOException
   {
-    return getJarEntry().getAttributes();
+    // FIXME: implement this
+    return null;
   }
 
   /**
-   * Returns a Manifest object for this jar file, or null if there is no
-   * manifest.
-   *
-   * @return The Manifest
+   * Returns the Manifest for this connection, or null if none
    *
    * @exception IOException If an error occurs
    */
   public Manifest getManifest () throws IOException
   {
-    if (jar_file == null)
-      jar_file = getJarFile();
+    JarFile file = getJarFile ();
 
-    return jar_file.getManifest();
+    return (file != null) ? file.getManifest() : null;
   }
 }
