--- /home/tromey/gnu/Nightly/classpath/classpath/java/nio/ShortViewBufferImpl.java	2003-05-19 03:05:13.000000000 -0600
+++ java/nio/ShortViewBufferImpl.java	2004-02-09 02:18:24.000000000 -0700
@@ -1,5 +1,5 @@
 /* ShortViewBufferImpl.java -- 
-   Copyright (C) 2003 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -40,54 +40,47 @@
 
 class ShortViewBufferImpl extends ShortBuffer
 {
-  private boolean readOnly;
+  /** Position in bb (i.e. a byte offset) where this buffer starts. */
   private int offset;
   private ByteBuffer bb;
+  private boolean readOnly;
   private ByteOrder endian;
   
-  public ShortViewBufferImpl (ByteBuffer bb, boolean readOnly)
-  {
-    super (bb.remaining () >> 1, bb.remaining () >> 1, bb.position (), 0);
-    this.bb = bb;
-    this.readOnly = readOnly;
-    // FIXME: What if this is called from ShortByteBufferImpl and ByteBuffer has changed its endianess ?
-    this.endian = bb.order ();
-  }
-
   public ShortViewBufferImpl (ByteBuffer bb, int offset, int capacity,
-                               int limit, int position, int mark,
-                               boolean readOnly)
+			      int limit, int position, int mark,
+			      boolean readOnly, ByteOrder endian)
   {
     super (limit >> 1, limit >> 1, position >> 1, mark >> 1);
     this.bb = bb;
     this.offset = offset;
     this.readOnly = readOnly;
-    // FIXME: What if this is called from ShortViewBufferImpl and ByteBuffer has changed its endianess ?
-    this.endian = bb.order ();
+    this.endian = endian;
   }
 
   public short get ()
   {
-    short result = bb.getShort ((position () << 1) + offset);
-    position (position () + 1);
+    int p = position();
+    short result = ByteBufferHelper.getShort(bb, (p << 1) + offset, endian);
+    position(p + 1);
     return result;
   }
 
   public short get (int index)
   {
-    return bb.getShort ((index << 1) + offset);
+    return ByteBufferHelper.getShort(bb, (index << 1) + offset, endian);
   }
 
   public ShortBuffer put (short value)
   {
-    bb.putShort ((position () << 1) + offset, value);
-    position (position () + 1);
+    int p = position();
+    ByteBufferHelper.putShort(bb, (p << 1) + offset, value, endian);
+    position(p + 1);
     return this;
   }
   
   public ShortBuffer put (int index, short value)
   {
-    bb.putShort ((index << 1) + offset, value);
+    ByteBufferHelper.putShort(bb, (index << 1) + offset, value, endian);
     return this;
   }
 
@@ -95,48 +88,42 @@
   {
     if (position () > 0)
       {
-        // Copy all data from position() to limit() to the beginning of the
-        // buffer, set position to end of data and limit to capacity
-        // XXX: This can surely be optimized, for direct and non-direct buffers
-        
         int count = limit () - position ();
-              
-        for (int i = 0; i < count; i++)
-          {
-            bb.putShort ((i >> 1) + offset,
-                          bb.getShort (((i + position ()) >> 1) + offset));
-          }
-
+	bb.shiftDown(offset, offset + 2 * position(), 2 * count);
         position (count);
         limit (capacity ());
       }
-
     return this;
   }
   
-  public ShortBuffer duplicate ()
-  {
-    // Create a copy of this object that shares its content
-    // FIXME: mark is not correct
-    return new ShortViewBufferImpl (bb, offset, capacity (), limit (),
-                                     position (), -1, isReadOnly ());
-  }
-  
   public ShortBuffer slice ()
   {
     // Create a sliced copy of this object that shares its content.
     return new ShortViewBufferImpl (bb, (position () >> 1) + offset,
-                                      remaining (), remaining (), 0, -1,
-                                     isReadOnly ());
+				    remaining(), remaining(), 0, -1,
+				    readOnly, endian);
   }
   
-  public ShortBuffer asReadOnlyBuffer ()
+  ShortBuffer duplicate (boolean readOnly)
   {
-    // Create a copy of this object that shares its content and is read-only
-    return new ShortViewBufferImpl (bb, (position () >> 1) + offset,
-                                     remaining (), remaining (), 0, -1, true);
+    int pos = position();
+    reset();
+    int mark = position();
+    position(pos);
+    return new ShortViewBufferImpl (bb, offset, capacity(), limit(),
+				    pos, mark, readOnly, endian);
   }
   
+  public ShortBuffer duplicate ()
+  {
+    return duplicate(readOnly);
+  }
+
+  public ShortBuffer asReadOnlyBuffer ()
+  {
+    return duplicate(true);
+  }
+
   public boolean isReadOnly ()
   {
     return readOnly;
@@ -149,6 +136,6 @@
   
   public ByteOrder order ()
   {
-    return ByteOrder.LITTLE_ENDIAN;
+    return endian;
   }
 }
