--- /home/tromey/gnu/egcs/classpath/classpath/java/lang/Integer.java	Sat Mar  9 22:59:00 2002
+++ java/lang/Integer.java	Tue Jun  4 16:33:56 2002
@@ -1,5 +1,5 @@
-/* Integer.java -- object wrapper for int
-   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+/* java.lang.Integer
+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -48,45 +48,36 @@
  * @author Paul Fisher
  * @author John Keiser
  * @author Warren Levy
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.0
- * @status updated to 1.4
+ * @since JDK 1.0
  */
 public final class Integer extends Number implements Comparable
 {
-  /**
-   * Compatible with JDK 1.0.2+.
-   */
+  // compatible with JDK 1.0.2+
   private static final long serialVersionUID = 1360826667806852920L;
 
   /**
-   * The minimum value an <code>int</code> can represent is -2147483648 (or
-   * -2<sup>31</sup>).
+   * The minimum value an <code>int</code> can represent is -2147483648.
    */
   public static final int MIN_VALUE = 0x80000000;
 
   /**
-   * The maximum value an <code>int</code> can represent is 2147483647 (or
-   * 2<sup>31</sup> - 1).
+   * The maximum value an <code>int</code> can represent is 2147483647.
    */
   public static final int MAX_VALUE = 0x7fffffff;
 
   /**
-   * The primitive type <code>int</code> is represented by this
+   * The primitive type <code>int</code> is represented by this 
    * <code>Class</code> object.
-   * @since 1.1
    */
-  public static final Class TYPE = VMClassLoader.getPrimitiveClass('I');
+  public static final Class TYPE = VMClassLoader.getPrimitiveClass ('I');
 
   /**
    * The immutable value of this Integer.
-   *
-   * @serial the wrapped int
    */
   private final int value;
 
   /**
-   * Create an <code>Integer</code> object representing the value of the
+   * Create an <code>Integer</code> object representing the value of the 
    * <code>int</code> argument.
    *
    * @param value the value to use
@@ -97,70 +88,135 @@
   }
 
   /**
-   * Create an <code>Integer</code> object representing the value of the
+   * Create an <code>Integer</code> object representing the value of the 
    * argument after conversion to an <code>int</code>.
    *
-   * @param s the string to convert
-   * @throws NumberFormatException if the String does not contain an int
-   * @see #valueOf(String)
+   * @param s the string to convert.
    */
-  public Integer(String s)
+  public Integer(String s) throws NumberFormatException
   {
-    value = parseInt(s, 10, false);
+    value = parseInt(s, 10);
   }
 
   /**
-   * Converts the <code>int</code> to a <code>String</code> using
-   * the specified radix (base). If the radix exceeds
-   * <code>Character.MIN_RADIX</code> or <code>Character.MAX_RADIX</code>, 10
-   * is used instead. If the result is negative, the leading character is
-   * '-' ('\\u002D'). The remaining characters come from
-   * <code>Character.forDigit(digit, radix)</code> ('0'-'9','a'-'z').
+   * Return a hashcode representing this Object.
    *
-   * @param num the <code>int</code> to convert to <code>String</code>
-   * @param radix the radix (base) to use in the conversion
-   * @return the <code>String</code> representation of the argument
+   * <code>Integer</code>'s hash code is calculated by simply returning its
+   * value.
+   *
+   * @return this Object's hash code.
    */
-  public static String toString(int num, int radix)
+  public int hashCode()
   {
-    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
-      radix = 10;
+    return value;
+  }
 
-    // For negative numbers, print out the absolute value w/ a leading '-'.
-    // Use an array large enough for a binary number.
-    char[] buffer = new char[33];
-    int i = 33;
-    boolean isNeg = false;
-    if (num < 0)
-      {
-        isNeg = true;
-        num = -num;
+  /**
+   * If the <code>Object</code> is not <code>null</code>, is an
+   * <code>instanceof</code> <code>Integer</code>, and represents
+   * the same primitive <code>int</code> value return 
+   * <code>true</code>.  Otherwise <code>false</code> is returned.
+   */
+  public boolean equals(Object obj)
+  {
+    return obj instanceof Integer && value == ((Integer)obj).value;
+  }
 
-        // When the value is MIN_VALUE, it overflows when made positive
-        if (num < 0)
-          return "" + MIN_VALUE;
+  /**
+   * Get the specified system property as an <code>Integer</code>.
+   *
+   * The <code>decode()</code> method will be used to interpret the value of
+   * the property.
+   * @param nm the name of the system property
+   * @return the system property as an <code>Integer</code>, or
+   *         <code>null</code> if the property is not found or cannot be
+   *         decoded as an <code>Integer</code>.
+   * @see java.lang.System#getProperty(java.lang.String)
+   * @see #decode(int)
+   */
+  public static Integer getInteger(String nm)
+  {
+    return getInteger(nm, null);
+  }
+
+  /**
+   * Get the specified system property as an <code>Integer</code>, or use a
+   * default <code>int</code> value if the property is not found or is not
+   * decodable.
+   * 
+   * The <code>decode()</code> method will be used to interpret the value of
+   * the property.
+   *
+   * @param nm the name of the system property
+   * @param val the default value to use if the property is not found or not
+   *        a number.
+   * @return the system property as an <code>Integer</code>, or the default
+   *         value if the property is not found or cannot be decoded as an
+   *         <code>Integer</code>.
+   * @see java.lang.System#getProperty(java.lang.String)
+   * @see #decode(int)
+   * @see #getInteger(java.lang.String,java.lang.Integer)
+   */
+  public static Integer getInteger(String nm, int val)
+  {
+    Integer result = getInteger(nm, null);
+    return (result == null) ? new Integer(val) : result;
+  }
+
+  /**
+   * Get the specified system property as an <code>Integer</code>, or use a
+   * default <code>Integer</code> value if the property is not found or is
+   * not decodable.
+   * 
+   * The <code>decode()</code> method will be used to interpret the value of
+   * the property.
+   *
+   * @param nm the name of the system property
+   * @param val the default value to use if the property is not found or not
+   *        a number.
+   * @return the system property as an <code>Integer</code>, or the default
+   *         value if the property is not found or cannot be decoded as an
+   *         <code>Integer</code>.
+   * @see java.lang.System#getProperty(java.lang.String)
+   * @see #decode(int)
+   * @see #getInteger(java.lang.String,int)
+   */
+  public static Integer getInteger(String nm, Integer def)
+  {
+    String val = System.getProperty(nm);
+    if (val == null) return def;
+    try
+      {
+      return decode(val);
+      }
+    catch (NumberFormatException e)
+      {
+	return def;
       }
+  }
 
+  private static String toUnsignedString(int num, int exp)
+  {
+    // Use an array large enough for a binary number.
+    int radix = 1 << exp;
+    int mask = radix - 1;
+    char[] buffer = new char[32];
+    int i = 32;
     do
       {
-        buffer[--i] = digits[num % radix];
-        num /= radix;
+        buffer[--i] = Character.forDigit(num & mask, radix);
+        num = num >>> exp;
       }
-    while (num > 0);
-
-    if (isNeg)
-      buffer[--i] = '-';
+    while (num != 0);
 
-    // Package constructor avoids an array copy.
-    return new String(buffer, i, 33 - i, true);
+    return String.valueOf(buffer, i, 32-i);
   }
 
   /**
    * Converts the <code>int</code> to a <code>String</code> assuming it is
    * unsigned in base 16.
-   *
    * @param i the <code>int</code> to convert to <code>String</code>
-   * @return the <code>String</code> representation of the argument
+   * @return the <code>String</code> representation of the argument.
    */
   public static String toHexString(int i)
   {
@@ -170,9 +226,8 @@
   /**
    * Converts the <code>int</code> to a <code>String</code> assuming it is
    * unsigned in base 8.
-   *
    * @param i the <code>int</code> to convert to <code>String</code>
-   * @return the <code>String</code> representation of the argument
+   * @return the <code>String</code> representation of the argument.
    */
   public static String toOctalString(int i)
   {
@@ -182,9 +237,8 @@
   /**
    * Converts the <code>int</code> to a <code>String</code> assuming it is
    * unsigned in base 2.
-   *
    * @param i the <code>int</code> to convert to <code>String</code>
-   * @return the <code>String</code> representation of the argument
+   * @return the <code>String</code> representation of the argument.
    */
   public static String toBinaryString(int i)
   {
@@ -194,401 +248,335 @@
   /**
    * Converts the <code>int</code> to a <code>String</code> and assumes
    * a radix of 10.
-   *
    * @param i the <code>int</code> to convert to <code>String</code>
-   * @return the <code>String</code> representation of the argument
-   * @see #toString(int, int)
+   * @return the <code>String</code> representation of the argument.
    */
   public static String toString(int i)
   {
     // This is tricky: in libgcj, String.valueOf(int) is a fast native
     // implementation.  In Classpath it just calls back to
-    // Integer.toString(int, int).
-    return String.valueOf(i);
+    // Integer.toString(int,int).
+    return String.valueOf (i);
   }
 
   /**
-   * Converts the specified <code>String</code> into an <code>int</code>
-   * using the specified radix (base). The string must not be <code>null</code>
-   * or empty. It may begin with an optional '-', which will negate the answer,
-   * provided that there are also valid digits. Each digit is parsed as if by
-   * <code>Character.digit(d, radix)</code>, and must be in the range
-   * <code>0</code> to <code>radix - 1</code>. Finally, the result must be
-   * within <code>MIN_VALUE</code> to <code>MAX_VALUE</code>, inclusive.
-   * Unlike Double.parseDouble, you may not have a leading '+'.
-   *
-   * @param s the <code>String</code> to convert
-   * @param radix the radix (base) to use in the conversion
-   * @return the <code>String</code> argument converted to </code>int</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as an
-   *         <code>int</code>
-   */
-  public static int parseInt(String str, int radix)
+   * Converts the <code>Integer</code> value to a <code>String</code> and
+   * assumes a radix of 10.
+   * @return the <code>String</code> representation of this <code>Integer</code>.
+   */    
+  public String toString()
   {
-    return parseInt(str, radix, false);
+    return toString (value);
   }
 
   /**
-   * Converts the specified <code>String</code> into an <code>int</code>.
-   * This function assumes a radix of 10.
-   *
-   * @param s the <code>String</code> to convert
-   * @return the <code>int</code> value of <code>s</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as an
-   *         <code>int</code>
-   * @see #parseInt(String, int)
+   * Converts the <code>int</code> to a <code>String</code> using
+   * the specified radix (base).
+   * @param i the <code>int</code> to convert to <code>String</code>.
+   * @param radix the radix (base) to use in the conversion.
+   * @return the <code>String</code> representation of the argument.
    */
-  public static int parseInt(String s)
+  public static String toString(int num, int radix)
   {
-    return parseInt(s, 10, false);
-  }
+    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+      radix = 10;
 
-  /**
-   * Creates a new <code>Integer</code> object using the <code>String</code>
-   * and specified radix (base).
-   *
-   * @param s the <code>String</code> to convert
-   * @param radix the radix (base) to convert with
-   * @return the new <code>Integer</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as an
-   *         <code>int</code>
-   * @see #parseInt(String, int)
-   */
-  public static Integer valueOf(String s, int radix)
-  {
-    return new Integer(parseInt(s, radix, false));
+    // For negative numbers, print out the absolute value w/ a leading '-'.
+    // Use an array large enough for a binary number.
+    char[] buffer = new char[33];
+    int i = 33;
+    boolean isNeg;
+    if (num < 0)
+      {
+        isNeg = true;
+        num = -(num);
+
+        // When the value is MIN_VALUE, it overflows when made positive
+        if (num < 0)
+          {
+            buffer[--i] = Character.forDigit(-(num + radix) % radix, radix);
+            num = -(num / radix);
+          }
+      }
+    else
+      isNeg = false;
+
+    do
+      {
+        buffer[--i] = Character.forDigit(num % radix, radix);
+        num /= radix;
+      }
+    while (num > 0);
+
+    if (isNeg)
+      buffer[--i] = '-';
+
+    return String.valueOf(buffer, i, 33-i);
   }
 
   /**
    * Creates a new <code>Integer</code> object using the <code>String</code>,
    * assuming a radix of 10.
-   *
-   * @param s the <code>String</code> to convert
-   * @return the new <code>Integer</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as an
-   *         <code>int</code>
-   * @see #Integer(String)
-   * @see #parseInt(String)
+   * @param s the <code>String</code> to convert.
+   * @return the new <code>Integer</code>.
+   * @see #Integer(java.lang.String)
+   * @see #parseInt(java.lang.String)
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as an <code>int</code>.
    */
-  public static Integer valueOf(String s)
+  public static Integer valueOf(String s) throws NumberFormatException
   {
-    return new Integer(parseInt(s, 10, false));
+    return new Integer(parseInt(s));
   }
 
   /**
-   * Return the value of this <code>Integer</code> as a <code>byte</code>.
-   *
-   * @return the byte value
+   * Creates a new <code>Integer</code> object using the <code>String</code>
+   * and specified radix (base).
+   * @param s the <code>String</code> to convert.
+   * @param radix the radix (base) to convert with.
+   * @return the new <code>Integer</code>.
+   * @see #parseInt(java.lang.String,int)
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as an <code>int</code>.
    */
-  public byte byteValue()
+  public static Integer valueOf(String s, int radix)
+    throws NumberFormatException
   {
-    return (byte) value;
+    return new Integer(parseInt(s, radix));
   }
 
   /**
-   * Return the value of this <code>Integer</code> as a <code>short</code>.
+   * Converts the specified <code>String</code> into an <code>int</code>.
+   * This function assumes a radix of 10.
    *
-   * @return the short value
-   */
-  public short shortValue()
-  {
-    return (short) value;
-  }
-
-  /**
-   * Return the value of this <code>Integer</code>.
-   * @return the int value
+   * @param s the <code>String</code> to convert
+   * @return the <code>int</code> value of the <code>String</code>
+   *         argument.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as an <code>int</code>.
    */
-  public int intValue()
+  public static int parseInt(String s) throws NumberFormatException
   {
-    return value;
+    return parseInt(s, 10);
   }
 
   /**
-   * Return the value of this <code>Integer</code> as a <code>long</code>.
+   * Converts the specified <code>String</code> into an <code>int</code>
+   * using the specified radix (base).
    *
-   * @return the long value
+   * @param s the <code>String</code> to convert
+   * @param radix the radix (base) to use in the conversion
+   * @return the <code>String</code> argument converted to </code>int</code>.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as a <code>int</code>.    
    */
-  public long longValue()
+  public static int parseInt(String str, int radix)
+    throws NumberFormatException
   {
-    return value;
-  }
+    final int len;
 
-  /**
-   * Return the value of this <code>Integer</code> as a <code>float</code>.
-   *
-   * @return the float value
-   */
-  public float floatValue()
-  {
-    return value;
+    if (str == null)
+      throw new NumberFormatException ();
+
+    if ((len = str.length()) == 0 ||
+        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
+      throw new NumberFormatException();
+
+    boolean isNeg = false;
+    int index = 0;
+    if (str.charAt(index) == '-')
+      if (len > 1)
+        {
+          isNeg = true;
+          index++;
+        }
+      else
+        throw new NumberFormatException();
+
+    return parseInt(str, index, len, isNeg, radix);
   }
 
-  /**
-   * Return the value of this <code>Integer</code> as a <code>double</code>.
-   *
-   * @return the double value
-   */
-  public double doubleValue()
+  private static int parseInt(String str, int index, int len, boolean isNeg,
+			      int radix)
+    throws NumberFormatException
   {
-    return value;
+    int val = 0;
+    int digval;
+
+    int max = MAX_VALUE / radix;
+    // We can't directly write `max = (MAX_VALUE + 1) / radix'.
+    // So instead we fake it.
+    if (isNeg && MAX_VALUE % radix == radix - 1)
+      ++max;
+
+    for ( ; index < len; index++)
+      {
+	if (val < 0 || val > max)
+	  throw new NumberFormatException();
+
+        if ((digval = Character.digit(str.charAt(index), radix)) < 0)
+          throw new NumberFormatException();
+
+        // Throw an exception for overflow if result is negative.
+	// However, we special-case the most negative value.
+	val = val * radix + digval;
+	if (val < 0 && (! isNeg || val != MIN_VALUE))
+	  throw new NumberFormatException();
+      }
+
+    return isNeg ? -(val) : val;
   }
 
   /**
-   * Converts the <code>Integer</code> value to a <code>String</code> and
-   * assumes a radix of 10.
+   * Convert the specified <code>String</code> into an <code>Integer</code>.
+   * The <code>String</code> may represent decimal, hexadecimal, or 
+   * octal numbers.
    *
-   * @return the <code>String</code> representation
+   * The <code>String</code> argument is interpreted based on the leading
+   * characters.  Depending on what the String begins with, the base will be
+   * interpreted differently:
+   *
+   * <table border=1>
+   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>
+   * <tr><td>#</td><td>16</td></tr>
+   * <tr><td>0x</td><td>16</td></tr>
+   * <tr><td>0X</td><td>16</td></tr>
+   * <tr><td>0</td><td>8</td></tr>
+   * <tr><td>Anything<br>Else</td><td>10</td></tr>
+   * </table>
+   *
+   * @param str the <code>String</code> to interpret.
+   * @return the value of the String as an <code>Integer</code>.
+   * @exception NumberFormatException thrown if the <code>String</code> 
+   * cannot be parsed as an <code>int</code>.    
    */
-  public String toString()
+  public static Integer decode(String str) throws NumberFormatException
   {
-    return String.valueOf(value);
+    boolean isNeg = false;
+    int index = 0;
+    int radix = 10;
+    final int len;
+
+    if (str == null || (len = str.length()) == 0)
+      throw new NumberFormatException("string null or empty");
+
+    // Negative numbers are always radix 10.
+    if (str.charAt(index) == '-')
+      {
+        radix = 10;
+        index++;
+        isNeg = true;
+      }
+    else if (str.charAt(index) == '#')
+      {
+        radix = 16;
+        index++;
+      }
+    else if (str.charAt(index) == '0')
+      {
+        // Check if str is just "0"
+        if (len == 1)
+          return new Integer(0);
+
+        index++;
+        if (str.charAt(index) == 'x' || str.charAt(index) == 'X')
+          {
+            radix = 16;
+            index++;
+          }
+        else
+          radix = 8;
+      }
+
+    if (index >= len)
+      throw new NumberFormatException("empty value");
+
+    return new Integer(parseInt(str, index, len, isNeg, radix));
   }
 
-  /**
-   * Return a hashcode representing this Object. <code>Integer</code>'s hash
-   * code is simply its value.
-   *
-   * @return this Object's hash code
-   */
-  public int hashCode()
+  /** Return the value of this <code>Integer</code> as a <code>byte</code>.
+   ** @return the value of this <code>Integer</code> as a <code>byte</code>.
+   **/
+  public byte byteValue()
   {
-    return value;
+    return (byte) value;
   }
 
-  /**
-   * Returns <code>true</code> if <code>obj</code> is an instance of
-   * <code>Integer</code> and represents the same int value.
-   *
-   * @param obj the object to compare
-   * @return whether these Objects are semantically equal
-   */
-  public boolean equals(Object obj)
+  /** Return the value of this <code>Integer</code> as a <code>short</code>.
+   ** @return the value of this <code>Integer</code> as a <code>short</code>.
+   **/
+  public short shortValue()
   {
-    return obj instanceof Integer && value == ((Integer) obj).value;
+    return (short) value;
   }
 
-  /**
-   * Get the specified system property as an <code>Integer</code>. The
-   * <code>decode()</code> method will be used to interpret the value of
-   * the property.
-   *
-   * @param nm the name of the system property
-   * @return the system property as an <code>Integer</code>, or null if the
-   *         property is not found or cannot be decoded
-   * @throws SecurityException if accessing the system property is forbidden
-   * @see System#getProperty(String)
-   * @see #decode(String)
-   */
-  public static Integer getInteger(String nm)
+  /** Return the value of this <code>Integer</code> as an <code>int</code>.
+   ** @return the value of this <code>Integer</code> as an <code>int</code>.
+   **/
+  public int intValue()
   {
-    return getInteger(nm, null);
+    return value;
   }
 
-  /**
-   * Get the specified system property as an <code>Integer</code>, or use a
-   * default <code>int</code> value if the property is not found or is not
-   * decodable. The <code>decode()</code> method will be used to interpret
-   * the value of the property.
-   *
-   * @param nm the name of the system property
-   * @param val the default value
-   * @return the value of the system property, or the default
-   * @throws SecurityException if accessing the system property is forbidden
-   * @see System#getProperty(String)
-   * @see #decode(String)
-   */
-  public static Integer getInteger(String nm, int val)
+  /** Return the value of this <code>Integer</code> as a <code>long</code>.
+   ** @return the value of this <code>Integer</code> as a <code>long</code>.
+   **/
+  public long longValue()
   {
-    Integer result = getInteger(nm, null);
-    return result == null ? new Integer(val) : result;
+    return value;
   }
 
-  /**
-   * Get the specified system property as an <code>Integer</code>, or use a
-   * default <code>Integer</code> value if the property is not found or is
-   * not decodable. The <code>decode()</code> method will be used to
-   * interpret the value of the property.
-   *
-   * @param nm the name of the system property
-   * @param val the default value
-   * @return the value of the system property, or the default
-   * @throws SecurityException if accessing the system property is forbidden
-   * @see System#getProperty(String)
-   * @see #decode(String)
-   */
-  public static Integer getInteger(String nm, Integer def)
+  /** Return the value of this <code>Integer</code> as a <code>float</code>.
+   ** @return the value of this <code>Integer</code> as a <code>float</code>.
+   **/
+  public float floatValue()
   {
-    if (nm == null || "".equals(nm))
-      return def;
-    nm = System.getProperty(nm);
-    if (nm == null)
-      return def;
-    try
-      {
-        return decode(nm);
-      }
-    catch (NumberFormatException e)
-      {
-        return def;
-      }
+    return value;
   }
 
-  /**
-   * Convert the specified <code>String</code> into an <code>Integer</code>.
-   * The <code>String</code> may represent decimal, hexadecimal, or
-   * octal numbers.
-   *
-   * <p>The extended BNF grammar is as follows:<br>
-   * <pre>
-   * <em>DecodableString</em>:
-   *      ( [ <code>-</code> ] <em>DecimalNumber</em> )
-   *    | ( [ <code>-</code> ] ( <code>0x</code> | <code>0X</code>
-   *              | <code>#</code> ) <em>HexDigit</em> { <em>HexDigit</em> } )
-   *    | ( [ <code>-</code> ] <code>0</code> { <em>OctalDigit</em> } )
-   * <em>DecimalNumber</em>:
-   *        <em>DecimalDigit except '0'</em> { <em>DecimalDigit</em> }
-   * <em>DecimalDigit</em>:
-   *        <em>Character.digit(d, 10) has value 0 to 9</em>
-   * <em>OctalDigit</em>:
-   *        <em>Character.digit(d, 8) has value 0 to 7</em>
-   * <em>DecimalDigit</em>:
-   *        <em>Character.digit(d, 16) has value 0 to 15</em>
-   * </pre>
-   * Finally, the value must be in the range <code>MIN_VALUE</code> to
-   * <code>MAX_VALUE</code>, or an exception is thrown.
-   *
-   * @param s the <code>String</code> to interpret
-   * @return the value of the String as an <code>Integer</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>int</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @since 1.2
-   */
-  public static Integer decode(String str)
+  /** Return the value of this <code>Integer</code> as a <code>double</code>.
+   ** @return the value of this <code>Integer</code> as a <code>double</code>.
+   **/
+  public double doubleValue()
   {
-    return new Integer(parseInt(str, 10, true));
+    return value;
   }
 
   /**
-   * Compare two Integers numerically by comparing their <code>int</code>
-   * values. The result is positive if the first is greater, negative if the
-   * second is greater, and 0 if the two are equal.
+   * Compare two Integers numerically by comparing their
+   * <code>int</code> values.
+   * @return a positive value if this <code>Integer</code> is greater
+   * in value than the argument <code>Integer</code>; a negative value
+   * if this <code>Integer</code> is smaller in value than the argument
+   * <code>Integer</code>; and <code>0</code>, zero, if this
+   * <code>Integer</code> is equal in value to the argument
+   * <code>Integer</code>.  
    *
-   * @param i the Integer to compare
-   * @return the comparison
    * @since 1.2
    */
   public int compareTo(Integer i)
   {
-    if (value == i.value)
+    if (this.value == i.value)
       return 0;
+
     // Returns just -1 or 1 on inequality; doing math might overflow.
-    return value > i.value ? 1 : -1;
+    if (this.value > i.value)
+      return 1;
+
+    return -1;
   }
 
   /**
-   * Behaves like <code>compareTo(Integer)</code> unless the Object
-   * is not an <code>Integer</code>.
+   * Behaves like <code>compareTo(java.lang.Integer)</code> unless the Object
+   * is not a <code>Integer</code>.  Then it throws a 
+   * <code>ClassCastException</code>.
+   * @exception ClassCastException if the argument is not a
+   * <code>Integer</code>.
    *
-   * @param o the object to compare
-   * @return the comparison
-   * @throws ClassCastException if the argument is not an <code>Integer</code>
-   * @see #compareTo(Integer)
-   * @see Comparable
    * @since 1.2
    */
   public int compareTo(Object o)
   {
-    return compareTo((Integer) o);
-  }
-
-  /**
-   * Helper for converting unsigned numbers to String.
-   *
-   * @param num the number
-   * @param exp log2(digit) (ie. 1, 3, or 4 for binary, oct, hex)
-   */
-  // Package visible for use by Long.
-  static String toUnsignedString(int num, int exp)
-  {
-    // Use an array large enough for a binary number.
-    int mask = (1 << exp) - 1;
-    char[] buffer = new char[32];
-    int i = 32;
-    do
-      {
-        buffer[--i] = digits[num & mask];
-        num >>>= exp;
-      }
-    while (num != 0);
-
-    // Package constructor avoids an array copy.
-    return new String(buffer, i, 32 - i, true);
-  }
-
-  /**
-   * Helper for parsing ints, used by Integer, Short, and Byte.
-   *
-   * @param str the string to parse
-   * @param radix the radix to use, must be 10 if decode is true
-   * @param decode if called from decode
-   * @return the parsed int value
-   * @throws NumberFormatException if there is an error
-   * @throws NullPointerException if decode is true and str if null
-   * @see #parseInt(String, int)
-   * @see #decode(String)
-   * @see Byte#parseInt(String, int)
-   * @see Short#parseInt(String, int)
-   */
-  static int parseInt(String str, int radix, boolean decode)
-  {
-    if (! decode && str == null)
-      throw new NumberFormatException();
-    int index = 0;
-    int len = str.length();
-    boolean isNeg = false;
-    if (len == 0)
-      throw new NumberFormatException();
-    int ch = str.charAt(index);
-    if (ch == '-')
-      {
-        if (len == 1)
-          throw new NumberFormatException();
-        isNeg = true;
-        ch = str.charAt(++index);
-      }
-    if (decode)
-      {
-        if (ch == '0')
-          {
-            if (++index == len)
-              return 0;
-            if ((str.charAt(index) & ~('x' ^ 'X')) == 'X')
-              {
-                radix = 16;
-                index++;
-              }
-            else
-              radix = 8;
-          }
-        else if (ch == '#')
-          {
-            radix = 16;
-            index++;
-          }
-      }
-    if (index == len)
-      throw new NumberFormatException();
-    int val = 0;
-    while (index < len)
-      {
-        ch = Character.digit(str.charAt(index++), radix);
-        val = val * radix + ch;
-        if (ch < 0 || (val < 0 && (index < len || ! isNeg
-                                   || val != MIN_VALUE)))
-          throw new NumberFormatException();
-      }
-    return isNeg ? -val : val;
+    return compareTo((Integer)o);
   }
 }
