--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/AbstractButton.java	2004-01-28 02:27:13.000000000 -0700
+++ javax/swing/AbstractButton.java	2003-07-14 02:18:15.000000000 -0600
@@ -1,5 +1,5 @@
 /* AbstractButton.java -- Provides basic button functionality.
-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   Copyright (C) 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -35,10 +35,9 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package javax.swing;
 
-import java.awt.AWTEvent;
-import java.awt.AWTEventMulticaster;
 import java.awt.Graphics;
 import java.awt.Image;
 import java.awt.Insets;
@@ -52,15 +51,11 @@
 import java.awt.event.ItemEvent;
 import java.awt.event.ItemListener;
 import java.awt.event.MouseEvent;
-import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
-import java.io.Serializable;
-import java.util.Vector;
-import java.util.EventListener;
 import javax.accessibility.AccessibleAction;
 import javax.accessibility.AccessibleIcon;
-import javax.accessibility.AccessibleRelationSet;
 import javax.accessibility.AccessibleStateSet;
+import javax.accessibility.AccessibleRelationSet;
 import javax.accessibility.AccessibleText;
 import javax.accessibility.AccessibleValue;
 import javax.swing.event.ChangeEvent;
@@ -68,1734 +63,739 @@
 import javax.swing.plaf.ButtonUI;
 import javax.swing.text.AttributeSet;
 
-
 /**
- * <p>The purpose of this class is to serve as a facade over a number of
- * classes which collectively represent the semantics of a button: the
- * button's model, its listeners, its action, and its look and feel. Some
- * parts of a button's state are stored explicitly in this class, other
- * parts are delegates to the model. Some methods related to buttons are
- * implemented in this class, other methods pass through to the current 
- * model or look and feel.</p>
- *
- * <p>Furthermore this class is supposed to serve as a base class for
- * several kinds of buttons with similar but non-identical semantics:
- * toggle buttons (radio buttons and checkboxes), simple "push" buttons,
- * menu items.</p>
- *
- * <p>Buttons have many properties, some of which are stored in this class
- * while others are delegated to the button's model. The following properties
- * are available:</p>
- *
- * <table>
- * <tr><th>Property               </th><th>Stored in</th><th>Bound?</th></tr>
- *
- * <tr><td>action                 </td><td>button</td> <td>no</td></tr>
- * <tr><td>actionCommand          </td><td>model</td>  <td>no</td></tr>
- * <tr><td>borderPainted          </td><td>button</td> <td>yes</td></tr>
- * <tr><td>contentAreaFilled      </td><td>button</td> <td>yes</td></tr>
- * <tr><td>disabledIcon           </td><td>button</td> <td>yes</td></tr>
- * <tr><td>disabledSelectedIcon   </td><td>button</td> <td>yes</td></tr>
- * <tr><td>displayedMnemonicIndex </td><td>button</td> <td>no</td></tr>
- * <tr><td>enabled                </td><td>model</td>  <td>no</td></tr>
- * <tr><td>focusPainted           </td><td>button</td> <td>yes</td></tr>
- * <tr><td>horizontalAlignment    </td><td>button</td> <td>yes</td></tr>
- * <tr><td>horizontalTextPosition </td><td>button</td> <td>yes</td></tr>
- * <tr><td>icon                   </td><td>button</td> <td>yes</td></tr>
- * <tr><td>iconTextGap            </td><td>button</td> <td>no</td></tr>
- * <tr><td>label (same as text)   </td><td>model</td>  <td>yes</td></tr>
- * <tr><td>margin                 </td><td>button</td> <td>yes</td></tr>
- * <tr><td>multiClickThreshold    </td><td>button</td> <td>no</td></tr>
- * <tr><td>pressedIcon            </td><td>button</td> <td>yes</td></tr>
- * <tr><td>rolloverEnabled        </td><td>button</td> <td>yes</td></tr>
- * <tr><td>rolloverIcon           </td><td>button</td> <td>yes</td></tr>
- * <tr><td>rolloverSelectedIcon   </td><td>button</td> <td>yes</td></tr>
- * <tr><td>selected               </td><td>model</td>  <td>no</td></tr>
- * <tr><td>selectedIcon           </td><td>button</td> <td>yes</td></tr>
- * <tr><td>selectedObjects        </td><td>button</td> <td>no</td></tr>
- * <tr><td>text                   </td><td>model</td>  <td>yes</td></tr>
- * <tr><td>UI                     </td><td>button</td> <td>yes</td></tr>
- * <tr><td>verticalAlignment      </td><td>button</td> <td>yes</td></tr>
- * <tr><td>verticalTextPosition   </td><td>button</td> <td>yes</td></tr>
- *
- * </table>
- *
- * <p>The various behavioral aspects of these properties follows:</p>
- *
- * <ul> 
- *
- * <li>When non-bound properties stored in the button change, the button
- * fires ChangeEvents to its ChangeListeners.</li>
- * 
- * <li>When bound properties stored in the button change, the button fires
- * PropertyChangeEvents to its PropertyChangeListeners</li>
+ * Provides basic button functionality
  *
- * <li>If any of the model's properties change, it fires a ChangeEvent to
- * its ChangeListeners, which include the button.</li>
- *
- * <li>If the button receives a ChangeEvent from its model, it will
- * propagate the ChangeEvent to its ChangeListeners, with the ChangeEvent's
- * "source" property set to refer to the button, rather than the model. The
- * the button will request a repaint, to paint its updated state.</li>
- *
- * <li>If the model's "selected" property changes, the model will fire an
- * ItemEvent to its ItemListeners, which include the button, in addition to
- * the ChangeEvent which models the property change. The button propagates
- * ItemEvents directly to its ItemListeners.</li>
- *
- * <li>If the model's armed and pressed properties are simultaneously
- * <code>true</code>, the model will fire an ActionEvent to its
- * ActionListeners, which include the button. The button will propagate
- * this ActionEvent to its ActionListeners, with the ActionEvent's "source"
- * property set to refer to the button, rather than the model.</li>
- *
- * </ul>
- *
- * @author Ronald Veldema (rveldema&064;cs.vu.nl)
- * @author Graydon Hoare (graydon&064;redhat.com)
+ * @author Ronald Veldema (rveldema@cs.vu.nl)
  */
-
 public abstract class AbstractButton extends JComponent
   implements ItemSelectable, SwingConstants
 {
-  /** The icon displayed by default. */
-  Icon default_icon;
-
-  /** The icon displayed when the button is pressed. */
-  Icon pressed_icon;
-
-  /** The icon displayed when the button is disabled. */
-  Icon disabled_icon;
-
-  /** The icon displayed when the button is selected. */
-  Icon selected_icon;
-
-  /** The icon displayed when the button is selected but disabled. */
-  Icon disabled_selected_icon;
-
-  /** The icon displayed when the button is rolled over. */
-  Icon rollover_icon;
-
-  /** The icon displayed when the button is selected and rolled over. */
-  Icon rollover_selected_icon;
-
-  /** The icon currently displayed. */
-  Icon current_icon;
-
-  /** The text displayed in the button. */
+  Icon default_icon, pressed_button, disabled_button,
+    selected_button, disabled_selected_button, current_icon;
   String text;
 
-  /** The vertical alignment of the button's text and icon. */
   int vert_align = CENTER;
-
-  /** The horizontal alignment of the button's text and icon. */
   int hori_align = CENTER;
-
-  /** The horizontal position of the button's text relative to its icon. */
   int hori_text_pos = CENTER;
-
-  /** The vertical position of the button's text relative to its icon. */
   int vert_text_pos = CENTER;
 
-  /** Whether or not the button paints its border. */
-  boolean paint_border = true;
-
-  /** Whether or not the button paints its focus state. */
-  boolean paint_focus;
-
-  /** Whether or not the button fills its content area. */
-  boolean content_area_filled;
-
-  /** The action taken when the button is clicked. */
-  Action action;
-
-  /** The button's current state. */
+  boolean paint_border = true, paint_focus;
+  Action action_taken;
   ButtonModel model;
-
-  /** The margin between the button's border and its label. */
   Insets margin;
 
-  /** a hint to the look and feel class, suggesting which character in the
-   * button's label should be underlined when drawing the label. */
-  int mnemonicIndex;
-
-  /** Listener the button uses to receive ActionEvents from its model.  */
-  ActionListener actionListener;
-
-  /** Listener the button uses to receive ItemEvents from its model.  */
-  ItemListener itemListener;
-
-  /** Listener the button uses to receive ChangeEvents from its model.  */  
-  ChangeListener changeListener;
-
-  /** Listener the button uses to receive PropertyChangeEvents from its
-      Action. */
-  PropertyChangeListener actionPropertyChangeListener;
-  
-  /** Fired in a PropertyChangeEvent when the "borderPainted" property changes. */
-  public static String BORDER_PAINTED_CHANGED_PROPERTY = "borderPainted";
-  
-  /** Fired in a PropertyChangeEvent when the "contentAreaFilled" property changes. */
-  public static String CONTENT_AREA_FILLED_CHANGED_PROPERTY = "contentAreaFilled";
-  
-  /** Fired in a PropertyChangeEvent when the "disabledIcon" property changes. */
-  public static String DISABLED_ICON_CHANGED_PROPERTY = "disabledIcon";
-  
-  /** Fired in a PropertyChangeEvent when the "disabledSelectedIcon" property changes. */
-  public static String DISABLED_SELECTED_ICON_CHANGED_PROPERTY = "disabledSelectedIcon";
-  
-  /** Fired in a PropertyChangeEvent when the "focusPainted" property changes. */
-  public static String FOCUS_PAINTED_CHANGED_PROPERTY = "focusPainted";
-
-  /** Fired in a PropertyChangeEvent when the "horizontalAlignment" property changes. */
-  public static String HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY = "horizontalAlignment";
-
-  /** Fired in a PropertyChangeEvent when the "horizontalTextPosition" property changes. */
-  public static String HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY = "horizontalTextPosition";
-
-  /** Fired in a PropertyChangeEvent when the "icon" property changes. */
-  public static String ICON_CHANGED_PROPERTY = "icon";
-
-  /** Fired in a PropertyChangeEvent when the "margin" property changes. */
-  public static String MARGIN_CHANGED_PROPERTY = "margin";
-
-  /** Fired in a PropertyChangeEvent when the "mnemonic" property changes. */
-  public static String MNEMONIC_CHANGED_PROPERTY = "mnemonic";
-
-  /** Fired in a PropertyChangeEvent when the "model" property changes. */
-  public static String MODEL_CHANGED_PROPERTY = "model";
+  public static final String FOCUS_PAINTED_CHANGED_PROPERTY = "focusPainted";
 
-  /** Fired in a PropertyChangeEvent when the "pressedIcon" property changes. */
-  public static String PRESSED_ICON_CHANGED_PROPERTY = "pressedIcon";
-
-  /** Fired in a PropertyChangeEvent when the "rolloverEnabled" property changes. */
-  public static String ROLLOVER_ENABLED_CHANGED_PROPERTY = "rolloverEnabled";
-
-  /** Fired in a PropertyChangeEvent when the "rolloverIcon" property changes. */
-  public static String ROLLOVER_ICON_CHANGED_PROPERTY = "rolloverIcon";
-  
-  /** Fired in a PropertyChangeEvent when the "rolloverSelectedIcon" property changes. */
-  public static String ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY = "rolloverSelectedIcon";
-  
-  /** Fired in a PropertyChangeEvent when the "selectedIcon" property changes. */
-  public static String SELECTED_ICON_CHANGED_PROPERTY = "selectedIcon";
-
-  /** Fired in a PropertyChangeEvent when the "text" property changes. */
-  public static String TEXT_CHANGED_PROPERTY = "text";
-
-  /** Fired in a PropertyChangeEvent when the "verticalAlignment" property changes. */
-  public static String VERTICAL_ALIGNMENT_CHANGED_PROPERTY = "verticalAlignment";
-
-  /** Fired in a PropertyChangeEvent when the "verticalTextPosition" property changes. */
-  public static String VERTICAL_TEXT_POSITION_CHANGED_PROPERTY = "verticalTextPosition";
+  /**
+   * AccessibleAbstractButton
+   */
+  protected abstract class AccessibleAbstractButton 
+    extends AccessibleJComponent 
+    implements AccessibleAction, AccessibleValue, AccessibleText {
 
     /**
-   * A Java Accessibility extension of the AbstractButton.
+     * Constructor AccessibleAbstractButton
+     * @param component TODO
      */
-  protected abstract class AccessibleAbstractButton
-    extends AccessibleJComponent implements AccessibleAction, AccessibleValue,
-                                            AccessibleText
-  {
-    protected AccessibleAbstractButton(JComponent c)
-    {
-      super(c);
-    }
+    protected AccessibleAbstractButton(AbstractButton component) {
+      super(component);
+      // TODO
+    } // AccessibleAbstractButton()
 
-    public AccessibleStateSet getAccessibleStateSet()
-    {
+    /**
+     * getAccessibleStateSet
+     * @returns AccessibleStateSet
+     */
+    public AccessibleStateSet getAccessibleStateSet() {
       return null; // TODO
-    }
+    } // getAccessibleStateSet()
 
-    public String getAccessibleName()
-    {
+    /**
+     * getAccessibleName
+     * @returns String
+     */
+    public String getAccessibleName() {
       return null; // TODO
-    }
+    } // getAccessibleName()
 
-    public AccessibleIcon[] getAccessibleIcon()
-    {
+    /**
+     * getAccessibleIcon
+     * @returns AccessibleIcon[]
+     */
+    public AccessibleIcon[] getAccessibleIcon() {
       return null; // TODO
-    }
+    } // getAccessibleIcon()
 
-    public AccessibleRelationSet getAccessibleRelationSet()
-    {
+    /**
+     * getAccessibleRelationSet
+     * @returns AccessibleRelationSet
+     */
+    public AccessibleRelationSet getAccessibleRelationSet() {
       return null; // TODO
-    }
+    } // getAccessibleRelationSet()
 
-    public AccessibleAction getAccessibleAction()
-    {
+    /**
+     * getAccessibleAction
+     * @returns AccessibleAction
+     */
+    public AccessibleAction getAccessibleAction() {
       return null; // TODO
-    }
+    } // getAccessibleAction()
 
-    public AccessibleValue getAccessibleValue()
-    {
+    /**
+     * getAccessibleValue
+     * @returns AccessibleValue
+     */
+    public AccessibleValue getAccessibleValue() {
       return null; // TODO
-    }
+    } // getAccessibleValue()
 
-    public int getAccessibleActionCount()
-    {
+    /**
+     * getAccessibleActionCount
+     * @returns int
+     */
+    public int getAccessibleActionCount() {
       return 0; // TODO
-    }
+    } // getAccessibleActionCount()
 
-    public String getAccessibleActionDescription(int value0)
-    {
+    /**
+     * getAccessibleActionDescription
+     * @param value0 TODO
+     * @returns String
+     */
+    public String getAccessibleActionDescription(int value0) {
       return null; // TODO
-    }
+    } // getAccessibleActionDescription()
 
-    public boolean doAccessibleAction(int value0)
-    {
+    /**
+     * doAccessibleAction
+     * @param value0 TODO
+     * @returns boolean
+     */
+    public boolean doAccessibleAction(int value0) {
       return false; // TODO
-    }
+    } // doAccessibleAction()
 
-    public Number getCurrentAccessibleValue()
-    {
+    /**
+     * getCurrentAccessibleValue
+     * @returns Number
+     */
+    public Number getCurrentAccessibleValue() {
       return null; // TODO
-    }
+    } // getCurrentAccessibleValue()
 
-    public boolean setCurrentAccessibleValue(Number value0)
-    {
+    /**
+     * setCurrentAccessibleValue
+     * @param value0 TODO
+     * @returns boolean
+     */
+    public boolean setCurrentAccessibleValue(Number value0) {
       return false; // TODO
-    }
+    } // setCurrentAccessibleValue()
 
-    public Number getMinimumAccessibleValue()
-    {
+    /**
+     * getMinimumAccessibleValue
+     * @returns Number
+     */
+    public Number getMinimumAccessibleValue() {
       return null; // TODO
-    }
+    } // getMinimumAccessibleValue()
 
-    public Number getMaximumAccessibleValue()
-    {
+    /**
+     * getMaximumAccessibleValue
+     * @returns Number
+     */
+    public Number getMaximumAccessibleValue() {
       return null; // TODO
-    }
+    } // getMaximumAccessibleValue()
 
-    public AccessibleText getAccessibleText()
-    {
+    /**
+     * getAccessibleText
+     * @returns AccessibleText
+     */
+    public AccessibleText getAccessibleText() {
       return null; // TODO
-    }
+    } // getAccessibleText()
 
-    public int getIndexAtPoint(Point value0)
-    {
+    /**
+     * getIndexAtPoint
+     * @param value0 TODO
+     * @returns int
+     */
+    public int getIndexAtPoint(Point value0) {
       return 0; // TODO
-    }
+    } // getIndexAtPoint()
 
-    public Rectangle getCharacterBounds(int value0)
-    {
+    /**
+     * getCharacterBounds
+     * @param value0 TODO
+     * @returns Rectangle
+     */
+    public Rectangle getCharacterBounds(int value0) {
       return null; // TODO
-    }
+    } // getCharacterBounds()
 
-    public int getCharCount()
-    {
+    /**
+     * getCharCount
+     * @returns int
+     */
+    public int getCharCount() {
       return 0; // TODO
-    }
+    } // getCharCount()
 
-    public int getCaretPosition()
-    {
+    /**
+     * getCaretPosition
+     * @returns int
+     */
+    public int getCaretPosition() {
       return 0; // TODO
-    }
+    } // getCaretPosition()
 
-    public String getAtIndex(int value0, int value1)
-    {
+    /**
+     * getAtIndex
+     * @param value0 TODO
+     * @param value1 TODO
+     * @returns String
+     */
+    public String getAtIndex(int value0, int value1) {
       return null; // TODO
-    }
+    } // getAtIndex()
 
-    public String getAfterIndex(int value0, int value1)
-    {
+    /**
+     * getAfterIndex
+     * @param value0 TODO
+     * @param value1 TODO
+     * @returns String
+     */
+    public String getAfterIndex(int value0, int value1) {
       return null; // TODO
-    }
+    } // getAfterIndex()
 
-    public String getBeforeIndex(int value0, int value1)
-    {
+    /**
+     * getBeforeIndex
+     * @param value0 TODO
+     * @param value1 TODO
+     * @returns String
+     */
+    public String getBeforeIndex(int value0, int value1) {
       return null; // TODO
-    }
+    } // getBeforeIndex()
 
-    public AttributeSet getCharacterAttribute(int value0)
-    {
+    /**
+     * getCharacterAttribute
+     * @param value0 TODO
+     * @returns AttributeSet
+     */
+    public AttributeSet getCharacterAttribute(int value0) {
       return null; // TODO
-    }
+    } // getCharacterAttribute()
 
-    public int getSelectionStart()
-    {
+    /**
+     * getSelectionStart
+     * @returns int
+     */
+    public int getSelectionStart() {
       return 0; // TODO
-    }
+    } // getSelectionStart()
 
-    public int getSelectionEnd()
-    {
+    /**
+     * getSelectionEnd
+     * @returns int
+     */
+    public int getSelectionEnd() {
       return 0; // TODO
-    }
+    } // getSelectionEnd()
 
-    public String getSelectedText()
-  {
+    /**
+     * getSelectedText
+     * @returns String
+     */
+    public String getSelectedText() {
       return null; // TODO
-    }
+    } // getSelectedText()
 
-    private Rectangle getTextRectangle()
-    {
+    /**
+     * getTextRectangle
+     * @returns Rectangle
+     */
+    private Rectangle getTextRectangle() {
       return null; // TODO
-    }
-    }
+    } // getTextRectangle()
 
-  /**
-   * Helper class used to subscribe to FocusEvents received by the button.
-   */
-  private class ButtonFocusListener implements FocusListener
+
+  } // AccessibleAbstractButton
+
+
+  static private class JFocusListener implements FocusListener
+  {
+    AbstractButton c;
+
+    JFocusListener(AbstractButton c)
     {
-    /**
-     * Possibly repaint the model in response to loss of focus.
-     *
-     * @param event The loss-of-focus event
-     */
+      this.c = c;
+    }
+
     public void focusLost(FocusEvent event)
+    {
+      c.getModel().setArmed(false);
+
+      System.out.println("LOST FOCUS");
+      if (c.isFocusPainted())
         {
-      if (AbstractButton.this.isFocusPainted())
-        AbstractButton.this.repaint();
+          c.repaint();
+        }
     }
-
-    /**
-     * Possibly repaint the button in response to acquisition of focus.
-     *
-     * @param event The gained-focus event
-     */
     public void focusGained(FocusEvent event)
     {
-      if (AbstractButton.this.isFocusPainted())
-        AbstractButton.this.repaint();
+      System.out.println("GAIN FOCUS");
     }
   }
 
-  /**
-   * Creates a new AbstractButton object.
-   */
   AbstractButton()
   {
     this("",null);
   }
 
-  /**
-   * Creates a new AbstractButton object.
-   *
-   * @param txt Value to use for the button's "text" property
-   * @param icon Value to use for the button's "defaultIcon" property
-   */
-  AbstractButton(String txt, Icon icon)
+  AbstractButton(String text,
+                 Icon icon)
   {
-    text = txt;
-    default_icon = icon;
-    model = new DefaultButtonModel();
-    actionListener = createActionListener();
-    changeListener = createChangeListener();
-    itemListener = createItemListener();
-
-    model.addActionListener(actionListener);
-    model.addChangeListener(changeListener);
-    model.addItemListener(itemListener);
+    this.text    = text;
+    setIcon(icon);
 
     setAlignmentX(LEFT_ALIGNMENT);
     setAlignmentY(CENTER_ALIGNMENT);
-    addFocusListener(new ButtonFocusListener());
-    updateUI();
+
+    addFocusListener( new JFocusListener(this) );
+
+    setModel(new DefaultButtonModel(this));
+
+    updateUI(); // get a proper ui
   }
 
-  /**
-   * Get the model the button is currently using.
-   *
-   * @return The current model
-   */
   public ButtonModel getModel()
-  {
-    return model;
-  }
+  {	return model;    }
 
-  /**
-   * Set the model the button is currently using. This un-registers all 
-   * listeners associated with the current model, and re-registers them
-   * with the new model.
-   *
-   * @param newModel The new model
-   */
   public void setModel(ButtonModel newModel)
-  {
-    if (newModel == model)
-      return;
+  {	model = newModel;    }
 
-    if (model != null)
-      {
-        model.removeActionListener(actionListener);
-        model.removeChangeListener(changeListener);
-        model.removeItemListener(itemListener);
-      }
-    ButtonModel old = model;
-    model = newModel;
-    if (model != null)
-      {
-        model.addActionListener(actionListener);
-        model.addChangeListener(changeListener);
-        model.addItemListener(itemListener);
-      }
-    firePropertyChange(MODEL_CHANGED_PROPERTY, old, model);
-    revalidate();
-    repaint();
-  }
-
-  /**
-   * Get the action command string for this button's model.
-   *
-   * @return The current action command string from the button's model
-   */
   public String getActionCommand()
-  {
-    return getModel().getActionCommand();
-  }
+  {	return getModel().getActionCommand();    }
 
-  /**
-   * Set the action command string for this button's model.
-   *
-   * @param aCommand The new action command string to set in the button's
-   * model.
-   */
   public void setActionCommand(String aCommand)
-  {
-    getModel().setActionCommand(aCommand);
-  }
+  {   getModel().setActionCommand(aCommand);   }
 
-  /**
-   * Adds an ActionListener to the button's listener list. When the
-   * button's model is clicked it fires an ActionEvent, and these
-   * listeners will be called.
-   *
-   * @param l The new listener to add
-   */
   public void addActionListener(ActionListener l)
-  {
-    listenerList.add(ActionListener.class, l);
-  }
+  {	getModel().addActionListener(l);    }
 
-  /**
-   * Removes an ActionListener from the button's listener list.
-   *
-   * @param l The listener to remove
-   */
   public void removeActionListener(ActionListener l)
-  {
-    listenerList.remove(ActionListener.class, l);
-  }
+  {	getModel().removeActionListener(l);    }
 
-  /**
-   * Adds an ItemListener to the button's listener list. When the button's
-   * model changes state (between any of ARMED, ENABLED, PRESSED, ROLLOVER
-   * or SELECTED) it fires an ItemEvent, and these listeners will be
-   * called.
-   *
-   * @param l The new listener to add
-   */
-  public void addItemListener(ItemListener l)
-  {
-    listenerList.add(ItemListener.class, l);
-  }
-
-  /**
-   * Removes an ItemListener from the button's listener list.
-   *
-   * @param l The listener to remove
-   */
-  public void removeItemListener(ItemListener l)
-  {
-    listenerList.remove(ItemListener.class, l);
-  }
-
-  /**
-   * Adds a ChangeListener to the button's listener list. When the button's
-   * model changes any of its (non-bound) properties, these listeners will be
-   * called. 
-   *
-   * @param l The new listener to add
-   */
   public void addChangeListener(ChangeListener l)
-  {
-    listenerList.add(ChangeListener.class, l);
-  }
+  {   getModel().addChangeListener(l);     }
 
-  /**
-   * Removes a ChangeListener from the button's listener list.
-   *
-   * @param l The listener to remove
-   */
   public void removeChangeListener(ChangeListener l)
-  {
-    listenerList.remove(ChangeListener.class, l);
-  }
+  {  getModel().removeChangeListener(l);    }
 
-  /**
-   * Calls {@link ItemListener.itemStateChanged} on each ItemListener in
-   * the button's listener list.
-   *
-   * @param e The event signifying that the button's model changed state
-   */
-  public void fireItemStateChanged(ItemEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ItemListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ItemListener)ll[i]).itemStateChanged(e);
-  }
-
-  /**
-   * Calls {@link ActionListener.actionPerformed} on each {@link
-   * ActionListener} in the button's listener list.
-   *
-   * @param e The event signifying that the button's model was clicked
-   */
-  public void fireActionPerformed(ActionEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ActionListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ActionListener)ll[i]).actionPerformed(e);
-  }
+  public void addItemListener(ItemListener l)
+  {  getModel().addItemListener(l);    }
 
-  /**
-   * Calls {@link ChangeEvent.stateChanged} on each {@link ChangeListener}
-   * in the button's listener list.
-   *
-   * @param e The event signifying a change in one of the (non-bound)
-   * properties of the button's model.
-   */
-  public void fireStateChanged(ChangeEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ChangeListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ChangeListener)ll[i]).stateChanged(e);
-  }
+  public void removeItemListener(ItemListener l)
+  {  getModel().removeItemListener(l);  }
 
-  /**
-   * Get the current keyboard mnemonic value. This value corresponds to a
-   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*
-   * codes) and is used to activate the button when pressed in conjunction
-   * with the "mouseless modifier" of the button's look and feel class, and
-   * when focus is in one of the button's ancestors.
-   *
-   * @return The button's current keyboard mnemonic
-   */
-  public int getMnemonic()
-  {
-    return getModel().getMnemonic();
-  }
+  public int getHorizontalAlignment()
+  {	return hori_align;    }
 
-  /**
-   * Set the current keyboard mnemonic value. This value corresponds to a
-   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*
-   * codes) and is used to activate the button when pressed in conjunction
-   * with the "mouseless modifier" of the button's look and feel class, and
-   * when focus is in one of the button's ancestors.
-   *
-   * @param mne A new mnemonic to use for the button
-   */
-  public void setMnemonic(char mne)
-  {
-    int old = getModel().getMnemonic();
-    getModel().setMnemonic(mne);
-    if (old != getModel().getMnemonic())
-      {
-        firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, (int) mne);        
-        revalidate();
-        repaint();
-      }
-  }
+  public int getHorizontalTextPosition()
+  {	return hori_text_pos;    }
 
-  /**
-   * Set the current keyboard mnemonic value. This value corresponds to a
-   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*
-   * codes) and is used to activate the button when pressed in conjunction
-   * with the "mouseless modifier" of the button's look and feel class, and
-   * when focus is in one of the button's ancestors.
-   *
-   * @param mne A new mnemonic to use for the button
-   */
-  public void setMnemonic(int mne)
-  {
-    int old = mne;
-    getModel().setMnemonic(mne);
-    if (old != getModel().getMnemonic())
-      {
-        firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, mne);
-        revalidate();
-        repaint();
-      }
-  }
+  public int getVerticalAlignment()
+  {	return vert_align;   }
 
-  /** 
-   * Sets the button's mnemonic index. The mnemonic index is a hint to the
-   * look and feel class, suggesting which character in the button's label
-   * should be underlined when drawing the label. If the mnemonic index is
-   * -1, no mnemonic will be displayed. 
-   * 
-   * If no mnemonic index is set, the button will choose a mnemonic index
-   * by default, which will be the first occurrence of the mnemonic
-   * character in the button's text.
-   *
-   * @param index An offset into the "text" property of the button
-   * @throws IllegalArgumentException If <code>index</code> is not within the
-   * range of legal offsets for the "text" property of the button.
-   * @since 1.4
-   */
+  public int getVerticalTextPosition()
+  {	return vert_text_pos;  }
 
-  public void setDisplayedMnemonicIndex(int index)
+  protected  void fireItemStateChanged(ItemEvent event)
   {
-    if (index < -1 || index >= text.length())
-      throw new IllegalArgumentException();
-    else
-      mnemonicIndex = index;
   }
   
-  /** 
-   * Get the button's mnemonic index, which is an offset into the button's
-   * "text" property.  The character specified by this offset should be
-   * underlined when the look and feel class draws this button.
-   *
-   * @return An index into the button's "text" property
-   */
-  public int getDisplayedMnemonicIndex(int index)
+  protected  void fireStateChanged(ChangeEvent event)
   {
-    return mnemonicIndex;
   }
   
-
-  /**
-   * Set the "rolloverEnabled" property. When rollover is enabled, and the
-   * look and feel supports it, the button will change its icon to
-   * rollover_icon, when the mouse passes over it.
-   *
-   * @param r Whether or not to enable rollover icon changes
-   */
-  public void setRolloverEnabled(boolean r)
-  {
-    boolean old = getModel().isRollover();
-    getModel().setRollover(r);
-    if (old != getModel().isRollover())
-  {
-        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, old, r);
-        revalidate();
-        repaint();
-      }
-  }
-
-  /**
-   * Returns whether or not rollover icon changes are enabled on the
-   * button.
-   *
-   * @return The state of the "rolloverEnabled" property
-   */
-  public boolean isRolloverEnabled()
-  {
-    return getModel().isRollover();
-  }
-
-  /**
-   * Set the value of the button's "selected" property. Selection is only
-   * meaningful for toggle-type buttons (check boxes, radio buttons).
-   *
-   * @param s New value for the property
-   */
-  public void setSelected(boolean s)
-  {
-    getModel().setSelected(s);
-  }
-
-  /**
-   * Get the value of the button's "selected" property. Selection is only
-   * meaningful for toggle-type buttons (check boxes, radio buttons).
-   *
-   * @return The value of the property
-   */
-  public boolean isSelected()
-  {
-    return getModel().isSelected();
-  }
-
-  /**
-   * Enables or disables the button. A button will neither be selectable
-   * nor preform any actions unless it is enabled.
-   *
-   * @param b Whether or not to enable the button
-   */
-  public void setEnabled(boolean b)
+  protected void fireActionPerformed(ActionEvent event)
   {
-    super.setEnabled(b);
-    getModel().setEnabled(b);
   }
 
-  /** 
-   * Set the horizontal alignment of the button's text and icon. The
-   * alignment is a numeric constant from {@link SwingConstants}. It must
-   * be one of: <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,
-   * <code>LEADING</code> or <code>TRAILING</code>.  The default is
-   * <code>RIGHT</code>.
-   * 
-   * @return The current horizontal alignment
-   */
-  public int getHorizontalAlignment()
-  {
-    return hori_align;
-  }
+  public void setVerticalAlignment(int alignment)
+  {	vert_align = alignment;    }
 
-  /**
-   * Set the horizontal alignment of the button's text and icon. The
-   * alignment is a numeric constant from {@link SwingConstants}. It must
-   * be one of: <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,
-   * <code>LEADING</code> or <code>TRAILING</code>.  The default is
-   * <code>RIGHT</code>.
-   *
-   * @param a The new horizontal alignment
-   * @throws IllegalArgumentException If alignment is not one of the legal
-   * constants.
-   */
-  public void setHorizontalAlignment(int a)
-  {
-    int old = hori_align;
-    hori_align = a;
-    if (old != a)
-      {
-        firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY, old, a);
-        revalidate();
-        repaint();
-      }
-  }
+  public void setHorizontalAlignment(int alignment)
+  {   hori_align = alignment;   }
 
-  /**
-   * Get the horizontal position of the button's text relative to its
-   * icon. The position is a numeric constant from {@link
-   * SwingConstants}. It must be one of: <code>RIGHT</code>,
-   * <code>LEFT</code>, <code>CENTER</code>, <code>LEADING</code> or
-   * <code>TRAILING</code>.  The default is <code>TRAILING</code>.
-   *
-   * @return The current horizontal text position
-   */
-  public int getHorizontalTextPosition()
-  {
-    return hori_text_pos;
-  }
+  public void setVerticalTextPosition(int textPosition)
+  {	vert_text_pos = textPosition;    }
 
-  /**
-   * Set the horizontal position of the button's text relative to its
-   * icon. The position is a numeric constant from {@link
-   * SwingConstants}. It must be one of: <code>RIGHT</code>,
-   * <code>LEFT</code>, <code>CENTER</code>, <code>LEADING</code> or
-   * <code>TRAILING</code>. The default is <code>TRAILING</code>.
-   *
-   * @param t The new horizontal text position
-   * @throws IllegalArgumentException If position is not one of the legal
-   * constants.
-   */
-  public void setHorizontalTextPosition(int t)
-  {
-    int old = hori_text_pos;
-    hori_text_pos = t;
-    if (old != t)
-      {
-        firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);
-        revalidate();
-        repaint();
-      }
-  }
+  public void setHorizontalTextPosition(int textPosition)
+  {   hori_text_pos = textPosition;   }
 
-  /**
-   * Get the vertical alignment of the button's text and icon. The
-   * alignment is a numeric constant from {@link SwingConstants}. It must
-   * be one of: <code>CENTER</code>, <code>TOP</code>, or
-   * <code>BOTTOM</code>. The default is <code>CENTER</code>.
-   *
-   * @return The current vertical alignment
-   */
-  public int getVerticalAlignment()
-  {
-    return vert_align;
-  }
+  public int getMnemonic()
+  {	return getModel().getMnemonic();    }
 
-  /**
-   * Set the vertical alignment of the button's text and icon. The
-   * alignment is a numeric constant from {@link SwingConstants}. It must
-   * be one of: <code>CENTER</code>, <code>TOP</code>, or
-   * <code>BOTTOM</code>. The default is <code>CENTER</code>.
-   *
-   * @param a The new vertical alignment
-   * @throws IllegalArgumentException If alignment is not one of the legal
-   * constants.
-   */
-  public void setVerticalAlignment(int a)
-  {
-    int old = vert_align;
-    vert_align = a;
-    if (old != a)
-      {
-        firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, old, a);
-        revalidate();
-        repaint();
-      }
-  }
+  public void setMnemonic(char mne)
+  {	getModel().setMnemonic(mne);    }
 
-  /**
-   * Get the vertical position of the button's text relative to its
-   * icon. The alignment is a numeric constant from {@link
-   * SwingConstants}. It must be one of: <code>CENTER</code>,
-   * <code>TOP</code>, or <code>BOTTOM</code>. The default is
-   * <code>CENTER</code>.
-   *
-   * @return The current vertical position
-   */
-  public int getVerticalTextPosition()
-  {
-    return vert_text_pos;
-  }
+  public void setMnemonic(int mne)
+  {	getModel().setMnemonic(mne);    }
 
-  /**
-   * Set the vertical position of the button's text relative to its
-   * icon. The alignment is a numeric constant from {@link
-   * SwingConstants}. It must be one of: <code>CENTER</code>,
-   * <code>TOP</code>, or <code>BOTTOM</code>. The default is
-   * <code>CENTER</code>.
-   *
-   * @param t The new vertical position
-   * @throws IllegalArgumentException If position is not one of the legal
-   * constants.
-   */
-  public void setVerticalTextPosition(int t)
-  {
-    int old = vert_text_pos;
-    vert_text_pos = t;
-    if (old != t)
-      {
-        firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);
-        revalidate();
-        repaint();
-      }
-  }
+  public void setRolloverEnabled(boolean b)
+  {    getModel().setRollover(b);    }
+
+  public boolean isRolloverEnabled()
+  {    return getModel().isRollover();     }
 
-  /**
-   * Set the value of the "borderPainted" property. If set to
-   * <code>false</code>, the button's look and feel class should not paint
-   * a border for the button. The default is <code>true</code>.
-   *
-   * @return The current value of the property.
-   */
   public boolean isBorderPainted()
-  {
-    return paint_border;
-  }
+  {	return paint_border;    }
 
-  /**
-   * Set the value of the "borderPainted" property. If set to
-   * <code>false</code>, the button's look and feel class should not paint
-   * a border for the button. The default is <code>true</code>.
-   *
-   * @param b The new value of the property.
-   */
   public void setBorderPainted(boolean b)
   {
-    boolean old = paint_border;
-        paint_border = b;
-    if (b != old)
+    if (b != paint_border)
       {
-        firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, old, b);
+        paint_border = b;
         revalidate();
         repaint();
       }
   }
 
-  /**
-   * Get the value of the "action" property. 
-   *
-   * @return The current value of the "action" property
-   */
   public Action getAction()
-  {
-    return action;
-  }
+  {	return action_taken;    }
 
-  /**
-   * <p>Set the button's "action" property, subscribing the new action to the
-   * button, as an ActionListener, if it is not already subscribed. The old
-   * Action, if it exists, is unsubscribed, and the button is unsubscribed
-   * from the old Action if it was previously subscribed as a
-   * PropertyChangeListener.</p>
-   *
-   * <p>This method also configures several of the button's properties from
-   * the Action, by calling {@link configurePropertiesFromAction}, and
-   * subscribes the button to the Action as a PropertyChangeListener.
-   * Subsequent changes to the Action will thus reconfigure the button 
-   * automatically.</p>
-   *
-   * @param a The new value of the "action" property
-   */
   public void setAction(Action a)
   {
-    if (action != null)
-      {
-        action.removePropertyChangeListener(actionPropertyChangeListener);
-        removeActionListener(action);
-        if (actionPropertyChangeListener != null)
-          {
-            action.removePropertyChangeListener(actionPropertyChangeListener);
-            actionPropertyChangeListener = null;
-          }
-        actionPropertyChangeListener = createActionPropertyChangeListener(a);
+    action_taken = a;
+    revalidate();
+    repaint();
   }
 
-    Action old = action;
-    action = a;
-    configurePropertiesFromAction(action);
+  public void setSelected(boolean b)
+  {	getModel().setSelected(b);    }
 
-    if (action != null)
-      {
-        action.addPropertyChangeListener(actionPropertyChangeListener);
-        addActionListener(action);
-      }
-  }
+  public boolean isSelected()
+  {	return getModel().isSelected();     }
 
-  /**
-   * Return the button's default "icon" property.
-   *
-   * @return The current default icon
-   */
   public Icon getIcon()
+  {	return default_icon;    }
+
+  public void setIcon(Icon defaultIcon)
   {
-    return default_icon;
-  }
+    if (default_icon == defaultIcon)
+      return;
 
-  /**
-   * Set the button's default "icon" property. This icon is used as a basis
-   * for the pressed and disabled icons, if none are explicitly set.
-   *
-   * @param i The new default icon
-   */
-  public void setIcon(Icon i)
+    default_icon = defaultIcon;
+    if (default_icon != null)
       {
-    Icon old = default_icon;
-    default_icon = i;
-    if (old != i)
-      {
-        firePropertyChange(ICON_CHANGED_PROPERTY, old, i);
+        // XXX FIXME - icons do not know their parent
+        //  			default_icon.setParent(this);
+      }
     revalidate();
     repaint();
   }
-  }
 
-  /**
-   * Return the button's "text" property. This property is synonymous with
-   * the "label" property.
-   *
-   * @return The current "text" property
-   */
   public String getText()
-  {
-    return text;
-  }
+  {	return text;    }
 
-  /**
-   * Set the button's "label" property. This property is synonymous with the
-   * "text" property.
-   *
-   * @param label The new "label" property
-   */
   public void setLabel(String label)
-  {
-    setText(label);
-  }
+  {	setText(label);    }
 
-  /**
-   * Return the button's "label" property. This property is synonymous with
-   * the "text" property.
-   *
-   * @return The current "label" property
-   */
   public String getLabel()
-  {
-    return getText();
-  }
+  {	return getText();    }
 
-  /**
-   * Set the button's "text" property. This property is synonymous with the
-   * "label" property.
-   *
-   * @param t The new "text" property
-   */
-  public void setText(String t)
+  public void setText(String text)
   {
-    String old = text;
-    text = t;
-    if (t != old)
-      {
-        firePropertyChange(TEXT_CHANGED_PROPERTY, old, t);
+    this.text = text;
     revalidate();
     repaint();
   }
-  }
 
-  /**
-   * Return the button's "margin" property, which is an {@link Insets} object
-   * describing the distance between the button's border and its text and
-   * icon.
-   *
-   * @return The current "margin" property
-   */
   public 	Insets getMargin()
-  {
-    return margin;
-  }
+  {      return margin; }
 
-  /**
-   * Set the button's "margin" property, which is an {@link Insets} object
-   * describing the distance between the button's border and its text and
-   * icon.
-   *
-   * @param m The new "margin" property
-   */
   public void setMargin(Insets m)
   {
-    Insets old = margin;
     margin = m;
-    if (m != old)
-      {
-        firePropertyChange(MARGIN_CHANGED_PROPERTY, old, m);
-        revalidate();
+    revalidate();
     repaint();
   }
-  }
 
-  /**
-   * Return the button's "pressedIcon" property. The look and feel class
-   * should paint this icon when the "pressed" property of the button's
-   * {@link ButtonModel} is <code>true</code>. This property may be
-   * <code>null</code>, in which case the default icon is used.
-   *
-   * @return The current "pressedIcon" property
-   */
-  public Icon getPressedIcon()
+  public void setEnabled(boolean b)
   {
-    return pressed_icon;
+    super.setEnabled(b);
+    getModel().setEnabled(b);
+    repaint();
   }
 
-  /**
-   * Set the button's "pressedIcon" property. The look and feel class
-   * should paint this icon when the "pressed" property of the button's
-   * {@link ButtonModel} is <code>true</code>. This property may be
-   * <code>null</code>, in which case the default icon is used.
-   *
-   * @param pressedIcon The new "pressedIcon" property
-   */
+  public Icon getPressedIcon()
+  {	return pressed_button;    }
+
   public void setPressedIcon(Icon pressedIcon)
   {
-    Icon old = pressed_icon;
-    pressed_icon = pressedIcon;
-    if (pressed_icon != old)
-      {
-        firePropertyChange(PRESSED_ICON_CHANGED_PROPERTY, old, pressed_icon);
+    pressed_button = pressedIcon;
     revalidate();
     repaint();
   }
-  }
 
-  /**
-   * Return the button's "disabledIcon" property. The look and feel class
-   * should paint this icon when the "enabled" property of the button's
-   * {@link ButtonModel} is <code>false</code>. This property may be
-   * <code>null</code>, in which case an icon is constructed, based on the
-   * default icon.
-   *
-   * @return The current "disabledIcon" property
-   */
   public Icon getDisabledIcon()
-  {
-    return disabled_icon;
-  }
+  {	return disabled_button;    }
 
-  /**
-   * Set the button's "disabledIcon" property. The look and feel class should
-   * paint this icon when the "enabled" property of the button's {@link
-   * ButtonModel} is <code>false</code>. This property may be
-   * <code>null</code>, in which case an icon is constructed, based on the
-   * default icon.
-   *
-   * @param disabledIcon The new "disabledIcon" property
-   */
   public void setDisabledIcon(Icon disabledIcon)
   {
-    disabled_icon = disabledIcon;
+    disabled_button = disabledIcon;
     revalidate();
     repaint();
   }
 
-  /**
-   * Return the button's "paintFocus" property. This property controls
-   * whether or not the look and feel class will paint a special indicator
-   * of focus state for the button. If it is false, the button still paints
-   * when focused, but no special decoration is painted to indicate the
-   * presence of focus.
-   *
-   * @return The current "paintFocus" property
-   */
   public boolean isFocusPainted()
-  {
-    return paint_focus;
-  }
+  {   return paint_focus;   }
 
-  /**
-   * Set the button's "paintFocus" property. This property controls whether
-   * or not the look and feel class will paint a special indicator of focus
-   * state for the button. If it is false, the button still paints when
-   * focused, but no special decoration is painted to indicate the presence
-   * of focus.
-   *
-   * @param b The new "paintFocus" property
-   */
   public void setFocusPainted(boolean b)
   {
     boolean old = paint_focus;
     paint_focus = b;
 
-    if (old != b)
+    firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY,
+                       old,
+                       b);
+    if (hasFocus())
       {
-        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, old, b);
         revalidate();
         repaint();
       }
   }
 
-  /**
-   * Return the button's "focusTraversable" property. This property controls
-   * whether or not the button can receive focus when the user attempts to
-   * traverse the focus hierarchy.
-   *
-   * @return The current "focusTraversable" property
-   */
   public boolean isFocusTraversable()
   {
+    //Identifies whether or not this component can receive the focus.
     return true;
   }
 
-  /**
-   * Verifies that a particular key is one of the valid constants used for
-   * describing horizontal alignment and positioning. The valid constants
-   * are the following members of {@link SwingConstants}:
-   * <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,
-   * <code>LEADING</code> or <code>TRAILING</code>.
-   *
-   * @param key The key to check
-   * @param exception A message to include in an IllegalArgumentException
-   *
-   * @return the value of key
-   *
-   * @throws IllegalArgumentException If key is not one of the valid constants
-   *
-   * @see setHorizontalTextPosition()
-   * @see setHorizontalAlignment()
-   */
+
   protected  int checkHorizontalKey(int key, String exception)
   {
-    switch (key)
-      {
-      case SwingConstants.RIGHT:
-      case SwingConstants.LEFT:
-      case SwingConstants.CENTER:
-      case SwingConstants.LEADING:
-      case SwingConstants.TRAILING:
-        break;
-      default:
-        throw new IllegalArgumentException(exception);
-      }
-    return key;
+    //       Verify that key is a legal value for the horizontalAlignment properties.
+    return 0;
   }
 
-  /**
-   * Verifies that a particular key is one of the valid constants used for
-   * describing vertical alignment and positioning. The valid constants are
-   * the following members of {@link SwingConstants}: <code>TOP</code>,
-   * <code>BOTTOM</code> or <code>CENTER</code>.
-   *
-   * @param key The key to check
-   * @param exception A message to include in an IllegalArgumentException
-   *
-   * @return the value of key
-   *
-   * @throws IllegalArgumentException If key is not one of the valid constants
-   *
-   * @see setVerticalTextPosition()
-   * @see setVerticalAlignment()
-   */
   protected  int checkVerticalKey(int key, String exception)
   {
-    switch (key)
-      {
-      case SwingConstants.TOP:
-      case SwingConstants.BOTTOM:
-      case SwingConstants.CENTER:
-        break;
-      default:
-        throw new IllegalArgumentException(exception);
-      }
-    return key;
+    //       Ensures that the key is a valid.
+    return 0;
   }
 
-  /**
-   * Configure various properties of the button by reading properties
-   * of an {@link Action}. The mapping of properties is as follows:
-   *
-   * <table>
-   *
-   * <tr><th>Action keyed property</th> <th>AbstractButton property</th></tr>
-   *
-   * <tr><td>NAME                 </td> <td>text                   </td></tr>
-   * <tr><td>SMALL_ICON           </td> <td>icon                   </td></tr>
-   * <tr><td>SHORT_DESCRIPTION    </td> <td>toolTipText            </td></tr>
-   * <tr><td>MNEMONIC_KEY         </td> <td>mnemonic               </td></tr>
-   * <tr><td>ACTION_COMMAND_KEY   </td> <td>actionCommand          </td></tr>
-   *
-   * </table>
-   *
-   * <p>In addition, this method always sets the button's "enabled" property to
-   * the value of the Action's "enabled" property.</p>
-   *
-   * <p>If the provided Action is <code>null</code>, the text, icon, and
-   * toolTipText properties of the button are set to <code>null</code>, and
-   * the "enabled" property is set to <code>true</code>; the mnemonic and
-   * actionCommand properties are unchanged.</p>
-   *
-   * @param a An Action to configure the button from
-   */
   protected  void configurePropertiesFromAction(Action a)
   {
-    if (a == null)
-      {
-        setText(null);
-        setIcon(null);
-        setEnabled(true);
-        setToolTipText(null);
-      }
-    else
-      {
-        setText((String)(a.getValue(Action.NAME)));
-        setIcon((Icon)(a.getValue(Action.SMALL_ICON)));
-        setEnabled(a.isEnabled());
-        setToolTipText((String)(a.getValue(Action.SHORT_DESCRIPTION)));
-        setMnemonic(((Integer)(a.getValue(Action.MNEMONIC_KEY))).intValue());
-        setActionCommand((String)(a.getValue(Action.ACTION_COMMAND_KEY)));
-      }
+    //Factory method which sets the ActionEvent source's properties according to values from the Action instance.
   }
 
-  /**
-   * <p>A factory method which should return an {@link ActionListener} that
-   * propagates events from the button's {@link ButtonModel} to any of the
-   * button's ActionListeners. By default, this is an inner class which
-   * calls {@link AbstractButton.fireActionPerformed} with a modified copy
-   * of the incoming model {@link ActionEvent}.</p>
-   *
-   * <p>The button calls this method during construction, stores the
-   * resulting ActionListener in its <code>actionListener</code> member
-   * field, and subscribes it to the button's model. If the button's model
-   * is changed, this listener is unsubscribed from the old model and
-   * subscribed to the new one.</p>
-   *
-   * @return A new ActionListener 
-   */
   protected  ActionListener createActionListener()
   {
     return new ActionListener()
       {
-        public void actionPerformed(ActionEvent e)
-        {
-          e.setSource(AbstractButton.this);
-          AbstractButton.this.fireActionPerformed(e);
-        }
+        public void actionPerformed(ActionEvent e) { }
       };
   }
 
-  /**
-   * <p>A factory method which should return a {@link PropertyChangeListener}
-   * that accepts changes to the specified {@link Action} and reconfigure
-   * the {@link AbstractButton}, by default using the {@link
-   * configurePropertiesFromAction} method.</p>
-   *
-   * <p>The button calls this method whenever a new Action is assigned to
-   * the button's "action" property, via {@link setAction}, and stores the
-   * resulting PropertyChangeListener in its
-   * <code>actionPropertyChangeListener</code> member field. The button
-   * then subscribes the listener to the button's new action. If the
-   * button's action is changed subsequently, the listener is unsubscribed
-   * from the old action and subscribed to the new one.</p>
-   *
-   * @param a The Action which will be listened to, and which should be 
-   * the same as the source of any PropertyChangeEvents received by the
-   * new listener returned from this method.
-   *
-   * @return A new PropertyChangeListener
-   */
   protected  PropertyChangeListener createActionPropertyChangeListener(Action a)
   {
-    return new PropertyChangeListener()
-      {
-        public void propertyChange(PropertyChangeEvent e)
-        {
-          Action act = (Action)(e.getSource());
-          AbstractButton.this.configurePropertiesFromAction(act);
-        }
-      };
+    //Factory method which creates the PropertyChangeListener used to update the ActionEvent source as properties change on its Action instance.
+    return null;
   }
 
-  /**
-   * <p>Factory method which creates a {@link ChangeListener}, used to
-   * subscribe to ChangeEvents from the button's model. Subclasses of
-   * AbstractButton may wish to override the listener used to subscribe to
-   * such ChangeEvents. By default, the listener just propagates the
-   * {@link ChangeEvent} to the button's ChangeListeners, via the {@link
-   * AbstractButton.fireStateChanged} method.</p>
-   *
-   * <p>The button calls this method during construction, stores the
-   * resulting ChangeListener in its <code>changeListener</code> member
-   * field, and subscribes it to the button's model. If the button's model
-   * is changed, this listener is unsubscribed from the old model and
-   * subscribed to the new one.</p>
-   *
-   * @return The new ChangeListener
-   */
   protected  ChangeListener createChangeListener()
   {
+    //       Subclasses that want to handle ChangeEvents differently can override this to return another ChangeListener implementation.
     return new ChangeListener()
       {
-        public void stateChanged(ChangeEvent e)
-        {
-          AbstractButton.this.fireStateChanged(e);
-          AbstractButton.this.revalidate();
-          AbstractButton.this.repaint();          
-        }
+        public void stateChanged(ChangeEvent e) { }
       };
   }
 
-  /**
-   * <p>Factory method which creates a {@link ItemListener}, used to
-   * subscribe to ItemEvents from the button's model. Subclasses of
-   * AbstractButton may wish to override the listener used to subscribe to
-   * such ItemEvents. By default, the listener just propagates the
-   * {@link ItemEvent} to the button's ItemListeners, via the {@link
-   * AbstractButton.fireItemStateChanged} method.</p>
-   *
-   * <p>The button calls this method during construction, stores the
-   * resulting ItemListener in its <code>changeListener</code> member
-   * field, and subscribes it to the button's model. If the button's model
-   * is changed, this listener is unsubscribed from the old model and
-   * subscribed to the new one.</p>
-   *
-   * <p>Note that ItemEvents are only generated from the button's model
-   * when the model's <em>selected</em> property changes. If you want to
-   * subscribe to other properties of the model, you must subscribe to
-   * ChangeEvents.
-   *
-   * @return The new ItemListener
-   */
   protected  ItemListener createItemListener()
   {
     return new ItemListener()
       {
-        public void itemStateChanged(ItemEvent e)
-        {
-          AbstractButton.this.fireItemStateChanged(e);
-        }
+        public void itemStateChanged(ItemEvent e) { }
       };
   }
 
-  /**
-   * Programmatically perform a "click" on the button: arming, pressing,
-   * waiting, un-pressing, and disarming the model.
-   */
   public void doClick()
   {
     doClick(100);
   }
 
-  /**
-   * Programmatically perform a "click" on the button: arming, pressing,
-   * waiting, un-pressing, and disarming the model.
-   *
-   * @param pressTime The number of milliseconds to wait in the pressed state
-   */
   public void doClick(int pressTime)
   {
-    getModel().setArmed(true);
-    getModel().setPressed(true);
-    try
-  {
-        java.lang.Thread.sleep(pressTime);
+    //Toolkit.tlkBeep ();
+    //Programmatically perform a "click".
   }
-    catch (java.lang.InterruptedException e)
+
+  public Icon getDisabledSelectedIcon()
   {
-        // probably harmless
+    //Returns the icon used by the button when it's disabled and selected.
+    return disabled_selected_button;
   }
-    getModel().setPressed(false);
-    getModel().setArmed(false);
+
+  public Icon getRolloverIcon()
+  {
+    //       Returns the rollover icon for the button.
+    return null;
   }
 
-  /**
-   * Return the button's disabled selected icon. The look and feel class
-   * should paint this icon when the "enabled" property of the button's model
-   * is <code>false</code> and its "selected" property is
-   * <code>true</code>. This icon can be <code>null</code>, in which case
-   * it is synthesized from the button's selected icon.
-   *
-   * @return The current disabled selected icon
-   */
-  public Icon getDisabledSelectedIcon()
+  Icon getRolloverSelectedIcon()
   {
-    return disabled_selected_icon;
+    //       Returns the rollover selection icon for the button.
+    return null;
   }
 
-  /**
-   * Set the button's disabled selected icon. The look and feel class
-   * should paint this icon when the "enabled" property of the button's model
-   * is <code>false</code> and its "selected" property is
-   * <code>true</code>. This icon can be <code>null</code>, in which case
-   * it is synthesized from the button's selected icon.
-   *
-   * @param disabledSelectedIcon The new disabled selected icon
-   */
-  public void setDisabledSelectedIcon(Icon disabledSelectedIcon)
+  Icon getSelectedIcon()
   {
-    Icon old = disabled_selected_icon;
-    disabled_selected_icon = disabledSelectedIcon;
-    if (old != disabledSelectedIcon)
+    //       Returns the selected icon for the button.
+    return selected_button;
+  }
+
+  public Object[] getSelectedObjects()
   {
-        firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, old, 
-                           disabledSelectedIcon);
-        revalidate();
-        repaint();        
+    //Returns an array (length 1) containing the label or null if the button is not selected.
+    return null;
   }
+
+  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)
+  {
+    //This is overridden to return false if the current Icon's Image is not equal to the passed in Image img.
+    return current_icon == img;
   }
 
+  public boolean isContentAreaFilled()
+  {
+    //       Checks whether the "content area" of the button should be filled.
+    return false;
+  }
 
-  /**
-   * Return the button's rollover icon. The look and feel class should
-   * paint this icon when the "rolloverEnabled" property of the button is
-   * <code>true</code> and the mouse rolls over the button.
-   *
-   * @return The current rollover icon
-   */
-  public Icon getRolloverIcon()
+  protected  void paintBorder(Graphics g)
   {
-    return rollover_icon;
+    //       Paint the button's border if BorderPainted property is true.
+    if (isBorderPainted())
+      super.paintBorder(g);
   }
 
-  /**
-   * Set the button's rollover icon. The look and feel class should
-   * paint this icon when the "rolloverEnabled" property of the button is
-   * <code>true</code> and the mouse rolls over the button.
-   *
-   * @param rolloverIcon The new rollover icon
-   */
-  public void setRolloverIcon(Icon rolloverIcon)
+  protected  String paramString()
   {
-    Icon old = rollover_icon;
-    rollover_icon = rolloverIcon;
-    if (old != rolloverIcon)
+    //        Returns a string representation of this AbstractButton.
+    return "AbstractButton";
+  }
+
+  public void setContentAreaFilled(boolean b)
   {
-        firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, old, 
-                           rolloverIcon);
-        revalidate();
-        repaint();
-      }
+    //Sets whether the button should paint the content area or leave it transparent.
   }
 
-  /**
-   * Return the button's rollover selected icon. The look and feel class
-   * should paint this icon when the "rolloverEnabled" property of the button
-   * is <code>true</code>, the "selected" property of the button's model is
-   * <code>true</code>, and the mouse rolls over the button.
-   *
-   * @return The current rollover selected icon
-   */
-  Icon getRolloverSelectedIcon()
+  public void setDisabledSelectedIcon(Icon disabledSelectedIcon)
   {
-    return rollover_selected_icon;
+    //          Sets the disabled selection icon for the button.
   }
 
-  /**
-   * Set the button's rollover selected icon. The look and feel class
-   * should paint this icon when the "rolloverEnabled" property of the button
-   * is <code>true</code>, the "selected" property of the button's model is
-   * <code>true</code>, and the mouse rolls over the button.
-   *
-   * @param rolloverSelectedIcon The new rollover selected icon
-   */
-  public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)
+  public void setRolloverIcon(Icon rolloverIcon)
   {
-    Icon old = rollover_selected_icon;
-    rollover_selected_icon = rolloverSelectedIcon;
-    if (old != rolloverSelectedIcon)
+    //       Sets the rollover icon for the button.
+  }
+  public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)
   {
-        firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, old, 
-                           rolloverSelectedIcon);
-        revalidate();
-        repaint();
+    //       Sets the rollover selected icon for the button.
   }
+
+  public void setSelectedIcon(Icon selectedIcon)
+  {
+    //       Sets the selected icon for the button.
   }
 
+  public void setUI(ButtonUI ui)
+  {	//       Sets the L&F object that renders this component.
+    super.setUI(ui);
+  }
 
-  /**
-   * Return the button's selected icon. The look and feel class should
-   * paint this icon when the "selected" property of the button's model is
-   * <code>true</code>, and either the "rolloverEnabled" property of the
-   * button is <code>false</code> or the mouse is not currently rolled
-   * over the button.
-   *
-   * @return The current selected icon
-   */
-  Icon getSelectedIcon()
+  public ButtonUI getUI()
   {
-    return selected_icon;
+    //Returns the L&F object that renders this component.
+    return (ButtonUI) ui;
   }
 
-  /**
-   * Set the button's selected icon. The look and feel class should
-   * paint this icon when the "selected" property of the button's model is
-   * <code>true</code>, and either the "rolloverEnabled" property of the
-   * button is <code>false</code> or the mouse is not currently rolled
-   * over the button.
-   *
-   * @param selectedIcon The new selected icon
-   */
-  public void setSelectedIcon(Icon selectedIcon)
+  public void updateUI()
   {
-    Icon old = selected_icon;
-    selected_icon = selectedIcon;
-    if (old != selectedIcon)
+    /*
+    //          Notification from the UIFactory that the L&F has changed.
+    if (getUI() == null)
     {
-        firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, old, 
-                           selectedIcon);
-        revalidate();
-        repaint();
+    setUI(getUI());
     }
+    */
   }
 
-  /**
-   * Returns an single-element array containing the "text" property of the
-   * button if the "selected" property of the button's model is
-   * <code>true</code>, otherwise returns <code>null</code>.
-   *
-   * @return The button's "selected object" array
-   */
-  public Object[] getSelectedObjects()
+  protected void processActionEvent(ActionEvent e)
   {
-    if (isSelected())
-      {
-        Object[] objs = new Object[1];
-        objs[0] = getText();
-        return objs;
+    System.out.println("PROCESS-ACTION-EVENT: " + e);
   }
-    else
+
+  protected void processMouseEvent(MouseEvent e)
   {
-        return null;
-      }
-  }
+    //	System.out.println("PROCESS-MOUSE-EVENT: " + e + ", PRESSED-IN-MODEL="+getModel().isPressed());
 
-  /**
-   * Called when image data becomes available for one of the button's icons.
-   *
-   * @param img The image being updated
-   * @param infoflags One of the constant codes in {@link ImageObserver} used to describe
-   * updated portions of an image.
-   * @param x X coordinate of the region being updated
-   * @param y Y coordinate of the region being updated
-   * @param w Width of the region beign updated
-   * @param h Height of the region being updated
-   *
-   * @return <code>true</code> if img is equal to the button's current
-   * icon, otherwise <code>false</code>
-   */
-  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w,
-                             int h)
+    switch (e.getID())
+      {
+      case MouseEvent.MOUSE_MOVED:
         {
-    return current_icon == img;
+          break;
         }
-
-  /**
-   * Returns the value of the button's "contentAreaFilled" property. This
-   * property indicates whether the area surrounding the text and icon of
-   * the button should be filled by the look and feel class.  If this
-   * property is <code>false</code>, the look and feel class should leave
-   * the content area transparent.
-   *
-   * @return The current value of the "contentAreaFilled" property
-   */
-  public boolean isContentAreaFilled()
+      case MouseEvent.MOUSE_PRESSED:
+        {
+          if (! isEnabled())
             {
-    return content_area_filled;
+              System.out.println("button not enabled, ignoring press");
             }
-
-  /**
-   * Sets the value of the button's "contentAreaFilled" property. This
-   * property indicates whether the area surrounding the text and icon of
-   * the button should be filled by the look and feel class.  If this
-   * property is <code>false</code>, the look and feel class should leave
-   * the content area transparent.
-   *
-   * @param b The new value of the "contentAreaFilled" property
-   */
-  public void setContentAreaFilled(boolean b)
+          else
             {
-    boolean old = content_area_filled;
-    content_area_filled = b;
-    if (b != old)
-      {
-        firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, old, b);
-        revalidate();
+              System.out.println("telling model:press: " + getModel());
+              getModel().setPressed(true);
               repaint();
             }
+          break;
         }
 
-  /**
-   * Paints the button's border, if the button's "borderPainted" property is
-   * <code>true</code>, by out calling to the button's look and feel class.
-   *
-   * @param g The graphics context used to paint the border
-   */
-  protected void paintBorder(Graphics g)
+      case MouseEvent.MOUSE_RELEASED:
+        {
+          if (! isEnabled())
             {
-    if (isBorderPainted())
-      super.paintBorder(g);
+              System.out.println("button not enabled, ignoring release");
             }
+          else
+            {
+              int flags = 0;
 
-  /**
-   * Returns a string, used only for debugging, which identifies or somehow
-   * represents this button. The exact value is implementation-defined.
-   *
-   * @return A string representation of the button
-   */
-  protected String paramString()
-  {
-    return "AbstractButton";
-  }
+              System.out.println("        XXX--> " + getActionCommand());
 
+              fireActionPerformed(new ActionEvent(this,
+                                                  ActionEvent.ACTION_PERFORMED,
+                                                  getActionCommand(),
+                                                  flags));
 
-  /**
-   * Set the "UI" property of the button, which is a look and feel class
-   * responsible for handling the button's input events and painting it.
-   *
-   * @param ui The new "UI" property
-   */
-  public void setUI(ButtonUI ui)
+              //System.out.println("telling model:release");
+              getModel().setPressed(false);
+              repaint();
+            }
+          break;
+        }
+      case MouseEvent.MOUSE_CLICKED:
         {
-    super.setUI(ui);
+          break;
         }
-  
-  /**
-   * Set the "UI" property of the button, which is a look and feel class
-   * responsible for handling the button's input events and painting it.
-   *
-   * @return The current "UI" property
-   */
-  public ButtonUI getUI()
-  {
-    return (ButtonUI) ui;
       }
-  
-  /**
-   * Set the "UI" property to a class constructed, via the {@link
-   * UIManager}, from the current look and feel. This should be overridden
-   * for each subclass of AbstractButton, to retrieve a suitable {@link
-   * ButtonUI} look and feel class.
-   */
-  public void updateUI()
-  {
   }
 }
