--- /home/tromey/gnu/classpath/classpath/java/lang/StringBuffer.java	Sat Mar  9 22:59:02 2002
+++ java/lang/StringBuffer.java	Tue Jan 22 16:01:35 2002
@@ -1,5 +1,5 @@
 /* StringBuffer.java -- Growable strings
-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -36,876 +36,692 @@
 exception statement from your version. */
 
 package java.lang;
-
 import java.io.Serializable;
 
+/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
+ * Updated using online JDK 1.2 docs.
+ * Believed complete and correct to JDK 1.2.
+ * Merged with Classpath.
+ */
+
 /**
  * <code>StringBuffer</code> represents a changeable <code>String</code>.
  * It provides the operations required to modify the
- * <code>StringBuffer</code>, including insert, replace, delete, append,
- * and reverse. It is thread-safe; meaning that all modifications to a buffer
- * are in synchronized methods.
+ * <code>StringBuffer</code> including insert, replace, delete, append,
+ * and reverse.
+ * <P>
  *
- * <p><code>StringBuffer</code>s are variable-length in nature, so even if
+ * <code>StringBuffer</code>s are variable-length in nature, so even if
  * you initialize them to a certain size, they can still grow larger than
- * that. <em>Capacity</em> indicates the number of characters the
+ * that.  <EM>Capacity</EM> indicates the number of characters the
  * <code>StringBuffer</code> can have in it before it has to grow (growing
  * the char array is an expensive operation involving <code>new</code>).
+ * <P>
  *
- * <p>Incidentally, compilers often implement the String operator "+"
- * by using a <code>StringBuffer</code> operation:<br>
- * <code>a + b</code><br>
- * is the same as<br>
- * <code>new StringBuffer().append(a).append(b).toString()</code>.
+ * Incidentally, the String operator "+" actually is turned into a
+ * <code>StringBuffer</code> operation:
+ * <BR>
+ * <code>a + b</code>
+ * <BR>
+ * is the same as
+ * <BR>
+ * <code>new StringBuffer(a).append(b).toString()</code>.
  *
- * <p>Classpath's StringBuffer is capable of sharing memory with Strings for
- * efficiency.  This will help when a StringBuffer is converted to a String
- * and the StringBuffer is not changed after that (quite common when performing
- * string concatenation).
+ * @implnote Classpath's StringBuffer is capable of sharing memory with
+ *           Strings for efficiency.  This will help in two instances:
+ *           first, when a StringBuffer is created from a String but is
+ *           never changed, and second, when a StringBuffer is converted
+ *           to a String and the StringBuffer is not changed after that.
  *
+ * @since JDK1.0
  * @author Paul Fisher
  * @author John Keiser
  * @author Tom Tromey
- * @author Eric Blake <ebb9@email.byu.edu>
- * @see String
- * @since 1.0
- * @status updated to 1.4
+ * @see java.lang.String
  */
 public final class StringBuffer implements Serializable, CharSequence
 {
-  /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = 3388685877147921107L;
-
-  /**
-   * Index of next available character (and thus the size of the current
-   * string contents).  Note that this has permissions set this way so that
-   * String can get the value.
-   *
-   * @serial the number of characters in the buffer
-   */
-  int count;
-
-  /**
-   * The buffer.  Note that this has permissions set this way so that String
-   * can get the value.
-   *
-   * @serial the buffer
-   */
-  char[] value;
-
-  /**
-   * True if the buffer is shared with another object (StringBuffer or
-   * String); this means the buffer must be copied before writing to it again.
-   * Note that this has permissions set this way so that String can get the
-   * value.
-   *
-   * @serial whether the buffer is shared
-   */
-  boolean shared;
-
-  /**
-   * The default capacity of a buffer.
-   */
-  private final static int DEFAULT_CAPACITY = 16;
-
-  /**
-   * Create a new StringBuffer with default capacity 16.
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param bool the <code>boolean</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(boolean)
    */
-  public StringBuffer()
+  public StringBuffer append (boolean bool)
   {
-    this(DEFAULT_CAPACITY);
+    return append (String.valueOf(bool));
   }
 
-  /**
-   * Create an empty <code>StringBuffer</code> with the specified initial
-   * capacity.
-   *
-   * @param capacity the initial capacity
-   * @throws NegativeArraySizeException if capacity is negative
+  /** Append the <code>char</code> to this <code>StringBuffer</code>.
+   *  @param c the <code>char</code> to append.
+   *  @return this <code>StringBuffer</code>.
    */
-  public StringBuffer(int capacity)
+  public synchronized StringBuffer append (char ch)
   {
-    value = new char[capacity];
-  }
-
-  /**
-   * Create a new <code>StringBuffer</code> with the characters in the
-   * specified <code>String</code>. Initial capacity will be the size of the
-   * String plus 16.
-   *
-   * @param str the <code>String</code> to convert
-   * @throws NullPointerException if str is null
-   */
-  public StringBuffer(String str)
-  {
-    // Unfortunately, because the size is 16 larger, we cannot share.
-    count = str.count;
-    value = new char[count + DEFAULT_CAPACITY];
-    str.getChars(0, count, value, 0);
-  }
-
-  /**
-   * Get the length of the <code>String</code> this <code>StringBuffer</code>
-   * would create. Not to be confused with the <em>capacity</em> of the
-   * <code>StringBuffer</code>.
-   *
-   * @return the length of this <code>StringBuffer</code>
-   * @see #capacity()
-   * @see #setLength(int)
-   */
-  public synchronized int length()
-  {
-    return count;
-  }
-
-  /**
-   * Get the total number of characters this <code>StringBuffer</code> can
-   * support before it must be grown.  Not to be confused with <em>length</em>.
-   *
-   * @return the capacity of this <code>StringBuffer</code>
-   * @see #length()
-   * @see #ensureCapacity(int)
-   */
-  public synchronized int capacity()
-  {
-    return value.length;
-  }
-
-  /**
-   * Increase the capacity of this <code>StringBuffer</code>. This will
-   * ensure that an expensive growing operation will not occur until
-   * <code>minimumCapacity</code> is reached. The buffer is grown to the
-   * larger of <code>minimumCapacity</code> and
-   * <code>capacity() * 2 + 2</code>, if it is not already large enough.
-   *
-   * @param minimumCapacity the new capacity
-   * @see #capacity()
-   */
-  public synchronized void ensureCapacity(int minimumCapacity)
-  {
-    ensureCapacity_unsynchronized(minimumCapacity);
+    ensureCapacity_unsynchronized (count + 1);
+    value[count++] = ch;
+    return this;
   }
 
-  /**
-   * Set the length of this StringBuffer. If the new length is greater than
-   * the current length, all the new characters are set to '\0'. If the new
-   * length is less than the current length, the first <code>newLength</code>
-   * characters of the old array will be preserved, and the remaining
-   * characters are truncated.
-   *
-   * @param newLength the new length
-   * @throws IndexOutOfBoundsException if the new length is negative
-   *         (while unspecified, this is a StringIndexOutOfBoundsException)
-   * @see #length()
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param inum the <code>int</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(int)
    */
-  public synchronized void setLength(int newLength)
-  {
-    if (newLength < 0)
-      throw new StringIndexOutOfBoundsException(newLength);
-
-    ensureCapacity_unsynchronized(newLength);
-    while (count < newLength)
-      value[count++] = '\0';
-    count = newLength;
-  }
+  public native StringBuffer append (int inum);
 
-  /**
-   * Get the character at the specified index.
-   *
-   * @param index the index of the character to get, starting at 0
-   * @return the character at the specified index
-   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()
-   *         (while unspecified, this is a StringIndexOutOfBoundsException)
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param lnum the <code>long</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(long)
    */
-  public synchronized char charAt(int index)
+  public StringBuffer append (long lnum)
   {
-    if (index < 0 || index >= count)
-      throw new StringIndexOutOfBoundsException(index);
-    return value[index];
+    return append (String.valueOf(lnum));
   }
 
-  /**
-   * Get the specified array of characters. <code>srcOffset - srcEnd</code>
-   * characters will be copied into the array you pass in.
-   *
-   * @param srcOffset the index to start copying from (inclusive)
-   * @param srcEnd the index to stop copying from (exclusive)
-   * @param dst the array to copy into
-   * @param dstOffset the index to start copying into
-   * @throws NullPointerException if dst is null
-   * @throws IndexOutOfBoundsException if any source or target indices are
-   *         out of range (while unspecified, source problems cause a
-   *         StringIndexOutOfBoundsException, and dest problems cause an
-   *         ArrayIndexOutOfBoundsException)
-   * @see System#arraycopy(Object, int, Object, int, int)
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param fnum the <code>float</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(float)
    */
-  public synchronized void getChars(int srcOffset, int srcEnd,
-                                    char[] dst, int dstOffset)
+  public StringBuffer append (float fnum)
   {
-    int todo = srcEnd - srcOffset;
-    if (srcOffset < 0 || srcEnd > count || todo < 0)
-      throw new StringIndexOutOfBoundsException();
-    System.arraycopy(value, srcOffset, dst, dstOffset, todo);
+    return append (String.valueOf(fnum));
   }
 
-  /**
-   * Set the character at the specified index.
-   *
-   * @param index the index of the character to set starting at 0
-   * @param ch the value to set that character to
-   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()
-   *         (while unspecified, this is a StringIndexOutOfBoundsException)
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param dnum the <code>double</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(double)
    */
-  public synchronized void setCharAt(int index, char ch)
+  public StringBuffer append (double dnum)
   {
-    if (index < 0 || index >= count)
-      throw new StringIndexOutOfBoundsException(index);
-    // Call ensureCapacity to enforce copy-on-write.
-    ensureCapacity_unsynchronized(count);
-    value[index] = ch;
+    return append (String.valueOf(dnum));
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param obj the <code>Object</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(Object)
-   * @see #append(String)
+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param obj the <code>Object</code> to convert and append.
+   *  @return this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(java.lang.Object)
    */
-  public StringBuffer append(Object obj)
+  public StringBuffer append (Object obj)
   {
-    return append(obj == null ? "null" : obj.toString());
+    return append (String.valueOf(obj));
   }
 
-  /**
-   * Append the <code>String</code> to this <code>StringBuffer</code>. If
-   * str is null, the String "null" is appended.
-   *
-   * @param str the <code>String</code> to append
-   * @return this <code>StringBuffer</code>
+  /** Append the <code>String</code> to this <code>StringBuffer</code>.
+   *  @param str the <code>String</code> to append.
+   *  @return this <code>StringBuffer</code>.
    */
-  public synchronized StringBuffer append(String str)
+  public synchronized StringBuffer append (String str)
   {
     if (str == null)
       str = "null";
-    int len = str.count;
-    ensureCapacity_unsynchronized(count + len);
+    int len = str.length();
+    ensureCapacity_unsynchronized (count + len);
     str.getChars(0, len, value, count);
     count += len;
     return this;
   }
 
-  /**
-   * Append the <code>StringBuffer</code> value of the argument to this
-   * <code>StringBuffer</code>. This behaves the same as
-   * <code>append((Object) stringBuffer)</code>, except it is more efficient.
-   *
-   * @param stringBuffer the <code>StringBuffer</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see #append(Object)
-   * @since 1.4
-   */
-  public synchronized StringBuffer append(StringBuffer stringBuffer)
-  {
-    if (stringBuffer == null)
-      return append("null");
-    synchronized (stringBuffer)
-      {
-        int len = stringBuffer.count;
-        ensureCapacity_unsynchronized(count + len);
-        System.arraycopy(stringBuffer.value, 0, value, count, len);
-        count += len;
-      }
-    return this;
-  }
-
-  /**
-   * Append the <code>char</code> array to this <code>StringBuffer</code>.
-   * This is similar (but more efficient) than
-   * <code>append(new String(data))</code>, except in the case of null.
-   *
-   * @param data the <code>char[]</code> to append
-   * @return this <code>StringBuffer</code>
-   * @throws NullPointerException if <code>str</code> is <code>null</code>
-   * @see #append(char[], int, int)
+  /** Append the <code>char</code> array to this <code>StringBuffer</code>.
+   *  @param data the <code>char[]</code> to append.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.
    */
-  public StringBuffer append(char[] data)
+  public StringBuffer append (char[] data)
   {
-    return append(data, 0, data.length);
+    return append (data, 0, data.length);
   }
 
-  /**
-   * Append part of the <code>char</code> array to this
-   * <code>StringBuffer</code>. This is similar (but more efficient) than
-   * <code>append(new String(data, offset, count))</code>, except in the case
-   * of null.
-   *
-   * @param data the <code>char[]</code> to append
-   * @param offset the start location in <code>str</code>
-   * @param count the number of characters to get from <code>str</code>
-   * @return this <code>StringBuffer</code>
-   * @throws NullPointerException if <code>str</code> is <code>null</code>
-   * @throws IndexOutOfBoundsException if offset or count is out of range
-   *         (while unspecified, this is a StringIndexOutOfBoundsException)
+  /** Append the <code>char</code> array to this <code>StringBuffer</code>.
+   *  @param data the <code>char[]</code> to append.
+   *  @param offset the place to start grabbing characters from
+   *         <code>str</code>.
+   *  @param count the number of characters to get from <code>str</code>.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> or
+   *             <code>offset+len</code> is out of range.
    */
-  public synchronized StringBuffer append(char[] data, int offset, int count)
+  public synchronized StringBuffer append (char[] data, int offset, int count)
   {
-    ensureCapacity_unsynchronized(this.count + count);
+    ensureCapacity_unsynchronized (this.count + count);
     System.arraycopy(data, offset, value, this.count, count);
     this.count += count;
     return this;
+  } 
+
+  /** Get the total number of characters this <code>StringBuffer</code>
+   *  can support before it must be grown.  Not to be confused with
+   *  <em>length</em>.
+   *  @return the capacity of this <code>StringBuffer</code>
+   *  @see #length()
+   *  @see #ensureCapacity(int)
+   */
+  public int capacity ()
+  {
+    return value.length;
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param bool the <code>boolean</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(boolean)
+  /** Get the character at the specified index.
+   *  @param index the index of the character to get, starting at 0.
+   *  @return the character at the specified index.
+   *  @exception IndexOutOfBoundsException if the desired character index
+   *             is negative or greater then length() - 1.
    */
-  public StringBuffer append(boolean bool)
+  public synchronized char charAt (int index)
   {
-    return append(bool ? "true" : "false");
+    if (index >= count)
+      throw new StringIndexOutOfBoundsException (index);
+    return value[index];
   }
 
-  /**
-   * Append the <code>char</code> to this <code>StringBuffer</code>.
-   *
-   * @param c the <code>char</code> to append
-   * @return this <code>StringBuffer</code>
+  /** Delete characters from this <code>StringBuffer</code>.
+   *  <code>delete(10, 12)</code> will delete 10 and 11, but not 12.
+   *  @param start the first character to delete.
+   *  @param end the index after the last character to delete.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception StringIndexOutOfBoundsException if <code>start</code>
+   *             or <code>end-1</code> are out of bounds, or if
+   *             <code>start > end</code>.
    */
-  public synchronized StringBuffer append(char ch)
+  public synchronized StringBuffer delete (int start, int end)
   {
-    ensureCapacity_unsynchronized(count + 1);
-    value[count++] = ch;
+    if (start < 0 || start > count || start > end)
+      throw new StringIndexOutOfBoundsException (start);
+    if (end > count)
+      end = count;
+    // This will unshare if required.
+    ensureCapacity_unsynchronized (count);
+    if (count - end != 0)
+      System.arraycopy (value, end, value, start, count - end);
+    count -= (end - start);
     return this;
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param inum the <code>int</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(int)
+  /** Delete a character from this <code>StringBuffer</code>.
+   *  @param index the index of the character to delete.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception StringIndexOutOfBoundsException if <code>index</code>
+   *             is out of bounds.
    */
-  // This is native in libgcj, for efficiency.
-  public StringBuffer append(int inum)
+  public StringBuffer deleteCharAt(int index)
   {
-    return append(String.valueOf(inum));
+    return delete (index, index + 1);
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param lnum the <code>long</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(long)
+  /** Increase the capacity of this <code>StringBuffer</code>.
+   *  This will ensure that an expensive growing operation will not occur
+   *  until <code>minimumCapacity</code> is reached.
+   *  If the capacity is actually already greater than <code>minimumCapacity</code>
+   *  @param minimumCapacity the new capacity.
+   *  @see #capacity()
    */
-  public StringBuffer append(long lnum)
+  public synchronized void ensureCapacity (int minimumCapacity)
   {
-    return append(Long.toString(lnum, 10));
+    if (shared || minimumCapacity > value.length)
+      {
+	// We don't want to make a larger vector when `shared' is
+	// set.  If we do, then setLength becomes very inefficient
+	// when repeatedly reusing a StringBuffer in a loop.
+	int max = (minimumCapacity > value.length
+		   ? value.length*2+2
+		   : value.length);
+	minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);
+	char[] nb = new char[minimumCapacity];
+	System.arraycopy(value, 0, nb, 0, count);
+	value = nb;
+	shared = false;
+      }
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param fnum the <code>float</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(float)
-   */
-  public StringBuffer append(float fnum)
+  // ensureCapacity is used by several synchronized methods in StringBuffer.
+  // There's no need to synchronize again.
+  private void ensureCapacity_unsynchronized (int minimumCapacity)
   {
-    return append(Float.toString(fnum));
+    if (shared || minimumCapacity > value.length)
+      {
+	// We don't want to make a larger vector when `shared' is
+	// set.  If we do, then setLength becomes very inefficient
+	// when repeatedly reusing a StringBuffer in a loop.
+	int max = (minimumCapacity > value.length
+		   ? value.length*2+2
+		   : value.length);
+	minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);
+	char[] nb = new char[minimumCapacity];
+	System.arraycopy(value, 0, nb, 0, count);
+	value = nb;
+	shared = false;
+      }
   }
 
-  /**
-   * Append the <code>String</code> value of the argument to this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param dnum the <code>double</code> to convert and append
-   * @return this <code>StringBuffer</code>
-   * @see String#valueOf(double)
+  /** Get the specified array of characters.
+   *  The characters will be copied into the array you pass in.
+   *  @param srcOffset the index to start copying from in the
+   *         <code>StringBuffer</code>.
+   *  @param srcEnd the number of characters to copy.
+   *  @param dst the array to copy into.
+   *  @param dstOffset the index to start copying into <code>dst</code>.
+   *  @exception NullPointerException if dst is null.
+   *  @exception IndexOutOfBoundsException if any source or target
+   *             indices are out of range.
+   *  @see java.lang.System#arraycopy(java.lang.Object,int,java.lang.Object,int,int)
    */
-  public StringBuffer append(double dnum)
+  public synchronized void getChars (int srcOffset, int srcEnd,
+				     char[] dst, int dstOffset)
   {
-    return append(Double.toString(dnum));
+    if (srcOffset < 0 || srcOffset > srcEnd)
+      throw new StringIndexOutOfBoundsException (srcOffset);
+    int todo = srcEnd - srcOffset;
+    if (srcEnd > count || dstOffset + todo > count)
+      throw new StringIndexOutOfBoundsException (srcEnd);
+    System.arraycopy(value, srcOffset, dst, dstOffset, todo);
   }
 
-  /**
-   * Delete characters from this <code>StringBuffer</code>.
-   * <code>delete(10, 12)</code> will delete 10 and 11, but not 12. It is
-   * harmless for end to be larger than length().
-   *
-   * @param start the first character to delete
-   * @param end the index after the last character to delete
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if start or end are out of bounds
-   * @since 1.2
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param bool the <code>boolean</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(boolean)
+   */
+  public StringBuffer insert (int offset, boolean bool)
+  {
+    return insert (offset, bool ? "true" : "false");
+  }
+
+  /** Insert the <code>char</code> argument into this <code>StringBuffer</code>.
+   *  @param offset the place to insert.
+   *  @param ch the <code>char</code> to insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
    */
-  public synchronized StringBuffer delete(int start, int end)
+  public synchronized StringBuffer insert (int offset, char ch)
   {
-    if (start < 0 || start > count || start > end)
-      throw new StringIndexOutOfBoundsException(start);
-    if (end > count)
-      end = count;
-    // This will unshare if required.
-    ensureCapacity_unsynchronized(count);
-    if (count - end != 0)
-      System.arraycopy(value, end, value, start, count - end);
-    count -= end - start;
+    if (offset < 0 || offset > count)
+      throw new StringIndexOutOfBoundsException (offset);
+    ensureCapacity_unsynchronized (count+1);
+    System.arraycopy(value, offset, value, offset+1, count-offset);
+    value[offset] = ch;
+    count++;
     return this;
   }
 
-  /**
-   * Delete a character from this <code>StringBuffer</code>.
-   *
-   * @param index the index of the character to delete
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if index is out of bounds
-   * @since 1.2
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param inum the <code>int</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(int)
    */
-  public StringBuffer deleteCharAt(int index)
+  public StringBuffer insert (int offset, int inum)
   {
-    return delete(index, index + 1);
+    return insert (offset, String.valueOf(inum));
   }
 
-  /**
-   * Replace characters between index <code>start</code> (inclusive) and
-   * <code>end</code> (exclusive) with <code>str</code>. If <code>end</code>
-   * is larger than the size of this StringBuffer, all characters after
-   * <code>start</code> are replaced.
-   *
-   * @param start the beginning index of characters to delete (inclusive)
-   * @param end the ending index of characters to delete (exclusive)
-   * @param str the new <code>String</code> to insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if start or end are out of bounds
-   * @throws NullPointerException if str is null
-   * @since 1.2
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param lnum the <code>long</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(long)
    */
-  public synchronized StringBuffer replace(int start, int end, String str)
+  public StringBuffer insert (int offset, long lnum)
   {
-    if (start < 0 || start > count || start > end)
-      throw new StringIndexOutOfBoundsException(start);
-
-    int len = str.count;
-    // Calculate the difference in 'count' after the replace.
-    int delta = len - (end > count ? count : end) + start;
-    ensureCapacity_unsynchronized(count + delta);
-
-    if (delta != 0 && end < count)
-      System.arraycopy(value, end, value, end + delta, count - end);
-
-    str.getChars(0, len, value, start);
-    count += delta;
-    return this;
+    return insert (offset, String.valueOf(lnum));
   }
 
-  /**
-   * Creates a substring of this StringBuffer, starting at a specified index
-   * and ending at the end of this StringBuffer.
-   *
-   * @param beginIndex index to start substring (base 0)
-   * @return new String which is a substring of this StringBuffer
-   * @throws StringIndexOutOfBoundsException if beginIndex is out of bounds
-   * @see #substring(int, int)
-   * @since 1.2
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param fnum the <code>float</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(float)
    */
-  public String substring(int beginIndex)
+  public StringBuffer insert (int offset, float fnum)
   {
-    return substring(beginIndex, count);
+    return insert (offset, String.valueOf(fnum));
   }
 
-  /**
-   * Creates a substring of this StringBuffer, starting at a specified index
-   * and ending at one character before a specified index. This is implemented
-   * the same as <code>substring(beginIndex, endIndex)</code>, to satisfy
-   * the CharSequence interface.
-   *
-   * @param beginIndex index to start at (inclusive, base 0)
-   * @param endIndex index to end at (exclusive)
-   * @return new String which is a substring of this StringBuffer
-   * @throws IndexOutOfBoundsException if beginIndex or endIndex is out of
-   *         bounds
-   * @see #substring(int, int)
-   * @since 1.4
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param dnum the <code>double</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(double)
    */
-  public CharSequence subSequence(int beginIndex, int endIndex)
+  public StringBuffer insert (int offset, double dnum)
   {
-    return substring(beginIndex, endIndex);
+    return insert (offset, String.valueOf(dnum));
   }
 
-  /**
-   * Creates a substring of this StringBuffer, starting at a specified index
-   * and ending at one character before a specified index.
-   *
-   * @param beginIndex index to start at (inclusive, base 0)
-   * @param endIndex index to end at (exclusive)
-   * @return new String which is a substring of this StringBuffer
-   * @throws StringIndexOutOfBoundsException if beginIndex or endIndex is out
-   *         of bounds
-   * @since 1.2
-   */
-  public synchronized String substring(int beginIndex, int endIndex)
-  {
-    int len = endIndex - beginIndex;
-    if (beginIndex < 0 || endIndex > count || len < 0)
-      throw new StringIndexOutOfBoundsException();
-    if (len == 0)
-      return "";
-    // Share the char[] unless 3/4 empty.
-    shared = (len << 2) >= value.length;
-    // Package constructor avoids an array copy.
-    return new String(value, beginIndex, len, shared);
-  }
-
-  /**
-   * Insert a subarray of the <code>char[]</code> argument into this
-   * <code>StringBuffer</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param str the <code>char[]</code> to insert
-   * @param str_offset the index in <code>str</code> to start inserting from
-   * @param len the number of characters to insert
-   * @return this <code>StringBuffer</code>
-   * @throws NullPointerException if <code>str</code> is <code>null</code>
-   * @throws StringIndexOutOfBoundsException if any index is out of bounds
-   * @since 1.2
-   */
-  public synchronized StringBuffer insert(int offset,
-                                          char[] str, int str_offset, int len)
-  {
-    if (offset < 0 || offset > count || len < 0
-        || str_offset < 0 || str_offset + len > str.length)
-      throw new StringIndexOutOfBoundsException();
-    ensureCapacity_unsynchronized(count + len);
-    System.arraycopy(value, offset, value, offset + len, count - offset);
-    System.arraycopy(str, str_offset, value, offset, len);
-    count += len;
-    return this;
-  }
-
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param obj the <code>Object</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @exception StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(Object)
+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.
+   *  Uses <code>String.valueOf()</code> to convert to
+   *  <code>String</code>.
+   *  @param offset the place to insert.
+   *  @param obj the <code>Object</code> to convert and insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   *  @see java.lang.String#valueOf(java.lang.Object)
    */
-  public StringBuffer insert(int offset, Object obj)
+  public StringBuffer insert (int offset, Object obj)
   {
-    return insert(offset, obj == null ? "null" : obj.toString());
+    return insert (offset, String.valueOf(obj));
   }
 
-  /**
-   * Insert the <code>String</code> argument into this
-   * <code>StringBuffer</code>. If str is null, the String "null" is used
-   * instead.
-   *
-   * @param offset the place to insert in this buffer
-   * @param str the <code>String</code> to insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
+  /** Insert the <code>String</code> argument into this <code>StringBuffer</code>.
+   *  @param offset the place to insert.
+   *  @param str the <code>String</code> to insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
    */
-  public synchronized StringBuffer insert(int offset, String str)
+  public synchronized StringBuffer insert (int offset, String str)
   {
     if (offset < 0 || offset > count)
-      throw new StringIndexOutOfBoundsException(offset);
+      throw new StringIndexOutOfBoundsException (offset);
+    // Note that using `null' is from JDK 1.2.
     if (str == null)
       str = "null";
-    int len = str.count;
-    ensureCapacity_unsynchronized(count + len);
-    System.arraycopy(value, offset, value, offset + len, count - offset);
+    int len = str.length();
+    ensureCapacity_unsynchronized (count+len);
+    System.arraycopy(value, offset, value, offset+len, count-offset);
     str.getChars(0, len, value, offset);
     count += len;
     return this;
   }
 
-  /**
-   * Insert the <code>char[]</code> argument into this
-   * <code>StringBuffer</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param data the <code>char[]</code> to insert
-   * @return this <code>StringBuffer</code>
-   * @throws NullPointerException if <code>data</code> is <code>null</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see #insert(int, char[], int, int)
+  /** Insert the <code>char[]</code> argument into this
+   *  <code>StringBuffer</code>. 
+   *  @param offset the place to insert.
+   *  @param data the <code>char[]</code> to insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception NullPointerException if <code>data</code> is
+   *             <code>null</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range for this <code>StringBuffer</code>.
+   */
+  public StringBuffer insert (int offset, char[] data)
+  {
+    // One could check if offset is invalid here instead of making sure that
+    // data isn't null before dereferencing, but this works just as well.
+    return insert (offset, data, 0, data == null ? 0 : data.length);
+  }
+
+  /** Insert the <code>char[]</code> argument into this
+   *  <code>StringBuffer</code>.
+   *  @param offset the place to insert.
+   *  @param str the <code>char[]</code> to insert.
+   *  @param str_offset the index in <code>str</code> to start inserting
+   *         from.
+   *  @param len the number of characters to insert.
+   *  @return this <code>StringBuffer</code>.
+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.
+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out
+   *             of range, for this <code>StringBuffer</code>, or if
+   *             <code>str_offset</code> or <code>str_offset+len</code>
+   *             are out of range for <code>str</code>.
    */
-  public StringBuffer insert(int offset, char[] data)
+  public synchronized StringBuffer insert(int offset, char[] str,
+					  int str_offset, int len)
   {
-    return insert(offset, data, 0, data.length);
+    if (offset < 0 || offset > count)
+      throw new StringIndexOutOfBoundsException (offset);
+    if (len < 0)
+      throw new StringIndexOutOfBoundsException (len);
+    if (str_offset < 0 || str_offset + len > str.length)
+      throw new StringIndexOutOfBoundsException (str_offset);
+    ensureCapacity_unsynchronized (count + len);
+    System.arraycopy(value, offset, value, offset + len, count - offset);
+    System.arraycopy(str, str_offset, value, offset, len);
+    count += len;
+    return this;
   }
 
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param bool the <code>boolean</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(boolean)
+  /** Get the length of the <code>String</code> this
+   *  <code>StringBuffer</code> would create.  Not to be confused with the
+   *  <em>capacity</em> of the <code>StringBuffer</code>.
+   *  @return the length of this <code>StringBuffer</code>.
+   *  @see #capacity()
+   *  @see #setLength(int)
    */
-  public StringBuffer insert(int offset, boolean bool)
+  public int length ()
   {
-    return insert(offset, bool ? "true" : "false");
+    return count;
   }
 
-  /**
-   * Insert the <code>char</code> argument into this <code>StringBuffer</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param ch the <code>char</code> to insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
+  /** Replace characters between index <code>start</code> (inclusive) and 
+   *  <code>end</code> (exclusive) with <code>str</code>. If <code>end</code> 
+   *  is larger than the size of this StringBuffer, all characters after
+   *  <code>start</code> are replaced.
+   *  @param start the beginning index of characters to delete (inclusive).
+   *  @param end the ending index of characters to delete (exclusive).
+   *  @param str the new <code>String</code> to insert.
+   *  @return this <code>StringBuffer</code>.
    */
-  public synchronized StringBuffer insert(int offset, char ch)
+  public synchronized StringBuffer replace (int start, int end, String str)
   {
-    if (offset < 0 || offset > count)
-      throw new StringIndexOutOfBoundsException(offset);
-    ensureCapacity_unsynchronized(count + 1);
-    System.arraycopy(value, offset, value, offset + 1, count - offset);
-    value[offset] = ch;
-    count++;
-    return this;
+    if (start < 0 || start > count || start > end)
+      throw new StringIndexOutOfBoundsException (start);
+  
+    int len = str.length();
+    // Calculate the difference in 'count' after the replace.
+    int delta = len - ((end > count ? count : end) - start);
+    ensureCapacity_unsynchronized (count + delta);
+        
+    if (delta != 0 && end < count)
+      System.arraycopy(value, end, value, end + delta, count - end);
+    
+    str.getChars (0, len, value, start);    
+    count += delta;    
+    return this;    
   }
 
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param inum the <code>int</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(int)
+  /** Reverse the characters in this StringBuffer.
+   *  @return this <code>StringBuffer</code>.
    */
-  public StringBuffer insert(int offset, int inum)
+  public synchronized StringBuffer reverse ()
   {
-    return insert(offset, String.valueOf(inum));
+    // Call ensureCapacity to enforce copy-on-write.
+    ensureCapacity_unsynchronized (count);
+    for (int i = 0; i < count / 2; ++i)
+      {
+	char c = value[i];
+	value[i] = value[count - i - 1];
+	value[count - i - 1] = c;
+      }
+    return this;
   }
 
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param lnum the <code>long</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(long)
+  /** Set the character at the specified index.
+   *  @param index the index of the character to set starting at 0.
+   *  @param ch the value to set that character to.
+   *  @exception IndexOutOfBoundsException if the specified character
+   *             index is not between 0 and length() - 1 (inclusive).
    */
-  public StringBuffer insert(int offset, long lnum)
+  public synchronized void setCharAt (int index, char ch)
   {
-    return insert(offset, Long.toString(lnum, 10));
+    if (index < 0 || index >= count)
+      throw new StringIndexOutOfBoundsException (index);
+    // Call ensureCapacity to enforce copy-on-write.
+    ensureCapacity_unsynchronized (count);
+    value[index] = ch;
   }
 
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param fnum the <code>float</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(float)
+  /** Set the length of this StringBuffer.
+   *  <P>
+   *  If the new length is greater than the current length, all the new
+   *  characters are set to '\0'.
+   *  <P>
+   *  If the new length is less than the current length, the first
+   *  <code>newLength</code> characters of the old array will be
+   * @param newLength the new length
+   * @exception IndexOutOfBoundsException if the new length is
+   *            negative.
+   * @see #length()
    */
-  public StringBuffer insert(int offset, float fnum)
+  public synchronized void setLength (int newLength)
   {
-    return insert(offset, Float.toString(fnum));
+    if (newLength < 0)
+      throw new StringIndexOutOfBoundsException (newLength);
+
+    ensureCapacity_unsynchronized (newLength);
+    for (int i = count; i < newLength; ++i)
+      value[i] = '\0';
+    count = newLength;
   }
 
-  /**
-   * Insert the <code>String</code> value of the argument into this
-   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert
-   * to <code>String</code>.
-   *
-   * @param offset the place to insert in this buffer
-   * @param dnum the <code>double</code> to convert and insert
-   * @return this <code>StringBuffer</code>
-   * @throws StringIndexOutOfBoundsException if offset is out of bounds
-   * @see String#valueOf(double)
+  /** Create a new StringBuffer with default capacity 16.
+   *  @see JLS 20.13.1
    */
-  public StringBuffer insert(int offset, double dnum)
+  public StringBuffer ()
   {
-    return insert(offset, Double.toString(dnum));
+    this (DEFAULT_CAPACITY);
   }
 
-  /**
-   * Finds the first instance of a substring in this StringBuffer.
-   *
-   * @param str String to find
-   * @return location (base 0) of the String, or -1 if not found
-   * @throws NullPointerException if str is null
-   * @see #indexOf(String, int)
-   * @since 1.4
+  /** Create an empty <code>StringBuffer</code> with the specified initial capacity.
+   *  @param capacity the initial capacity.
    */
-  public int indexOf(String str)
+  public StringBuffer (int capacity)
   {
-    return indexOf(str, 0);
+    count = 0;
+    value = new char[capacity];
+    shared = false;
   }
 
-  /**
-   * Finds the first instance of a String in this StringBuffer, starting at
-   * a given index.  If starting index is less than 0, the search starts at
-   * the beginning of this String.  If the starting index is greater than the
-   * length of this String, or the substring is not found, -1 is returned.
-   *
-   * @param str String to find
-   * @param fromIndex index to start the search
-   * @return location (base 0) of the String, or -1 if not found
-   * @throws NullPointerException if str is null
-   * @since 1.4
-   */
-  public synchronized int indexOf(String str, int fromIndex)
-  {
-    if (fromIndex < 0)
-      fromIndex = 0;
-    int limit = count - str.count;
-    for ( ; fromIndex <= limit; fromIndex++)
-      if (regionMatches(fromIndex, str))
-        return fromIndex;
-    return -1;
+  /** Create a new <code>StringBuffer</code> with the characters in the specified <code>String</code>.
+   *  Initial capacity will be the size of the String plus 16.
+   *  @param str the <code>String</code> to make a <code>StringBuffer</code> out of.
+   *  @XXX optimize for sharing.
+   */
+  public StringBuffer (String str)
+  {
+    // The documentation is not clear, but experimentation with
+    // other implementations indicates that StringBuffer(null)
+    // should throw a NullPointerException.
+    count = str.length();
+    // JLS: The initial capacity of the string buffer is 16 plus the
+    // length of the argument string.
+    value = new char[count + DEFAULT_CAPACITY];
+    str.getChars(0, count, value, 0);
+    shared = false;
   }
 
   /**
-   * Finds the last instance of a substring in this StringBuffer.
+   * Creates a substring of this StringBuffer, starting at a specified index
+   * and ending at the end of this StringBuffer.
    *
-   * @param str String to find
-   * @return location (base 0) of the String, or -1 if not found
-   * @throws NullPointerException if str is null
-   * @see #lastIndexOf(String, int)
-   * @since 1.4
+   * @param beginIndex index to start substring (base 0)
+   * 
+   * @return new String which is a substring of this StringBuffer
+   *
+   * @exception StringIndexOutOfBoundsException 
+   *   if (beginIndex < 0 || beginIndex > this.length())
    */
-  public int lastIndexOf(String str)
+  public String substring (int beginIndex)
   {
-    return lastIndexOf(str, count - str.count);
+    return substring (beginIndex, count);
   }
 
   /**
-   * Finds the last instance of a String in this StringBuffer, starting at a
-   * given index.  If starting index is greater than the maximum valid index,
-   * then the search begins at the end of this String.  If the starting index
-   * is less than zero, or the substring is not found, -1 is returned.
+   * Creates a substring of this StringBuffer, starting at a specified index
+   * and ending at one character before a specified index.
    *
-   * @param str String to find
-   * @param fromIndex index to start the search
-   * @return location (base 0) of the String, or -1 if not found
-   * @throws NullPointerException if str is null
-   * @since 1.4
-   */
-  public synchronized int lastIndexOf(String str, int fromIndex)
-  {
-    fromIndex = Math.min(fromIndex, count - str.count);
-    for ( ; fromIndex >= 0; fromIndex--)
-      if (regionMatches(fromIndex, str))
-        return fromIndex;
-    return -1;
-  }
-
-  /**
-   * Reverse the characters in this StringBuffer. The same sequence of
-   * characters exists, but in the reverse index ordering.
+   * @param beginIndex index to start substring (base 0)
+   * @param endIndex index after the last character to be 
+   *   copied into the substring
+   * 
+   * @return new String which is a substring of this StringBuffer
    *
-   * @return this <code>StringBuffer</code>
+   * @exception StringIndexOutOfBoundsException 
+   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)
    */
-  public synchronized StringBuffer reverse()
+  public synchronized String substring (int beginIndex, int endIndex) 
   {
-    // Call ensureCapacity to enforce copy-on-write.
-    ensureCapacity_unsynchronized(count);
-    for (int i = count >> 1, j = count - i; --i >= 0; ++j)
-      {
-        char c = value[i];
-        value[i] = value[j];
-        value[j] = c;
-      }
-    return this;
+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex)
+      throw new StringIndexOutOfBoundsException ();
+    // FIXME: for libgcj it would be possible, and more efficient, to
+    // enable sharing here.
+    return new String (value, beginIndex, endIndex - beginIndex);
   }
 
   /**
-   * Convert this <code>StringBuffer</code> to a <code>String</code>. The
-   * String is composed of the characters currently in this StringBuffer. Note
-   * that the result is a copy, and that future modifications to this buffer
-   * do not affect the String.
+   * Creates a substring of this StringBuffer, starting at a specified index
+   * and ending at one character before a specified index.
+   * <p>
+   * To implement <code>CharSequence</code>.
+   * Calls <code>substring(beginIndex, endIndex)</code>.
+   *
+   * @param beginIndex index to start substring (base 0)
+   * @param endIndex index after the last character to be 
+   *   copied into the substring
+   * 
+   * @return new String which is a substring of this StringBuffer
    *
-   * @return the characters in this StringBuffer
+   * @exception StringIndexOutOfBoundsException 
+   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)
    */
-  public String toString()
+  public CharSequence subSequence (int beginIndex, int endIndex) 
   {
-    // The string will set this.shared = true.
-    return new String(this);
+    return substring(beginIndex, endIndex);
   }
 
-  /**
-   * An unsynchronized version of ensureCapacity, used internally to avoid
-   * the cost of a second lock on the same object. This also has the side
-   * effect of duplicating the array, if it was shared (to form copy-on-write
-   * semantics).
-   *
-   * @param minimumCapacity the minimum capacity
-   * @see #ensureCapacity(int)
+
+  /** Convert this <code>StringBuffer</code> to a <code>String</code>.
+   *  @return the characters in this StringBuffer
    */
-  private void ensureCapacity_unsynchronized(int minimumCapacity)
+  public String toString ()
   {
-    if (shared || minimumCapacity > value.length)
-      {
-        // We don't want to make a larger vector when `shared' is
-        // set.  If we do, then setLength becomes very inefficient
-        // when repeatedly reusing a StringBuffer in a loop.
-        int max = (minimumCapacity > value.length
-                   ? value.length * 2 + 2
-                   : value.length);
-        minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);
-        char[] nb = new char[minimumCapacity];
-        System.arraycopy(value, 0, nb, 0, count);
-        value = nb;
-        shared = false;
-      }
+    // Note: in libgcj this causes the StringBuffer to be shared.  In
+    // Classpath it does not.
+    return new String (this);
   }
 
-  /**
-   * Predicate which determines if a substring of this matches another String
-   * starting at a specified offset for each String and continuing for a
-   * specified length. This is more efficient than creating a String to call
-   * indexOf on.
-   *
-   * @param toffset index to start comparison at for this String
-   * @param other non-null String to compare to region of this
-   * @return true if regions match, false otherwise
-   * @see #indexOf(String, int)
-   * @see #lastIndexOf(String, int)
-   * @see String#regionMatches(boolean, int, String, int, int)
-   */
-  private boolean regionMatches(int toffset, String other)
-  {
-    int len = other.count;
-    int index = other.offset;
-    while (--len >= 0)
-      if (value[toffset++] != other.value[index++])
-        return false;
-    return true;
-  }
+  // Index of next available character.  Note that this has
+  // permissions set this way so that String can get the value.
+  int count;
+
+  // The buffer.  Note that this has permissions set this way so that
+  // String can get the value.
+  char[] value;
+
+  // True if we need to copy the buffer before writing to it again.
+  // FIXME: JDK 1.2 doesn't specify this.  The new buffer-growing
+  // semantics make this less useful in that case, too.  Note that
+  // this has permissions set this way so that String can get the
+  // value.
+  boolean shared;
+
+  static final long serialVersionUID = 3388685877147921107L;
+  private final static int DEFAULT_CAPACITY = 16; // JLS 20.13.1
 }
