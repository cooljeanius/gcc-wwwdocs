--- /home/tromey/gnu/classpath/classpath/java/nio/ByteBuffer.java	Mon Dec 30 15:39:05 2002
+++ java/nio/ByteBuffer.java	Thu Feb 13 08:56:23 2003
@@ -45,16 +45,16 @@
 public abstract class ByteBuffer extends Buffer implements Comparable
 {
   private ByteOrder endian = ByteOrder.BIG_ENDIAN;
-  
-  protected byte [] backing_buffer;
+
+  int offset;
+  byte[] backing_buffer;
   
   /**
    * Allocates a new direct byte buffer.
    */ 
   public static ByteBuffer allocateDirect (int capacity)
   {
-    ByteBuffer b = new gnu.java.nio. ByteBufferImpl(capacity, 0, capacity);
-    return b;
+    throw new Error ("direct buffers are not implemented");
   }
 
   /**
@@ -75,7 +75,7 @@
   {
     return new ByteBufferImpl (array, offset, length);
   }
- 
+
   /**
    * Wraps a byte array into a buffer.
    */
@@ -84,6 +84,11 @@
     return wrap (array, 0, array.length);
   }
 
+  ByteBuffer (int capacity, int limit, int position, int mark)
+  {
+    super (capacity, limit, position, mark);
+  }
+
   /**
    * This method transfers bytes from this buffer into
    * the given destination array.
@@ -101,10 +106,10 @@
    */
   public ByteBuffer get (byte[] dst, int offset, int length)
   {
-    if ((offset < 0) ||
-        (offset > dst.length) ||
-        (length < 0) ||
-        (length > (dst.length - offset)))
+    if ((offset < 0)
+        || (offset > dst.length)
+        || (length < 0)
+        || (length > (dst.length - offset)))
       throw new IndexOutOfBoundsException ();
 
     for (int i = offset; i < offset + length; i++)
@@ -145,9 +150,7 @@
       throw new IllegalArgumentException ();
 
     while (src.hasRemaining ())
-      {
-        put (src.get ());
-      }
+      put (src.get ());
     
     return this;
   }
@@ -176,10 +179,8 @@
       throw new IndexOutOfBoundsException ();
 
     for (int i = offset; i < offset + length; i++)
-      {
-        put (src [i]);
-      }
-
+      put (src [i]);
+    
     return this;
   }
 
@@ -200,9 +201,10 @@
   /**
    * Tells whether or not this buffer is backed by an accessible byte array.
    */
-  public final boolean hasArray()
+  public final boolean hasArray ()
   {
-    return (backing_buffer != null);
+    return (backing_buffer != null
+             && !isReadOnly ());
   }
 
   /**
@@ -213,7 +215,7 @@
    * @exception UnsupportedOperationException If this buffer is not backed
    * by an accessible array.
    */
-  public final byte[] array()
+  public final byte[] array ()
   {
     if (backing_buffer == null)
       throw new UnsupportedOperationException ();
@@ -233,7 +235,7 @@
    * @exception UnsupportedOperationException If this buffer is not backed
    * by an accessible array.
    */
-  public final int arrayOffset()
+  public final int arrayOffset ()
   {
     if (backing_buffer == null)
       throw new UnsupportedOperationException ();
@@ -241,20 +243,10 @@
     if (isReadOnly ())
       throw new ReadOnlyBufferException ();
 
-    // FIXME: Return correct value
-    return 0;
+    return offset;
   }
   
   /**
-   * Returns the current hash code of this buffer.
-   */
-  public int hashCode()
-  {
-    // FIXME: Check what SUN calcs here
-    return super.hashCode();
-  }
-
-  /**
    * Tells whether or not this buffer is equal to another object.
    */
   public boolean equals (Object obj)
@@ -610,6 +602,9 @@
    */
   public String toString ()
   {
-    return "";
+    return getClass ().getName () +
+	    "[pos=" + position () +
+	    " lim=" + limit () +
+	    " cap=" + capacity () + "]";
   }
 }
