--- /home/tromey/gnu/Nightly/classpath/classpath/java/nio/ByteBuffer.java	2004-02-12 02:22:33.000000000 -0700
+++ java/nio/ByteBuffer.java	2004-02-17 02:18:13.000000000 -0700
@@ -44,7 +44,7 @@
 public abstract class ByteBuffer extends Buffer
   implements Comparable
 {
-  private ByteOrder endian = ByteOrder.BIG_ENDIAN;
+  ByteOrder endian = ByteOrder.BIG_ENDIAN;
 
   int array_offset;
   byte[] backing_buffer;
@@ -52,16 +52,8 @@
   ByteBuffer (int capacity, int limit, int position, int mark)
   {
     super (capacity, limit, position, mark);
-    array_offset = 0;
   }
 
-  ByteBuffer (byte[] buffer, int offset, int capacity, int limit, int position, int mark)
-  {
-    super (capacity, limit, position, mark);
-    this.backing_buffer = buffer;
-    this.array_offset = offset;
-  }
-  
   /**
    * Allocates a new direct byte buffer.
    */ 
@@ -75,7 +67,7 @@
    */
   public static ByteBuffer allocate (int capacity)
   {
-    return new ByteBufferImpl (capacity);
+    return wrap(new byte[capacity], 0, capacity);
   }
 
   /**
@@ -87,6 +79,14 @@
    */
   final public static ByteBuffer wrap (byte[] array, int offset, int length)
   {
+    // FIXME: In GCJ and other implementations where arrays may not
+    // move we might consider, at least when offset==0:
+    // return new DirectByteBufferImpl(array,
+    //                                 address_of_data(array) + offset,
+    //                                 length, length, 0, false);
+    // This may be more efficient, mainly because we can then use the
+    // same logic for all ByteBuffers.
+
     return new ByteBufferImpl (array, 0, array.length, offset + length, offset, -1, false);
   }
 
@@ -116,11 +116,10 @@
    */
   public ByteBuffer get (byte[] dst, int offset, int length)
   {
-    if ((offset < 0)
-        || (offset > dst.length)
-        || (length < 0)
-        || (length > (dst.length - offset)))
+    if (offset < 0 || length < 0 || offset + length > dst.length)
       throw new IndexOutOfBoundsException ();
+    if (length > remaining())
+      throw new BufferUnderflowException();
 
     for (int i = offset; i < offset + length; i++)
       {
