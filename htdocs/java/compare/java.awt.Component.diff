--- /home/tromey/gnu/classpath/classpath/java/awt/Component.java	Thu May  9 19:18:47 2002
+++ java/awt/Component.java	Mon Mar 25 00:03:18 2002
@@ -1,5 +1,4 @@
-/* Component.java -- a graphics component
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation
+/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -35,533 +34,122 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
-
 package java.awt;
-
-import java.awt.dnd.DropTarget;
-import java.awt.event.ComponentEvent;
-import java.awt.event.ComponentListener;
-import java.awt.event.FocusEvent;
-import java.awt.event.FocusListener;
-import java.awt.event.HierarchyBoundsListener;
-import java.awt.event.HierarchyEvent;
-import java.awt.event.HierarchyListener;
-import java.awt.event.KeyEvent;
-import java.awt.event.KeyListener;
-import java.awt.event.InputMethodEvent;
-import java.awt.event.InputMethodListener;
-import java.awt.event.MouseEvent;
-import java.awt.event.MouseListener;
-import java.awt.event.MouseMotionListener;
-import java.awt.event.MouseWheelListener;
-import java.awt.event.MouseWheelEvent;
-import java.awt.event.PaintEvent;
-import java.awt.im.InputContext;
-import java.awt.im.InputMethodRequests;
-import java.awt.image.BufferStrategy;
-import java.awt.image.ColorModel;
-import java.awt.image.ImageObserver;
-import java.awt.image.ImageProducer;
-import java.awt.image.VolatileImage;
-import java.awt.peer.ComponentPeer;
-import java.awt.peer.LightweightPeer;
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyChangeSupport;
-import java.io.ObjectInputStream;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
+import java.awt.event.*;
+import java.awt.image.*;
 import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.io.Serializable;
-import java.lang.reflect.Array;
-import java.util.Collections;
+import java.lang.reflect.*;
 import java.util.EventListener;
-import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Locale;
-import java.util.Set;
+import java.util.ResourceBundle;
 import java.util.Vector;
-import javax.accessibility.Accessible;
-import javax.accessibility.AccessibleComponent;
-import javax.accessibility.AccessibleContext;
-import javax.accessibility.AccessibleRole;
-import javax.accessibility.AccessibleState;
-import javax.accessibility.AccessibleStateSet;
+import java.awt.peer.ComponentPeer;
+import java.awt.peer.LightweightPeer;
+import java.beans.PropertyChangeSupport;
+import java.beans.PropertyChangeListener;
+// import javax.accessibility.AccessibleContext;
 
 /**
- * The root of all evil. All graphical representations are subclasses of this
- * giant class, which is designed for screen display and user interaction.
- * This class can be extended directly to build a lightweight component (one
- * not associated with a native window); lightweight components must reside
- * inside a heavyweight window.
- *
- * <p>This class is Serializable, which has some big implications. A user can
- * save the state of all graphical components in one VM, and reload them in
- * another. Note that this class will only save Serializable listeners, and
- * ignore the rest, without causing any serialization exceptions. However, by
- * making a listener serializable, and adding it to another element, you link
- * in that entire element to the state of this component. To get around this,
- * use the idiom shown in the example below - make listeners non-serializable
- * in inner classes, rather than using this object itself as the listener, if
- * external objects do not need to save the state of this object.
- *
- * <p><pre>
- * import java.awt.*;
- * import java.awt.event.*;
- * import java.io.Serializable;
- * class MyApp implements Serializable
- * {
- *   BigObjectThatShouldNotBeSerializedWithAButton bigOne;
- *   // Serializing aButton will not suck in an instance of MyApp, with its
- *   // accompanying field bigOne.
- *   Button aButton = new Button();
- *   class MyActionListener implements ActionListener
- *   {
- *     public void actionPerformed(ActionEvent e)
- *     {
- *       System.out.println("Hello There");
- *     }
- *   }
- *   MyApp()
- *   {
- *     aButton.addActionListener(new MyActionListener());
- *   }
- * }
- *
- * <p>Status: Incomplete. The event dispatch mechanism is implemented. All
- * other methods defined in the J2SE 1.3 API javadoc exist, but are mostly
- * incomplete or only stubs; except for methods relating to the Drag and
- * Drop, Input Method, and Accessibility frameworks: These methods are
- * present but commented out.
- *
- * @author original author unknown
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.0
- * @status still missing 1.4 support
- */
-public abstract class Component
-  implements ImageObserver, MenuContainer, Serializable
+  * The root of all evil.
+  *
+  * Status: Incomplete. The event dispatch mechanism is implemented. All 
+  * other methods defined in the J2SE 1.3 API javadoc exist, but are mostly 
+  * incomplete or only stubs; except for methods relating to the Drag and Drop, 
+  * Input Method, and Accessibility frameworks: These methods are present but 
+  * commented out.
+  */
+public abstract class Component implements ImageObserver, MenuContainer, 
+					   java.io.Serializable
 {
-  // Word to the wise - this file is huge. Search for '\f' (^L) for logical
-  // sectioning by fields, public API, private API, and nested classes.
-
-
-  /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = -7644114512714619750L;
-
   /**
    * Constant returned by the <code>getAlignmentY</code> method to indicate
-   * that the component wishes to be aligned to the top relative to
+   * that the component wishes to be aligned to the bottom relative to
    * other components.
-   *
-   * @see #getAlignmentY()
    */
-  public static final float TOP_ALIGNMENT = 0;
+  public static final float BOTTOM_ALIGNMENT = (float)1.0;
 
   /**
-   * Constant returned by the <code>getAlignmentY</code> and
+   * Constant returned by the <code>getAlignmentY</code> and 
    * <code>getAlignmentX</code> methods to indicate
    * that the component wishes to be aligned to the center relative to
    * other components.
-   *
-   * @see #getAlignmentX()
-   * @see #getAlignmentY()
    */
-  public static final float CENTER_ALIGNMENT = 0.5f;
+  public static final float CENTER_ALIGNMENT = (float)0.5;
 
   /**
    * Constant returned by the <code>getAlignmentY</code> method to indicate
-   * that the component wishes to be aligned to the bottom relative to
+   * that the component wishes to be aligned to the top relative to
    * other components.
-   *
-   * @see #getAlignmentY()
    */
-  public static final float BOTTOM_ALIGNMENT = 1;
+  public static final float TOP_ALIGNMENT = (float)0.0;
 
   /**
    * Constant returned by the <code>getAlignmentX</code> method to indicate
    * that the component wishes to be aligned to the right relative to
    * other components.
-   *
-   * @see #getAlignmentX()
    */
-  public static final float RIGHT_ALIGNMENT = 1;
+  public static final float RIGHT_ALIGNMENT = (float)1.0;
 
   /**
    * Constant returned by the <code>getAlignmentX</code> method to indicate
    * that the component wishes to be aligned to the left relative to
    * other components.
-   *
-   * @see #getAlignmentX()
-   */
-  public static final float LEFT_ALIGNMENT = 0;
-
-  /**
-   * Make the treelock a String so that it can easily be identified
-   * in debug dumps. We clone the String in order to avoid a conflict in
-   * the unlikely event that some other package uses exactly the same string
-   * as a lock object.
    */
-  static final Object treeLock = new String("AWT_TREE_LOCK");
+  public static final float LEFT_ALIGNMENT = (float)0.0;
 
-  // Serialized fields from the serialization spec.
+  /* Make the treelock a String so that it can easily be identified
+     in debug dumps. We clone the String in order to avoid a conflict in 
+     the unlikely event that some other package uses exactly the same string
+     as a lock object. */
+  static Object treeLock = new String("AWT_TREE_LOCK");
 
-  /**
-   * The x position of the component in the parent's coordinate system.
-   *
-   * @see #getLocation()
-   * @serial the x position
-   */
+  /* Serialized fields from the serialization spec. */
+  // FIXME: Default values?
   int x;
-
-  /**
-   * The y position of the component in the parent's coordinate system.
-   *
-   * @see #getLocation()
-   * @serial the y position
-   */
   int y;
-
-  /**
-   * The component width.
-   *
-   * @see #getSize()
-   * @serial the width
-   */
   int width;
-
-  /**
-   * The component height.
-   *
-   * @see #getSize()
-   * @serial the height
-   */
   int height;
-
-  /**
-   * The foreground color for the component. This may be null.
-   *
-   * @see #getForeground()
-   * @see #setForeground(Color)
-   * @serial the foreground color
-   */
   Color foreground;
-
-  /**
-   * The background color for the component. This may be null.
-   *
-   * @see #getBackground()
-   * @see #setBackground(Color)
-   * @serial the background color
-   */
   Color background;
-
-  /**
-   * The default font used in the component. This may be null.
-   *
-   * @see #getFont()
-   * @see #setFont(Font)
-   * @serial the font
-   */
   Font font;
-
-  /**
-   * The font in use by the peer, or null if there is no peer.
-   *
-   * @serial the peer's font
-   */
   Font peerFont;
-
-  /**
-   * The cursor displayed when the pointer is over this component. This may
-   * be null.
-   *
-   * @see #getCursor()
-   * @see #setCursor(Cursor)
-   */
   Cursor cursor;
-
-  /**
-   * The locale for the component.
-   *
-   * @see #getLocale()
-   * @see #setLocale(Locale)
-   */
   Locale locale;
-
-  /**
-   * True if the object should ignore repaint events (usually because it is
-   * not showing).
-   *
-   * @see #getIgnoreRepaint()
-   * @see #setIgnoreRepaint(boolean)
-   * @serial true to ignore repaints
-   * @since 1.4
-   */
-  boolean ignoreRepaint;
-
-  /**
-   * True when the object is visible (although it is only showing if all
-   * ancestors are likewise visible). For component, this defaults to true.
-   *
-   * @see #isVisible()
-   * @see #setVisible(boolean)
-   * @serial true if visible
-   */
-  boolean visible = true;
-
-  /**
-   * True if the object is enabled, meaning it can interact with the user.
-   * For component, this defaults to true.
-   *
-   * @see #isEnabled()
-   * @see #setEnabled(boolean)
-   * @serial true if enabled
-   */
+  boolean visible = true; // default (except for Window)
   boolean enabled = true;
-
-  /**
-   * True if the object is valid. This is set to false any time a size
-   * adjustment means the component need to be layed out again.
-   *
-   * @see #isValid()
-   * @see #validate()
-   * @see #invalidate()
-   * @serial true if layout is valid
-   */
   boolean valid;
-
-  /**
-   * The DropTarget for drag-and-drop operations.
-   *
-   * @see #getDropTarget()
-   * @see #setDropTarget(DropTarget)
-   * @serial the drop target, or null
-   * @since 1.2
-   */
-  DropTarget dropTarget;
-
-  /**
-   * The list of popup menus for this component.
-   *
-   * @see #add(PopupMenu)
-   * @serial the list of popups
-   */
+  boolean hasFocus;
+  //DropTarget dropTarget;
   Vector popups;
-
-  /**
-   * The component's name. May be null, in which case a default name is
-   * generated on the first use.
-   *
-   * @see #getName()
-   * @see #setName(String)
-   * @serial the name
-   */
   String name;
-
-  /**
-   * True once the user has set the name. Note that the user may set the name
-   * to null.
-   *
-   * @see #name
-   * @see #getName()
-   * @see #setName(String)
-   * @serial true if the name has been explicitly set
-   */
   boolean nameExplicitlySet;
-
-  /**
-   * Indicates if the object can be focused. Defaults to true for components.
-   *
-   * @see #isFocusable()
-   * @see #setFocusable(boolean)
-   * @since 1.4
-   */
-  boolean focusable = true;
-
-  /**
-   * Tracks whether this component uses default focus traversal, or has a
-   * different policy.
-   *
-   * @see #isFocusTraversableOverridden()
-   * @since 1.4
-   */
-  int isFocusTraversableOverridden;
-
-  /**
-   * The focus traversal keys, if not inherited from the parent or default
-   * keyboard manager. These sets will contain only AWTKeyStrokes that
-   * represent press and release events to use as focus control.
-   *
-   * @see #getFocusTraversalKeys(int)
-   * @see #setFocusTraversalKeys(int, Set)
-   * @since 1.4
-   */
-  Set[] focusTraversalKeys;
-
-  /**
-   * True if focus traversal keys are enabled. This defaults to true for
-   * Component. If this is true, keystrokes in focusTraversalKeys are trapped
-   * and processed automatically rather than being passed on to the component.
-   *
-   * @see #getFocusTraversalKeysEnabled()
-   * @see #setFocusTraversalKeysEnabled(boolean)
-   * @since 1.4
-   */
-  boolean focusTraversalKeysEnabled = true;
-
-  /**
-   * Cached information on the minimum size. Should have been transient.
-   *
-   * @serial ignore
-   */
   Dimension minSize;
-
-  /**
-   * Cached information on the preferred size. Should have been transient.
-   *
-   * @serial ignore
-   */
   Dimension prefSize;
-
-  /**
-   * Set to true if an event is to be handled by this component, false if
-   * it is to be passed up the hierarcy.
-   *
-   * @see #dispatchEvent(AWTEvent)
-   * @serial true to process event locally
-   */
-  boolean newEventsOnly;
-
-  /**
-   * Set by subclasses to enable event handling of particular events, and
-   * left alone when modifying listeners. For component, this defaults to
-   * enabling only input methods.
-   *
-   * @see #enableInputMethods(boolean)
-   * @see AWTEvent
-   * @serial the mask of events to process
-   */
-  long eventMask = AWTEvent.INPUT_ENABLED_EVENT_MASK;
-
-  /**
-   * Describes all registered PropertyChangeListeners.
-   *
-   * @see #addPropertyChangeListener(PropertyChangeListener)
-   * @see #removePropertyChangeListener(PropertyChangeListener)
-   * @see #firePropertyChange(String, Object, Object)
-   * @serial the property change listeners
-   * @since 1.2
-   */
+  boolean newEventsOnly;  
+  long eventMask = AWTEvent.PAINT_EVENT_MASK;
   PropertyChangeSupport changeSupport;
-
-  /**
-   * True if the component has been packed (layed out).
-   *
-   * @serial true if this is packed
-   */
   boolean isPacked;
+  int componentSerializedDataVersion;
+  /* AccessibleContext accessibleContext; */
 
-  /**
-   * The serialization version for this class. Currently at version 4.
-   *
-   * XXX How do we handle prior versions?
-   *
-   * @serial the serialization version
-   */
-  int componentSerializedDataVersion = 4;
-
-  /**
-   * The accessible context associated with this component. This is only set
-   * by subclasses.
-   *
-   * @see #getAccessibleContext()
-   * @serial the accessibility context
-   * @since 1.2
-   */
-  AccessibleContext accessibleContext;
-
-
-  // Guess what - listeners are special cased in serialization. See
-  // readObject and writeObject.
+  /* Anything else is non-serializable, and should be declared "transient". */
+  transient Container parent;
+  transient java.awt.peer.ComponentPeer peer;
 
-  /** Component listener chain. */
   transient ComponentListener componentListener;
-
-  /** Focus listener chain. */
   transient FocusListener focusListener;
-
-  /** Key listener chain. */
   transient KeyListener keyListener;
-
-  /** Mouse listener chain. */
   transient MouseListener mouseListener;
-
-  /** Mouse motion listener chain. */
   transient MouseMotionListener mouseMotionListener;
-
-  /**
-   * Mouse wheel listener chain.
-   *
-   * @since 1.4
-   */
-  transient MouseWheelListener mouseWheelListener;
-
-  /**
-   * Input method listener chain.
-   *
-   * @since 1.2
-   */
   transient InputMethodListener inputMethodListener;
-
-  /**
-   * Hierarcy listener chain.
-   *
-   * @since 1.3
-   */
   transient HierarchyListener hierarchyListener;
-
-  /**
-   * Hierarcy bounds listener chain.
-   *
-   * @since 1.3
-   */
   transient HierarchyBoundsListener hierarchyBoundsListener;
 
-  // Anything else is non-serializable, and should be declared "transient".
-
-  /** The parent. */
-  transient Container parent;
-
-  /** The associated native peer. */
-  transient ComponentPeer peer;
-
-  /** The preferred component orientation. */
   transient ComponentOrientation orientation = ComponentOrientation.UNKNOWN;
 
   /**
-   * The associated graphics configuration.
-   *
-   * @since 1.4
-   */
-  transient GraphicsConfiguration graphicsConfig;
-
-  /**
-   * The buffer strategy for repainting.
-   *
-   * @since 1.4
-   */
-  transient BufferStrategy bufferStrategy;
-
-
-  // Public and protected API.
-
-  /**
-   * Default constructor for subclasses. When Component is extended directly,
-   * it forms a lightweight component that must be hosted in an opaque native
-   * container higher in the tree.
+   * Default constructor for subclasses.
    */
   protected Component()
   {
@@ -570,13 +158,11 @@
   /**
    * Returns the name of this component.
    *
-   * @return the name of this component
-   * @see #setName(String)
-   * @since 1.1
+   * @return The name of this component.
    */
   public String getName()
   {
-    if (name == null && ! nameExplicitlySet)
+    if (name == null && !nameExplicitlySet)
       name = generateName();
     return name;
   }
@@ -584,130 +170,136 @@
   /**
    * Sets the name of this component to the specified name.
    *
-   * @param name the new name of this component
-   * @see #getName()
-   * @since 1.1
+   * @param name The new name of this component.
    */
   public void setName(String name)
   {
     nameExplicitlySet = true;
     this.name = name;
   }
+  
+  /** Subclasses should override this to return unique component names like 
+    * "menuitem0".
+    */
+  String generateName()
+  {
+    // Component is abstract.
+    return null;
+  }
 
   /**
    * Returns the parent of this component.
-   *
-   * @return the parent of this component
+   * 
+   * @return The parent of this component.
    */
   public Container getParent()
   {
-    return parent;
+    return parent;  
+  }
+
+  // Sets the peer for this component.
+  final void setPeer (ComponentPeer peer)
+  {
+    this.peer = peer;
   }
 
   /**
-   * Returns the native windowing system peer for this component. Only the
-   * platform specific implementation code should call this method.
+   * Returns the native windowing system peer for this component.
    *
-   * @return the peer for this component
-   * @deprecated user programs should not directly manipulate peers; use
-   *             {@link #isDisplayable()} instead
+   * @return The peer for this component.
+   * @deprecated
    */
   // Classpath's Gtk peers rely on this.
-  public ComponentPeer getPeer()
+  public java.awt.peer.ComponentPeer getPeer()
   {
     return peer;
   }
 
-  /**
-   * Set the associated drag-and-drop target, which receives events when this
-   * is enabled.
-   *
-   * @param dt the new drop target
-   * @see #isEnabled()
-   */
+  // FIXME: java.awt.dnd classes not yet implemented
+  /*
   public void setDropTarget(DropTarget dt)
   {
     this.dropTarget = dt;
   }
-
-  /**
-   * Gets the associated drag-and-drop target, if there is one.
-   *
-   * @return the drop target
-   */
+  
   public DropTarget getDropTarget()
   {
     return dropTarget;
   }
-
-  /**
-   * Returns the graphics configuration of this component, if there is one.
-   * If it has not been set, it is inherited from the parent.
-   *
-   * @return the graphics configuration, or null
-   * @since 1.3
-   */
+  */
+  
+  /** @since 1.3 */
   public GraphicsConfiguration getGraphicsConfiguration()
   {
     return getGraphicsConfigurationImpl();
   }
 
+  /** Implementation method that allows classes such as Canvas and
+      Window to override the graphics configuration without violating
+      the published API. */
+  GraphicsConfiguration getGraphicsConfigurationImpl()
+  {
+    if (peer != null)
+      {
+	GraphicsConfiguration config = peer.getGraphicsConfiguration();
+	if (config != null)
+	  return config;
+      }
+
+    if (parent != null)
+      return parent.getGraphicsConfiguration();
+
+    return null;
+  }
+
   /**
    * Returns the object used for synchronization locks on this component
    * when performing tree and layout functions.
    *
-   * @return the synchronization lock for this component
+   * @return The synchronization lock for this component.
    */
   public final Object getTreeLock()
   {
     return treeLock;
   }
 
+  // The sync lock object for this component.
+  final void setTreeLock(Object tree_lock)
+  {
+    this.treeLock = tree_lock;
+  }
+
   /**
-   * Returns the toolkit in use for this component. The toolkit is associated
-   * with the frame this component belongs to.
+   * Returns the toolkit in use for this component.
    *
-   * @return the toolkit for this component
+   * @return The toolkit for this component.
    */
   public Toolkit getToolkit()
   {
     if (peer != null)
       {
-        Toolkit tk = peer.getToolkit();
-        if (tk != null)
-          return tk;
+	Toolkit tk = peer.getToolkit();
+	if (tk != null)
+	  return tk;
       }
     if (parent != null)
-      return parent.getToolkit();
-    return Toolkit.getDefaultToolkit();
+      return parent.getToolkit ();
+    return Toolkit.getDefaultToolkit ();
   }
 
   /**
-   * Tests whether or not this component is valid. A invalid component needs
+   * Tests whether or not this component is valid.  A invalid component needs
    * to have its layout redone.
    *
-   * @return true if this component is valid
-   * @see #validate()
-   * @see #invalidate()
+   * @return <code>true</code> if this component is valid, <code>false</code>
+   * otherwise.
    */
   public boolean isValid()
   {
     return valid;
   }
-
-  /**
-   * Tests if the component is displayable. It must be connected to a native
-   * screen resource, and all its ancestors must be displayable. A containment
-   * hierarchy is made displayable when a window is packed or made visible.
-   *
-   * @return true if the component is displayable
-   * @see Container#add(Component)
-   * @see Container#remove(Component)
-   * @see Window#pack()
-   * @see Window#show()
-   * @see Window#dispose()
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public boolean isDisplayable()
   {
     if (parent != null)
@@ -716,11 +308,10 @@
   }
 
   /**
-   * Tests whether or not this component is visible. Except for top-level
-   * frames, components are initially visible.
+   * Tests whether or not this component is visible.
    *
-   * @return true if the component is visible
-   * @see #setVisible(boolean)
+   * @return <code>true</code> if the component is visible,
+   * <code>false</code> otherwise.
    */
   public boolean isVisible()
   {
@@ -729,26 +320,25 @@
 
   /**
    * Tests whether or not this component is actually being shown on
-   * the screen. This will be true if and only if it this component is
+   * the screen.  This will be true if and only if it this component is
    * visible and its parent components are all visible.
    *
-   * @return true if the component is showing on the screen
-   * @see #setVisible(boolean)
+   * @return <code>true</code> if the component is showing on the screen,
+   * <code>false</code> otherwise.
    */
   public boolean isShowing()
   {
     if (! visible || peer == null)
       return false;
 
-    return parent == null ? true : parent.isShowing();
+    return parent == null ? true : parent.isShowing ();
   }
 
   /**
-   * Tests whether or not this component is enabled. Components are enabled
-   * by default, and must be enabled to receive user input or generate events.
+   * Tests whether or not this component is enabled.
    *
-   * @return true if the component is enabled
-   * @see #setEnabled(boolean)
+   * @return <code>true</code> if the component is enabled,
+   * <code>false</code> otherwise.
    */
   public boolean isEnabled()
   {
@@ -756,14 +346,12 @@
   }
 
   /**
-   * Enables or disables this component. The component must be enabled to
-   * receive events (except that lightweight components always receive mouse
-   * events).
-   *
-   * @param enabled true to enable this component
-   * @see #isEnabled()
-   * @see #isLightweight()
-   * @since 1.1
+   * Enables or disables this component.
+   *
+   * @param enabled <code>true</code> to enable this component, 
+   * <code>false</code> to disable it.
+   *
+   * @deprecated Deprecated in favor of <code>setEnabled()</code>.
    */
   public void setEnabled(boolean b)
   {
@@ -775,7 +363,7 @@
   /**
    * Enables this component.
    *
-   * @deprecated use {@link #setEnabled(boolean)} instead
+   * @deprecated Deprecated in favor of <code>setEnabled()</code>.
    */
   public void enable()
   {
@@ -785,8 +373,10 @@
   /**
    * Enables or disables this component.
    *
-   * @param enabled true to enable this component
-   * @deprecated use {@link #setEnabled(boolean)} instead
+   * @param enabled <code>true</code> to enable this component, 
+   * <code>false</code> to disable it.
+   *
+   * @deprecated Deprecated in favor of <code>setEnabled()</code>.
    */
   public void enable(boolean b)
   {
@@ -796,268 +386,206 @@
   /**
    * Disables this component.
    *
-   * @deprecated use {@link #setEnabled(boolean)} instead
+   * @deprecated Deprecated in favor of <code>setEnabled()</code>.
    */
   public void disable()
   {
     setEnabled(false);
   }
 
-  /**
-   * Checks if this image is painted to an offscreen image buffer that is
-   * later copied to screen (double buffering reduces flicker). This version
-   * returns false, so subclasses must override it if they provide double
-   * buffering.
-   *
-   * @return true if this is double buffered; defaults to false
-   */
   public boolean isDoubleBuffered()
   {
     return false;
   }
 
-  /**
-   * Enables or disables input method support for this component. By default,
-   * components have this enabled. Input methods are given the opportunity
-   * to process key events before this component and its listeners.
-   *
-   * @param enable true to enable input method processing
-   * @see #processKeyEvent(KeyEvent)
-   * @since 1.2
-   */
+  /** @since 1.2 */
   public void enableInputMethods(boolean enable)
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    // FIXME
   }
 
   /**
-   * Makes this component visible or invisible. Note that it wtill might
-   * not show the component, if a parent is invisible.
+   * Makes this component visible or invisible.
    *
-   * @param visible true to make this component visible
-   * @see #isVisible()
-   * @since 1.1
+   * @param visible <code>true</code> to make this component visible,
+   * </code>false</code> to make it invisible.
+   * @specnote  Inspection by subclassing shows that Sun's implementation
+   * calls show(boolean) which then calls show() or hide(). It is
+   * the show() method that is overriden in subclasses like Window.
+   * We do the same to preserve compatibility for subclasses.
    */
   public void setVisible(boolean b)
   {
-    // Inspection by subclassing shows that Sun's implementation calls
-    // show(boolean) which then calls show() or hide(). It is the show()
-    // method that is overriden in subclasses like Window.
     if (peer != null)
-      peer.setVisible(b);
+      peer.setVisible (b);
     this.visible = b;
   }
 
   /**
    * Makes this component visible on the screen.
    *
-   * @deprecated use {@link #setVisible(boolean)} instead
+   * @deprecated Deprecated in favor of <code>setVisible()</code>.
    */
   public void show()
   {
-    setVisible(true);
+    setVisible (true);
   }
 
   /**
    * Makes this component visible or invisible.
    *
-   * @param visible true to make this component visible
-   * @deprecated use {@link #setVisible(boolean)} instead
+   * @param visible <code>true</code> to make this component visible,
+   * </code>false</code> to make it invisible.
+   *
+   * @deprecated Deprecated in favor of <code>setVisible()</code>.
    */
   public void show(boolean b)
   {
-    setVisible(b);
+    setVisible (b);
   }
 
   /**
    * Hides this component so that it is no longer shown on the screen.
    *
-   * @deprecated use {@link #setVisible(boolean)} instead
+   * @deprecated Deprecated in favor of <code>setVisible()</code>.
    */
   public void hide()
   {
-    setVisible(false);
+    setVisible (false);
   }
 
   /**
-   * Returns this component's foreground color. If not set, this is inherited
-   * from the parent.
+   * Returns this component's foreground color.
    *
-   * @return this component's foreground color, or null
-   * @see #setForeground(Color)
+   * @return This component's foreground color.
    */
   public Color getForeground()
   {
     if (foreground != null)
       return foreground;
-    return parent == null ? null : parent.getForeground();
+    if (parent != null)
+      return parent.getForeground();
+    return null;
   }
 
   /**
-   * Sets this component's foreground color to the specified color. This is a
-   * bound property.
+   * Sets this component's foreground color to the specified color.
    *
-   * @param c the new foreground color
-   * @see #getForeground()
+   * @param foreground_color The new foreground color.
    */
   public void setForeground(Color c)
   {
-    firePropertyChange("foreground", foreground, c);
     if (peer != null)
       peer.setForeground(c);
-    foreground = c;
-  }
-
-  /**
-   * Tests if the foreground was explicitly set, or just inherited from the
-   * parent.
-   *
-   * @return true if the foreground has been set
-   * @since 1.4
-   */
-  public boolean isForegroundSet()
-  {
-    return foreground != null;
+    this.foreground = c;
   }
 
   /**
-   * Returns this component's background color. If not set, this is inherited
-   * from the parent.
+   * Returns this component's background color.
    *
-   * @return the background color of the component, or null
-   * @see #setBackground(Color)
+   * @return the background color of the component. null may be
+   * returned instead of the actual background color, if this
+   * method is called before the component is added to the
+   * component hierarchy.
    */
   public Color getBackground()
   {
     if (background != null)
       return background;
-    return parent == null ? null : parent.getBackground();
+    if (parent != null)
+      return parent.getBackground();
+    return null;
   }
 
   /**
-   * Sets this component's background color to the specified color. The parts
-   * of the component affected by the background color may by system dependent.
-   * This is a bound property.
+   * Sets this component's background color to the specified color.
    *
-   * @param c the new background color
-   * @see #getBackground()
+   * @param background_color The new background color
    */
   public void setBackground(Color c)
   {
-    firePropertyChange("background", background, c);
     if (peer != null)
       peer.setBackground(c);
-    background = c;
-  }
-
-  /**
-   * Tests if the background was explicitly set, or just inherited from the
-   * parent.
-   *
-   * @return true if the background has been set
-   * @since 1.4
-   */
-  public boolean isBackgroundSet()
-  {
-    return background != null;
+    this.background = c;
   }
 
   /**
-   * Returns the font in use for this component. If not set, this is inherited
-   * from the parent.
+   * Returns the font in use for this component.
    *
-   * @return the font for this component
-   * @see #setFont(Font)
+   * @return The font for this component.
    */
   public Font getFont()
   {
     if (font != null)
       return font;
-    return parent == null ? null : parent.getFont();
+    if (parent != null)
+      return parent.getFont();
+    return null;
   }
 
   /**
-   * Sets the font for this component to the specified font. This is a bound
-   * property.
+   * Sets the font for this component to the specified font.
    *
-   * @param font the new font for this component
-   * @see #getFont()
+   * @param font The new font for this component.
    */
   public void setFont(Font f)
   {
-    firePropertyChange("font", font, f);
     if (peer != null)
       peer.setFont(f);
-    font = f;
+    this.font = f;
   }
 
   /**
-   * Tests if the font was explicitly set, or just inherited from the parent.
+   * Returns the locale for this component.  If this component does not
+   * have a locale, the locale of the parent component is returned.  If the
+   * component has no parent, the system default locale is returned.
    *
-   * @return true if the font has been set
-   * @since 1.4
+   * @return The locale for this component.
    */
-  public boolean isFontSet()
-  {
-    return font != null;
-  }
-
-  /**
-   * Returns the locale for this component. If this component does not
-   * have a locale, the locale of the parent component is returned.
-   *
-   * @return the locale for this component
-   * @throws IllegalComponentStateException if it has no locale or parent
-   * @see setLocale(Locale)
-   * @since 1.1
-   */
-  public Locale getLocale()
+  public Locale getLocale() throws IllegalComponentStateException
   {
     if (locale != null)
       return locale;
     if (parent == null)
       throw new IllegalComponentStateException
-        ("Component has no parent: can't determine Locale");
+        ("Component has no parent: Can not determine Locale");
     return parent.getLocale();
   }
 
   /**
-   * Sets the locale for this component to the specified locale. This is a
-   * bound property.
+   * Sets the locale for this component to the specified locale.
    *
-   * @param locale the new locale for this component
+   * @param locale The new locale for this component.
    */
-  public void setLocale(Locale l)
+  public void setLocale(Locale l)  
   {
-    firePropertyChange("locale", locale, l);
-    locale = l;
-    // New writing/layout direction or more/less room for localized labels.
+    this.locale = l;
+
+    /* new writing/layout direction perhaps, or make more/less
+       room for localized text labels */
     invalidate();
   }
 
   /**
    * Returns the color model of the device this componet is displayed on.
    *
-   * @return this object's color model
-   * @see Toolkit#getColorModel()
+   * @return This object's color model.
    */
   public ColorModel getColorModel()
   {
     GraphicsConfiguration config = getGraphicsConfiguration();
-    return config != null ? config.getColorModel()
-      : getToolkit().getColorModel();
+
+    if (config != null)
+      return config.getColorModel();
+
+    return getToolkit().getColorModel();    
   }
 
   /**
    * Returns the location of this component's top left corner relative to
-   * its parent component. This may be outdated, so for synchronous behavior,
-   * you should use a component listner.
+   * its parent component.
    *
-   * @return the location of this component
-   * @see #setLocation(int, int)
-   * @see #getLocationOnScreen()
-   * @since 1.1
+   * @return The location of this component.
    */
   public Point getLocation()
   {
@@ -1068,23 +596,25 @@
    * Returns the location of this component's top left corner in screen
    * coordinates.
    *
-   * @return the location of this component in screen coordinates
-   * @throws IllegalComponentStateException if the component is not showing
+   * @return The location of this component in screen coordinates.
    */
   public Point getLocationOnScreen()
   {
-    if (! isShowing())
-      throw new IllegalComponentStateException("component not showing");
+    if (! isShowing ())
+      throw new IllegalComponentStateException ("component not showing");
+
     // We know peer != null here.
-    return peer.getLocationOnScreen();
+    return peer.getLocationOnScreen ();
   }
 
   /**
    * Returns the location of this component's top left corner relative to
    * its parent component.
    *
-   * @return the location of this component
-   * @deprecated use {@link #getLocation()} instead
+   * @return The location of this component.
+   *
+   * @deprecated This method is deprecated in favor of 
+   * <code>getLocation()</code>.
    */
   public Point location()
   {
@@ -1092,20 +622,19 @@
   }
 
   /**
-   * Moves this component to the specified location, relative to the parent's
-   * coordinates. The coordinates are the new upper left corner of this
-   * component.
-   *
-   * @param x the new X coordinate of this component
-   * @param y the new Y coordinate of this component
-   * @see #getLocation()
-   * @see #setBounds(int, int, int, int)
+   * Moves this component to the specified location.  The coordinates are
+   * the new upper left corner of this component.
+   *
+   * @param x The new X coordinate of this component.
+   * @param y The new Y coordinate of this component.
    */
-  public void setLocation(int x, int y)
+  public void setLocation (int x, int y)
   {
-    if (this.x == x && this.y == y)
+    if ((this.x == x) && (this.y == y))
       return;
+
     invalidate();
+
     this.x = x;
     this.y = y;
     if (peer != null)
@@ -1113,29 +642,24 @@
   }
 
   /**
-   * Moves this component to the specified location, relative to the parent's
-   * coordinates. The coordinates are the new upper left corner of this
-   * component.
-   *
-   * @param x the new X coordinate of this component
-   * @param y the new Y coordinate of this component
-   * @deprecated use {@link #setLocation(int, int)} instead
+   * Moves this component to the specified location.  The coordinates are
+   * the new upper left corner of this component.
+   *
+   * @param x The new X coordinate of this component.
+   * @param y The new Y coordinate of this component.
+   *
+   * @deprecated Deprecated in favor for <code>setLocation</code>.
    */
   public void move(int x, int y)
   {
-    setLocation(x, y);
+    setLocation(x,y);
   }
 
   /**
-   * Moves this component to the specified location, relative to the parent's
-   * coordinates. The coordinates are the new upper left corner of this
-   * component.
+   * Moves this component to the specified location.  The coordinates are
+   * the new upper left corner of this component.
    *
-   * @param p new coordinates for this component
-   * @throws NullPointerException if p is null
-   * @see #getLocation()
-   * @see #setBounds(int, int, int, int)
-   * @since 1.1
+   * @param p New coordinates for this component.
    */
   public void setLocation(Point p)
   {
@@ -1145,9 +669,7 @@
   /**
    * Returns the size of this object.
    *
-   * @return the size of this object
-   * @see #setSize(int, int)
-   * @since 1.1
+   * @return The size of this object.
    */
   public Dimension getSize()
   {
@@ -1157,8 +679,9 @@
   /**
    * Returns the size of this object.
    *
-   * @return the size of this object
-   * @deprecated use {@link #getSize()} instead
+   * @return The size of this object.
+   *
+   * @deprecated This method is deprecated in favor of <code>getSize</code>.
    */
   public Dimension size()
   {
@@ -1167,17 +690,17 @@
 
   /**
    * Sets the size of this component to the specified width and height.
-   *
-   * @param width the new width of this component
-   * @param height the new height of this component
-   * @see #getSize()
-   * @see #setBounds(int, int, int, int)
+   * 
+   * @param width The new width of this component.
+   * @param height The new height of this component.
    */
   public void setSize(int width, int height)
   {
-    if (this.width == width && this.height == height)
+    if ((this.width == width) && (this.height == height))
       return;
+
     invalidate();
+
     this.width = width;
     this.height = height;
     if (peer != null)
@@ -1186,10 +709,11 @@
 
   /**
    * Sets the size of this component to the specified value.
+   * 
+   * @param width The new width of the component.
+   * @param height The new height of the component.
    *
-   * @param width the new width of the component
-   * @param height the new height of the component
-   * @deprecated use {@link #setSize(int, int)} instead
+   * @deprecated This method is deprecated in favor of <code>setSize</code>.
    */
   public void resize(int width, int height)
   {
@@ -1198,12 +722,8 @@
 
   /**
    * Sets the size of this component to the specified value.
-   *
-   * @param d the new size of this component
-   * @throws NullPointerException if d is null
-   * @see #setSize(int, int)
-   * @see #setBounds(int, int, int, int)
-   * @since 1.1
+   * 
+   * @param dim The new size of this component.
    */
   public void setSize(Dimension d)
   {
@@ -1212,10 +732,10 @@
 
   /**
    * Sets the size of this component to the specified value.
+   * 
+   * @param dim The new size of this component.
    *
-   * @param d the new size of this component
-   * @throws NullPointerException if d is null
-   * @deprecated use {@link #setSize(Dimension)} instead
+   * @deprecated This method is deprecated in favor of <code>setSize</code>.
    */
   public void resize(Dimension d)
   {
@@ -1223,27 +743,25 @@
   }
 
   /**
-   * Returns a bounding rectangle for this component. Note that the
+   * Returns a bounding rectangle for this component.  Note that the
    * returned rectange is relative to this component's parent, not to
    * the screen.
    *
-   * @return the bounding rectangle for this component
-   * @see #setBounds(int, int, int, int)
-   * @see #getLocation()
-   * @see #getSize()
+   * @return The bounding rectangle for this component.
    */
   public Rectangle getBounds()
   {
-    return new Rectangle(x, y, width, height);
+    return new Rectangle (x, y, width, height);
   }
 
   /**
-   * Returns a bounding rectangle for this component. Note that the
+   * Returns a bounding rectangle for this component.  Note that the
    * returned rectange is relative to this component's parent, not to
    * the screen.
    *
-   * @return the bounding rectangle for this component
-   * @deprecated use {@link #getBounds()} instead
+   * @return The bounding rectangle for this component.
+   *
+   * @deprecated Deprecated in favor of <code>getBounds()</code>.
    */
   public Rectangle bounds()
   {
@@ -1251,42 +769,46 @@
   }
 
   /**
-   * Sets the bounding rectangle for this component to the specified values.
-   * Note that these coordinates are relative to the parent, not to the screen.
+   * Sets the bounding rectangle for this component to the specified
+   * values.  Note that these coordinates are relative to the parent,
+   * not to the screen.
    *
-   * @param x the X coordinate of the upper left corner of the rectangle
-   * @param y the Y coordinate of the upper left corner of the rectangle
-   * @param w the width of the rectangle
-   * @param h the height of the rectangle
-   * @see #getBounds()
-   * @see #setLocation(int, int)
-   * @see #setLocation(Point)
-   * @see #setSize(int, int)
-   * @see #setSize(Dimension)
-   * @since 1.1
+   * @param x The X coordinate of the upper left corner of the rectangle.
+   * @param y The Y coordinate of the upper left corner of the rectangle.
+   * @param width The width of the rectangle.
+   * @param height The height of the rectangle.
    */
   public void setBounds(int x, int y, int w, int h)
   {
-    if (this.x == x && this.y == y && width == w && height == h)
+    if (this.x == x
+	&& this.y == y
+	&& this.width == w
+	&& this.height == h)
       return;
+
     invalidate();
+
     this.x = x;
     this.y = y;
-    width = w;
-    height = h;
+    this.width = w;
+    this.height = h;
+
     if (peer != null)
       peer.setBounds(x, y, w, h);
   }
 
   /**
-   * Sets the bounding rectangle for this component to the specified values.
-   * Note that these coordinates are relative to the parent, not to the screen.
+   * Sets the bounding rectangle for this component to the specified
+   * values.  Note that these coordinates are relative to the parent,
+   * not to the screen.
+   *
+   * @param x The X coordinate of the upper left corner of the rectangle.
+   * @param y The Y coordinate of the upper left corner of the rectangle.
+   * @param width The width of the rectangle.
+   * @param height The height of the rectangle.
    *
-   * @param x the X coordinate of the upper left corner of the rectangle
-   * @param y the Y coordinate of the upper left corner of the rectangle
-   * @param w the width of the rectangle
-   * @param h the height of the rectangle
-   * @deprecated use {@link #setBounds(int, int, int, int)} instead
+   * @deprecated This method is deprecated in favor of
+   * <code>setBounds(int, int, int, int)</code>.
    */
   public void reshape(int x, int y, int width, int height)
   {
@@ -1295,169 +817,100 @@
 
   /**
    * Sets the bounding rectangle for this component to the specified
-   * rectangle. Note that these coordinates are relative to the parent, not
-   * to the screen.
+   * rectangle.  Note that these coordinates are relative to the parent,
+   * not to the screen.
    *
-   * @param r the new bounding rectangle
-   * @throws NullPointerException if r is null
-   * @see #getBounds()
-   * @see #setLocation(Point)
-   * @see #setSize(Dimension)
-   * @since 1.1
+   * @param bounding_rectangle The new bounding rectangle.
    */
   public void setBounds(Rectangle r)
-  {
+  { 
     setBounds(r.x, r.y, r.width, r.height);
   }
-
-  /**
-   * Gets the x coordinate of the upper left corner. This is more efficient
-   * than getBounds().x or getLocation().x.
-   *
-   * @return the current x coordinate
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public int getX()
   {
     return x;
   }
-
-  /**
-   * Gets the y coordinate of the upper left corner. This is more efficient
-   * than getBounds().y or getLocation().y.
-   *
-   * @return the current y coordinate
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public int getY()
   {
     return y;
   }
-
-  /**
-   * Gets the width of the component. This is more efficient than
-   * getBounds().width or getSize().width.
-   *
-   * @return the current width
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public int getWidth()
   {
     return width;
   }
-
-  /**
-   * Gets the height of the component. This is more efficient than
-   * getBounds().height or getSize().height.
-   *
-   * @return the current width
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public int getHeight()
   {
     return height;
   }
-
-  /**
-   * Returns the bounds of this component. This allows reuse of an existing
-   * rectangle, if r is non-null.
-   *
-   * @param r the rectangle to use, or null
-   * @return the bounds
-   */
+  
   public Rectangle getBounds(Rectangle r)
   {
-    if (r == null)
-      r = new Rectangle();
-    r.x = x;
-    r.y = y;
-    r.width = width;
-    r.height = height;
+    r.x = this.x;
+    r.y = this.y;
+    r.width = this.width;
+    r.height = this.height;
     return r;
   }
-
-  /**
-   * Returns the size of this component. This allows reuse of an existing
-   * dimension, if d is non-null.
-   *
-   * @param d the dimension to use, or null
-   * @return the size
-   */
+  
   public Dimension getSize(Dimension d)
   {
-    if (d == null)
-      d = new Dimension();
-    d.width = width;
-    d.height = height;
+    d.width = this.width;
+    d.height = this.height;
     return d;
   }
-
-  /**
-   * Returns the location of this component. This allows reuse of an existing
-   * point, if p is non-null.
-   *
-   * @param p the point to use, or null
-   * @return the location
-   */
+  
   public Point getLocation(Point p)
   {
-    if (p == null)
-      p = new Point();
     p.x = x;
     p.y = y;
     return p;
   }
-
-  /**
-   * Tests if this component is opaque. All "heavyweight" (natively-drawn)
-   * components are opaque. A component is opaque if it draws all pixels in
-   * the bounds; a lightweight component is partially transparent if it lets
-   * pixels underneath show through. Subclasses that guarantee that all pixels
-   * will be drawn should override this.
-   *
-   * @return true if this is opaque
-   * @see #isLightweight()
-   * @since 1.2
-   */
+  
+  /** @since 1.2 */
   public boolean isOpaque()
   {
-    return ! isLightweight();
+    return !isLightweight();
   }
-
-  /**
-   * Return whether the component is lightweight. That means the component has
-   * no native peer, but is displayable. This applies to subclasses of
-   * Component not in this package, such as javax.swing.
+  
+  /** 
+   * Return whether the component is lightweight.
+   *
+   * @return true if component has a peer and and the peer is lightweight.
    *
-   * @return true if the component has a lightweight peer
-   * @see #isDisplayable()
    * @since 1.2
-   */
+   */  
   public boolean isLightweight()
   {
-    return peer instanceof LightweightPeer;
+    return (peer != null) && (peer instanceof LightweightPeer);
   }
 
   /**
    * Returns the component's preferred size.
    *
-   * @return the component's preferred size
-   * @see #getMinimumSize()
-   * @see LayoutManager
+   * @return The component's preferred size.
    */
   public Dimension getPreferredSize()
   {
-    if (prefSize == null)
-      prefSize = (peer != null ? peer.getPreferredSize()
-                       : new Dimension(width, height));
-    return prefSize;
+    if (peer == null)
+      return new Dimension(width, height);
+    else
+      return peer.getPreferredSize();
   }
 
   /**
    * Returns the component's preferred size.
    *
-   * @return the component's preferred size
-   * @deprecated use {@link #getPreferredSize()} instead
+   * @return The component's preferred size.
+   *
+   * @deprecated Deprecated in favor of <code>getPreferredSize()</code>.
    */
   public Dimension preferredSize()
   {
@@ -1467,23 +920,22 @@
   /**
    * Returns the component's minimum size.
    *
-   * @return the component's minimum size
-   * @see #getPreferredSize()
-   * @see LayoutManager
+   * @return The component's minimum size.
    */
   public Dimension getMinimumSize()
   {
-    if (minSize == null)
-      minSize = (peer != null ? peer.getMinimumSize()
-                 : new Dimension(width, height));
-    return minSize;
+    if (peer == null)
+      return new Dimension(width, height);
+    else
+      return peer.getMinimumSize();
   }
 
   /**
    * Returns the component's minimum size.
    *
-   * @return the component's minimum size
-   * @deprecated use {@link #getMinimumSize()} instead
+   * @return The component's minimum size.
+   *
+   * @deprecated Deprecated in favor of <code>getMinimumSize()</code>
    */
   public Dimension minimumSize()
   {
@@ -1493,10 +945,7 @@
   /**
    * Returns the component's maximum size.
    *
-   * @return the component's maximum size
-   * @see #getMinimumSize()
-   * @see #getPreferredSize()
-   * @see LayoutManager
+   * @return The component's maximum size.
    */
   public Dimension getMaximumSize()
   {
@@ -1504,11 +953,10 @@
   }
 
   /**
-   * Returns the preferred horizontal alignment of this component. The value
-   * returned will be between {@link #LEFT_ALIGNMENT} and
-   * {@link #RIGHT_ALIGNMENT}, inclusive.
+   * Returns the preferred horizontal alignment of this component.  The
+   * value returned will be one of the constants defined in this class.
    *
-   * @return the preferred horizontal alignment of this component
+   * @return The preferred horizontal alignment of this component.
    */
   public float getAlignmentX()
   {
@@ -1516,11 +964,10 @@
   }
 
   /**
-   * Returns the preferred vertical alignment of this component. The value
-   * returned will be between {@link #TOP_ALIGNMENT} and
-   * {@link #BOTTOM_ALIGNMENT}, inclusive.
+   * Returns the preferred vertical alignment of this component.  The
+   * value returned will be one of the constants defined in this class.
    *
-   * @return the preferred vertical alignment of this component
+   * @return The preferred vertical alignment of this component.
    */
   public float getAlignmentY()
   {
@@ -1528,11 +975,8 @@
   }
 
   /**
-   * Calls the layout manager to re-layout the component. This is called
+   * Calls the layout manager to re-layout the component.  This is called
    * during validation of a container in most cases.
-   *
-   * @see #validate()
-   * @see LayoutManager
    */
   public void doLayout()
   {
@@ -1540,10 +984,10 @@
   }
 
   /**
-   * Calls the layout manager to re-layout the component. This is called
+   * Calls the layout manager to re-layout the component.  This is called
    * during validation of a container in most cases.
    *
-   * @deprecated use {@link #doLayout()} instead
+   * @deprecated This method is deprecated in favor of <code>doLayout()</code>.
    */
   public void layout()
   {
@@ -1551,13 +995,7 @@
   }
 
   /**
-   * Called to ensure that the layout for this component is valid. This is
-   * usually called on containers.
-   *
-   * @see #invalidate()
-   * @see #doLayout()
-   * @see LayoutManager
-   * @see Container#validate()
+   * Called to ensure that the layout for this component is valid.
    */
   public void validate()
   {
@@ -1565,43 +1003,41 @@
   }
 
   /**
-   * Invalidates this component and all of its parent components. This will
-   * cause them to have their layout redone. This is called frequently, so
-   * make it fast.
+   * Invalidates this component and all of its parent components.  This will
+   * cause them to have their layout redone.
    */
   public void invalidate()
   {
     valid = false;
-    prefSize = null;
-    minSize = null;
-    if (parent != null && parent.valid)
-      parent.invalidate();
+
+    if ((parent != null) && parent.valid)
+      parent.invalidate ();
   }
 
   /**
-   * Returns a graphics object for this component. Returns <code>null</code>
+   * Returns a graphics object for this component.  Returns <code>null</code>
    * if this component is not currently displayed on the screen.
    *
-   * @return a graphics object for this component
-   * @see #paint(Graphics)
+   * @return A graphics object for this component.
    */
   public Graphics getGraphics()
   {
     if (peer != null)
       {
-        Graphics gfx = peer.getGraphics();
-        if (gfx != null)
-          return gfx;
-        // create graphics for lightweight:
-        Container parent = getParent();
-        if (parent != null)
-          {
-            gfx = parent.getGraphics();
-            Rectangle bounds = getBounds();
-            gfx.setClip(bounds);
-            gfx.translate(bounds.x, bounds.y);
-            return gfx;
-          }
+	Graphics gfx = peer.getGraphics();
+	if (gfx != null)
+	  return gfx;
+      
+	// create graphics for lightweight:
+	Container parent = getParent();
+	if (parent != null)
+	  {
+	    gfx = parent.getGraphics();
+	    Rectangle bounds = getBounds();
+	    gfx.setClip(bounds);
+	    gfx.translate(bounds.x, bounds.y);
+	    return gfx;
+	  }
       }
     return null;
   }
@@ -1609,89 +1045,57 @@
   /**
    * Returns the font metrics for the specified font in this component.
    *
-   * @param font the font to retrieve metrics for
-   * @return the font metrics for the specified font
-   * @throws NullPointerException if font is null
-   * @see #getFont()
-   * @see Toolkit#getFontMetrics(Font)
+   * @param font The font to retrieve metrics for.
+   *
+   * @return The font metrics for the specified font.
    */
   public FontMetrics getFontMetrics(Font font)
   {
-    return peer == null ? getToolkit().getFontMetrics(font)
-      : peer.getFontMetrics(font);
+    if (peer == null)
+      return getToolkit().getFontMetrics(font);
+    return peer.getFontMetrics (font);
   }
 
   /**
-   * Sets the cursor for this component to the specified cursor. The cursor
-   * is displayed when the point is contained by the component, and the
-   * component is visible, displayable, and enabled. This is inherited by
-   * subcomponents unless they set their own cursor.
-   *
-   * @param cursor the new cursor for this component
-   * @see #isEnabled()
-   * @see #isShowing()
-   * @see #getCursor()
-   * @see #contains(int, int)
-   * @see Toolkit#createCustomCursor(Image, Point, String)
+   * Sets the cursor for this component to the specified cursor.
+   *
+   * @param cursor The new cursor for this component.
    */
   public void setCursor(Cursor cursor)
   {
     this.cursor = cursor;
     if (peer != null)
-      peer.setCursor(cursor);
+      peer.setCursor (cursor);
   }
 
   /**
-   * Returns the cursor for this component. If not set, this is inherited
-   * from the parent, or from Cursor.getDefaultCursor().
+   * Returns the cursor for this component.
    *
-   * @return the cursor for this component
+   * @return The cursor for this component.
    */
   public Cursor getCursor()
   {
-    if (cursor != null)
-      return cursor;
-    return parent != null ? parent.getCursor() : Cursor.getDefaultCursor();
-  }
-
-  /**
-   * Tests if the cursor was explicitly set, or just inherited from the parent.
-   *
-   * @return true if the cursor has been set
-   * @since 1.4
-   */
-  public boolean isCursorSet()
-  {
-    return cursor != null;
+    return this.cursor;
   }
 
   /**
-   * Paints this component on the screen. The clipping region in the graphics
-   * context will indicate the region that requires painting. This is called
-   * whenever the component first shows, or needs to be repaired because
-   * something was temporarily drawn on top. It is not necessary for
-   * subclasses to call <code>super.paint(g)</code>. Components with no area
-   * are not painted.
+   * Paints this component on the screen.  The clipping region in the
+   * graphics context will indicate the region that requires painting.
    *
-   * @param g the graphics context for this paint job
-   * @see #update(Graphics)
+   * @param graphics The graphics context for this paint job.
    */
   public void paint(Graphics g)
   {
   }
 
   /**
-   * Updates this component. This is called in response to
-   * <code>repaint</code>. This method fills the component with the
-   * background color, then sets the foreground color of the specified
-   * graphics context to the foreground color of this component and calls
-   * the <code>paint()</code> method. The coordinates of the graphics are
-   * relative to this component. Subclasses should call either
-   * <code>super.update(g)</code> or <code>paint(g)</code>.
-   *
-   * @param graphics the graphics context for this update
-   * @see #paint(Graphics)
-   * @see #repaint()
+   * Updates this component.  This method fills the component
+   * with the background color, then sets the foreground color of the
+   * specified graphics context to the foreground color of this component
+   * and calls the <code>paint()</code> method.
+   * // FIXME: What are the coords relative to?
+   *
+   * @param graphics The graphics context for this update.
    */
   public void update(Graphics g)
   {
@@ -1701,93 +1105,92 @@
   /**
    * Paints this entire component, including any sub-components.
    *
-   * @param graphics the graphics context for this paint job
-   * @see #paint(Graphics)
+   * @param graphics The graphics context for this paint job.
    */
   public void paintAll(Graphics g)
-  {
-    if (! visible)
+  {    
+    if (!visible)
       return;
+	
     if (peer != null)
       peer.paint(g);
     paint(g);
   }
 
   /**
-   * Repaint this entire component. The <code>update()</code> method
+   * Repaint this entire component.  The <code>update()</code> method
    * on this component will be called as soon as possible.
-   *
-   * @see #update(Graphics)
-   * @see #repaint(long, int, int, int, int)
+   * // FIXME: What are the coords relative to?
    */
   public void repaint()
   {
-    repaint(0, 0, 0, width, height);
+    repaint(0, 0, 0, getWidth(), getHeight());
   }
 
   /**
-   * Repaint this entire component. The <code>update()</code> method on this
-   * component will be called in approximate the specified number of
-   * milliseconds.
+   * Repaint this entire component.  The <code>update()</code> method
+   * on this component will be called in approximate the specified number
+   * of milliseconds.
+   * // FIXME: What are the coords relative to?
    *
-   * @param tm milliseconds before this component should be repainted
-   * @see #paint(Graphics)
-   * @see #repaint(long, int, int, int, int)
+   * @param tm The number of milliseconds before this component should
+   * be repainted.
    */
   public void repaint(long tm)
   {
-    repaint(tm, 0, 0, width, height);
+    repaint(tm, 0, 0, getWidth(), getHeight());
   }
 
   /**
-   * Repaints the specified rectangular region within this component. The
-   * <code>update</code> method on this component will be called as soon as
-   * possible. The coordinates are relative to this component.
+   * Repaints the specified rectangular region within this component.
+   * This <code>update</code> method on this component will be called as
+   * soon as possible.
+   * // FIXME: What are the coords relative to?
    *
-   * @param x the X coordinate of the upper left of the region to repaint
-   * @param y the Y coordinate of the upper left of the region to repaint
-   * @param w the width of the region to repaint
-   * @param h the height of the region to repaint
-   * @see #update(Graphics)
-   * @see #repaint(long, int, int, int, int)
+   * @param x The X coordinate of the upper left of the region to repaint
+   * @param y The Y coordinate of the upper left of the region to repaint
+   * @param width The width of the region to repaint.
+   * @param height The height of the region to repaint.
    */
-  public void repaint(int x, int y, int w, int h)
+  public void repaint(int x, int y, int width, int height)
   {
-    repaint(0, x, y, w, h);
+    repaint(0, x, y, width, height);
   }
 
   /**
-   * Repaints the specified rectangular region within this component. The
-   * <code>update</code> method on this component will be called in
-   * approximately the specified number of milliseconds. The coordinates
-   * are relative to this component.
+   * Repaints the specified rectangular region within this component.
+   * This <code>update</code> method on this component will be called in
+   * approximately the specified number of milliseconds.
+   * // FIXME: What are the coords relative to?
    *
-   * @param tm milliseconds before this component should be repainted
-   * @param x the X coordinate of the upper left of the region to repaint
-   * @param y the Y coordinate of the upper left of the region to repaint
-   * @param w the width of the region to repaint
-   * @param h the height of the region to repaint
-   * @see #update(Graphics)
+   * @param tm The number of milliseconds before this component should
+   * be repainted.
+   * @param x The X coordinate of the upper left of the region to repaint
+   * @param y The Y coordinate of the upper left of the region to repaint
+   * @param width The width of the region to repaint.
+   * @param height The height of the region to repaint.
    */
   public void repaint(long tm, int x, int y, int width, int height)
-  {
+  {    
     // Handle lightweight repainting by forwarding to native parent
-    if (isLightweight() && parent != null)
+    if (isLightweight() && (parent != null))
       {
-        if (parent != null)
-          parent.repaint(tm, x + getX(), y + getY(), width, height);
+	if (parent != null)
+	  parent.repaint(tm, x+getX(), y+getY(), width, height);
+	return;
       }
-    else if (peer != null)
+
+    if (peer != null)
       peer.repaint(tm, x, y, width, height);
   }
 
   /**
-   * Prints this component. This method is provided so that printing can be
-   * done in a different manner from painting. However, the implementation
-   * in this class simply calls the <code>paint()</code> method.
+   * Prints this component.  This method is
+   * provided so that printing can be done in a different manner from
+   * painting.  However, the implementation in this class simply calls
+   * the <code>paint()</code> method.
    *
-   * @param graphics the graphics context of the print device
-   * @see #paint(Graphics)
+   * @param graphics The graphics context of the print device.
    */
   public void print(Graphics g)
   {
@@ -1795,13 +1198,12 @@
   }
 
   /**
-   * Prints this component, including all sub-components. This method is
+   * Prints this component, including all sub-components.  This method is
    * provided so that printing can be done in a different manner from
-   * painting. However, the implementation in this class simply calls the
-   * <code>paintAll()</code> method.
+   * painting.  However, the implementation in this class simply calls
+   * the <code>paintAll()</code> method.
    *
-   * @param graphics the graphics context of the print device
-   * @see #paintAll(Graphics)
+   * @param graphics The graphics context of the print device.
    */
   public void printAll(Graphics g)
   {
@@ -1809,130 +1211,83 @@
   }
 
   /**
-   * Called when an image has changed so that this component is repainted.
-   * This incrementally draws an image as more bits are available, when
-   * possible. Incremental drawing is enabled if the system property
-   * <code>awt.image.incrementalDraw</code> is not present or is true, in which
-   * case the redraw rate is set to 100ms or the value of the system property
-   * <code>awt.image.redrawrate</code>.
-   *
-   * <p>The coordinate system used depends on the particular flags.
-   *
-   * @param image the image that has been updated
-   * @param flags tlags as specified in <code>ImageObserver</code>
-   * @param x the X coordinate
-   * @param y the Y coordinate
-   * @param w the width
-   * @param h the height
-   * @return true if the image has been fully loaded
-   * @see ImageObserver
-   * @see Graphics#drawImage(Image, int, int, Color, ImageObserver)
-   * @see Graphics#drawImage(Image, int, int, ImageObserver)
-   * @see Graphics#drawImage(Image, int, int, int, int, Color, ImageObserver)
-   * @see Graphics#drawImage(Image, int, int, int, int, ImageObserver)
-   * @see ImageObserver#update(Image, int, int, int, int, int)
+   * Called when an image has changed so that this component is
+   * repainted.
+   *
+   * @param image The image that has been updated.
+   * @param flags Flags as specified in <code>ImageObserver</code>.
+   * @param x The X coordinate 
+   * @param y The Y coordinate
+   * @param width The width
+   * @param height The height
+   *
+   * @return <code>true</code> if the image has been fully loaded,
+   * <code>false</code> otherwise.
    */
-  public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h)
+  public boolean imageUpdate (Image img, int infoflags, int x, int y,
+			      int w, int h)
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    // FIXME
+    return false;
   }
 
   /**
    * Creates an image from the specified producer.
    *
-   * @param producer the image procedure to create the image from
-   * @return the resulting image
+   * @param producer The image procedure to create the image from.
+   *
+   * @return The resulting image.
    */
   public Image createImage(ImageProducer producer)
   {
-    // XXX What if peer or producer is null?
     return peer.createImage(producer);
   }
 
   /**
    * Creates an image with the specified width and height for use in
-   * double buffering. Headless environments do not support images.
+   * double buffering.
    *
-   * @param width the width of the image
-   * @param height the height of the image
-   * @return the requested image, or null if it is not supported
-   */
-  public Image createImage(int width, int height)
-  {
-    if (GraphicsEnvironment.isHeadless())
-      return null;
-    GraphicsConfiguration config = getGraphicsConfiguration();
-    return config == null ? null : config.createCompatibleImage(width, height);
-  }
-
-  /**
-   * Creates an image with the specified width and height for use in
-   * double buffering. Headless environments do not support images.
+   * @param width The width of the image.
+   * @param height The height of the image.
    *
-   * @param width the width of the image
-   * @param height the height of the image
-   * @return the requested image, or null if it is not supported
-   * @since 1.4
+   * @return The requested image.
    */
-  public VolatileImage createVolatileImage(int width, int height)
-  {
-    if (GraphicsEnvironment.isHeadless())
-      return null;
-    GraphicsConfiguration config = getGraphicsConfiguration();
-    return config == null ? null
-      : config.createCompatibleVolatileImage(width, height);
-  }
-
-  /**
-   * Creates an image with the specified width and height for use in
-   * double buffering. Headless environments do not support images. The image
-   * will support the specified capabilities.
-   *
-   * @param width the width of the image
-   * @param height the height of the image
-   * @param caps the requested capabilities
-   * @return the requested image, or null if it is not supported
-   * @throws AWTException if a buffer with the capabilities cannot be created
-   * @since 1.4
-   */
-  public VolatileImage createVolatileImage(int width, int height,
-                                           ImageCapabilities caps)
-    throws AWTException
+  public Image createImage(int width, int height)
   {
-    if (GraphicsEnvironment.isHeadless())
-      return null;
-    GraphicsConfiguration config = getGraphicsConfiguration();
-    return config == null ? null
-      : config.createCompatibleVolatileImage(width, height, caps);
+    return getGraphicsConfiguration().createCompatibleImage(width, height);
   }
 
   /**
    * Prepares the specified image for rendering on this component.
    *
-   * @param image the image to prepare for rendering
-   * @param observer the observer to notify of image preparation status
-   * @return true if the image is already fully prepared
-   * @throws NullPointerException if image is null
+   * @param image The image to prepare for rendering.
+   * @param observer The image observer to notify of the status of the
+   * image preparation.
+   *
+   * @return <code>true</code> if the image is already fully prepared
+   * for rendering, <code>false</code> otherwise.
    */
   public boolean prepareImage(Image image, ImageObserver observer)
   {
-    return prepareImage(image, image.getWidth(observer),
-                        image.getHeight(observer), observer);
+    return prepareImage(image, image.getWidth(observer), 
+			image.getHeight(observer), observer);
   }
 
   /**
    * Prepares the specified image for rendering on this component at the
    * specified scaled width and height
    *
-   * @param image the image to prepare for rendering
-   * @param width the scaled width of the image
-   * @param height the scaled height of the image
-   * @param observer the observer to notify of image preparation status
-   * @return true if the image is already fully prepared
+   * @param image The image to prepare for rendering.
+   * @param width The scaled width of the image.
+   * @param height The scaled height of the image.
+   * @param observer The image observer to notify of the status of the
+   * image preparation.
+   *
+   * @return <code>true</code> if the image is already fully prepared
+   * for rendering, <code>false</code> otherwise.
    */
   public boolean prepareImage(Image image, int width, int height,
-                              ImageObserver observer)
+			      ImageObserver observer)
   {
     return peer.prepareImage(image, width, height, observer);
   }
@@ -1941,105 +1296,78 @@
    * Returns the status of the loading of the specified image. The value
    * returned will be those flags defined in <code>ImageObserver</code>.
    *
-   * @param image the image to check on
-   * @param observer the observer to notify of image loading progress
-   * @return the image observer flags indicating the status of the load
-   * @see #prepareImage(Image, int, int, ImageObserver)
-   * @see #Toolkit#checkImage(Image, int, int, ImageObserver)
-   * @throws NullPointerException if image is null
+   * @param image The image to check on.
+   * @param observer The observer to be notified as the image loading
+   * progresses.
+   *
+   * @return The image observer flags indicating the status of the load.
    */
   public int checkImage(Image image, ImageObserver observer)
   {
-    return checkImage(image, image.getWidth(observer),
-                      image.getHeight(observer), observer);
+    return checkImage(image, image.getWidth(observer), 
+		      image.getHeight(observer), observer);
   }
 
   /**
    * Returns the status of the loading of the specified image. The value
    * returned will be those flags defined in <code>ImageObserver</code>.
    *
-   * @param image the image to check on
-   * @param width the scaled image width
-   * @param height the scaled image height
-   * @param observer the observer to notify of image loading progress
-   * @return the image observer flags indicating the status of the load
-   * @see #prepareImage(Image, int, int, ImageObserver)
-   * @see #Toolkit#checkImage(Image, int, int, ImageObserver)
+   * @param image The image to check on.
+   * @param width The scaled image width.
+   * @param height The scaled image height.
+   * @param observer The observer to be notified as the image loading
+   * progresses.
+   *
+   * @return The image observer flags indicating the status of the load.
    */
-  public int checkImage(Image image, int width, int height,
-                        ImageObserver observer)
+  public int checkImage (Image image, int width, int height,
+			 ImageObserver observer)
   {
     if (peer != null)
-      return peer.checkImage(image, width, height, observer);
-    return getToolkit().checkImage(image, width, height, observer);
+      return peer.checkImage (image, width, height, observer);
+    return getToolkit ().checkImage (image, width, height, observer);
   }
 
   /**
-   * Sets whether paint messages delivered by the operating system should be
-   * ignored. This does not affect messages from AWT, except for those
-   * triggered by OS messages. Setting this to true can allow faster
-   * performance in full-screen mode or page-flipping.
+   * Tests whether or not the specified point is contained within this
+   * component.  Coordinates are relative to this component.
    *
-   * @param ignoreRepaint the new setting for ignoring repaint events
-   * @see #getIgnoreRepaint()
-   * @see BufferStrategy
-   * @see GraphicsDevice.setFullScreenWindow(Window)
-   * @since 1.4
-   */
-  public void setIgnoreRepaint(boolean ignoreRepaint)
-  {
-    this.ignoreRepaint = ignoreRepaint;
-  }
-
-  /**
-   * Test whether paint events from the operating system are ignored.
+   * @param x The X coordinate of the point to test.
+   * @param y The Y coordinate of the point to test.
    *
-   * @return the status of ignoring paint events
-   * @see #setIgnoreRepaint(boolean)
-   * @since 1.4
+   * @return <code>true</code> if the point is within this component,
+   * <code>false</code> otherwise.
    */
-  public boolean getIgnoreRepaint()
+  public boolean contains (int x, int y)
   {
-    return ignoreRepaint;
+    return (x >= 0) && (y >= 0) && (x < width) && (y < height);
   }
 
   /**
    * Tests whether or not the specified point is contained within this
-   * component. Coordinates are relative to this component.
+   * component.  Coordinates are relative to this component.
    *
-   * @param x the X coordinate of the point to test
-   * @param y the Y coordinate of the point to test
-   * @return true if the point is within this component
-   * @see #getComponentAt(int, int)
-   */
-  public boolean contains(int x, int y)
-  {
-    return x >= 0 && y >= 0 && x < width && y < height;
-  }
-
-  /**
-   * Tests whether or not the specified point is contained within this
-   * component. Coordinates are relative to this component.
+   * @param x The X coordinate of the point to test.
+   * @param y The Y coordinate of the point to test.
    *
-   * @param x the X coordinate of the point to test
-   * @param y the Y coordinate of the point to test
-   * @return true if the point is within this component
-   * @deprecated use {@link #contains(int, int)} instead
+   * @return <code>true</code> if the point is within this component,
+   * <code>false</code> otherwise.
+   *
+   * @deprecated Deprecated in favor of <code>contains(int, int)</code>.
    */
   public boolean inside(int x, int y)
   {
-    return contains(x, y);
+    return contains(x,y);
   }
 
   /**
    * Tests whether or not the specified point is contained within this
-   * component. Coordinates are relative to this component.
+   * component.  Coordinates are relative to this component.
+   *
+   * @param point The point to test.
    *
-   * @param p the point to test
-   * @return true if the point is within this component
-   * @throws NullPointerException if p is null
-   * @see #getComponentAt(Point)
-   * @since 1.1
+   * @return <code>true</code> if the point is within this component,
+   * <code>false</code> otherwise.
    */
   public boolean contains(Point p)
   {
@@ -2047,29 +1375,36 @@
   }
 
   /**
-   * Returns the component occupying the position (x,y). This will either
+   * Returns the component occupying the position (x,y).  This will either
    * be this component, an immediate child component, or <code>null</code>
    * if neither of the first two occupies the specified location.
    *
-   * @param x the X coordinate to search for components at
-   * @param y the Y coordinate to search for components at
-   * @return the component at the specified location, or null
-   * @see #contains(int, int)
+   * @param x The X coordinate to search for components at.
+   * @param y The Y coordinate to search for components at.
+   *
+   * @return The component at the specified location, for <code>null</code>
+   * if there is none.
    */
   public Component getComponentAt(int x, int y)
   {
-    return contains(x, y) ? this : null;
+    if (contains(x,y))
+      return this;
+    return null;
   }
 
   /**
-   * Returns the component occupying the position (x,y). This will either
+   * Returns the component occupying the position (x,y).  This will either
    * be this component, an immediate child component, or <code>null</code>
    * if neither of the first two occupies the specified location.
    *
-   * @param x the X coordinate to search for components at
-   * @param y the Y coordinate to search for components at
-   * @return the component at the specified location, or null
-   * @deprecated use {@link #getComponentAt(int, int)} instead
+   * @param x The X coordinate to search for components at.
+   * @param y The Y coordinate to search for components at.
+   *
+   * @return The component at the specified location, for <code>null</code>
+   * if there is none.
+   *
+   * @deprecated The method is deprecated in favor of 
+   * <code>getComponentAt()</code>.
    */
   public Component locate(int x, int y)
   {
@@ -2077,15 +1412,14 @@
   }
 
   /**
-   * Returns the component occupying the position (x,y). This will either
+   * Returns the component occupying the specified point  This will either
    * be this component, an immediate child component, or <code>null</code>
    * if neither of the first two occupies the specified location.
    *
-   * @param p the point to search for components at
-   * @return the component at the specified location, or null
-   * @throws NullPointerException if p is null
-   * @see #contains(Point)
-   * @since 1.1
+   * @param point The point to search for components at.
+   *
+   * @return The component at the specified location, for <code>null</code>
+   * if there is none.
    */
   public Component getComponentAt(Point p)
   {
@@ -2095,55 +1429,91 @@
   /**
    * AWT 1.0 event dispatcher.
    *
-   * @param e the event to dispatch
-   * @deprecated use {@link #dispatchEvent(AWTEvent)} instead
+   * @deprecated Deprecated in favor of <code>dispatchEvent()</code>.
    */
   public void deliverEvent(Event e)
   {
-    // XXX Add backward compatibility handling.
   }
 
-  /**
-   * Forwards AWT events to processEvent() if:<ul>
-   * <li>Events have been enabled for this type of event via
-   * <code>enableEvents()</code></li>,
-   * <li>There is at least one registered listener for this type of event</li>
-   * </ul>
-   *
-   * @param e the event to dispatch
-   */
+  /** Forward AWT events to processEvent() if:
+    *     - Events have been enabled for this type of event via enableEvents(),
+    *   OR:
+    *	 - There is at least one registered listener for this type of event
+    * 
+    * @param event The event to dispatch
+    *
+    * @specnote This method is final, but we need to be able to 
+    *           override it in order to handle other event types in our 
+    *	        subclasses. The solution is to define a second, non-final
+    *           method - dispatchEventImpl() - to actually do the work. 
+    *           Investigations with Thread.dumpStack() on the dispatch thread 
+    *           in JDK 1.3 show Sun's implementation is doing the same 
+    *           thing.
+    */
   public final void dispatchEvent(AWTEvent e)
   {
-    // Some subclasses in the AWT package need to override this behavior,
-    // hence the use of dispatchEventImpl().
     dispatchEventImpl(e);
-    if (peer != null && ! e.consumed)
+
+    /* Give the peer a chance to handle the event. */
+    if (peer != null)
       peer.handleEvent(e);
   }
 
+  void dispatchEventImpl(AWTEvent e)
+  {
+    // Make use of event id's in order to avoid multiple instanceof tests.
+    if (e.id <= ComponentEvent.COMPONENT_LAST 
+        && e.id >= ComponentEvent.COMPONENT_FIRST
+        && (componentListener != null 
+	    || (eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= KeyEvent.KEY_LAST
+             && e.id >= KeyEvent.KEY_FIRST
+	     && (keyListener != null
+		 || (eventMask & AWTEvent.KEY_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= MouseEvent.MOUSE_LAST
+             && e.id >= MouseEvent.MOUSE_FIRST
+	     && (mouseListener != null
+		 || mouseMotionListener != null
+		 || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= FocusEvent.FOCUS_LAST
+             && e.id >= FocusEvent.FOCUS_FIRST
+	     && (focusListener != null
+		 || (eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= InputMethodEvent.INPUT_METHOD_LAST
+             && e.id >= InputMethodEvent.INPUT_METHOD_FIRST
+	     && (inputMethodListener != null
+		 || (eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= HierarchyEvent.HIERARCHY_LAST
+             && e.id >= HierarchyEvent.HIERARCHY_FIRST
+	     && (hierarchyListener != null
+		 || hierarchyBoundsListener != null
+		 || (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0))
+      processEvent(e);
+    else if (e.id <= PaintEvent.PAINT_LAST
+	     && e.id >= PaintEvent.PAINT_FIRST
+	     && (eventMask & AWTEvent.PAINT_EVENT_MASK) != 0)      
+      processEvent(e);
+  }
+  
   /**
    * AWT 1.0 event dispatcher.
    *
-   * @param e the event to dispatch
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #dispatchEvent(AWTEvent)} instead
+   * @deprecated Deprecated in favor of <code>dispatchEvent()</code>.
    */
   public boolean postEvent(Event e)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
-   *
-   * @param listener the new listener to add
-   * @see ComponentEvent
-   * @see #removeComponentListener(ComponentListener)
-   * @see #getComponentListeners()
-   * @since 1.1
+   * Adds the specified listener to this component.
+   *
+   * @param listener The new listener to add.
    */
   public synchronized void addComponentListener(ComponentListener l)
   {
@@ -2153,14 +1523,9 @@
   }
 
   /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
+   * Removes the specified listener from the component.
    *
-   * @param listener the listener to remove
-   * @see ComponentEvent
-   * @see #addComponentListener(ComponentListener)
-   * @see #getComponentListeners()
-   * @since 1.1
+   * @param listener The listener to remove.
    */
   public synchronized void removeComponentListener(ComponentListener l)
   {
@@ -2168,194 +1533,74 @@
   }
 
   /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addComponentListener(ComponentListener)
-   * @see #removeComponentListener(ComponentListener)
-   * @since 1.4
-   */
-  public synchronized ComponentListener[] getComponentListeners()
-  {
-    return (ComponentListener[])
-      AWTEventMulticaster.getListeners(componentListener,
-                                       ComponentListener.class);
-  }
-
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
+   * Adds the specified listener to this component.
    *
-   * @param listener the new listener to add
-   * @see FocusEvent
-   * @see #removeFocusListener(FocusListener)
-   * @see #getFocusListeners()
-   * @since 1.1
+   * @param listener The new listener to add.
    */
   public synchronized void addFocusListener(FocusListener l)
   {
     focusListener = AWTEventMulticaster.add(focusListener, l);
     if (focusListener != null)
-      enableEvents(AWTEvent.FOCUS_EVENT_MASK);
+      enableEvents(AWTEvent.FOCUS_EVENT_MASK);    
   }
 
   /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
+   * Removes the specified listener from the component.
    *
-   * @param listener the listener to remove
-   * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #getFocusListeners()
-   * @since 1.1
+   * @param listener The listener to remove.
    */
   public synchronized void removeFocusListener(FocusListener l)
   {
     focusListener = AWTEventMulticaster.remove(focusListener, l);
   }
-
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addFocusListener(FocusListener)
-   * @see #removeFocusListener(FocusListener)
-   * @since 1.4
-   */
-  public synchronized FocusListener[] getFocusListeners()
-  {
-    return (FocusListener[])
-      AWTEventMulticaster.getListeners(focusListener, FocusListener.class);
-  }
-
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
-   *
-   * @param listener the new listener to add
-   * @see HierarchyEvent
-   * @see #removeHierarchyListener(HierarchyListener)
-   * @see #getHierarchyListeners()
-   * @since 1.3
-   */
+  
+  /** @since 1.3 */
   public synchronized void addHierarchyListener(HierarchyListener l)
   {
     hierarchyListener = AWTEventMulticaster.add(hierarchyListener, l);
     if (hierarchyListener != null)
-      enableEvents(AWTEvent.HIERARCHY_EVENT_MASK);
+      enableEvents(AWTEvent.HIERARCHY_EVENT_MASK);    
   }
-
-  /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
-   *
-   * @param listener the listener to remove
-   * @see HierarchyEvent
-   * @see #addHierarchyListener(HierarchyListener)
-   * @see #getHierarchyListeners()
-   * @since 1.3
-   */
+  
+  /** @since 1.3 */
   public synchronized void removeHierarchyListener(HierarchyListener l)
   {
     hierarchyListener = AWTEventMulticaster.remove(hierarchyListener, l);
   }
 
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addHierarchyListener(HierarchyListener)
-   * @see #removeHierarchyListener(HierarchyListener)
-   * @since 1.4
-   */
-  public synchronized HierarchyListener[] getHierarchyListeners()
-  {
-    return (HierarchyListener[])
-      AWTEventMulticaster.getListeners(hierarchyListener,
-                                       HierarchyListener.class);
-  }
-
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
-   *
-   * @param listener the new listener to add
-   * @see HierarchyEvent
-   * @see #removeHierarchyBoundsListener(HierarchyBoundsListener)
-   * @see #getHierarchyBoundsListeners()
-   * @since 1.3
-   */
-  public synchronized void
-    addHierarchyBoundsListener(HierarchyBoundsListener l)
+  /** @since 1.3 */
+  public synchronized void addHierarchyBoundsListener(HierarchyBoundsListener l)
   {
-    hierarchyBoundsListener =
+    hierarchyBoundsListener = 
       AWTEventMulticaster.add(hierarchyBoundsListener, l);
     if (hierarchyBoundsListener != null)
-      enableEvents(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK);
+      enableEvents(AWTEvent.HIERARCHY_EVENT_MASK);    
   }
 
-  /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
-   *
-   * @param listener the listener to remove
-   * @see HierarchyEvent
-   * @see #addHierarchyBoundsListener(HierarchyBoundsListener)
-   * @see #getHierarchyBoundsListeners()
-   * @since 1.3
-   */
-  public synchronized void
+  /** @since 1.3 */
+  public synchronized void 
     removeHierarchyBoundsListener(HierarchyBoundsListener l)
   {
-    hierarchyBoundsListener =
+    hierarchyBoundsListener = 
       AWTEventMulticaster.remove(hierarchyBoundsListener, l);
   }
 
   /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addHierarchyBoundsListener(HierarchyBoundsListener)
-   * @see #removeHierarchyBoundsListener(HierarchyBoundsListener)
-   * @since 1.4
-   */
-  public synchronized HierarchyBoundsListener[] getHierarchyBoundsListeners()
-  {
-    return (HierarchyBoundsListener[])
-      AWTEventMulticaster.getListeners(hierarchyBoundsListener,
-                                       HierarchyBoundsListener.class);
-  }
-
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
+   * Adds the specified listener to this component.
    *
-   * @param listener the new listener to add
-   * @see KeyEvent
-   * @see #removeKeyListener(KeyListener)
-   * @see #getKeyListeners()
-   * @since 1.1
+   * @param listener The new listener to add.
    */
   public synchronized void addKeyListener(KeyListener l)
   {
     keyListener = AWTEventMulticaster.add(keyListener, l);
     if (keyListener != null)
-      enableEvents(AWTEvent.KEY_EVENT_MASK);
+      enableEvents(AWTEvent.KEY_EVENT_MASK);    
   }
 
   /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
+   * Removes the specified listener from the component.
    *
-   * @param listener the listener to remove
-   * @see KeyEvent
-   * @see #addKeyListener(KeyListener)
-   * @see #getKeyListeners()
-   * @since 1.1
+   * @param listener The listener to remove.
    */
   public synchronized void removeKeyListener(KeyListener l)
   {
@@ -2363,318 +1608,158 @@
   }
 
   /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addKeyListener(KeyListener)
-   * @see #removeKeyListener(KeyListener)
-   * @since 1.4
-   */
-  public synchronized KeyListener[] getKeyListeners()
-  {
-    return (KeyListener[])
-      AWTEventMulticaster.getListeners(keyListener, KeyListener.class);
-  }
-
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
+   * Adds the specified listener to this component.
    *
-   * @param listener the new listener to add
-   * @see MouseEvent
-   * @see #removeMouseListener(MouseListener)
-   * @see #getMouseListeners()
-   * @since 1.1
+   * @param listener The new listener to add.
    */
   public synchronized void addMouseListener(MouseListener l)
   {
     mouseListener = AWTEventMulticaster.add(mouseListener, l);
     if (mouseListener != null)
-      enableEvents(AWTEvent.MOUSE_EVENT_MASK);
+      enableEvents(AWTEvent.MOUSE_EVENT_MASK);    
   }
 
   /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
+   * Removes the specified listener from the component.
    *
-   * @param listener the listener to remove
-   * @see MouseEvent
-   * @see #addMouseListener(MouseListener)
-   * @see #getMouseListeners()
-   * @since 1.1
+   * @param listener The listener to remove.
    */
   public synchronized void removeMouseListener(MouseListener l)
   {
-    mouseListener = AWTEventMulticaster.remove(mouseListener, l);
-  }
-
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addMouseListener(MouseListener)
-   * @see #removeMouseListener(MouseListener)
-   * @since 1.4
-   */
-  public synchronized MouseListener[] getMouseListeners()
-  {
-    return (MouseListener[])
-      AWTEventMulticaster.getListeners(mouseListener, MouseListener.class);
+    mouseListener = AWTEventMulticaster.remove(mouseListener, l);    
   }
 
   /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
+   * Adds the specified listener to this component.
    *
-   * @param listener the new listener to add
-   * @see MouseEvent
-   * @see #removeMouseMotionListener(MouseMotionListener)
-   * @see #getMouseMotionListeners()
-   * @since 1.1
+   * @param listener The new listener to add.
    */
   public synchronized void addMouseMotionListener(MouseMotionListener l)
   {
     mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener, l);
     if (mouseMotionListener != null)
-      enableEvents(AWTEvent.MOUSE_EVENT_MASK);
+      enableEvents(AWTEvent.MOUSE_EVENT_MASK);    
   }
 
   /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
+   * Removes the specified listener from the component.
    *
-   * @param listener the listener to remove
-   * @see MouseEvent
-   * @see #addMouseMotionListener(MouseMotionListener)
-   * @see #getMouseMotionListeners()
-   * @since 1.1
+   * @param listener The listener to remove.
    */
   public synchronized void removeMouseMotionListener(MouseMotionListener l)
   {
     mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, l);
   }
 
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addMouseMotionListener(MouseMotionListener)
-   * @see #removeMouseMotionListener(MouseMotionListener)
-   * @since 1.4
-   */
-  public synchronized MouseMotionListener[] getMouseMotionListeners()
+  /** @since 1.2 */
+  public synchronized void addInputMethodListener(InputMethodListener l)
   {
-    return (MouseMotionListener[])
-      AWTEventMulticaster.getListeners(mouseMotionListener,
-                                       MouseMotionListener.class);
+    inputMethodListener = AWTEventMulticaster.add(inputMethodListener, l);
+    if (inputMethodListener != null)
+      enableEvents(AWTEvent.INPUT_METHOD_EVENT_MASK);    
   }
 
-  /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
-   *
-   * @param listener the new listener to add
-   * @see MouseEvent
-   * @see MouseWheelEvent
-   * @see #removeMouseWheelListener(MouseWheelListener)
-   * @see #getMouseWheelListeners()
-   * @since 1.4
-   */
-  public synchronized void addMouseWheelListener(MouseWheelListener l)
+  /** @since 1.2 */
+  public synchronized void removeInputMethodListener(InputMethodListener l)
   {
-    mouseWheelListener = AWTEventMulticaster.add(mouseWheelListener, l);
-    if (mouseWheelListener != null)
-      enableEvents(AWTEvent.MOUSE_WHEEL_EVENT_MASK);
+    inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);
   }
 
-  /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
-   *
-   * @param listener the listener to remove
-   * @see MouseEvent
-   * @see MouseWheelEvent
-   * @see #addMouseWheelListener(MouseWheelListener)
-   * @see #getMouseWheelListeners()
-   * @since 1.4
-   */
-  public synchronized void removeMouseWheelListener(MouseWheelListener l)
+  /** Returns all registered EventListers of the given listenerType. 
+    * listenerType must be a subclass of EventListener, or a 
+    * ClassClassException is thrown.
+    * @since 1.3 
+    */
+  public EventListener[] getListeners(Class listenerType)
+  {
+    if (listenerType == ComponentListener.class)
+      return getListenersImpl(listenerType, componentListener);
+    else if (listenerType == FocusListener.class)
+      return getListenersImpl(listenerType, focusListener);
+    else if (listenerType == KeyListener.class)
+      return getListenersImpl(listenerType, keyListener);
+    else if (listenerType == MouseListener.class)
+      return getListenersImpl(listenerType, mouseListener);
+    else if (listenerType == MouseMotionListener.class)
+      return getListenersImpl(listenerType, mouseMotionListener);
+    else if (listenerType == InputMethodListener.class)
+      return getListenersImpl(listenerType, inputMethodListener);
+    else if (listenerType == HierarchyListener.class)
+      return getListenersImpl(listenerType, hierarchyListener);
+    else if (listenerType == HierarchyBoundsListener.class)
+      return getListenersImpl(listenerType, hierarchyBoundsListener);
+    else
+      return getListenersImpl(listenerType, null);
+  }
+  
+  static EventListener[] getListenersImpl(Class listenerType, EventListener el)
   {
-    mouseWheelListener = AWTEventMulticaster.remove(mouseWheelListener, l);
+    if (! EventListener.class.isAssignableFrom(listenerType))
+      throw new ClassCastException();
+    
+    Vector v = new Vector();
+    if (el != null)
+      getListenerList (el, v);    
+    EventListener[] el_a = (EventListener[]) Array.newInstance(listenerType, 
+							       v.size());
+    v.copyInto(el_a);
+    return el_a;
+  }
+
+  static void getListenerList(EventListener el, Vector v)
+  {
+    if (el instanceof AWTEventMulticaster)
+      {
+        AWTEventMulticaster mc = (AWTEventMulticaster) el;
+        getListenerList(mc.a, v);
+	getListenerList(mc.b, v);
+      }
+    else
+      v.addElement(el);      
   }
 
+  // The input method framework is currently unimplemented.  
+  // /** @since 1.2 */
+  //
+  //public InputMethodRequests getInputMethodRequests()
+  //
+  // /** @since 1.2 */
+  //
+  // public InputContext getInputContext()
+
   /**
-   * Returns an array of all specified listeners registered on this component.
+   * Enables the specified events.  The events to enable are specified
+   * by OR-ing together the desired masks from <code>AWTEvent</code>.
+   * <p>
+   * Events are enabled by default when a listener is attached to the
+   * component for that event type.  This method can be used by subclasses
+   * to ensure the delivery of a specified event regardless of whether
+   * or not a listener is attached.
    *
-   * @return an array of listeners
-   * @see #addMouseWheelListener(MouseWheelListener)
-   * @see #removeMouseWheelListener(MouseWheelListener)
-   * @since 1.4
+   * @param enable_events The desired events to enable.
    */
-  public synchronized MouseWheelListener[] getMouseWheelListeners()
+  protected final void enableEvents(long eventsToEnable)
   {
-    return (MouseWheelListener[])
-      AWTEventMulticaster.getListeners(mouseWheelListener,
-                                       MouseWheelListener.class);
+    eventMask |= eventsToEnable;
+    // TODO: Unlike Sun's implementation, I think we should try and 
+    // enable/disable events at the peer (gtk/X) level. This will avoid 
+    // clogging the event pipeline with useless mousemove events that 
+    // we arn't interested in, etc. This will involve extending the peer 
+    // interface, but thats okay because the peer interfaces have been
+    // deprecated for a long time, and no longer feature in the 
+    // API specification at all.
+
+    if (isLightweight() && (parent != null))
+      parent.enableEvents(eventsToEnable);
+    else if (peer != null)
+      peer.setEventMask (eventMask);
   }
 
   /**
-   * Adds the specified listener to this component. This is harmless if the
-   * listener is null, but if the listener has already been registered, it
-   * will now be registered twice.
+   * Disables the specified events.  The events to disable are specified
+   * by OR-ing together the desired masks from <code>AWTEvent</code>.
    *
-   * @param listener the new listener to add
-   * @see InputMethodEvent
-   * @see #removeInputMethodListener(InputMethodListener)
-   * @see #getInputMethodListeners()
-   * @see #getInputMethodRequests()
-   * @since 1.2
-   */
-  public synchronized void addInputMethodListener(InputMethodListener l)
-  {
-    inputMethodListener = AWTEventMulticaster.add(inputMethodListener, l);
-    if (inputMethodListener != null)
-      enableEvents(AWTEvent.INPUT_METHOD_EVENT_MASK);
-  }
-
-  /**
-   * Removes the specified listener from the component. This is harmless if
-   * the listener was not previously registered.
-   *
-   * @param listener the listener to remove
-   * @see InputMethodEvent
-   * @see #addInputMethodListener(InputMethodListener)
-   * @see #getInputMethodRequests()
-   * @since 1.2
-   */
-  public synchronized void removeInputMethodListener(InputMethodListener l)
-  {
-    inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);
-  }
-
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addInputMethodListener(InputMethodListener)
-   * @see #removeInputMethodListener(InputMethodListener)
-   * @since 1.4
-   */
-  public synchronized InputMethodListener[] getInputMethodListeners()
-  {
-    return (InputMethodListener[])
-      AWTEventMulticaster.getListeners(inputMethodListener,
-                                       InputMethodListener.class);
-  }
-
-  /**
-   * Returns all registered EventListers of the given listenerType.
-   *
-   * @param listenerType the class of listeners to filter
-   * @return an array of registered listeners
-   * @see #getComponentListeners()
-   * @see #getFocusListeners()
-   * @see #getHierarchyListeners()
-   * @see #getHierarchyBoundsListeners()
-   * @see #getKeyListeners()
-   * @see #getMouseListeners()
-   * @see #getMouseMotionListeners()
-   * @see #getMouseWheelListeners()
-   * @see #getInputMethodListeners()
-   * @see #getPropertyChangeListeners()
-   * @since 1.3
-   */
-  public EventListener[] getListeners(Class listenerType)
-  {
-    if (listenerType == ComponentListener.class)
-      return getComponentListeners();
-    if (listenerType == FocusListener.class)
-      return getFocusListeners();
-    if (listenerType == HierarchyListener.class)
-      return getHierarchyListeners();
-    if (listenerType == HierarchyBoundsListener.class)
-      return getHierarchyBoundsListeners();
-    if (listenerType == KeyListener.class)
-      return getKeyListeners();
-    if (listenerType == MouseListener.class)
-      return getMouseListeners();
-    if (listenerType == MouseMotionListener.class)
-      return getMouseMotionListeners();
-    if (listenerType == MouseWheelListener.class)
-      return getMouseWheelListeners();
-    if (listenerType == InputMethodListener.class)
-      return getInputMethodListeners();
-    if (listenerType == PropertyChangeListener.class)
-      return getPropertyChangeListeners();
-    return (EventListener[]) Array.newInstance(listenerType, 0);
-  }
-
-  /**
-   * Returns the input method request handler, for subclasses which support
-   * on-the-spot text input. By default, input methods are handled by AWT,
-   * and this returns null.
-   *
-   * @return the input method handler, null by default
-   * @since 1.2
-   */
-  public InputMethodRequests getInputMethodRequests()
-  {
-    return null;
-  }
-
-  /**
-   * Gets the input context of this component, which is inherited from the
-   * parent unless this is overridden.
-   *
-   * @return the text input context
-   * @since 1.2
-   */
-  public InputContext getInputContext()
-  {
-    return parent == null ? null : parent.getInputContext();
-  }
-
-  /**
-   * Enables the specified events. The events to enable are specified
-   * by OR-ing together the desired masks from <code>AWTEvent</code>.
-   *
-   * <p>Events are enabled by default when a listener is attached to the
-   * component for that event type. This method can be used by subclasses
-   * to ensure the delivery of a specified event regardless of whether
-   * or not a listener is attached.
-   *
-   * @param eventsToEnable the desired events to enable
-   * @see #processEvent(AWTEvent)
-   * @see #disableEvents(long)
-   * @see AWTEvent
-   * @since 1.1
-   */
-  protected final void enableEvents(long eventsToEnable)
-  {
-    eventMask |= eventsToEnable;
-    // TODO: Unlike Sun's implementation, I think we should try and
-    // enable/disable events at the peer (gtk/X) level. This will avoid
-    // clogging the event pipeline with useless mousemove events that
-    // we arn't interested in, etc. This will involve extending the peer
-    // interface, but thats okay because the peer interfaces have been
-    // deprecated for a long time, and no longer feature in the
-    // API specification at all.
-    if (isLightweight() && parent != null)
-      parent.enableEvents(eventsToEnable);
-    else if (peer != null)
-      peer.setEventMask(eventMask);
-  }
-
-  /**
-   * Disables the specified events. The events to disable are specified
-   * by OR-ing together the desired masks from <code>AWTEvent</code>.
-   *
-   * @param eventsToDisable the desired events to disable
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param disable_events The desired events to disable.
    */
   protected final void disableEvents(long eventsToDisable)
   {
@@ -2682,52 +1767,80 @@
     // forward new event mask to peer?
   }
 
-  /**
-   * This is called by the EventQueue if two events with the same event id
-   * and owner component are queued. Returns a new combined event, or null if
-   * no combining is done. The coelesced events are currently mouse moves
-   * (intermediate ones are discarded) and paint events (a merged paint is
-   * created in place of the two events).
-   *
-   * @param existingEvent the event on the queue
-   * @param newEvent the new event that might be entered on the queue
-   * @return null if both events are kept, or the replacement coelesced event
-   */
+  /** coalesceEvents is called by the EventQueue if two events with the same 
+    * event id are queued. Returns a new combined event, or null if no 
+    * combining is done. 
+    */
   protected AWTEvent coalesceEvents(AWTEvent existingEvent, AWTEvent newEvent)
   {
     switch (existingEvent.id)
       {
       case MouseEvent.MOUSE_MOVED:
       case MouseEvent.MOUSE_DRAGGED:
-        // Just drop the old (intermediate) event and return the new one.
-        return newEvent;
+	// Just drop the old (intermediate) event and return the new one.
+	return newEvent;
       case PaintEvent.PAINT:
       case PaintEvent.UPDATE:
-        return coalescePaintEvents((PaintEvent) existingEvent,
-                                   (PaintEvent) newEvent);
-      default:
-        return null;
+	return coalescePaintEvents((PaintEvent) existingEvent,
+				   (PaintEvent) newEvent);
       }
+    return null;
+  }
+  
+  /**
+   * Coalesce paint events. Current heuristic is: Merge if the union of
+   * areas is less than twice that of the sum of the areas. The X server
+   * tend to create a lot of paint events that are adjacent but not
+   * overlapping.
+   *
+   * <pre>
+   * +------+
+   * |      +-----+  ...will be merged
+   * |      |     |
+   * |      |     |
+   * +------+     |
+   *        +-----+
+   * 
+   * +---------------+--+
+   * |               |  |  ...will not be merged
+   * +---------------+  |
+   *                 |  |
+   *                 |  |
+   *                 |  |
+   *                 |  |
+   *                 |  |
+   *                 +--+
+   * </pre>
+   */
+  private PaintEvent coalescePaintEvents(PaintEvent queuedEvent,
+					 PaintEvent newEvent)
+  {
+    Rectangle r1 = queuedEvent.getUpdateRect();
+    Rectangle r2 = newEvent.getUpdateRect();
+    Rectangle union = r1.union(r2);
+    
+    int r1a = r1.width * r1.height;
+    int r2a = r2.width * r2.height;
+    int ua  = union.width * union.height;
+    
+    if (ua > (r1a+r2a)*2)
+      return null;
+    /* The 2 factor should maybe be reconsidered. Perhaps 3/2
+       would be better? */
+
+    newEvent.setUpdateRect(union);
+    return newEvent;
   }
 
   /**
-   * Processes the specified event. In this class, this method simply
+   * Processes the specified event.  In this class, this method simply
    * calls one of the more specific event handlers.
-   *
-   * @param event the event to process
-   * @throws NullPointerException if e is null
-   * @see #processComponentEvent(ComponentEvent)
-   * @see #processFocusEvent(FocusEvent)
-   * @see #processKeyEvent(KeyEvent)
-   * @see #processMouseEvent(MouseEvent)
-   * @see #processMouseMotionEvent(MouseEvent)
-   * @see #processInputMethodEvent(InputMethodEvent)
-   * @see #processHierarchyEvent(HierarchyEvent)
-   * @see #processMouseWheelEvent(MouseWheelEvent)
-   * @since 1.1
+   * 
+   * @param event The event to process.
    */
   protected void processEvent(AWTEvent e)
   {
+
     /* Note: the order of these if statements are
        important. Subclasses must be checked first. Eg. MouseEvent
        must be checked before ComponentEvent, since a MouseEvent
@@ -2737,15 +1850,13 @@
       processFocusEvent((FocusEvent) e);
     else if (e instanceof PaintEvent)
       processPaintEvent((PaintEvent) e);
-    else if (e instanceof MouseWheelEvent)
-      processMouseWheelEvent((MouseWheelEvent) e);
     else if (e instanceof MouseEvent)
       {
-        if (e.id == MouseEvent.MOUSE_MOVED
-            || e.id == MouseEvent.MOUSE_DRAGGED)
-          processMouseMotionEvent((MouseEvent) e);
-        else
-          processMouseEvent((MouseEvent) e);
+        if (e.id == MouseEvent.MOUSE_MOVED 
+	    || e.id == MouseEvent.MOUSE_DRAGGED)
+	  processMouseMotionEvent((MouseEvent) e);
+	else
+	  processMouseEvent((MouseEvent) e);
       }
     else if (e instanceof KeyEvent)
       processKeyEvent((KeyEvent) e);
@@ -2756,23 +1867,18 @@
     else if (e instanceof HierarchyEvent)
       {
         if (e.id == HierarchyEvent.HIERARCHY_CHANGED)
-          processHierarchyEvent((HierarchyEvent) e);
-        else
-          processHierarchyBoundsEvent((HierarchyEvent) e);
+	  processHierarchyEvent((HierarchyEvent) e);
+	else
+	  processHierarchyBoundsEvent((HierarchyEvent) e);
       }
   }
 
   /**
    * Called when a component event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners
+   * enabled.  This method passes the event along to any listeners
    * that are attached.
    *
-   * @param event the <code>ComponentEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see ComponentListener
-   * @see #addComponentListener(ComponentListener)
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param event The <code>ComponentEvent</code> to process.
    */
   protected void processComponentEvent(ComponentEvent e)
   {
@@ -2780,32 +1886,30 @@
       return;
     switch (e.id)
       {
-      case ComponentEvent.COMPONENT_HIDDEN:
-        componentListener.componentHidden(e);
-        break;
-      case ComponentEvent.COMPONENT_MOVED:
-        componentListener.componentMoved(e);
-        break;
-      case ComponentEvent.COMPONENT_RESIZED:
-        componentListener.componentResized(e);
-        break;
-      case ComponentEvent.COMPONENT_SHOWN:
-        componentListener.componentShown(e);
-        break;
+        case ComponentEvent.COMPONENT_HIDDEN:
+	  componentListener.componentHidden(e);
+	break;
+		
+        case ComponentEvent.COMPONENT_MOVED:
+	  componentListener.componentMoved(e);
+	break;
+	
+	case ComponentEvent.COMPONENT_RESIZED:
+	  componentListener.componentResized(e);
+	break;
+	
+	case ComponentEvent.COMPONENT_SHOWN:
+	  componentListener.componentShown(e);
+	break;
       }
   }
 
   /**
    * Called when a focus event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners
+   * enabled.  This method passes the event along to any listeners
    * that are attached.
    *
-   * @param event the <code>FocusEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see FocusListener
-   * @see #addFocusListener(FocusListener)
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param event The <code>FocusEvent</code> to process.
    */
   protected void processFocusEvent(FocusEvent e)
   {
@@ -2814,25 +1918,20 @@
     switch (e.id)
       {
         case FocusEvent.FOCUS_GAINED:
-          focusListener.focusGained(e);
-        break;
+	  focusListener.focusGained(e);
+	break;
         case FocusEvent.FOCUS_LOST:
-          focusListener.focusLost(e);
-        break;
-      }
+	  focusListener.focusLost(e);
+	break;
+      }    
   }
 
   /**
    * Called when a key event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners
+   * enabled.  This method passes the event along to any listeners
    * that are attached.
    *
-   * @param event the <code>KeyEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see KeyListener
-   * @see #addKeyListener(KeyListener)
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param event The <code>KeyEvent</code> to process.
    */
   protected void processKeyEvent(KeyEvent e)
   {
@@ -2840,29 +1939,24 @@
       return;
     switch (e.id)
       {
-        case KeyEvent.KEY_PRESSED:
-          keyListener.keyPressed(e);
-        break;
-        case KeyEvent.KEY_RELEASED:
-          keyListener.keyReleased(e);
-        break;
-        case KeyEvent.KEY_TYPED:
-          keyListener.keyTyped(e);
-        break;
+	case KeyEvent.KEY_PRESSED:
+	  keyListener.keyPressed(e);
+	break;
+	case KeyEvent.KEY_RELEASED:
+	  keyListener.keyReleased(e);
+	break;
+	case KeyEvent.KEY_TYPED:
+	  keyListener.keyTyped(e);
+	break;
       }
   }
 
   /**
    * Called when a regular mouse event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners
+   * enabled.  This method passes the event along to any listeners
    * that are attached.
    *
-   * @param event the <code>MouseEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see MouseListener
-   * @see #addMouseListener(MouseListener)
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param event The <code>MouseEvent</code> to process.
    */
   protected void processMouseEvent(MouseEvent e)
   {
@@ -2870,35 +1964,30 @@
       return;
     switch (e.id)
       {
-        case MouseEvent.MOUSE_CLICKED:
-          mouseListener.mouseClicked(e);
-        break;
+	case MouseEvent.MOUSE_CLICKED:
+	  mouseListener.mouseClicked(e);
+	break;
         case MouseEvent.MOUSE_ENTERED:
-          mouseListener.mouseEntered(e);
-        break;
-        case MouseEvent.MOUSE_EXITED:
-          mouseListener.mouseExited(e);
-        break;
-        case MouseEvent.MOUSE_PRESSED:
-          mouseListener.mousePressed(e);
-        break;
-        case MouseEvent.MOUSE_RELEASED:
-          mouseListener.mouseReleased(e);
-        break;
+	  mouseListener.mouseEntered(e);
+	break;
+	case MouseEvent.MOUSE_EXITED:
+	  mouseListener.mouseExited(e);
+	break;
+	case MouseEvent.MOUSE_PRESSED:
+	  mouseListener.mousePressed(e);
+	break;
+	case MouseEvent.MOUSE_RELEASED:
+	  mouseListener.mouseReleased(e);
+	break;
       }
   }
 
   /**
    * Called when a mouse motion event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners
+   * enabled.  This method passes the event along to any listeners
    * that are attached.
    *
-   * @param event the <code>MouseMotionEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see MouseMotionListener
-   * @see #addMouseMotionListener(MouseMotionListener)
-   * @see #enableEvents(long)
-   * @since 1.1
+   * @param event The <code>MouseMotionEvent</code> to process.
    */
   protected void processMouseMotionEvent(MouseEvent e)
   {
@@ -2906,73 +1995,32 @@
       return;
     switch (e.id)
       {
-        case MouseEvent.MOUSE_DRAGGED:
-          mouseMotionListener.mouseDragged(e);
-        break;
+	case MouseEvent.MOUSE_DRAGGED:
+	  mouseMotionListener.mouseDragged(e);
+	break;
         case MouseEvent.MOUSE_MOVED:
-          mouseMotionListener.mouseMoved(e);
-        break;
-      }
-  }
-
-  /**
-   * Called when a mouse wheel event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners that are
-   * attached.
-   *
-   * @param event the <code>MouseWheelEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see MouseWheelListener
-   * @see #addMouseWheelListener(MouseWheelListener)
-   * @see #enableEvents(long)
-   * @since 1.4
-   */
-  protected void processMouseWheelEvent(MouseWheelEvent e)
-  {
-    if (mouseWheelListener != null
-        && e.id == MouseEvent.MOUSE_WHEEL)
-      mouseWheelListener.mouseWheelMoved(e);
+	  mouseMotionListener.mouseMoved(e);
+	break;
+      }	
   }
 
-  /**
-   * Called when an input method event is dispatched and component events are
-   * enabled. This method passes the event along to any listeners that are
-   * attached.
-   *
-   * @param event the <code>InputMethodEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see InputMethodListener
-   * @see #addInputMethodListener(InputMethodListener)
-   * @see #enableEvents(long)
-   * @since 1.2
-   */
+  /** @since 1.2 */
   protected void processInputMethodEvent(InputMethodEvent e)
   {
     if (inputMethodListener == null)
       return;
     switch (e.id)
       {
-        case InputMethodEvent.CARET_POSITION_CHANGED:
+	case InputMethodEvent.CARET_POSITION_CHANGED:
           inputMethodListener.caretPositionChanged(e);
-        break;
-        case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
+	break;
+	case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
           inputMethodListener.inputMethodTextChanged(e);
-        break;
-      }
+	break;
+      }	
   }
-
-  /**
-   * Called when a hierarchy change event is dispatched and component events
-   * are enabled. This method passes the event along to any listeners that are
-   * attached.
-   *
-   * @param event the <code>HierarchyEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see HierarchyListener
-   * @see #addHierarchyListener(HierarchyListener)
-   * @see #enableEvents(long)
-   * @since 1.3
-   */
+  
+  /** @since 1.3 */
   protected void processHierarchyEvent(HierarchyEvent e)
   {
     if (hierarchyListener == null)
@@ -2980,19 +2028,8 @@
     if (e.id == HierarchyEvent.HIERARCHY_CHANGED)
       hierarchyListener.hierarchyChanged(e);
   }
-
-  /**
-   * Called when a hierarchy bounds event is dispatched and component events
-   * are enabled. This method passes the event along to any listeners that are
-   * attached.
-   *
-   * @param event the <code>HierarchyEvent</code> to process
-   * @throws NullPointerException if e is null
-   * @see HierarchyBoundsListener
-   * @see #addHierarchyBoundsListener(HierarchyBoundsListener)
-   * @see #enableEvents(long)
-   * @since 1.3
-   */
+  
+  /** @since 1.3 */
   protected void processHierarchyBoundsEvent(HierarchyEvent e)
   {
     if (hierarchyBoundsListener == null)
@@ -3000,177 +2037,155 @@
     switch (e.id)
       {
         case HierarchyEvent.ANCESTOR_MOVED:
-          hierarchyBoundsListener.ancestorMoved(e);
-        break;
-        case HierarchyEvent.ANCESTOR_RESIZED:
-          hierarchyBoundsListener.ancestorResized(e);
-        break;
+	  hierarchyBoundsListener.ancestorMoved(e);
+	break;
+	case HierarchyEvent.ANCESTOR_RESIZED:
+	  hierarchyBoundsListener.ancestorResized(e);
+	break;
+      }
+  }
+
+  private void processPaintEvent(PaintEvent event)
+  {
+    // Can't do graphics without peer
+    if (peer == null)
+      return;
+
+    Graphics gfx = getGraphics();
+    Shape clip = event.getUpdateRect();
+    gfx.setClip(clip);
+
+    switch (event.id)
+      {
+      case PaintEvent.PAINT:
+	paint(gfx);
+	break;
+      case PaintEvent.UPDATE:
+	update(gfx);
+	break;
+      default:
+	throw new IllegalArgumentException("unknown paint event");
       }
   }
 
   /**
    * AWT 1.0 event processor.
    *
-   * @param evt the event to handle
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processEvent(AWTEvent)} instead
+   * @deprecated Deprecated in favor of <code>processEvent</code>.
    */
   public boolean handleEvent(Event evt)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseEvent()</code>.
    */
   public boolean mouseDown(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
-
+  
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseMotionEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseMotionEvent()</code>.
    */
   public boolean mouseDrag(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseEvent()</code>.
    */
   public boolean mouseUp(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseMotionEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseMotionEvent()</code>.
    */
   public boolean mouseMove(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseEvent()</code>.
    */
   public boolean mouseEnter(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 mouse event.
    *
-   * @param evt the event to handle
-   * @param x the x coordinate, ignored
-   * @param y the y coordinate, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processMouseEvent(MouseEvent)} instead
+   * @deprecated Deprecated in favor of <code>processMouseEvent()</code>.
    */
   public boolean mouseExit(Event evt, int x, int y)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 key press event.
    *
-   * @param evt the event to handle
-   * @param key the key pressed, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processKeyEvent(KeyEvent)} instead
+   * @deprecated Deprecated in favor of <code>processKeyEvent</code>.
    */
   public boolean keyDown(Event evt, int key)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 key press event.
    *
-   * @param evt the event to handle
-   * @param key the key pressed, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processKeyEvent(KeyEvent)} instead
+   * @deprecated Deprecated in favor of <code>processKeyEvent</code>.
    */
   public boolean keyUp(Event evt, int key)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * AWT 1.0 action event processor.
    *
-   * @param evt the event to handle
-   * @param what the object acted on, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated in classes which support actions, use
-   *             <code>processActionEvent(ActionEvent)</code> instead
+   * @deprecated Deprecated in favor of the <code>ActionListener</code>
+   * interface.
    */
   public boolean action(Event evt, Object what)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
    * Called to inform this component it has been added to a container.
-   * A native peer - if any - is created at this time. This method is
+   * A native peer - if any - is created at this time.  This method is
    * called automatically by the AWT system and should not be called by
    * user level code.
-   *
-   * @see #isDisplayable()
-   * @see #removeNotify()
    */
   public void addNotify()
   {
     if (peer == null)
       peer = getToolkit().createComponent(this);
+
     /* Now that all the children has gotten their peers, we should
        have the event mask needed for this component and its
        lightweight subcomponents. */
+
     peer.setEventMask(eventMask);
+
     /* We do not invalidate here, but rather leave that job up to
        the peer. For efficiency, the peer can choose not to
        invalidate if it is happy with the current dimensions,
@@ -3179,631 +2194,218 @@
 
   /**
    * Called to inform this component is has been removed from its
-   * container. Its native peer - if any - is destroyed at this time.
+   * container.  Its native peer - if any - is destroyed at this time.
    * This method is called automatically by the AWT system and should
    * not be called by user level code.
-   *
-   * @see #isDisplayable()
-   * @see #addNotify()
    */
   public void removeNotify()
-  {
+  {    
     if (peer != null)
       peer.dispose();
     peer = null;
   }
-
-  /**
-   * AWT 1.0 focus event.
-   *
-   * @param evt the event to handle
-   * @param what the Object focused, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processFocusEvent(FocusEvent)} instead
-   */
+  
+  /** @deprecated */
   public boolean gotFocus(Event evt, Object what)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
-
-  /**
-   * AWT 1.0 focus event.
-   *
-   * @param evt the event to handle
-   * @param what the Object focused, ignored
-   * @return false: since the method was deprecated, the return has no meaning
-   * @deprecated use {@link #processFocusEvent(FocusEvent)} instead
-   */
+  
+  /** @deprecated */
   public boolean lostFocus(Event evt, Object what)
   {
-    // XXX Add backward compatibility handling.
     return false;
   }
 
   /**
-   * Tests whether or not this component is in the group that can be
-   * traversed using the keyboard traversal mechanism (such as the TAB key).
+   * Tests whether or not this component is in the group that can
+   * be traversed using the keyboard traversal mechanism (such as the TAB
+   * key).
    *
-   * @return true if the component is traversed via the TAB key
-   * @see #setFocusable(boolean)
-   * @since 1.1
-   * @deprecated use {@link #isFocusable()} instead
+   * @return <code>true</code> if the component is traversed via the TAB
+   * key, <code>false</code> otherwise.
    */
   public boolean isFocusTraversable()
   {
-    return enabled && visible && (peer == null || peer.isFocusTraversable());
-  }
-
-  /**
-   * Tests if this component can receive focus.
-   *
-   * @return true if this component can receive focus
-   * @since 1.4
-   */
-  public boolean isFocusable()
-  {
-    return focusable;
-  }
-
-  /**
-   * Specify whether this component can receive focus.
-   *
-   * @param focusable the new focusable status
-   * @since 1.4
-   */
-  public void setFocusable(boolean focusable)
-  {
-    firePropertyChange("focusable", this.focusable, focusable);
-    this.focusable = focusable;
+    return enabled && visible && (peer == null || peer.isFocusTraversable ());
   }
 
   /**
-   * Sets the focus traversal keys for a given type of focus events. Normally,
-   * the default values should match the operating system's native choices. To
-   * disable a given traversal, use <code>Collections.EMPTY_SET</code>. The
-   * event dispatcher will consume PRESSED, RELEASED, and TYPED events for the
-   * specified key, although focus can only transfer on PRESSED or RELEASED.
-   *
-   * <p>The defauts are:
-   * <table>
-   *   <th><td>Identifier</td><td>Meaning</td><td>Default</td></th>
-   *   <tr><td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</td>
-   *     <td>Normal forward traversal</td>
-   *     <td>TAB on KEY_PRESSED, Ctrl-TAB on KEY_PRESSED</td></tr>
-   *   <tr><td>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</td>
-   *     <td>Normal backward traversal</td>
-   *     <td>Shift-TAB on KEY_PRESSED, Ctrl-Shift-TAB on KEY_PRESSED</td></tr>
-   *   <tr><td>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</td>
-   *     <td>Go up a traversal cycle</td><td>None</td></tr>
-   * </table>
-   *
-   * <p>Specifying null allows inheritance from the parent, or from the current
-   * KeyboardFocusManager default set. If not null, the set must contain only
-   * AWTKeyStrokes that are not already focus keys and are not KEY_TYPED
-   * events.
-   *
-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
-   *        UP_CYCLE_TRAVERSAL_KEYS
-   * @param keystrokes a set of keys, or null
-   * @throws IllegalArgumentException if id or keystrokes is invalid
-   * @see #getFocusTraversalKeys(int)
-   * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
-   * @since 1.4
-   */
-  public void setFocusTraversalKeys(int id, Set keystrokes)
-  {
-    if (keystrokes == null)
-      throw new IllegalArgumentException();
-    Set sa;
-    Set sb;
-    String name;
-    switch (id)
-      {
-      case KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS:
-        sa = getFocusTraversalKeys
-          (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);
-        sb = getFocusTraversalKeys
-          (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);
-        name = "forwardFocusTraversalKeys";
-        break;
-      case KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS:
-        sa = getFocusTraversalKeys
-          (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);
-        sb = getFocusTraversalKeys
-          (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);
-        name = "backwardFocusTraversalKeys";
-        break;
-      case KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS:
-        sa = getFocusTraversalKeys
-          (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);
-        sb = getFocusTraversalKeys
-          (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);
-        name = "upCycleFocusTraversalKeys";
-        break;
-      default:
-        throw new IllegalArgumentException();
-      }
-    int i = keystrokes.size();
-    Iterator iter = keystrokes.iterator();
-    while (--i >= 0)
-      {
-        Object o = iter.next();
-        if (! (o instanceof AWTKeyStroke)
-            || sa.contains(o) || sb.contains(o)
-            || ((AWTKeyStroke) o).keyCode == KeyEvent.VK_UNDEFINED)
-          throw new IllegalArgumentException();
-      }
-    if (focusTraversalKeys == null)
-      focusTraversalKeys = new Set[3];
-    keystrokes = Collections.unmodifiableSet(new HashSet(keystrokes));
-    firePropertyChange(name, focusTraversalKeys[id], keystrokes);
-    focusTraversalKeys[id] = keystrokes;
-  }
-
-  /**
-   * Returns the set of keys for a given focus traversal action, as defined
-   * in <code>setFocusTraversalKeys</code>. If not set, this is inherited from
-   * the parent component, which may have gotten it from the
-   * KeyboardFocusManager.
-   *
-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
-   *        UP_CYCLE_TRAVERSAL_KEYS
-   * @throws IllegalArgumentException if id is invalid
-   * @see #setFocusTraversalKeys(int, Set)
-   * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
-   * @since 1.4
-   */
-  public Set getFocusTraversalKeys(int id)
-  {
-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS
-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException();
-    Set s = null;
-    if (focusTraversalKeys != null)
-      s = focusTraversalKeys[id];
-    if (s == null && parent != null)
-      s = parent.getFocusTraversalKeys(id);
-    return s == null ? (KeyboardFocusManager.getCurrentKeyboardFocusManager()
-                        .getDefaultFocusTraversalKeys(id)) : s;
-  }
-
-  /**
-   * Tests whether the focus traversal keys for a given action are explicitly
-   * set or inherited.
-   *
-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
-   *        UP_CYCLE_TRAVERSAL_KEYS
-   * @return true if that set is explicitly specified
-   * @throws IllegalArgumentException if id is invalid
-   * @see #getFocusTraversalKeys(int)
-   * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
-   * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
-   * @since 1.4
-   */
-  public boolean areFocusTraversalKeysSet(int id)
-  {
-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS
-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException();
-    return focusTraversalKeys != null && focusTraversalKeys[id] != null;
-  }
-
-  /**
-   * Sets whether focus traversal keys are enabled, which consumes traversal
-   * keys and performs the focus event automatically.
-   *
-   * @param focusTraversalKeysEnabled the new value of the flag
-   * @see #getFocusTraversalKeysEnabled()
-   * @see #setFocusTraversalKeys(int, Set)
-   * @see #getFocusTraversalKeys(int)
-   * @since 1.4
-   */
-  public void setFocusTraversalKeysEnabled(boolean focusTraversalKeysEnabled)
-  {
-    firePropertyChange("focusTraversalKeysEnabled",
-                       this.focusTraversalKeysEnabled,
-                       focusTraversalKeysEnabled);
-    this.focusTraversalKeysEnabled = focusTraversalKeysEnabled;
-  }
-
-  /**
-   * Tests whether focus traversal keys are enabled. If they are, then focus
-   * traversal keys are consumed and focus events performed automatically,
-   * without the component seeing the keystrokes.
-   *
-   * @return true if focus traversal is enabled
-   * @see #setFocusTraversalKeysEnabled(boolean)
-   * @see #setFocusTraversalKeys(int, Set)
-   * @see #getFocusTraversalKeys(int)
-   * @since 1.4
-   */
-  public boolean getFocusTraversalKeysEnabled()
-  {
-    return focusTraversalKeysEnabled;
-  }
-
-  /**
-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be able to receive focus. Thus, this
-   * request may fail, or be delayed until the window receives focus. It is
-   * recommended that <code>requestFocusInWindow</code> be used where
-   * possible to be more platform-independent.
-   *
-   * @see #requestFocusInWindow()
-   * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
+   * Requests that this component be given focus.  The <code>gotFocus()</code>
+   * method on this event will be called when and if this request was
+   * successful.
    */
   public void requestFocus()
   {
-    // If there's no peer then this component can't get the focus. We
+    // If there's no peer then this component can't get the focus.  We
     // treat it as a silent rejection of the request.
     if (peer != null)
-      peer.requestFocus();
+      peer.requestFocus ();
   }
 
-  /**
-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be able to receive focus. Thus, this
-   * request may fail, or be delayed until the window receives focus. It is
-   * recommended that <code>requestFocusInWindow</code> be used where
-   * possible to be more platform-independent.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
-   *
-   * @param temporary true if the focus request is temporary
-   * @return true if the request has a chance of success
-   * @see #requestFocusInWindow()
-   * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
-   * @since 1.4
-   */
-  protected boolean requestFocus(boolean temporary)
-  {
-    // XXX Implement correctly.
-    requestFocus();
-    return true;
-  }
-
-  /**
-   * Requests that this component be given focus, if it resides in the
-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be focused.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
-   *
-   * @return true if the request has a chance of success
-   * @see #requestFocus()
-   * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
-   * @since 1.4
-   */
-  public boolean requestFocusInWindow()
-  {
-    // XXX Implement correctly.
-    requestFocus();
-    return true;
-  }
-
-  /**
-   * Requests that this component be given focus, if it resides in the
-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be focused.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
-   *
-   * @param temporary true if the focus request is temporary
-   * @return true if the request has a chance of success
-   * @see #requestFocus()
-   * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
-   * @since 1.4
-   */
-  protected boolean requestFocusInWindow(boolean temporary)
-  {
-    // XXX Implement correctly.
-    requestFocus();
-    return true;
+  // This method is used to implement transferFocus().
+  // CHILD is the child making the request.
+  // This is overridden by Container; when called for an ordinary
+  // component there is no child and so we always return null.
+  Component findNextFocusComponent (Component child)
+  {
+    return null;
   }
 
   /**
-   * Transfers focus to the next component in the focus traversal order, as
-   * though this were the current focus owner.
-   *
-   * @see #requestFocus()
-   * @since 1.1
+   * Transfers focus to the next component in the focus traversal order.
    */
   public void transferFocus()
   {
     Component next;
     if (parent == null)
-      next = findNextFocusComponent(null);
+      next = findNextFocusComponent (null);
     else
-      next = parent.findNextFocusComponent(this);
+      next = parent.findNextFocusComponent (this);
     if (next != null && next != this)
-      next.requestFocus();
-  }
-
-  /**
-   * Returns the root container that owns the focus cycle where this component
-   * resides. A focus cycle root is in two cycles, one as the ancestor, and
-   * one as the focusable element; this call always returns the ancestor.
-   *
-   * @return the ancestor container that owns the focus cycle
-   * @since 1.4
-   */
-  public Container getFocusCycleRootAncestor()
-  {
-    // XXX Implement.
-    throw new Error("not implemented");
-  }
-
-  /**
-   * Tests if the container is the ancestor of the focus cycle that this
-   * component belongs to.
-   *
-   * @param c the container to test
-   * @return true if c is the focus cycle root
-   * @since 1.4
-   */
-  public boolean isFocusCycleRoot(Container c)
-  {
-    return c == getFocusCycleRootAncestor();
+      next.requestFocus ();
   }
 
   /**
    * AWT 1.0 focus event processor.
    *
-   * @deprecated use {@link #transferFocus()} instead
+   * @deprecated Deprecated in favor of <code>transferFocus()</code>.
    */
   public void nextFocus()
   {
     transferFocus();
   }
 
-  /**
-   * Transfers focus to the previous component in the focus traversal order, as
-   * though this were the current focus owner.
-   *
-   * @see #requestFocus()
-   * @since 1.4
-   */
-  public void transferFocusBackward()
-  {
-    // XXX Implement.
-    throw new Error("not implemented");
-  }
-
-  /**
-   * Transfers focus to the focus cycle root of this component. However, if
-   * this is a Window, the default focus owner in the window in the current
-   * focus cycle is focused instead.
-   *
-   * @see #requestFocus()
-   * @see #isFocusCycleRoot()
-   * @since 1.4
-   */
-  public void transferFocusUpCycle()
-  {
-    // XXX Implement.
-    throw new Error("not implemented");
-  }
-
-  /**
-   * Tests if this component is the focus owner. Use {@link #isFocusOwner()}
-   * instead.
-   *
-   * @return true if this component owns focus
-   * @since 1.2
-   */
+  /** @since 1.2 */
   public boolean hasFocus()
   {
-    return isFocusOwner();
-  }
-
-  /**
-   * Tests if this component is the focus owner.
-   *
-   * @return true if this component owns focus
-   * @since 1.4
-   */
-  public boolean isFocusOwner()
-  {
-    // XXX Implement.
-    throw new Error("not implemented");
+    return hasFocus;
   }
 
   /**
    * Adds the specified popup menu to this component.
    *
-   * @param menu the popup menu to be added
-   * @see #remove(MenuComponent)
-   * @since 1.1
+   * @param menu The popup menu to be added.
    */
   public synchronized void add(PopupMenu popup)
   {
     if (popups == null)
       popups = new Vector();
-    popups.add(popup);
+    popups.addElement(popup);    
   }
 
   /**
    * Removes the specified popup menu from this component.
    *
-   * @param menu the popup menu to remove
-   * @see #add(PopupMenu)
-   * @since 1.1
+   * @param menu The popup menu to remove.
    */
   public synchronized void remove(MenuComponent popup)
   {
-    if (popups != null)
-      popups.remove(popup);
+    popups.removeElement(popup);
   }
 
   /**
-   * Returns a debugging string representing this component. The string may
-   * be empty but not null.
+   * Returns a debugging string representing this component.
    *
-   * @return a string representing this component
+   * @return A string representing this component.
    */
   protected String paramString()
   {
     StringBuffer param = new StringBuffer();
     String name = getName();
     if (name != null)
-      param.append(name).append(",");
-    param.append(width).append("x").append(height).append("+").append(x)
-      .append("+").append(y);
-    if (! isValid())
+      {
+	param.append(name);
+	param.append(",");
+      }
+    param.append(width);
+    param.append("x");
+    param.append(height);
+    param.append("+");
+    param.append(x);
+    param.append("+");
+    param.append(y);
+    
+    if (!isValid())
       param.append(",invalid");
-    if (! isVisible())
+    if (!isVisible())
       param.append(",invisible");
-    if (! isEnabled())
+    if (!isEnabled())
       param.append(",disabled");
-    if (! isOpaque())
+    if (!isOpaque())
       param.append(",translucent");
     if (isDoubleBuffered())
       param.append(",doublebuffered");
+    
     return param.toString();
   }
 
   /**
-   * Returns a string representation of this component. This is implemented
-   * as <code>getClass().getName() + '[' + paramString() + ']'</code>.
+   * Returns a string representation of this component.
    *
-   * @return a string representation of this component
+   * @return A string representation of this component
    */
   public String toString()
   {
-    return getClass().getName() + '[' + paramString() + ']';
+    return this.getClass().getName() + "[" + paramString() + "]";
   }
 
   /**
-   * Prints a listing of this component to <code>System.out</code>.
-   *
-   * @see #list(PrintStream)
+   * Prints a listing of this component to the standard output.
    */
-  public void list()
+  public void list ()
   {
-    list(System.out, 0);
+    list (System.out, 0);
   }
 
   /**
    * Prints a listing of this component to the specified print stream.
    *
-   * @param stream the <code>PrintStream</code> to print to
+   * @param stream The <code>PrintStream</code> to print to.
    */
-  public void list(PrintStream out)
+  public void list (PrintStream out)
   {
-    list(out, 0);
+    list (out, 0);
   }
 
   /**
    * Prints a listing of this component to the specified print stream,
    * starting at the specified indentation point.
    *
-   * @param stream the <code>PrintStream</code> to print to
-   * @param indent the indentation point
+   * @param stream The <code>PrintStream</code> to print to.
+   * @param indent The indentation point.
    */
-  public void list(PrintStream out, int indent)
+  public void list (PrintStream out, int indent)
   {
     for (int i = 0; i < indent; ++i)
-      out.print(' ');
-    out.println(toString());
+      out.print (' ');
+    out.println (toString ());
   }
 
   /**
    * Prints a listing of this component to the specified print writer.
    *
-   * @param writer the <code>PrintWrinter</code> to print to
-   * @since 1.1
+   * @param writer The <code>PrintWrinter</code> to print to.
    */
-  public void list(PrintWriter out)
+  public void list (PrintWriter out)
   {
-    list(out, 0);
+    list (out, 0);
   }
 
   /**
    * Prints a listing of this component to the specified print writer,
    * starting at the specified indentation point.
    *
-   * @param writer the <code>PrintWriter</code> to print to
-   * @param indent the indentation point
-   * @since 1.1
+   * @param writer The <code>PrintWriter</code> to print to.
+   * @param indent The indentation point.
    */
-  public void list(PrintWriter out, int indent)
+  public void list (PrintWriter out, int indent)
   {
     for (int i = 0; i < indent; ++i)
-      out.print(' ');
-    out.println(toString());
+      out.print (' ');
+    out.println (toString ());
   }
 
-  /**
-   * Adds the specified property listener to this component. This is harmless
-   * if the listener is null, but if the listener has already been registered,
-   * it will now be registered twice. The property listener ignores inherited
-   * properties. Recognized properties include:<br>
-   * <ul>
-   * <li>the font (<code>"font"</code>)</li>
-   * <li>the background color (<code>"background"</code>)</li>
-   * <li>the foreground color (<code>"foreground"</code>)</li>
-   * <li>the focusability (<code>"focusable"</code>)</li>
-   * <li>the focus key traversal enabled state
-   *     (<code>"focusTraversalKeysEnabled"</code>)</li>
-   * <li>the set of forward traversal keys
-   *     (<code>"forwardFocusTraversalKeys"</code>)</li>
-   * <li>the set of backward traversal keys
-   *     (<code>"backwardFocusTraversalKeys"</code>)</li>
-   * <li>the set of up-cycle traversal keys
-   *     (<code>"upCycleFocusTraversalKeys"</code>)</li>
-   * </ul>
-   *
-   * @param listener the new listener to add
-   * @see #removePropertyChangeListener(PropertyChangeListener)
-   * @see #getPropertyChangeListeners()
-   * @see #addPropertyChangeListener(String, PropertyChangeListener)
-   * @since 1.1
-   */
   public void addPropertyChangeListener(PropertyChangeListener listener)
   {
     if (changeSupport == null)
@@ -3811,85 +2413,20 @@
     changeSupport.addPropertyChangeListener(listener);
   }
 
-  /**
-   * Removes the specified property listener from the component. This is
-   * harmless if the listener was not previously registered.
-   *
-   * @param listener the listener to remove
-   * @see #addPropertyChangeListener(PropertyChangeListener)
-   * @see #getPropertyChangeListeners()
-   * @see #removePropertyChangeListener(String, PropertyChangeListener)
-   * @since 1.1
-   */
   public void removePropertyChangeListener(PropertyChangeListener listener)
   {
     if (changeSupport != null)
-      changeSupport.removePropertyChangeListener(listener);
-  }
-
-  /**
-   * Returns an array of all specified listeners registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addPropertyChangeListener(PropertyChangeListener)
-   * @see #removePropertyChangeListener(PropertyChangeListener)
-   * @see #getPropertyChangeListeners(String)
-   * @since 1.4
-   */
-  public PropertyChangeListener[] getPropertyChangeListeners()
-  {
-    return changeSupport == null ? new PropertyChangeListener[0]
-      : changeSupport.getPropertyChangeListeners();
+      changeSupport.removePropertyChangeListener(listener);         
   }
 
-  /**
-   * Adds the specified property listener to this component. This is harmless
-   * if the listener is null, but if the listener has already been registered,
-   * it will now be registered twice. The property listener ignores inherited
-   * properties. The listener is keyed to a single property. Recognized
-   * properties include:<br>
-   * <ul>
-   * <li>the font (<code>"font"</code>)</li>
-   * <li>the background color (<code>"background"</code>)</li>
-   * <li>the foreground color (<code>"foreground"</code>)</li>
-   * <li>the focusability (<code>"focusable"</code>)</li>
-   * <li>the focus key traversal enabled state
-   *     (<code>"focusTraversalKeysEnabled"</code>)</li>
-   * <li>the set of forward traversal keys
-   *     (<code>"forwardFocusTraversalKeys"</code>)</li>
-p   * <li>the set of backward traversal keys
-   *     (<code>"backwardFocusTraversalKeys"</code>)</li>
-   * <li>the set of up-cycle traversal keys
-   *     (<code>"upCycleFocusTraversalKeys"</code>)</li>
-   * </ul>
-   *
-   * @param propertyName the property name to filter on
-   * @param listener the new listener to add
-   * @see #removePropertyChangeListener(String, PropertyChangeListener)
-   * @see #getPropertyChangeListeners(String)
-   * @see #addPropertyChangeListener(PropertyChangeListener)
-   * @since 1.1
-   */
   public void addPropertyChangeListener(String propertyName,
-                                        PropertyChangeListener listener)
+                                	PropertyChangeListener listener)
   {
     if (changeSupport == null)
       changeSupport = new PropertyChangeSupport(this);
-    changeSupport.addPropertyChangeListener(propertyName, listener);
+    changeSupport.addPropertyChangeListener(propertyName, listener);  
   }
 
-  /**
-   * Removes the specified property listener on a particular property from
-   * the component. This is harmless if the listener was not previously
-   * registered.
-   *
-   * @param propertyName the property name to filter on
-   * @param listener the listener to remove
-   * @see #addPropertyChangeListener(String, PropertyChangeListener)
-   * @see #getPropertyChangeListeners(String)
-   * @see #removePropertyChangeListener(PropertyChangeListener)
-   * @since 1.1
-   */
   public void removePropertyChangeListener(String propertyName,
                                            PropertyChangeListener listener)
   {
@@ -3897,1067 +2434,52 @@
       changeSupport.removePropertyChangeListener(propertyName, listener);
   }
 
-  /**
-   * Returns an array of all specified listeners on the named property that
-   * are registered on this component.
-   *
-   * @return an array of listeners
-   * @see #addPropertyChangeListener(String, PropertyChangeListener)
-   * @see #removePropertyChangeListener(String, PropertyChangeListener)
-   * @see #getPropertyChangeListeners()
-   * @since 1.4
-   */
-  public PropertyChangeListener[] getPropertyChangeListeners(String property)
-  {
-    return changeSupport == null ? new PropertyChangeListener[0]
-      : changeSupport.getPropertyChangeListeners(property);
-  }
-
-  /**
-   * Report a change in a bound property to any registered property listeners.
-   *
-   * @param propertyName the property that changed
-   * @param oldValue the old property value
-   * @param newValue the new property value
-   */
-  protected void firePropertyChange(String propertyName, Object oldValue,
+  protected void firePropertyChange(String propertyName, Object oldValue, 
                                     Object newValue)
   {
     if (changeSupport != null)
-      changeSupport.firePropertyChange(propertyName, oldValue, newValue);
-  }
-
-  /**
-   * Report a change in a bound property to any registered property listeners.
-   *
-   * @param propertyName the property that changed
-   * @param oldValue the old property value
-   * @param newValue the new property value
-   */
-  protected void firePropertyChange(String propertyName, boolean oldValue,
-                                    boolean newValue)
-  {
-    if (changeSupport != null)
-      changeSupport.firePropertyChange(propertyName, oldValue, newValue);
-  }
-
-  /**
-   * Report a change in a bound property to any registered property listeners.
-   *
-   * @param propertyName the property that changed
-   * @param oldValue the old property value
-   * @param newValue the new property value
-   */
-  protected void firePropertyChange(String propertyName, int oldValue,
-                                    int newValue)
-  {
-    if (changeSupport != null)
-      changeSupport.firePropertyChange(propertyName, oldValue, newValue);
+      changeSupport.firePropertyChange(propertyName, oldValue, newValue);    
   }
 
-  /**
-   * Sets the text layout orientation of this component. New components default
-   * to UNKNOWN (which behaves like LEFT_TO_RIGHT). This method affects only
-   * the current component, while
-   * {@link #applyComponentOrientation(ComponentOrientation)} affects the
-   * entire hierarchy.
-   *
-   * @param o the new orientation
-   * @throws NullPointerException if o is null
-   * @see #getComponentOrientation()
-   */
   public void setComponentOrientation(ComponentOrientation o)
   {
-    if (o == null)
-      throw new NullPointerException();
     orientation = o;
   }
 
-  /**
-   * Determines the text layout orientation used by this component.
-   *
-   * @return the component orientation
-   * @see #setComponentOrientation(ComponentOrientation)
-   */
   public ComponentOrientation getComponentOrientation()
   {
     return orientation;
   }
 
-  /**
-   * Sets the text layout orientation of this component. New components default
-   * to UNKNOWN (which behaves like LEFT_TO_RIGHT). This method affects the
-   * entire hierarchy, while
-   * {@link #setComponentOrientation(ComponentOrientation)} affects only the
-   * current component.
-   *
-   * @param o the new orientation
-   * @throws NullPointerException if o is null
-   * @see #getComponentOrientation()
-   * @since 1.4
-   */
-  public void applyComponentOrientation(ComponentOrientation o)
-  {
-    setComponentOrientation(o);
-  }
-
-  /**
-   * Returns the accessibility framework context of this class. Component is
-   * not accessible, so the default implementation returns null. Subclasses
-   * must override this behavior, and return an appropriate subclass of
-   * {@link AccessibleAWTComponent}.
-   *
-   * @return the accessibility context
-   */
+  /*
   public AccessibleContext getAccessibleContext()
   {
-    return null;
-  }
-
-
-  // Helper methods; some are package visible for use by subclasses.
-
-  /**
-   * Subclasses should override this to return unique component names like
-   * "menuitem0".
-   *
-   * @return the generated name for this component
-   */
-  String generateName()
-  {
-    // Component is abstract.
-    return null;
-  }
-
-  /**
-   * Sets the peer for this component.
-   *
-   * @param peer the new peer
-   */
-  final void setPeer(ComponentPeer peer)
-  {
-    this.peer = peer;
-  }
-
-  /**
-   * Implementation method that allows classes such as Canvas and Window to
-   * override the graphics configuration without violating the published API.
-   *
-   * @return the graphics configuration
-   */
-  GraphicsConfiguration getGraphicsConfigurationImpl()
-  {
-    if (peer != null)
-      {
-        GraphicsConfiguration config = peer.getGraphicsConfiguration();
-        if (config != null)
-          return config;
-      }
-
-    if (parent != null)
-      return parent.getGraphicsConfiguration();
-
-    return null;
-  }
-
-  /**
-   * Implementation of dispatchEvent. Allows trusted package classes to
-   * dispatch additional events first.
-   *
-   * @param e the event to dispatch
-   */
-  void dispatchEventImpl(AWTEvent e)
-  {
-    // Make use of event id's in order to avoid multiple instanceof tests.
-    if (e.id <= ComponentEvent.COMPONENT_LAST
-        && e.id >= ComponentEvent.COMPONENT_FIRST
-        && (componentListener != null
-            || (eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= KeyEvent.KEY_LAST
-             && e.id >= KeyEvent.KEY_FIRST
-             && (keyListener != null
-                 || (eventMask & AWTEvent.KEY_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= MouseEvent.MOUSE_LAST
-             && e.id >= MouseEvent.MOUSE_FIRST
-             && (mouseListener != null
-                 || mouseMotionListener != null
-                 || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= FocusEvent.FOCUS_LAST
-             && e.id >= FocusEvent.FOCUS_FIRST
-             && (focusListener != null
-                 || (eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= InputMethodEvent.INPUT_METHOD_LAST
-             && e.id >= InputMethodEvent.INPUT_METHOD_FIRST
-             && (inputMethodListener != null
-                 || (eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= HierarchyEvent.HIERARCHY_LAST
-             && e.id >= HierarchyEvent.HIERARCHY_FIRST
-             && (hierarchyListener != null
-                 || hierarchyBoundsListener != null
-                 || (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0))
-      processEvent(e);
-    else if (e.id <= PaintEvent.PAINT_LAST
-             && e.id >= PaintEvent.PAINT_FIRST
-             && (eventMask & AWTEvent.PAINT_EVENT_MASK) != 0)
-      processEvent(e);
-  }
-
-  /**
-   * Coalesce paint events. Current heuristic is: Merge if the union of
-   * areas is less than twice that of the sum of the areas. The X server
-   * tend to create a lot of paint events that are adjacent but not
-   * overlapping.
-   *
-   * <pre>
-   * +------+
-   * |      +-----+  ...will be merged
-   * |      |     |
-   * |      |     |
-   * +------+     |
-   *        +-----+
-   *
-   * +---------------+--+
-   * |               |  |  ...will not be merged
-   * +---------------+  |
-   *                 |  |
-   *                 |  |
-   *                 |  |
-   *                 |  |
-   *                 |  |
-   *                 +--+
-   * </pre>
-   *
-   * @param queuedEvent the first paint event
-   * @param newEvent the second paint event
-   * @return the combined paint event, or null
-   */
-  private PaintEvent coalescePaintEvents(PaintEvent queuedEvent,
-                                         PaintEvent newEvent)
-  {
-    Rectangle r1 = queuedEvent.getUpdateRect();
-    Rectangle r2 = newEvent.getUpdateRect();
-    Rectangle union = r1.union(r2);
-
-    int r1a = r1.width * r1.height;
-    int r2a = r2.width * r2.height;
-    int ua  = union.width * union.height;
-
-    if (ua > (r1a+r2a)*2)
-      return null;
-    /* The 2 factor should maybe be reconsidered. Perhaps 3/2
-       would be better? */
-
-    newEvent.setUpdateRect(union);
-    return newEvent;
+    return accessibleContext;
   }
+  */
 
-  /**
-   * Does the work for a paint event.
-   *
-   * @param event the event to process
-   */
-  private void processPaintEvent(PaintEvent event)
-  {
-    // Can't do graphics without peer
-    if (peer == null)
-      return;
-
-    Graphics gfx = getGraphics();
-    Shape clip = event.getUpdateRect();
-    gfx.setClip(clip);
-
-    switch (event.id)
-      {
-      case PaintEvent.PAINT:
-        paint(gfx);
-        break;
-      case PaintEvent.UPDATE:
-        update(gfx);
-        break;
-      default:
-        throw new IllegalArgumentException("unknown paint event");
-      }
-  }
-
-  /**
-   * This method is used to implement transferFocus(). CHILD is the child
-   * making the request. This is overridden by Container; when called for an
-   * ordinary component there is no child and so we always return null.
-   *
-   * @param child the component making the request
-   * @return the next component to focus on
-   */
-  Component findNextFocusComponent(Component child)
-  {
-    return null;
-  }
-
-  /**
-   * Deserializes this component. This regenerates all serializable listeners
-   * which were registered originally.
-   *
-   * @param s the stream to read from
-   * @throws ClassNotFoundException if deserialization fails
-   * @throws IOException if the stream fails
-   */
-  private void readObject(ObjectInputStream s)
-    throws ClassNotFoundException, IOException
-  {
-    s.defaultReadObject();
-    String key = (String) s.readObject();
-    while (key != null)
-      {
-        Object listener = s.readObject();
-        if ("componentL".equals(key))
-          addComponentListener((ComponentListener) listener);
-        else if ("focusL".equals(key))
-          addFocusListener((FocusListener) listener);
-        else if ("keyL".equals(key))
-          addKeyListener((KeyListener) listener);
-        else if ("mouseL".equals(key))
-          addMouseListener((MouseListener) listener);
-        else if ("mouseMotionL".equals(key))
-          addMouseMotionListener((MouseMotionListener) listener);
-        else if ("inputMethodL".equals(key))
-          addInputMethodListener((InputMethodListener) listener);
-        else if ("hierarchyL".equals(key))
-          addHierarchyListener((HierarchyListener) listener);
-        else if ("hierarchyBoundsL".equals(key))
-          addHierarchyBoundsListener((HierarchyBoundsListener) listener);
-        else if ("mouseWheelL".equals(key))
-          addMouseWheelListener((MouseWheelListener) listener);
-        key = (String) s.readObject();
-      }
-  }
-
-  /**
-   * Serializes this component. This ignores all listeners which do not
-   * implement Serializable, but includes those that do.
-   *
-   * @param s the stream to write to
-   * @throws IOException if the stream fails
-   */
-  private void writeObject(ObjectOutputStream s) throws IOException
-  {
-    s.defaultWriteObject();
-    AWTEventMulticaster.save(s, "componentL", componentListener);
-    AWTEventMulticaster.save(s, "focusL", focusListener);
-    AWTEventMulticaster.save(s, "keyL", keyListener);
-    AWTEventMulticaster.save(s, "mouseL", mouseListener);
-    AWTEventMulticaster.save(s, "mouseMotionL", mouseMotionListener);
-    AWTEventMulticaster.save(s, "inputMethodL", inputMethodListener);
-    AWTEventMulticaster.save(s, "hierarchyL", hierarchyListener);
-    AWTEventMulticaster.save(s, "hierarchyBoundsL", hierarchyBoundsListener);
-    AWTEventMulticaster.save(s, "mouseWheelL", mouseWheelListener);
-    s.writeObject(null);
-  }
-
-
-  // Nested classes.
-
-  /**
-   * This class provides accessibility support for subclasses of container.
-   *
-   * @author Eric Blake <ebb9@email.byu.edu>
-   * @since 1.3
-   * @status updated to 1.4
-   */
-  protected abstract class AccessibleAWTComponent extends AccessibleContext
-    implements Serializable, AccessibleComponent
-  {
-    /**
-     * Compatible with JDK 1.3+.
-     */
-    private static final long serialVersionUID = 642321655757800191L;
-
-    /**
-     * Converts show/hide events to PropertyChange events, and is registered
-     * as a component listener on this component.
-     *
-     * @serial the component handler
-     */
-    protected ComponentListener accessibleAWTComponentHandler
-      = new AccessibleAWTComponentHandler();
-
-    /**
-     * Converts focus events to PropertyChange events, and is registered
-     * as a focus listener on this component.
-     *
-     * @serial the focus handler
-     */
-    protected FocusListener accessibleAWTFocusHandler
-      = new AccessibleAWTFocusHandler();
-
-    /**
-     * The default constructor.
-     */
-    protected AccessibleAWTComponent()
-    {
-      Component.this.addComponentListener(accessibleAWTComponentHandler);
-      Component.this.addFocusListener(accessibleAWTFocusHandler);
-    }
-
-    /**
-     * Adds a global property change listener to the accessible component.
-     *
-     * @param l the listener to add
-     * @see #ACCESSIBLE_NAME_PROPERTY
-     * @see #ACCESSIBLE_DESCRIPTION_PROPERTY
-     * @see #ACCESSIBLE_STATE_PROPERTY
-     * @see #ACCESSIBLE_VALUE_PROPERTY
-     * @see #ACCESSIBLE_SELECTION_PROPERTY
-     * @see #ACCESSIBLE_TEXT_PROPERTY
-     * @see #ACCESSIBLE_VISIBLE_DATA_PROPERTY
-     */
-    public void addPropertyChangeListener(PropertyChangeListener l)
-    {
-      Component.this.addPropertyChangeListener(l);
-      super.addPropertyChangeListener(l);
-    }
-
-    /**
-     * Removes a global property change listener from this accessible
-     * component.
-     *
-     * @param l the listener to remove
-     */
-    public void removePropertyChangeListener(PropertyChangeListener l)
-    {
-      Component.this.removePropertyChangeListener(l);
-      super.removePropertyChangeListener(l);
-    }
-
-    /**
-     * Returns the accessible name of this component. It is almost always
-     * wrong to return getName(), since it is not localized. In fact, for
-     * things like buttons, this should be the text of the button, not the
-     * name of the object. The tooltip text might also be appropriate.
-     *
-     * @return the name
-     * @see #setAccessibleName(String)
-     */
-    public String getAccessibleName()
-    {
-      return accessibleName == null ? getName() : accessibleName;
-    }
-
-    /**
-     * Returns a brief description of this accessible context. This should
-     * be localized.
-     *
-     * @return a description of this component
-     * @see #setAccessibleDescription(String)
-     */
-    public String getAccessibleDescription()
-    {
-      return accessibleDescription;
-    }
-
-    /**
-     * Returns the role of this component.
-     *
-     * @return the accessible role
-     */
-    public AccessibleRole getAccessibleRole()
-    {
-      return AccessibleRole.AWT_COMPONENT;
-    }
-
-    /**
-     * Returns a state set describing this component's state.
-     *
-     * @return a new state set
-     * @see AccessibleState
-     */
-    public AccessibleStateSet getAccessibleStateSet()
-    {
-      AccessibleStateSet s = new AccessibleStateSet();
-      if (Component.this.isEnabled())
-        s.add(AccessibleState.ENABLED);
-      if (isFocusable())
-        s.add(AccessibleState.FOCUSABLE);
-      if (isFocusOwner())
-        s.add(AccessibleState.FOCUSED);
-      if (isOpaque())
-        s.add(AccessibleState.OPAQUE);
-      if (Component.this.isShowing())
-        s.add(AccessibleState.SHOWING);
-      if (Component.this.isVisible())
-        s.add(AccessibleState.VISIBLE);
-      return s;
-    }
-
-    /**
-     * Returns the parent of this component, if it is accessible.
-     *
-     * @return the accessible parent
-     */
-    public Accessible getAccessibleParent()
-    {
-      if (accessibleParent == null)
-        {
-          Container parent = getParent();
-          accessibleParent = parent instanceof Accessible
-            ? (Accessible) parent : null;
-        }
-      return accessibleParent;
-    }
-
-    /**
-     * Returns the index of this component in its accessible parent.
-     *
-     * @return the index, or -1 if the parent is not accessible
-     * @see #getAccessibleParent()
-     */
-    public int getAccessibleIndexInParent()
-    {
-      if (getAccessibleParent() == null)
-        return -1;
-      AccessibleContext context
-        = ((Component) accessibleParent).getAccessibleContext();
-      if (context == null)
-        return -1;
-      for (int i = context.getAccessibleChildrenCount(); --i >= 0; )
-        if (context.getAccessibleChild(i) == Component.this)
-          return i;
-      return -1;
-    }
-
-    /**
-     * Returns the number of children of this component which implement
-     * Accessible. Subclasses must override this if they can have children.
-     *
-     * @return the number of accessible children, default 0
-     */
-    public int getAccessibleChildrenCount()
-    {
-      return 0;
-    }
-
-    /**
-     * Returns the ith accessible child. Subclasses must override this if
-     * they can have children.
-     *
-     * @return the ith accessible child, or null
-     * @see #getAccessibleChildrenCount()
-     */
-    public Accessible getAccessibleChild(int i)
-    {
-      return null;
-    }
-
-    /**
-     * Returns the locale of this component.
-     *
-     * @return the locale
-     * @throws IllegalComponentStateException if the locale is unknown
-     */
-    public Locale getLocale()
-    {
-      return Component.this.getLocale();
-    }
-
-    /**
-     * Returns this, since it is an accessible component.
-     *
-     * @return the accessible component
-     */
-    public AccessibleComponent getAccessibleComponent()
-    {
-      return this;
-    }
-
-    /**
-     * Gets the background color.
-     *
-     * @return the background color
-     * @see #setBackground(Color)
-     */
-    public Color getBackground()
-    {
-      return Component.this.getBackground();
-    }
-
-    /**
-     * Sets the background color.
-     *
-     * @param c the background color
-     * @see #getBackground()
-     * @see #isOpaque()
-     */
-    public void setBackground(Color c)
-    {
-      Component.this.setBackground(c);
-    }
-
-    /**
-     * Gets the foreground color.
-     *
-     * @return the foreground color
-     * @see #setForeground(Color)
-     */
-    public Color getForeground()
-    {
-      return Component.this.getForeground();
-    }
-
-    /**
-     * Sets the foreground color.
-     *
-     * @param c the foreground color
-     * @see #getForeground()
-     */
-    public void setForeground(Color c)
-    {
-      Component.this.setForeground(c);
-    }
-
-    /**
-     * Gets the cursor.
-     *
-     * @return the cursor
-     * @see #setCursor(Cursor)
-     */
-    public Cursor getCursor()
-    {
-      return Component.this.getCursor();
-    }
-
-    /**
-     * Sets the cursor.
-     *
-     * @param cursor the cursor
-     * @see #getCursor()
-     */
-    public void setCursor(Cursor cursor)
-    {
-      Component.this.setCursor(cursor);
-    }
-
-    /**
-     * Gets the font.
-     *
-     * @return the font
-     * @see #setFont(Font)
-     */
-    public Font getFont()
-    {
-      return Component.this.getFont();
-    }
-
-    /**
-     * Sets the font.
-     *
-     * @param f the font
-     * @see #getFont()
-     */
-    public void setFont(Font f)
-    {
-      Component.this.setFont(f);
-    }
-
-    /**
-     * Gets the font metrics for a font.
-     *
-     * @param f the font to look up
-     * @return its metrics
-     * @throws NullPointerException if f is null
-     * @see #getFont()
-     */
-    public FontMetrics getFontMetrics(Font f)
-    {
-      return Component.this.getFontMetrics(f);
-    }
-
-    /**
-     * Tests if the component is enabled.
-     *
-     * @return true if the component is enabled
-     * @see #setEnabled(boolean)
-     * @see #getAccessibleStateSet()
-     * @see AccessibleState#ENABLED
-     */
-    public boolean isEnabled()
-    {
-      return Component.this.isEnabled();
-    }
-
-    /**
-     * Set whether the component is enabled.
-     *
-     * @param b the new enabled status
-     * @see #isEnabled()
-     */
-    public void setEnabled(boolean b)
-    {
-      Component.this.setEnabled(b);
-    }
-
-    /**
-     * Test whether the component is visible (not necesarily showing).
-     *
-     * @return true if it is visible
-     * @see #setVisible(boolean)
-     * @see #getAccessibleStateSet()
-     * @see AccessibleState#VISIBLE
-     */
-    public boolean isVisible()
-    {
-      return Component.this.isVisible();
-    }
-
-    /**
-     * Sets the visibility of this component.
-     *
-     * @param b the desired visibility
-     * @see #isVisible()
-     */
-    public void setVisible(boolean b)
-    {
-      Component.this.setVisible(b);
-    }
-
-    /**
-     * Tests if the component is showing.
-     *
-     * @return true if this is showing
-     */
-    public boolean isShowing()
-    {
-      return Component.this.isShowing();
-    }
-
-    /**
-     * Tests if the point is contained in this component.
-     *
-     * @param p the point to check
-     * @return true if it is contained
-     * @throws NullPointerException if p is null
-     */
-    public boolean contains(Point p)
-    {
-      return Component.this.contains(p.x, p.y);
-    }
-
-    /**
-     * Returns the location of this object on the screen, or null if it is
-     * not showing.
-     *
-     * @return the location relative to screen coordinates, if showing
-     * @see #getBounds()
-     * @see #getLocation()
-     */
-    public Point getLocationOnScreen()
-    {
-      return Component.this.isShowing() ? Component.this.getLocationOnScreen()
-        : null;
-    }
-
-    /**
-     * Returns the location of this object relative to its parent's coordinate
-     * system, or null if it is not showing.
-     *
-     * @return the location
-     * @see #getBounds()
-     * @see #getLocationOnScreen()
-     */
-    public Point getLocation()
-    {
-      return Component.this.isShowing() ? Component.this.getLocation() : null;
-    }
-
-    /**
-     * Sets the location of this relative to its parent's coordinate system.
-     *
-     * @param p the location
-     * @throws NullPointerException if p is null
-     * @see #getLocation()
-     */
-    public void setLocation(Point p)
-    {
-      Component.this.setLocation(p.x, p.y);
-    }
-
-    /**
-     * Gets the bounds of this component, or null if it is not on screen.
-     *
-     * @return the bounds
-     * @see #contains(Point)
-     * @see #setBounds(Rectangle)
-     */
-    public Rectangle getBounds()
-    {
-      return Component.this.isShowing() ? Component.this.getBounds() : null;
-    }
-
-    /**
-     * Sets the bounds of this component.
-     *
-     * @param r the bounds
-     * @throws NullPointerException if r is null
-     * @see #getBounds()
-     */
-    public void setBounds(Rectangle r)
-    {
-      Component.this.setBounds(r.x, r.y, r.width, r.height);
-    }
-
-    /**
-     * Gets the size of this component, or null if it is not showing.
-     *
-     * @return the size
-     * @see #setSize(Dimension)
-     */
-    public Dimension getSize()
-    {
-      return Component.this.isShowing() ? Component.this.getSize() : null;
-    }
-
-    /**
-     * Sets the size of this component.
-     *
-     * @param d the size
-     * @throws NullPointerException if d is null
-     * @see #getSize()
-     */
-    public void setSize(Dimension d)
-    {
-      Component.this.setSize(d.width, d.height);
-    }
-
-    /**
-     * Returns the Accessible child at a point relative to the coordinate
-     * system of this component, if one exists, or null. Since components
-     * have no children, subclasses must override this to get anything besides
-     * null.
-     *
-     * @param p the point to check
-     * @return the accessible child at that point
-     * @throws NullPointerException if p is null
-     */
-    public Accessible getAccessibleAt(Point p)
-    {
-      return null;
-    }
-
-    /**
-     * Tests whether this component can accept focus.
-     *
-     * @return true if this is focus traversable
-     * @see #getAccessibleStateSet()
-     * @see AccessibleState#FOCUSABLE
-     * @see AccessibleState#FOCUSED
-     */
-    public boolean isFocusTraversable()
-    {
-      return Component.this.isFocusTraversable();
-    }
-
-    /**
-     * Requests focus for this component.
-     *
-     * @see #isFocusTraversable()
-     */
-    public void requestFocus()
-    {
-      Component.this.requestFocus();
-    }
-
-    /**
-     * Adds a focus listener.
-     *
-     * @param l the listener to add
-     */
-    public void addFocusListener(FocusListener l)
-    {
-      Component.this.addFocusListener(l);
-    }
-
-    /**
-     * Removes a focus listener.
-     *
-     * @param l the listener to remove
-     */
-    public void removeFocusListener(FocusListener l)
-    {
-      Component.this.removeFocusListener(l);
-    }
-
-    /**
-     * Converts component changes into property changes.
-     *
-     * @author Eric Blake <ebb9@email.byu.edu>
-     * @since 1.3
-     * @status updated to 1.4
-     */
-    protected class AccessibleAWTComponentHandler implements ComponentListener
-    {
-      /**
-       * Default constructor.
-       */
-      protected AccessibleAWTComponentHandler()
-      {
-      }
-
-      /**
-       * Convert a component hidden to a property change.
-       *
-       * @param e the event to convert
-       */
-      public void componentHidden(ComponentEvent e)
-      {
-        AccessibleAWTComponent.this.firePropertyChange
-          (ACCESSIBLE_STATE_PROPERTY, AccessibleState.VISIBLE, null);
-      }
-
-      /**
-       * Convert a component shown to a property change.
-       *
-       * @param e the event to convert
-       */
-      public void componentShown(ComponentEvent e)
-      {
-        AccessibleAWTComponent.this.firePropertyChange
-          (ACCESSIBLE_STATE_PROPERTY, null, AccessibleState.VISIBLE);
-      }
-
-      /**
-       * Moving a component does not affect properties.
-       *
-       * @param e ignored
-       */
-      public void componentMoved(ComponentEvent e)
-      {
-      }
-
-      /**
-       * Resizing a component does not affect properties.
-       *
-       * @param e ignored
-       */
-      public void componentResized(ComponentEvent e)
-      {
-      }
-    } // class AccessibleAWTComponentHandler
-
-    /**
-     * Converts focus changes into property changes.
-     *
-     * @author Eric Blake <ebb9@email.byu.edu>
-     * @since 1.3
-     * @status updated to 1.4
-     */
-    protected class AccessibleAWTFocusHandler implements FocusListener
-    {
-      /**
-       * Default constructor.
-       */
-      protected AccessibleAWTFocusHandler()
-      {
-      }
-
-      /**
-       * Convert a focus gained to a property change.
-       *
-       * @param e the event to convert
-       */
-      public void focusGained(FocusEvent e)
-      {
-        AccessibleAWTComponent.this.firePropertyChange
-          (ACCESSIBLE_STATE_PROPERTY, null, AccessibleState.FOCUSED);
-      }
+/**
+  * AWT 1.0 focus event processor.
+  *
+  * @deprecated Deprecated in favor of <code>processFocusEvent</code>.
+  
+public boolean
+gotFocus(Event event, Object what)
+{
+  return(true);
+}
+*/
 
-      /**
-       * Convert a focus lost to a property change.
-       *
-       * @param e the event to convert
-       */
-      public void focusLost(FocusEvent e)
-      {
-        AccessibleAWTComponent.this.firePropertyChange
-          (ACCESSIBLE_STATE_PROPERTY, AccessibleState.FOCUSED, null);
-      }
-    } // class AccessibleAWTComponentHandler
-  } // class AccessibleAWTComponent
+/**
+  * AWT 1.0 focus event processor.
+  *
+  * @deprecated Deprecated in favor of <code>processFocusEvent</code>.
+  
+public boolean
+lostFocus(Event event, Object what)
+{
+  return(true);
+}
+*/
 
-  /**
-   * This class provides support for blitting offscreen surfaces.
-   *
-   * @author Eric Blake <ebb9@email.byu.edu>
-   * @since 1.4
-   * @XXX Shell class, to allow compilation. This needs documentation and
-   * correct implementation.
-   */
-  protected class BltBufferStrategy extends BufferStrategy
-  {
-    protected BufferCapabilities caps;
-    protected VolatileImage[] backBuffers;
-    protected boolean validatedContents;
-    protected int width;
-    protected int height;
-    protected BltBufferStrategy(int num, BufferCapabilities caps)
-    {
-      this.caps = caps;
-      createBackBuffers(num);
-    }
-    protected void createBackBuffers(int num)
-    {
-      backBuffers = new VolatileImage[num];
-    }
-    public BufferCapabilities getCapabilities()
-    {
-      return caps;
-    }
-    public Graphics getDrawGraphics() { return null; }
-    public void show() {}
-    protected void revalidate() {}
-    public boolean contentsLost() { return false; }
-    public boolean contentsRestored() { return false; }
-  } // class BltBufferStrategy
-
-  /**
-   * This class provides support for flipping component buffers. It is only
-   * designed for use by Canvas and Window.
-   *
-   * @author Eric Blake <ebb9@email.byu.edu>
-   * @since 1.4
-   * @XXX Shell class, to allow compilation. This needs documentation and
-   * correct implementation.
-   */
-  protected class FlipBufferStrategy extends BufferStrategy
-  {
-    protected int numBuffers;
-    protected BufferCapabilities caps;
-    protected Image drawBuffer;
-    protected VolatileImage drawVBuffer;
-    protected boolean validatedContents;
-    protected FlipBufferStrategy(int num, BufferCapabilities caps)
-      throws AWTException
-    {
-      this.caps = caps;
-      createBuffers(num, caps);
-    }
-    protected void createBuffers(int num, BufferCapabilities caps)
-      throws AWTException {}
-    protected Image getBackBuffer()
-    {
-      return drawBuffer;
-    }
-    protected void flip(BufferCapabilities.FlipContents flipAction) {}
-    protected void destroyBuffers() {}
-    public BufferCapabilities getCapabilities()
-    {
-      return caps;
-    }
-    public Graphics getDrawGraphics() { return null; }
-    protected void revalidate() {}
-    public boolean contentsLost() { return false; }
-    public boolean contentsRestored() { return false; }
-    public void show() {}
-  } // class FlipBufferStrategy
-} // class Component
+}
