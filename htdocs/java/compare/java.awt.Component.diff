--- /home/tromey/gnu/Nightly/classpath/classpath/java/awt/Component.java	2004-04-18 02:22:12.000000000 -0600
+++ java/awt/Component.java	2004-05-27 02:18:58.000000000 -0600
@@ -383,18 +383,18 @@
   boolean focusable = true;
 
   /**
-   * Tracks whether this component uses default focus traversal, or has a
-   * different policy.
+   * Tracks whether this component's {@link #isFocusTraversable}
+   * method has been overridden.
    *
-   * @see #isFocusTraversableOverridden()
    * @since 1.4
    */
   int isFocusTraversableOverridden;
 
   /**
-   * The focus traversal keys, if not inherited from the parent or default
-   * keyboard manager. These sets will contain only AWTKeyStrokes that
-   * represent press and release events to use as focus control.
+   * The focus traversal keys, if not inherited from the parent or
+   * default keyboard focus manager. These sets will contain only
+   * AWTKeyStrokes that represent press and release events to use as
+   * focus control.
    *
    * @see #getFocusTraversalKeys(int)
    * @see #setFocusTraversalKeys(int, Set)
@@ -557,6 +557,12 @@
   transient BufferStrategy bufferStrategy;
 
   /**
+   * true if requestFocus was called on this component when its
+   * top-level ancestor was not focusable.
+   */
+  private transient FocusEvent pendingFocusRequest = null;
+
+  /**
    * The system properties that affect image updating.
    */
   private static transient boolean incrementalDraw;
@@ -566,6 +572,8 @@
   {
     incrementalDraw = Boolean.getBoolean ("awt.image.incrementalDraw");
     redrawRate = Long.getLong ("awt.image.redrawrate");
+    // Set the default KeyboardFocusManager.
+    KeyboardFocusManager.setCurrentKeyboardFocusManager (null);
   }
 
   // Public and protected API.
@@ -2963,6 +2971,7 @@
   {
     if (focusListener == null)
       return;
+
     switch (e.id)
       {
         case FocusEvent.FOCUS_GAINED:
@@ -3411,13 +3420,18 @@
   }
 
   /**
-   * Sets the focus traversal keys for a given type of focus events. Normally,
-   * the default values should match the operating system's native choices. To
-   * disable a given traversal, use <code>Collections.EMPTY_SET</code>. The
-   * event dispatcher will consume PRESSED, RELEASED, and TYPED events for the
-   * specified key, although focus can only transfer on PRESSED or RELEASED.
+   * Sets the focus traversal keys for one of the three focus
+   * traversal directions supported by Components: {@link
+   * #KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}, {@link
+   * #KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}, or {@link
+   * #KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}. Normally, the
+   * default values should match the operating system's native
+   * choices. To disable a given traversal, use
+   * <code>Collections.EMPTY_SET</code>. The event dispatcher will
+   * consume PRESSED, RELEASED, and TYPED events for the specified
+   * key, although focus can only transfer on PRESSED or RELEASED.
    *
-   * <p>The defauts are:
+   * <p>The defaults are:
    * <table>
    *   <th><td>Identifier</td><td>Meaning</td><td>Default</td></th>
    *   <tr><td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</td>
@@ -3430,10 +3444,13 @@
    *     <td>Go up a traversal cycle</td><td>None</td></tr>
    * </table>
    *
-   * <p>Specifying null allows inheritance from the parent, or from the current
-   * KeyboardFocusManager default set. If not null, the set must contain only
-   * AWTKeyStrokes that are not already focus keys and are not KEY_TYPED
-   * events.
+   * If keystrokes is null, this component's focus traversal key set
+   * is inherited from one of its ancestors.  If none of its ancestors
+   * has its own set of focus traversal keys, the focus traversal keys
+   * are set to the defaults retrieved from the current
+   * KeyboardFocusManager.  If not null, the set must contain only
+   * AWTKeyStrokes that are not already focus keys and are not
+   * KEY_TYPED events.
    *
    * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
    *        UP_CYCLE_TRAVERSAL_KEYS
@@ -3448,7 +3465,24 @@
   public void setFocusTraversalKeys(int id, Set keystrokes)
   {
     if (keystrokes == null)
-      throw new IllegalArgumentException();
+      {
+        Container parent = getParent ();
+
+        while (parent != null)
+          {
+            if (parent.areFocusTraversalKeysSet (id))
+              {
+                keystrokes = parent.getFocusTraversalKeys (id);
+                break;
+              }
+            parent = parent.getParent ();
+          }
+
+        if (keystrokes == null)
+          keystrokes = KeyboardFocusManager.getCurrentKeyboardFocusManager ().
+            getDefaultFocusTraversalKeys (id);
+      }
+
     Set sa;
     Set sb;
     String name;
@@ -3476,50 +3510,60 @@
         name = "upCycleFocusTraversalKeys";
         break;
       default:
-        throw new IllegalArgumentException();
+        throw new IllegalArgumentException ();
       }
-    int i = keystrokes.size();
-    Iterator iter = keystrokes.iterator();
+
+    int i = keystrokes.size ();
+    Iterator iter = keystrokes.iterator ();
+
     while (--i >= 0)
       {
-        Object o = iter.next();
-        if (! (o instanceof AWTKeyStroke)
-            || sa.contains(o) || sb.contains(o)
+        Object o = iter.next ();
+        if (!(o instanceof AWTKeyStroke)
+            || sa.contains (o) || sb.contains (o)
             || ((AWTKeyStroke) o).keyCode == KeyEvent.VK_UNDEFINED)
-          throw new IllegalArgumentException();
+          throw new IllegalArgumentException ();
       }
+
     if (focusTraversalKeys == null)
       focusTraversalKeys = new Set[3];
-    keystrokes = Collections.unmodifiableSet(new HashSet(keystrokes));
-    firePropertyChange(name, focusTraversalKeys[id], keystrokes);
+
+    keystrokes = Collections.unmodifiableSet (new HashSet (keystrokes));
+    firePropertyChange (name, focusTraversalKeys[id], keystrokes);
+
     focusTraversalKeys[id] = keystrokes;
   }
 
   /**
-   * Returns the set of keys for a given focus traversal action, as defined
-   * in <code>setFocusTraversalKeys</code>. If not set, this is inherited from
-   * the parent component, which may have gotten it from the
-   * KeyboardFocusManager.
+   * Returns the set of keys for a given focus traversal action, as
+   * defined in <code>setFocusTraversalKeys</code>.  If not set, this
+   * is inherited from the parent component, which may have gotten it
+   * from the KeyboardFocusManager.
    *
-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
-   *        UP_CYCLE_TRAVERSAL_KEYS
+   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,
+   * or UP_CYCLE_TRAVERSAL_KEYS
    * @throws IllegalArgumentException if id is invalid
-   * @see #setFocusTraversalKeys(int, Set)
+   * @see #setFocusTraversalKeys (int, Set)
    * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
    * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
    * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
    * @since 1.4
    */
-  public Set getFocusTraversalKeys(int id)
+  public Set getFocusTraversalKeys (int id)
   {
-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS
-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
+    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&
+        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&
+        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
       throw new IllegalArgumentException();
+
     Set s = null;
+
     if (focusTraversalKeys != null)
       s = focusTraversalKeys[id];
+
     if (s == null && parent != null)
-      s = parent.getFocusTraversalKeys(id);
+      s = parent.getFocusTraversalKeys (id);
+
     return s == null ? (KeyboardFocusManager.getCurrentKeyboardFocusManager()
                         .getDefaultFocusTraversalKeys(id)) : s;
   }
@@ -3528,269 +3572,417 @@
    * Tests whether the focus traversal keys for a given action are explicitly
    * set or inherited.
    *
-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or
-   *        UP_CYCLE_TRAVERSAL_KEYS
+   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,
+   * or UP_CYCLE_TRAVERSAL_KEYS
    * @return true if that set is explicitly specified
    * @throws IllegalArgumentException if id is invalid
-   * @see #getFocusTraversalKeys(int)
+   * @see #getFocusTraversalKeys (int)
    * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
    * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
    * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
    * @since 1.4
    */
-  public boolean areFocusTraversalKeysSet(int id)
+  public boolean areFocusTraversalKeysSet (int id)
   {
-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS
-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException();
+    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&
+        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&
+        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)
+      throw new IllegalArgumentException ();
+
     return focusTraversalKeys != null && focusTraversalKeys[id] != null;
   }
 
   /**
-   * Sets whether focus traversal keys are enabled, which consumes traversal
-   * keys and performs the focus event automatically.
+   * Enable or disable focus traversal keys on this Component.  If
+   * they are, then the keyboard focus manager consumes and acts on
+   * key press and release events that trigger focus traversal, and
+   * discards the corresponding key typed events.  If focus traversal
+   * keys are disabled, then all key events that would otherwise
+   * trigger focus traversal are sent to this Component.
    *
    * @param focusTraversalKeysEnabled the new value of the flag
-   * @see #getFocusTraversalKeysEnabled()
-   * @see #setFocusTraversalKeys(int, Set)
-   * @see #getFocusTraversalKeys(int)
+   * @see #getFocusTraversalKeysEnabled ()
+   * @see #setFocusTraversalKeys (int, Set)
+   * @see #getFocusTraversalKeys (int)
    * @since 1.4
    */
-  public void setFocusTraversalKeysEnabled(boolean focusTraversalKeysEnabled)
+  public void setFocusTraversalKeysEnabled (boolean focusTraversalKeysEnabled)
   {
-    firePropertyChange("focusTraversalKeysEnabled",
-                       this.focusTraversalKeysEnabled,
-                       focusTraversalKeysEnabled);
+    firePropertyChange ("focusTraversalKeysEnabled",
+			this.focusTraversalKeysEnabled,
+			focusTraversalKeysEnabled);
     this.focusTraversalKeysEnabled = focusTraversalKeysEnabled;
   }
 
   /**
-   * Tests whether focus traversal keys are enabled. If they are, then focus
-   * traversal keys are consumed and focus events performed automatically,
-   * without the component seeing the keystrokes.
-   *
-   * @return true if focus traversal is enabled
-   * @see #setFocusTraversalKeysEnabled(boolean)
-   * @see #setFocusTraversalKeys(int, Set)
-   * @see #getFocusTraversalKeys(int)
+   * Check whether or not focus traversal keys are enabled on this
+   * Component.  If they are, then the keyboard focus manager consumes
+   * and acts on key press and release events that trigger focus
+   * traversal, and discards the corresponding key typed events.  If
+   * focus traversal keys are disabled, then all key events that would
+   * otherwise trigger focus traversal are sent to this Component.
+   *
+   * @return true if focus traversal keys are enabled
+   * @see #setFocusTraversalKeysEnabled (boolean)
+   * @see #setFocusTraversalKeys (int, Set)
+   * @see #getFocusTraversalKeys (int)
    * @since 1.4
    */
-  public boolean getFocusTraversalKeysEnabled()
+  public boolean getFocusTraversalKeysEnabled ()
   {
     return focusTraversalKeysEnabled;
   }
 
   /**
-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be able to receive focus. Thus, this
-   * request may fail, or be delayed until the window receives focus. It is
-   * recommended that <code>requestFocusInWindow</code> be used where
-   * possible to be more platform-independent.
+   * Request that this Component be given the keyboard input focus and
+   * that its top-level ancestor become the focused Window.
+   *
+   * For the request to be granted, the Component must be focusable,
+   * displayable and showing and the top-level Window to which it
+   * belongs must be focusable.  If the request is initially denied on
+   * the basis that the top-level Window is not focusable, the request
+   * will be remembered and granted when the Window does become
+   * focused.
    *
-   * @see #requestFocusInWindow()
+   * Never assume that this Component is the focus owner until it
+   * receives a FOCUS_GAINED event.
+   *
+   * The behaviour of this method is platform-dependent.
+   * {@link #requestFocusInWindow} should be used instead.
+   *
+   * @see #requestFocusInWindow ()
    * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
-   */
-  public void requestFocus()
-  {
-    // If there's no peer then this component can't get the focus. We
-    // treat it as a silent rejection of the request.
-    if (peer != null)
-      peer.requestFocus();
+   * @see #addFocusListener (FocusListener)
+   * @see #isFocusable ()
+   * @see #isDisplayable ()
+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()
+   */
+  public void requestFocus ()
+  {
+    if (isDisplayable ()
+	&& isShowing ()
+	&& isFocusable ())
+      {
+        synchronized (getTreeLock ())
+          {
+            // Find this Component's top-level ancestor.
+            Container parent = getParent ();
+
+            while (parent != null
+                   && !(parent instanceof Window))
+              parent = parent.getParent ();
+
+            Window toplevel = (Window) parent;
+            if (toplevel.isFocusableWindow ())
+              {
+                if (peer != null)
+                  // This call will cause a FOCUS_GAINED event to be
+                  // posted to the system event queue if the native
+                  // windowing system grants the focus request.
+                  peer.requestFocus ();
+                else
+                  {
+                    // Either our peer hasn't been created yet or we're a
+                    // lightweight component.  In either case we want to
+                    // post a FOCUS_GAINED event.
+                    EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();
+                    eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED));
+                  }
+              }
+            else
+              pendingFocusRequest = new FocusEvent(this, FocusEvent.FOCUS_GAINED);
+          }
+      }
   }
 
   /**
-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be able to receive focus. Thus, this
-   * request may fail, or be delayed until the window receives focus. It is
-   * recommended that <code>requestFocusInWindow</code> be used where
-   * possible to be more platform-independent.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
+   * Request that this Component be given the keyboard input focus and
+   * that its top-level ancestor become the focused Window.
+   *
+   * For the request to be granted, the Component must be focusable,
+   * displayable and showing and the top-level Window to which it
+   * belongs must be focusable.  If the request is initially denied on
+   * the basis that the top-level Window is not focusable, the request
+   * will be remembered and granted when the Window does become
+   * focused.
+   *
+   * Never assume that this Component is the focus owner until it
+   * receives a FOCUS_GAINED event.
+   *
+   * The behaviour of this method is platform-dependent.
+   * {@link #requestFocusInWindow} should be used instead.
+   *
+   * If the return value is false, the request is guaranteed to fail.
+   * If the return value is true, the request will succeed unless it
+   * is vetoed or something in the native windowing system intervenes,
+   * preventing this Component's top-level ancestor from becoming
+   * focused.  This method is meant to be called by derived
+   * lightweight Components that want to avoid unnecessary repainting
+   * when they know a given focus transfer need only be temporary.
    *
    * @param temporary true if the focus request is temporary
    * @return true if the request has a chance of success
-   * @see #requestFocusInWindow()
+   * @see #requestFocusInWindow ()
    * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
+   * @see #addFocusListener (FocusListener)
+   * @see #isFocusable ()
+   * @see #isDisplayable ()
+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()
    * @since 1.4
    */
-  protected boolean requestFocus(boolean temporary)
+  protected boolean requestFocus (boolean temporary)
   {
-    // XXX Implement correctly.
-    requestFocus();
+    if (isDisplayable ()
+	&& isShowing ()
+	&& isFocusable ())
+      {
+        synchronized (getTreeLock ())
+          {
+            // Find this Component's top-level ancestor.
+            Container parent = getParent ();
+
+            while (parent != null
+                   && !(parent instanceof Window))
+              parent = parent.getParent ();
+
+            Window toplevel = (Window) parent;
+            if (toplevel.isFocusableWindow ())
+              {
+                if (peer != null)
+                  // This call will cause a FOCUS_GAINED event to be
+                  // posted to the system event queue if the native
+                  // windowing system grants the focus request.
+                  peer.requestFocus ();
+                else
+                  {
+                    // Either our peer hasn't been created yet or we're a
+                    // lightweight component.  In either case we want to
+                    // post a FOCUS_GAINED event.
+                    EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();
+                    eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));
+                  }
+              }
+            else
+              // FIXME: need to add a focus listener to our top-level
+              // ancestor, so that we can post this event when it becomes
+              // the focused window.
+              pendingFocusRequest = new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary);
+          }
+      }
+    // Always return true.
     return true;
   }
 
   /**
-   * Requests that this component be given focus, if it resides in the
-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be focused.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
+   * Request that this component be given the keyboard input focus, if
+   * its top-level ancestor is the currently focused Window.  A
+   * <code>FOCUS_GAINED</code> event will be fired if and only if this
+   * request is successful. To be successful, the component must be
+   * displayable, showing, and focusable, and its ancestor top-level
+   * Window must be focused.
+   *
+   * If the return value is false, the request is guaranteed to fail.
+   * If the return value is true, the request will succeed unless it
+   * is vetoed or something in the native windowing system intervenes,
+   * preventing this Component's top-level ancestor from becoming
+   * focused.
    *
    * @return true if the request has a chance of success
-   * @see #requestFocus()
+   * @see #requestFocus ()
    * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
+   * @see #addFocusListener (FocusListener)
+   * @see #isFocusable ()
+   * @see #isDisplayable ()
+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()
    * @since 1.4
    */
-  public boolean requestFocusInWindow()
+  public boolean requestFocusInWindow ()
   {
-    // XXX Implement correctly.
-    requestFocus();
-    return true;
+    return requestFocusInWindow (false);
   }
 
   /**
-   * Requests that this component be given focus, if it resides in the
-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>
-   * event will be fired if and only if this request is successful. To be
-   * successful, the component must be displayable, visible, and focusable,
-   * and the top-level Window must be focused.
-   *
-   * <p>If the return value is false, the request is guaranteed to fail. If
-   * it is true, it will likely succeed unless the action is vetoed or
-   * something in the native windowing system intervenes. The temporary flag,
-   * and thus this method in general, is not designed for public use; rather
-   * it is a hook for lightweight components to notify their container in
-   * an attempt to reduce the amount of repainting necessary.
+   * Request that this component be given the keyboard input focus, if
+   * its top-level ancestor is the currently focused Window.  A
+   * <code>FOCUS_GAINED</code> event will be fired if and only if this
+   * request is successful. To be successful, the component must be
+   * displayable, showing, and focusable, and its ancestor top-level
+   * Window must be focused.
+   *
+   * If the return value is false, the request is guaranteed to fail.
+   * If the return value is true, the request will succeed unless it
+   * is vetoed or something in the native windowing system intervenes,
+   * preventing this Component's top-level ancestor from becoming
+   * focused.  This method is meant to be called by derived
+   * lightweight Components that want to avoid unnecessary repainting
+   * when they know a given focus transfer need only be temporary.
    *
    * @param temporary true if the focus request is temporary
    * @return true if the request has a chance of success
-   * @see #requestFocus()
+   * @see #requestFocus ()
    * @see FocusEvent
-   * @see #addFocusListener(FocusListener)
-   * @see #isFocusable()
-   * @see #isDisplayable()
-   * @see KeyboardFocusManager#clearGlobalFocusOwner()
+   * @see #addFocusListener (FocusListener)
+   * @see #isFocusable ()
+   * @see #isDisplayable ()
+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()
    * @since 1.4
    */
-  protected boolean requestFocusInWindow(boolean temporary)
+  protected boolean requestFocusInWindow (boolean temporary)
   {
-    // XXX Implement correctly.
-    requestFocus();
-    return true;
+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();
+
+    Window focusedWindow = manager.getFocusedWindow ();
+
+    if (isDisplayable ()
+	&& isShowing ()
+	&& isFocusable ())
+      {
+        if (focusedWindow != null)
+          {
+            synchronized (getTreeLock ())
+              {
+                Container parent = getParent ();
+
+                while (parent != null
+                       && !(parent instanceof Window))
+                  parent = parent.getParent ();
+
+                Window toplevel = (Window) parent;
+
+                // Check if top-level ancestor is currently focused window.
+                if (focusedWindow == toplevel)
+                  {
+                    if (peer != null)
+                      // This call will cause a FOCUS_GAINED event to be
+                      // posted to the system event queue if the native
+                      // windowing system grants the focus request.
+                      peer.requestFocus ();
+                    else
+                      {
+                        // Either our peer hasn't been created yet or we're a
+                        // lightweight component.  In either case we want to
+                        // post a FOCUS_GAINED event.
+                        EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();
+                        eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));
+                      }
+                  }
+                else
+                  return false;
+              }
+          }
+
+        return true;
+      }
+    return false;
   }
 
   /**
-   * Transfers focus to the next component in the focus traversal order, as
-   * though this were the current focus owner.
+   * Transfers focus to the next component in the focus traversal
+   * order, as though this were the current focus owner.
    *
    * @see #requestFocus()
    * @since 1.1
    */
-  public void transferFocus()
+  public void transferFocus ()
   {
-    Component next;
-    if (parent == null)
-      next = findNextFocusComponent(null);
-    else
-      next = parent.findNextFocusComponent(this);
-    if (next != null && next != this)
-      next.requestFocus();
+    nextFocus ();
   }
 
   /**
-   * Returns the root container that owns the focus cycle where this component
-   * resides. A focus cycle root is in two cycles, one as the ancestor, and
-   * one as the focusable element; this call always returns the ancestor.
+   * Returns the root container that owns the focus cycle where this
+   * component resides. A focus cycle root is in two cycles, one as
+   * the ancestor, and one as the focusable element; this call always
+   * returns the ancestor.
    *
    * @return the ancestor container that owns the focus cycle
    * @since 1.4
    */
-  public Container getFocusCycleRootAncestor()
+  public Container getFocusCycleRootAncestor ()
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    if (this instanceof Window
+	&& ((Container) this).isFocusCycleRoot ())
+      return (Container) this;
+
+    Container parent = getParent ();
+
+    while (parent != null
+	   && !parent.isFocusCycleRoot ())
+      parent = parent.getParent ();
+
+    return parent;
   }
 
   /**
-   * Tests if the container is the ancestor of the focus cycle that this
-   * component belongs to.
+   * Tests if the container is the ancestor of the focus cycle that
+   * this component belongs to.
    *
    * @param c the container to test
    * @return true if c is the focus cycle root
    * @since 1.4
    */
-  public boolean isFocusCycleRoot(Container c)
+  public boolean isFocusCycleRoot (Container c)
   {
-    return c == getFocusCycleRootAncestor();
+    return c == getFocusCycleRootAncestor ();
   }
 
   /**
-   * AWT 1.0 focus event processor.
+   * AWT 1.0 focus event processor.  Transfers focus to the next
+   * component in the focus traversal order, as though this were the
+   * current focus owner.
    *
-   * @deprecated use {@link #transferFocus()} instead
+   * @deprecated use {@link #transferFocus ()} instead
    */
-  public void nextFocus()
+  public void nextFocus ()
   {
-    transferFocus();
+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();
+
+    manager.focusNextComponent (this);
   }
 
   /**
-   * Transfers focus to the previous component in the focus traversal order, as
-   * though this were the current focus owner.
+   * Transfers focus to the previous component in the focus traversal
+   * order, as though this were the current focus owner.
    *
-   * @see #requestFocus()
+   * @see #requestFocus ()
    * @since 1.4
    */
-  public void transferFocusBackward()
+  public void transferFocusBackward ()
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();
+
+    manager.focusPreviousComponent (this);
   }
 
   /**
-   * Transfers focus to the focus cycle root of this component. However, if
-   * this is a Window, the default focus owner in the window in the current
-   * focus cycle is focused instead.
+   * Transfers focus to the focus cycle root of this component.
+   * However, if this is a Window, the default focus owner in the
+   * window in the current focus cycle is focused instead.
    *
-   * @see #requestFocus()
-   * @see #isFocusCycleRoot()
+   * @see #requestFocus ()
+   * @see #isFocusCycleRoot ()
    * @since 1.4
    */
-  public void transferFocusUpCycle()
+  public void transferFocusUpCycle ()
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();
+
+    manager.upFocusCycle (this);
   }
 
   /**
-   * Tests if this component is the focus owner. Use {@link #isFocusOwner()}
-   * instead.
+   * Tests if this component is the focus owner. Use {@link
+   * #isFocusOwner ()} instead.
    *
    * @return true if this component owns focus
    * @since 1.2
    */
-  public boolean hasFocus()
+  public boolean hasFocus ()
   {
-    return isFocusOwner();
+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();
+
+    Component focusOwner = manager.getFocusOwner ();
+
+    return this == focusOwner;
   }
 
   /**
@@ -3801,8 +3993,7 @@
    */
   public boolean isFocusOwner()
   {
-    // XXX Implement.
-    throw new Error("not implemented");
+    return hasFocus ();
   }
 
   /**
@@ -4337,6 +4528,8 @@
    * making the request. This is overridden by Container; when called for an
    * ordinary component there is no child and so we always return null.
    *
+   * FIXME: is this still needed, in light of focus traversal policies?
+   *
    * @param child the component making the request
    * @return the next component to focus on
    */
@@ -4897,23 +5090,23 @@
      * Tests whether this component can accept focus.
      *
      * @return true if this is focus traversable
-     * @see #getAccessibleStateSet()
+     * @see #getAccessibleStateSet ()
      * @see AccessibleState#FOCUSABLE
      * @see AccessibleState#FOCUSED
      */
-    public boolean isFocusTraversable()
+    public boolean isFocusTraversable ()
     {
-      return Component.this.isFocusTraversable();
+      return Component.this.isFocusTraversable ();
     }
 
     /**
      * Requests focus for this component.
      *
-     * @see #isFocusTraversable()
+     * @see #isFocusTraversable ()
      */
-    public void requestFocus()
+    public void requestFocus ()
     {
-      Component.this.requestFocus();
+      Component.this.requestFocus ();
     }
 
     /**
