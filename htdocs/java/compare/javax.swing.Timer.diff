--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/Timer.java	2004-04-29 02:24:17.000000000 -0600
+++ javax/swing/Timer.java	2004-06-18 02:18:55.000000000 -0600
@@ -47,44 +47,107 @@
 
 public class Timer implements Serializable
 {
+  private static final long serialVersionUID = -1116180831621385484L;
+  
   protected EventListenerList listenerList = new EventListenerList();
   
-  int ticks;
-  static boolean verbose;
+  // This object manages a "queue" of virtual actionEvents, maintained as a
+  // simple long counter. When the timer expires, a new event is queued,
+  // and a dispatcher object is pushed into the system event queue. When
+  // the system thread runs the dispatcher, it will fire as many
+  // ActionEvents as have been queued, unless the timer is set to
+  // coalescing mode, in which case it will fire only one ActionEvent.
+
+  private long queue;
+  private Object queueLock = new Object();
+  private void queueEvent()
+  {
+    synchronized (queueLock)
+      {
+        queue++;
+        if (queue == 1)
+          SwingUtilities.invokeLater(new Runnable() { public void run() { drainEvents(); } });
+      }
+  }
+
+  private void drainEvents()
+  {
+    synchronized (queueLock)
+      {
+        if (isCoalesce())
+          {
+            if (queue > 0)
+              fireActionPerformed();
+          }
+        else
+          {
+            while(queue > 0)
+              {                  
+                fireActionPerformed();
+                queue--;
+              }          
+          }
+        queue = 0;
+      }
+  }
+  
+
+  static boolean logTimers;
+  boolean coalesce = true;
+  boolean repeats = true;
   boolean running;
-  boolean repeat_ticks = true;
-  long interval, init_delay;
+  int ticks;
+  int delay;
+  int initialDelay;
     
-  class Waker extends Thread
+  private class Waker 
+    extends Thread
   {
     public void run()
     {
       running = true;
-      try {
-	sleep(init_delay);
-		
-	while (running)
-	  {
-	    sleep(interval);
-
-	    if (verbose)
-	      {
-		System.out.println("javax.swing.Timer -> clocktick");
-	      }
+      try 
+        {
 
-	    ticks++;
-	    fireActionPerformed();
-  
-	    if (! repeat_ticks)
-	      break;
-	  }
-	running = false;
-      } catch (Exception e) {
-	System.out.println("swing.Timer::" + e);
-      }
+          sleep(initialDelay);
+          
+          while (running)
+            {
+              sleep(delay);
+              
+              if (logTimers)
+                System.out.println("javax.swing.Timer -> clocktick");
+              
+              if (! repeats)
+                break;
+            }
+          running = false;
+      } 
+      catch (Exception e) 
+        {
+          System.out.println("swing.Timer::" + e);
+        }
     }
   }
 
+  public Timer(int d, ActionListener listener)
+  {
+    delay = d;
+
+    if (listener != null)
+      addActionListener(listener);
+  }
+
+  public void setCoalesce(boolean c)
+  {
+    coalesce = c;
+  }
+
+  public boolean isCoalesce()
+  {
+    return coalesce;
+  }
+
   public void addActionListener(ActionListener listener)
   {
     listenerList.add (ActionListener.class, listener);
@@ -123,37 +186,47 @@
 
   void fireActionPerformed ()
   {
-    fireActionPerformed (new ActionEvent (this, ticks, "Timer"));
+    fireActionPerformed (new ActionEvent (this, ticks++, "Timer"));
   }
 
-  public static void setLogTimers(boolean flag)
+  public static void setLogTimers(boolean lt)
   {
-    verbose = flag;
+    logTimers = lt;
   }
 
   public static boolean getLogTimers()
   {
-    return verbose;
+    return logTimers;
   }
     
-  public void setDelay(int delay)
+  public void setDelay(int d)
   {
-    interval = delay;
+    delay = d;
   }
 
   public int getDelay()
   {
-    return (int)interval;
+    return delay;
+  }
+
+  public void setInitialDelay(int i)
+  {
+    initialDelay = i;
   }
 
-  public void setInitialDelay(int initialDelay)
+  public int getInitialDelay()
   {
-    init_delay = initialDelay;
+    return initialDelay;
   }
 
-  public void setRepeats(boolean flag)
+  public void setRepeats(boolean r)
   {
-    repeat_ticks = flag;
+    repeats = r;
+  }
+
+  public boolean isRepeats()
+  {
+    return repeats;
   }
 
   public boolean isRunning()
@@ -171,6 +244,15 @@
     new Waker().start();
   }
 
+  public void restart()
+  {
+    synchronized (queueLock)
+      {
+        queue = 0;
+      }
+    start();
+  }
+
   public void stop()
   {
     running = false;
