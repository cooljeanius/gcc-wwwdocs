--- /home/tromey/gnu/classpath/classpath/java/awt/Container.java	Mon Dec 30 15:39:03 2002
+++ java/awt/Container.java	Tue Dec 10 19:20:24 2002
@@ -59,9 +59,7 @@
  *
  * @author original author unknown
  * @author Eric Blake <ebb9@email.byu.edu>
- *
  * @since 1.0
- *
  * @status still missing 1.4 support
  */
 public class Container extends Component
@@ -80,9 +78,7 @@
 
   Dimension maxSize;
 
-  /**
-   * @since 1.4
-   */
+  /** @since 1.4 */
   boolean focusCycleRoot;
 
   int containerSerializedDataVersion;
@@ -111,7 +107,6 @@
    * Returns the number of components in this container.
    *
    * @return The number of components in this container.
-   *
    * @deprecated use {@link #getComponentCount()} instead
    */
   public int countComponents()
@@ -123,19 +118,16 @@
    * Returns the component at the specified index.
    *
    * @param index The index of the component to retrieve.
-   *
    * @return The requested component.
-   *
    * @throws ArrayIndexOutOfBoundsException If the specified index is invalid
    */
   public Component getComponent(int n)
   {
     synchronized (getTreeLock ())
       {
-        if (n < 0 || n >= ncomponents)
-          throw new ArrayIndexOutOfBoundsException("no such component");
-
-        return component[n];
+	if (n < 0 || n >= ncomponents)
+	  throw new ArrayIndexOutOfBoundsException("no such component");
+	return component[n];
       }
   }
 
@@ -148,12 +140,10 @@
   {
     synchronized (getTreeLock ())
       {
-        Component[] result = new Component[ncomponents];
-
-        if (ncomponents > 0)
-          System.arraycopy(component, 0, result, 0, ncomponents);
-
-        return result;
+	Component[] result = new Component[ncomponents];
+	if (ncomponents > 0)
+	  System.arraycopy(component, 0, result, 0, ncomponents);
+	return result;
       }
   }
 
@@ -167,7 +157,6 @@
   {
     if (peer == null)
       return new Insets(0, 0, 0, 0);
-    
     return ((ContainerPeer) peer).getInsets();
   }
 
@@ -188,7 +177,6 @@
    * component list.
    *
    * @param component The component to add to the container.
-   *
    * @return The same component that was added.
    */
   public Component add(Component comp)
@@ -202,7 +190,7 @@
    * component list.  This method should not be used. Instead, use
    * <code>add(Component, Object</code>.
    *
-   * @param name The name of the component to be added.
+   * @param name FIXME
    * @param component The component to be added.
    *
    * @return The same component that was added.
@@ -280,70 +268,69 @@
   {
     synchronized (getTreeLock ())
       {
-        if (index > ncomponents
-            || (index < 0 && index != -1)
-            || comp instanceof Window
-            || (comp instanceof Container
-                && ((Container) comp).isAncestorOf(this)))
-          throw new IllegalArgumentException();
-
-        // Reparent component, and make sure component is instantiated if
-        // we are.
-        if (comp.parent != null)
-          comp.parent.remove(comp);
-        comp.parent = this;
-        if (peer != null)
-          {
-            comp.addNotify();
+	if (index > ncomponents
+	    || (index < 0 && index != -1)
+	    || comp instanceof Window
+	    || (comp instanceof Container
+		&& ((Container) comp).isAncestorOf(this)))
+	  throw new IllegalArgumentException();
+
+	// Reparent component, and make sure component is instantiated if
+	// we are.
+	if (comp.parent != null)
+	  comp.parent.remove(comp);
+	comp.parent = this;
+	if (peer != null)
+	  {
+	    comp.addNotify();
 
-            if (comp.isLightweight())
-              enableEvents(comp.eventMask);
-          }
+	    if (comp.isLightweight())
+	      enableEvents(comp.eventMask);
+	  }
 
-        invalidate();
+	invalidate();
 
-        if (component == null)
-          component = new Component[4]; // FIXME, better initial size?
+	if (component == null)
+	  component = new Component[4]; // FIXME, better initial size?
 
-        // This isn't the most efficient implementation.  We could do less
-        // copying when growing the array.  It probably doesn't matter.
-        if (ncomponents >= component.length)
-          {
-            int nl = component.length * 2;
-            Component[] c = new Component[nl];
-            System.arraycopy(component, 0, c, 0, ncomponents);
-            component = c;
-          }
-  
-        if (index == -1)
-          component[ncomponents++] = comp;
-        else
-          {
-            System.arraycopy(component, index, component, index + 1,
-                             ncomponents - index);
-            component[index] = comp;
-            ++ncomponents;
-          }
+	// This isn't the most efficient implementation.  We could do less
+	// copying when growing the array.  It probably doesn't matter.
+	if (ncomponents >= component.length)
+	  {
+	    int nl = component.length * 2;
+	    Component[] c = new Component[nl];
+	    System.arraycopy(component, 0, c, 0, ncomponents);
+	    component = c;
+	  }
+	if (index == -1)
+	  component[ncomponents++] = comp;
+	else
+	  {
+	    System.arraycopy(component, index, component, index + 1,
+			     ncomponents - index);
+	    component[index] = comp;
+	    ++ncomponents;
+	  }
 
-        // Notify the layout manager.
-        if (layoutMgr != null)
-          {
-            if (layoutMgr instanceof LayoutManager2)
-              {
-                LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
-                lm2.addLayoutComponent(comp, constraints);
-              }
-            else if (constraints instanceof String)
-              layoutMgr.addLayoutComponent((String) constraints, comp);
-            else
-              layoutMgr.addLayoutComponent(null, comp);
-          }
+	// Notify the layout manager.
+	if (layoutMgr != null)
+	  {
+	    if (layoutMgr instanceof LayoutManager2)
+	      {
+		LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
+		lm2.addLayoutComponent(comp, constraints);
+	      }
+	    else if (constraints instanceof String)
+	      layoutMgr.addLayoutComponent((String) constraints, comp);
+	    else
+	      layoutMgr.addLayoutComponent(null, comp);
+	  }
 
-        // Post event to notify of adding the container.
-        ContainerEvent ce = new ContainerEvent(this,
-                                               ContainerEvent.COMPONENT_ADDED,
-                                               comp);
-        getToolkit().getSystemEventQueue().postEvent(ce);
+	// Post event to notify of adding the container.
+	ContainerEvent ce = new ContainerEvent(this,
+					       ContainerEvent.COMPONENT_ADDED,
+					       comp);
+	getToolkit().getSystemEventQueue().postEvent(ce);
       }
   }
 
@@ -356,24 +343,24 @@
   {
     synchronized (getTreeLock ())
       {
-        Component r = component[index];
+	Component r = component[index];
 
-        r.removeNotify();
+	r.removeNotify();
 
-        System.arraycopy(component, index + 1, component, index,
-                         ncomponents - index - 1);
-        component[--ncomponents] = null;
+	System.arraycopy(component, index + 1, component, index,
+			 ncomponents - index - 1);
+	component[--ncomponents] = null;
 
-        invalidate();
+	invalidate();
 
-        if (layoutMgr != null)
-          layoutMgr.removeLayoutComponent(r);
+	if (layoutMgr != null)
+	  layoutMgr.removeLayoutComponent(r);
 
-        // Post event to notify of adding the container.
-        ContainerEvent ce = new ContainerEvent(this,
-                                               ContainerEvent.COMPONENT_REMOVED,
-                                               r);
-        getToolkit().getSystemEventQueue().postEvent(ce);
+	// Post event to notify of adding the container.
+	ContainerEvent ce = new ContainerEvent(this,
+					       ContainerEvent.COMPONENT_REMOVED,
+					       r);
+	getToolkit().getSystemEventQueue().postEvent(ce);
       }
   }
 
@@ -386,14 +373,14 @@
   {
     synchronized (getTreeLock ())
       {
-        for (int i = 0; i < ncomponents; ++i)
-          {
-            if (component[i] == comp)
-              {
-                remove(i);
-                break;
-              }
-          }
+	for (int i = 0; i < ncomponents; ++i)
+	  {
+	    if (component[i] == comp)
+	      {
+		remove(i);
+		break;
+	      }
+	  }
       }
   }
 
@@ -404,8 +391,8 @@
   {
     synchronized (getTreeLock ())
       {
-        while (ncomponents > 0)
-          remove(0);
+	while (ncomponents > 0)
+	  remove(0);
       }
   }
 
@@ -538,7 +525,6 @@
    * Returns the preferred size of this container.
    *
    * @return The preferred size of this container.
-   *
    * @deprecated use {@link #getPreferredSize()} instead
    */
   public Dimension preferredSize()
@@ -563,7 +549,6 @@
    * Returns the minimum size of this container.
    *
    * @return The minimum size of this container.
-   *
    * @deprecated use {@link #getMinimumSize()} instead
    */
   public Dimension minimumSize()
@@ -724,10 +709,6 @@
   }
 
   /**
-   * Returns an array of all the objects currently registered as FooListeners
-   * upon this Container. FooListeners are registered using the addFooListener
-   * method.
-   *
    * @since 1.3
    */
   public EventListener[] getListeners(Class listenerType)
@@ -779,7 +760,6 @@
    * AWT 1.0 event processor.
    *
    * @param event The event that occurred.
-   *
    * @deprecated use {@link #dispatchEvent(AWTEvent)} instead
    */
   public void deliverEvent(Event e)
@@ -804,20 +784,20 @@
   {
     synchronized (getTreeLock ())
       {
-        if (! contains(x, y))
-          return null;
-        for (int i = 0; i < ncomponents; ++i)
-          {
-            // Ignore invisible children...
-            if (!component[i].isVisible())
-              continue;
-
-            int x2 = x - component[i].x;
-            int y2 = y - component[i].y;
-            if (component[i].contains(x2, y2))
-              return component[i];
-          }
-        return this;
+	if (! contains(x, y))
+	  return null;
+	for (int i = 0; i < ncomponents; ++i)
+	  {
+	    // Ignore invisible children...
+	    if (!component[i].isVisible())
+	      continue;
+
+	    int x2 = x - component[i].x;
+	    int y2 = y - component[i].y;
+	    if (component[i].contains(x2, y2))
+	      return component[i];
+	  }
+	return this;
       }
   }
 
@@ -833,7 +813,6 @@
    *
    * @return The component containing the specified point, or <code>null</code>
    * if there is no such point.
-   *
    * @deprecated use {@link #getComponentAt(int, int)} instead
    */
   public Component locate(int x, int y)
@@ -862,31 +841,31 @@
   {
     synchronized (getTreeLock ())
       {
-        if (! contains(x, y))
-          return null;
+	if (! contains(x, y))
+	  return null;
 
-        for (int i = 0; i < ncomponents; ++i)
-          {
-            // Ignore invisible children...
-            if (!component[i].isVisible())
-              continue;
-
-            int x2 = x - component[i].x;
-            int y2 = y - component[i].y;
-            // We don't do the contains() check right away because
-            // findComponentAt would redundantly do it first thing.
-            if (component[i] instanceof Container)
-              {
-                Container k = (Container) component[i];
-                Component r = k.findComponentAt(x2, y2);
-                if (r != null)
-                  return r;
-              }
-            else if (component[i].contains(x2, y2))
-              return component[i];
-          }
+	for (int i = 0; i < ncomponents; ++i)
+	  {
+	    // Ignore invisible children...
+	    if (!component[i].isVisible())
+	      continue;
+
+	    int x2 = x - component[i].x;
+	    int y2 = y - component[i].y;
+	    // We don't do the contains() check right away because
+	    // findComponentAt would redundantly do it first thing.
+	    if (component[i] instanceof Container)
+	      {
+		Container k = (Container) component[i];
+		Component r = k.findComponentAt(x2, y2);
+		if (r != null)
+		  return r;
+	      }
+	    else if (component[i].contains(x2, y2))
+	      return component[i];
+	  }
 
-        return this;
+	return this;
       }
   }
 
@@ -915,9 +894,9 @@
   {
     synchronized (getTreeLock ())
       {
-        for (int i = 0; i < ncomponents; ++i)
-          component[i].removeNotify();
-        super.removeNotify();
+	for (int i = 0; i < ncomponents; ++i)
+	  component[i].removeNotify();
+	super.removeNotify();
       }
   }
 
@@ -934,14 +913,14 @@
   {
     synchronized (getTreeLock ())
       {
-        while (true)
-          {
-            if (comp == null)
-              return false;
-            if (comp == this)
-              return true;
-            comp = comp.getParent();
-          }
+	while (true)
+	  {
+	    if (comp == null)
+	      return false;
+	    if (comp == this)
+	      return true;
+	    comp = comp.getParent();
+	  }
       }
   }
 
@@ -971,9 +950,9 @@
   {
     synchronized (getTreeLock ())
       {
-        super.list(out, indent);
-        for (int i = 0; i < ncomponents; ++i)
-          component[i].list(out, indent + 2);
+	super.list(out, indent);
+	for (int i = 0; i < ncomponents; ++i)
+	  component[i].list(out, indent + 2);
       }
   }
 
@@ -988,93 +967,62 @@
   {
     synchronized (getTreeLock ())
       {
-        super.list(out, indent);
-        for (int i = 0; i < ncomponents; ++i)
-          component[i].list(out, indent + 2);
+	super.list(out, indent);
+	for (int i = 0; i < ncomponents; ++i)
+	  component[i].list(out, indent + 2);
       }
   }
 
   public void setFocusTraversalKeys(int id, Set keys)
   {
-    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException ();
   }
-  
   public Set getFocusTraversalKeys(int id)
   {
-    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException ();
-
     return null;
   }
-  
   public boolean areFocusTraversalKeysSet(int id)
   {
-    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&
-        id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)
-      throw new IllegalArgumentException ();
-
     return false;
   }
-  
   public boolean isFocusCycleRoot(Container c)
   {
     return false;
   }
-  
   public void transferFocusBackward()
   {
   }
-  
   public void setFocusTraversalPolicy(FocusTraversalPolicy policy)
   {
   }
-  
   public FocusTraversalPolicy getFocusTraversalPolicy()
   {
     return null;
   }
-  
   public boolean isFocusTraversalPolicySet()
   {
     return false;
   }
-  
   public void setFocusCycleRoot(boolean focusCycleRoot)
   {
   }
-  
   public boolean isFocusCycleRoot()
   {
     return false;
   }
-  
   public void transferFocusDownCycle()
   {
   }
-  
   public void applyComponentOrientation(ComponentOrientation o)
   {
-    if (orientation == null)
-      throw new NullPointerException ();
   }
-  
   public void addPropertyChangeListener(PropertyChangeListener l)
   {
   }
-  
   public void addPropertyChangeListener(String name, PropertyChangeListener l)
   {
   }
 
+
   // Hidden helper methods.
 
   /**
@@ -1096,14 +1044,14 @@
   {
     synchronized (getTreeLock ())
       {
-        for (int i = 0; i < ncomponents; ++i)
-          {
-            Component comp = component[i];
-            boolean applicable = comp.isVisible()
-              && (comp.isLightweight() || !lightweightOnly);
+	for (int i = 0; i < ncomponents; ++i)
+	  {
+	    Component comp = component[i];
+	    boolean applicable = comp.isVisible()
+	      && (comp.isLightweight() || !lightweightOnly);
 
-            if (applicable)
-              visitChild(gfx, visitor, comp);
+	    if (applicable)
+	      visitChild(gfx, visitor, comp);
 	  }
       }
   }
@@ -1152,50 +1100,50 @@
   {
     synchronized (getTreeLock ())
       {
-        int start, end;
-        if (child != null)
-          {
-            for (start = 0; start < ncomponents; ++start)
-              {
-                if (component[start] == child)
-                  break;
-              }
-            end = start;
-            // This special case lets us be sure to terminate.
-            if (end == 0)
-              end = ncomponents;
-            ++start;
-          }
-        else
-          {
-            start = 0;
-            end = ncomponents;
-          }
+	int start, end;
+	if (child != null)
+	  {
+	    for (start = 0; start < ncomponents; ++start)
+	      {
+		if (component[start] == child)
+		  break;
+	      }
+	    end = start;
+	    // This special case lets us be sure to terminate.
+	    if (end == 0)
+	      end = ncomponents;
+	    ++start;
+	  }
+	else
+	  {
+	    start = 0;
+	    end = ncomponents;
+	  }
 
-        for (int j = start; j != end; ++j)
-          {
-            if (j >= ncomponents)
-              {
-                // The JCL says that we should wrap here.  However, that
-                // seems wrong.  To me it seems that focus order should be
-                // global within in given window.  So instead if we reach
-                // the end we try to look in our parent, if we have one.
-                if (parent != null)
-                  return parent.findNextFocusComponent(this);
-                j -= ncomponents;
-              }
-            if (component[j] instanceof Container)
-              {
-                Component c = component[j];
-                c = c.findNextFocusComponent(null);
-                if (c != null)
-                  return c;
-              }
-            else if (component[j].isFocusTraversable())
-              return component[j];
-          }
+	for (int j = start; j != end; ++j)
+	  {
+	    if (j >= ncomponents)
+	      {
+		// The JCL says that we should wrap here.  However, that
+		// seems wrong.  To me it seems that focus order should be
+		// global within in given window.  So instead if we reach
+		// the end we try to look in our parent, if we have one.
+		if (parent != null)
+		  return parent.findNextFocusComponent(this);
+		j -= ncomponents;
+	      }
+	    if (component[j] instanceof Container)
+	      {
+		Component c = component[j];
+		c = c.findNextFocusComponent(null);
+		if (c != null)
+		  return c;
+	      }
+	    else if (component[j].isFocusTraversable())
+	      return component[j];
+	  }
 
-        return null;
+	return null;
       }
   }
 
@@ -1203,15 +1151,16 @@
   {
     synchronized (getTreeLock ())
       {
-        for (int i = ncomponents;  --i >= 0; )
-          {
-            component[i].addNotify();
-            if (component[i].isLightweight())
-              enableEvents(component[i].eventMask);
-          }
+	for (int i = ncomponents;  --i >= 0; )
+	  {
+	    component[i].addNotify();
+	    if (component[i].isLightweight())
+	      enableEvents(component[i].eventMask);
+	  }
       }
   }
 
+
   // Nested classes.
 
   /* The following classes are used in concert with the
@@ -1251,7 +1200,6 @@
    * This class provides accessibility support for subclasses of container.
    *
    * @author Eric Blake <ebb9@email.byu.edu>
-   *
    * @since 1.3
    */
   protected class AccessibleAWTContainer extends AccessibleAWTComponent
@@ -1286,14 +1234,14 @@
     public int getAccessibleChildrenCount()
     {
       synchronized (getTreeLock ())
-        {
-          int count = 0;
-          int i = component == null ? 0 : component.length;
-          while (--i >= 0)
-            if (component[i] instanceof Accessible)
-              count++;
-          return count;
-        }
+	{
+	  int count = 0;
+	  int i = component == null ? 0 : component.length;
+	  while (--i >= 0)
+	    if (component[i] instanceof Accessible)
+	      count++;
+	  return count;
+	}
     }
 
     /**
@@ -1305,17 +1253,17 @@
     public Accessible getAccessibleChild(int i)
     {
       synchronized (getTreeLock ())
-        {
-          if (component == null)
-            return null;
-          int index = -1;
-          while (i >= 0 && ++index < component.length)
-            if (component[index] instanceof Accessible)
-              i--;
-          if (i < 0)
-            return (Accessible) component[index];
-          return null;
-        }
+	{
+	  if (component == null)
+	    return null;
+	  int index = -1;
+	  while (i >= 0 && ++index < component.length)
+	    if (component[index] instanceof Accessible)
+	      i--;
+	  if (i < 0)
+	    return (Accessible) component[index];
+	  return null;
+	}
     }
 
     /**
@@ -1323,9 +1271,7 @@
      * coordinates), if one exists.
      *
      * @param p the point to look at
-     *
      * @return an accessible object at that point, or null
-     *
      * @throws NullPointerException if p is null
      */
     public Accessible getAccessibleAt(Point p)
@@ -1340,7 +1286,6 @@
      * when children are added or removed from the enclosing accessible object.
      *
      * @author Eric Blake <ebb9@email.byu.edu>
-     *
      * @since 1.3
      */
     protected class AccessibleContainerHandler implements ContainerListener
@@ -1379,6 +1324,7 @@
   } // class AccessibleAWTPanel
 } // class Container
 
+
 /**
  * Undocumented helper class.
  * STUBBED
@@ -1393,50 +1339,39 @@
   private transient boolean isMouseInNativeContainer;
   private Cursor nativeCursor;
   private long eventMask;
-  
   LightweightDispatcher(Container c)
   {
   }
-
   void dispose()
   {
   }
-
   void enableEvents(long l)
   {
   }
-
   boolean dispatchEvent(AWTEvent e)
   {
     return true;
   }
-
   boolean isMouseGrab(MouseEvent e)
   {
     return true;
   }
-
   boolean processMouseEvent(MouseEvent e)
   {
     return true;
   }
-
   void trackMouseEnterExit(Component c, MouseEvent e)
   {
   }
-
   void startListeningForOtherDrags()
   {
   }
-
   void stopListeningForOtherDrags()
   {
   }
-
   public void eventDispatched(AWTEvent e)
   {
   }
-
   void retargetMouseEvent(Component c, int i, MouseEvent e)
   {
   }
