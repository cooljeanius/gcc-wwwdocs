--- /home/tromey/gnu/classpath/classpath/java/awt/Container.java	Thu May  9 19:18:48 2002
+++ java/awt/Container.java	Thu Jan 24 22:26:03 2002
@@ -1,5 +1,4 @@
-/* Container.java -- parent container class in AWT
-   Copyright (C) 1999, 2000, 2002 Free Software Foundation
+/* Copyright (C) 1999, 2000, 2002  Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -37,54 +36,28 @@
 
 package java.awt;
 
-import java.awt.event.AWTEventListener;
-import java.awt.event.ContainerEvent;
-import java.awt.event.ContainerListener;
-import java.awt.event.MouseEvent;
-import java.awt.peer.ComponentPeer;
-import java.awt.peer.ContainerPeer;
-import java.awt.peer.LightweightPeer;
-import java.beans.PropertyChangeListener;
+import java.awt.event.*;
 import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.io.Serializable;
 import java.util.EventListener;
-import java.util.Set;
-import javax.accessibility.Accessible;
+import java.awt.peer.ComponentPeer;
+import java.awt.peer.ContainerPeer;
+import java.awt.peer.LightweightPeer;
+
+/* A somewhat incomplete class. */
 
-/**
- * A generic window toolkit object that acts as a container for other objects.
- * Components are tracked in a list, and new elements are at the end of the
- * list or bottom of the stacking order.
- *
- * @author original author unknown
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.0
- * @status still missing 1.4 support
- */
 public class Container extends Component
 {
-  /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = 4613797578919906343L;
-
   /* Serialized fields from the serialization spec. */
   int ncomponents;
   Component[] component;
   LayoutManager layoutMgr;
-
-  LightweightDispatcher dispatcher;
-
+  /* LightweightDispatcher dispatcher; */ // wtf?
   Dimension maxSize;
-
-  /** @since 1.4 */
-  boolean focusCycleRoot;
-
   int containerSerializedDataVersion;
 
   /* Anything else is non-serializable, and should be declared "transient". */
-  transient ContainerListener containerListener;
+  transient ContainerListener containerListener;  
 
   /**
    * Default constructor for subclasses.
@@ -107,21 +80,26 @@
    * Returns the number of components in this container.
    *
    * @return The number of components in this container.
-   * @deprecated use {@link #getComponentCount()} instead
+   *
+   * @deprecated This method is deprecated in favor of 
+   * <code>getComponentCount()</code>.
    */
   public int countComponents()
   {
-    return getComponentCount();
+    return ncomponents;
   }
 
   /**
    * Returns the component at the specified index.
    *
    * @param index The index of the component to retrieve.
+   *
    * @return The requested component.
-   * @throws ArrayIndexOutOfBoundsException If the specified index is invalid
+   *
+   * @exception ArrayIndexOutOfBoundsException If the specified index is not
+   * valid.
    */
-  public Component getComponent(int n)
+  public Component getComponent (int n)
   {
     if (n < 0 || n >= ncomponents)
       throw new ArrayIndexOutOfBoundsException("no such component");
@@ -159,7 +137,9 @@
    * borders, the margin, etc.
    *
    * @return The insets for this container.
-   * @deprecated use {@link #getInsets()} instead
+   *
+   * @deprecated This method is deprecated in favor of
+   * <code>getInsets()</code>.
    */
   public Insets insets()
   {
@@ -171,11 +151,12 @@
    * component list.
    *
    * @param component The component to add to the container.
+   *
    * @return The same component that was added.
    */
-  public Component add(Component comp)
+  public Component add (Component comp)
   {
-    addImpl(comp, null, -1);
+    addImpl (comp, null, -1);
     return comp;
   }
 
@@ -189,9 +170,9 @@
    *
    * @return The same component that was added.
    */
-  public Component add(String name, Component comp)
+  public Component add (String name, Component comp)
   {
-    addImpl(comp, name, -1);
+    addImpl (comp, name, -1);
     return comp;
   }
 
@@ -207,9 +188,9 @@
    *
    * @param throws ArrayIndexOutOfBounds If the specified index is invalid.
    */
-  public Component add(Component comp, int index)
+  public Component add (Component comp, int index)
   {
-    addImpl(comp, null, index);
+    addImpl (comp, null, index);
     return comp;
   }
 
@@ -221,9 +202,9 @@
    * @param component The component to be added to this container.
    * @param constraints The layout constraints for this component.
    */
-  public void add(Component comp, Object constraints)
+  public void add (Component comp, Object constraints)
   {
-    addImpl(comp, constraints, -1);
+    addImpl (comp, constraints, -1);
   }
 
   /**
@@ -238,9 +219,9 @@
    *
    * @param throws ArrayIndexOutOfBounds If the specified index is invalid.
    */
-  public void add(Component comp, Object constraints, int index)
+  public void add (Component comp, Object constraints, int index)
   {
-    addImpl(comp, constraints, index);
+    addImpl (comp, constraints, index);
   }
 
   /**
@@ -258,29 +239,29 @@
    *
    * @param throws ArrayIndexOutOfBounds If the specified index is invalid.
    */
-  protected void addImpl(Component comp, Object constraints, int index)
+  protected void addImpl (Component comp, Object constraints, int index)
   {
     if (index > ncomponents
-        || (index < 0 && index != -1)
-        || comp instanceof Window
-        || (comp instanceof Container
-            && ((Container) comp).isAncestorOf(this)))
-      throw new IllegalArgumentException();
+	|| (index < 0 && index != -1)
+	|| comp instanceof Window
+	|| (comp instanceof Container
+	    && ((Container) comp).isAncestorOf (this)))
+      throw new IllegalArgumentException ();
 
     // Reparent component, and make sure component is instantiated if
     // we are.
     if (comp.parent != null)
-      comp.parent.remove(comp);
+      comp.parent.remove (comp);
     comp.parent = this;
     if (peer != null)
       {
-        comp.addNotify();
+	comp.addNotify ();
 
-        if (comp.isLightweight())
-          enableEvents(comp.eventMask);
+	if (comp.isLightweight())
+	  enableEvents(comp.eventMask);
       }
 
-    invalidate();
+    invalidate ();
 
     if (component == null)
       component = new Component[4]; // FIXME, better initial size?
@@ -289,39 +270,39 @@
     // copying when growing the array.  It probably doesn't matter.
     if (ncomponents >= component.length)
       {
-        int nl = component.length * 2;
-        Component[] c = new Component[nl];
-        System.arraycopy(component, 0, c, 0, ncomponents);
-        component = c;
+	int nl = component.length * 2;
+	Component[] c = new Component[nl];
+	System.arraycopy (component, 0, c, 0, ncomponents);
+	component = c;
       }
     if (index == -1)
       component[ncomponents++] = comp;
     else
       {
-        System.arraycopy(component, index, component, index + 1,
-                          ncomponents - index);
-        component[index] = comp;
-        ++ncomponents;
+	System.arraycopy (component, index, component, index + 1,
+			  ncomponents - index);
+	component[index] = comp;
+	++ncomponents;
       }
 
     // Notify the layout manager.
     if (layoutMgr != null)
       {
-        if (layoutMgr instanceof LayoutManager2)
-          {
-            LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
-            lm2.addLayoutComponent(comp, constraints);
-          }
-        else if (constraints instanceof String)
-          layoutMgr.addLayoutComponent((String) constraints, comp);
-        else
-          layoutMgr.addLayoutComponent(null, comp);
+	if (layoutMgr instanceof LayoutManager2)
+	  {
+	    LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
+	    lm2.addLayoutComponent (comp, constraints);
+	  }
+	else if (constraints instanceof String)
+	  layoutMgr.addLayoutComponent ((String) constraints, comp);
+	else
+	  layoutMgr.addLayoutComponent (null, comp);
       }
 
     // Post event to notify of adding the container.
-    ContainerEvent ce = new ContainerEvent(this,
-                                            ContainerEvent.COMPONENT_ADDED,
-                                            comp);
+    ContainerEvent ce = new ContainerEvent (this,
+					    ContainerEvent.COMPONENT_ADDED,
+					    comp);
     getToolkit().getSystemEventQueue().postEvent(ce);
   }
 
@@ -330,25 +311,25 @@
    *
    * @param index The index of the component to remove.
    */
-  public void remove(int index)
+  public void remove (int index)
   {
     Component r = component[index];
 
-    r.removeNotify();
+    r.removeNotify ();
 
-    System.arraycopy(component, index + 1, component, index,
-                      ncomponents - index - 1);
+    System.arraycopy (component, index + 1, component, index,
+		      ncomponents - index - 1);
     component[--ncomponents] = null;
 
-    invalidate();
+    invalidate ();
 
     if (layoutMgr != null)
-      layoutMgr.removeLayoutComponent(r);
+      layoutMgr.removeLayoutComponent (r);
 
     // Post event to notify of adding the container.
-    ContainerEvent ce = new ContainerEvent(this,
-                                            ContainerEvent.COMPONENT_REMOVED,
-                                            r);
+    ContainerEvent ce = new ContainerEvent (this,
+					    ContainerEvent.COMPONENT_REMOVED,
+					    r);
     getToolkit().getSystemEventQueue().postEvent(ce);
   }
 
@@ -357,15 +338,15 @@
    *
    * @return component The component to remove from this container.
    */
-  public void remove(Component comp)
+  public void remove (Component comp)
   {
     for (int i = 0; i < ncomponents; ++i)
       {
-        if (component[i] == comp)
-          {
-            remove(i);
-            break;
-          }
+	if (component[i] == comp)
+	  {
+	    remove (i);
+	    break;
+	  }
       }
   }
 
@@ -375,7 +356,7 @@
   public void removeAll()
   {
     while (ncomponents > 0)
-      remove(0);
+      remove (0);
   }
 
   /**
@@ -397,7 +378,7 @@
   public void setLayout(LayoutManager mgr)
   {
     layoutMgr = mgr;
-    invalidate();
+    invalidate ();
   }
 
   /**
@@ -406,13 +387,14 @@
   public void doLayout()
   {
     if (layoutMgr != null)
-      layoutMgr.layoutContainer(this);
+      layoutMgr.layoutContainer (this);
   }
 
   /**
    * Layout the components in this container.
    *
-   * @deprecated use {@link #doLayout()} instead
+   * @deprecated This method is deprecated in favor of
+   * <code>doLayout()</code>.
    */
   public void layout()
   {
@@ -425,7 +407,7 @@
    */
   public void invalidate()
   {
-    super.invalidate();
+    super.invalidate ();
   }
 
   /**
@@ -436,10 +418,10 @@
     // FIXME: use the tree lock?
     synchronized (this)
       {
-        if (! isValid())
-          {
-            validateTree();
-          }
+	if (! isValid ())
+	  {
+	    validateTree ();
+	  }
       }
   }
 
@@ -450,30 +432,30 @@
   protected void validateTree()
   {
     if (valid)
-      return;
+      return; 
 
     ContainerPeer cPeer = null;
-    if (peer != null && ! (peer instanceof LightweightPeer))
+    if ((peer != null) && !(peer instanceof LightweightPeer))
       {
-        cPeer = (ContainerPeer) peer;
-        cPeer.beginValidate();
+	cPeer = (ContainerPeer) peer;
+	cPeer.beginValidate();
       }
 
-    doLayout();
+    doLayout ();
     for (int i = 0; i < ncomponents; ++i)
       {
-        Component comp = component[i];
-        if (! comp.isValid())
-          {
-            if (comp instanceof Container)
-              {
-                ((Container) comp).validateTree();
-              }
-            else
-              {
-                component[i].validate();
-              }
-          }
+	Component comp = component[i];
+	if (! comp.isValid ())
+	  {
+	    if (comp instanceof Container)
+	      {
+		((Container) comp).validateTree();
+	      }
+	    else
+	      {
+		component[i].validate();
+	      }
+	  }
       }
 
     /* children will call invalidate() when they are layed out. It
@@ -499,16 +481,18 @@
   public Dimension getPreferredSize()
   {
     if (layoutMgr != null)
-      return layoutMgr.preferredLayoutSize(this);
+      return layoutMgr.preferredLayoutSize (this);
     else
-      return super.getPreferredSize();
+      return super.getPreferredSize ();
   }
 
   /**
    * Returns the preferred size of this container.
    *
    * @return The preferred size of this container.
-   * @deprecated use {@link #getPreferredSize()} instead
+   * 
+   * @deprecated This method is deprecated in favor of 
+   * <code>getPreferredSize()</code>.
    */
   public Dimension preferredSize()
   {
@@ -523,16 +507,18 @@
   public Dimension getMinimumSize()
   {
     if (layoutMgr != null)
-      return layoutMgr.minimumLayoutSize(this);
+      return layoutMgr.minimumLayoutSize (this);
     else
-      return super.getMinimumSize();
+      return super.getMinimumSize ();
   }
 
   /**
    * Returns the minimum size of this container.
    *
    * @return The minimum size of this container.
-   * @deprecated use {@link #getMinimumSize()} instead
+   * 
+   * @deprecated This method is deprecated in favor of 
+   * <code>getMinimumSize()</code>.
    */
   public Dimension minimumSize()
   {
@@ -548,11 +534,11 @@
   {
     if (layoutMgr != null && layoutMgr instanceof LayoutManager2)
       {
-        LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
-        return lm2.maximumLayoutSize(this);
+	LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
+	return lm2.maximumLayoutSize (this);
       }
     else
-      return super.getMaximumSize();
+      return super.getMaximumSize ();
   }
 
   /**
@@ -566,8 +552,8 @@
   {
     if (layoutMgr instanceof LayoutManager2)
       {
-        LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
-        return lm2.getLayoutAlignmentX(this);
+	LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
+	return lm2.getLayoutAlignmentX (this);
       }
     else
       return super.getAlignmentX();
@@ -584,8 +570,8 @@
   {
     if (layoutMgr instanceof LayoutManager2)
       {
-        LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
-        return lm2.getLayoutAlignmentY(this);
+	LayoutManager2 lm2 = (LayoutManager2) layoutMgr;
+	return lm2.getLayoutAlignmentY (this);
       }
     else
       return super.getAlignmentY();
@@ -608,6 +594,64 @@
     visitChildren(g, GfxPaintVisitor.INSTANCE, true);
   }
 
+  /** 
+   * Perform a graphics operation on the children of this container.
+   * For each applicable child, the visitChild() method will be called
+   * to perform the graphics operation.
+   *
+   * @param gfx The graphics object that will be used to derive new
+   * graphics objects for the children.
+   *
+   * @param visitor Object encapsulating the graphics operation that
+   * should be performed.
+   *
+   * @param lightweightOnly If true, only lightweight components will
+   * be visited.
+   */
+  private void visitChildren(Graphics gfx, GfxVisitor visitor,
+			     boolean lightweightOnly)
+  {
+    // FIXME: do locking
+
+    for (int i = 0; i < ncomponents; ++i)
+      {
+	Component comp = component[i];
+	boolean applicable = comp.isVisible()
+	  && (comp.isLightweight() || !lightweightOnly);
+
+	if (applicable)
+	  visitChild(gfx, visitor, comp);
+      }
+  }
+
+  /**
+   * Perform a graphics operation on a child. A translated and clipped
+   * graphics object will be created, and the visit() method of the
+   * visitor will be called to perform the operation.
+   *
+   * @param gfx The graphics object that will be used to derive new
+   * graphics objects for the child.
+   *
+   * @param visitor Object encapsulating the graphics operation that
+   * should be performed.
+   *
+   * @param comp The child component that should be visited.
+   */
+  private void visitChild(Graphics gfx, GfxVisitor visitor,
+			  Component comp)
+  {
+    Rectangle bounds = comp.getBounds();
+    Rectangle clip = gfx.getClipBounds().intersection(bounds);
+    
+    if (clip.isEmpty()) return;
+
+    Graphics gfx2 = gfx.create();
+    gfx2.setClip(clip.x, clip.y, clip.width, clip.height);
+    gfx2.translate(bounds.x, bounds.y);
+    
+    visitor.visit(comp, gfx2);
+  }
+
   /**
    * Updates this container.  The implementation of this method in this
    * class forwards to any lightweight components in this container.  If
@@ -659,6 +703,17 @@
     visitChildren(g, GfxPrintAllVisitor.INSTANCE, true);
   }
 
+  void dispatchEventImpl(AWTEvent e)
+  {
+    if ((e.id <= ContainerEvent.CONTAINER_LAST
+             && e.id >= ContainerEvent.CONTAINER_FIRST)
+	&& (containerListener != null
+	    || (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0))
+      processEvent(e); 
+    else
+      super.dispatchEventImpl(e);
+  }  
+
   /**
    * Adds the specified container listener to this object's list of
    * container listeners.
@@ -667,7 +722,7 @@
    */
   public synchronized void addContainerListener(ContainerListener l)
   {
-    containerListener = AWTEventMulticaster.add(containerListener, l);
+    containerListener = AWTEventMulticaster.add (containerListener, l);
   }
 
   /**
@@ -681,24 +736,12 @@
     containerListener = AWTEventMulticaster.remove(containerListener, l);
   }
 
-  /**
-   * @since 1.4
-   */
-  public synchronized ContainerListener[] getContainerListeners()
-  {
-    return (ContainerListener[])
-      AWTEventMulticaster.getListeners(containerListener,
-                                       ContainerListener.class);
-  }
-
-  /**
-   * @since 1.3
-   */
+  /** @since 1.3 */
   public EventListener[] getListeners(Class listenerType)
   {
     if (listenerType == ContainerListener.class)
-      return getContainerListeners();
-    return super.getListeners(listenerType);
+      return getListenersImpl(listenerType, containerListener);
+    else return super.getListeners(listenerType);
   }
 
   /**
@@ -729,12 +772,12 @@
     switch (e.id)
       {
       case ContainerEvent.COMPONENT_ADDED:
-        containerListener.componentAdded(e);
-        break;
+	containerListener.componentAdded(e);
+	break;
 
       case ContainerEvent.COMPONENT_REMOVED:
-        containerListener.componentRemoved(e);
-        break;
+	containerListener.componentRemoved(e);
+	break;    
       }
   }
 
@@ -742,7 +785,9 @@
    * AWT 1.0 event processor.
    *
    * @param event The event that occurred.
-   * @deprecated use {@link #dispatchEvent(AWTEvent)} instead
+   *
+   * @deprecated This method is deprecated in favor of 
+   * <code>dispatchEvent()</code>.
    */
   public void deliverEvent(Event e)
   {
@@ -762,20 +807,20 @@
    * @return The component containing the specified point, or
    * <code>null</code> if there is no such point.
    */
-  public Component getComponentAt(int x, int y)
+  public Component getComponentAt (int x, int y)
   {
-    if (! contains(x, y))
+    if (! contains (x, y))
       return null;
     for (int i = 0; i < ncomponents; ++i)
       {
-        // Ignore invisible children...
-        if (!component[i].isVisible())
-          continue;
-
-        int x2 = x - component[i].x;
-        int y2 = y - component[i].y;
-        if (component[i].contains(x2, y2))
-          return component[i];
+	// Ignore invisible children...
+	if (!component[i].isVisible())
+	  continue;
+
+	int x2 = x - component[i].x;
+	int y2 = y - component[i].y;
+	if (component[i].contains (x2, y2))
+	  return component[i];
       }
     return this;
   }
@@ -792,7 +837,9 @@
    *
    * @return The component containing the specified point, or <code>null</code>
    * if there is no such point.
-   * @deprecated use {@link #getComponentAt(int, int)} instead
+   *
+   * @deprecated This method is deprecated in favor of
+   * <code>getComponentAt(int, int)</code>.
    */
   public Component locate(int x, int y)
   {
@@ -808,6 +855,7 @@
    * case <code>null</code> is returned.
    *
    * @param point The point to return the component at.
+   *
    * @return The component containing the specified point, or <code>null</code>
    * if there is no such point.
    */
@@ -816,30 +864,30 @@
     return getComponentAt(p.x, p.y);
   }
 
-  public Component findComponentAt(int x, int y)
+  public Component findComponentAt (int x, int y)
   {
-    if (! contains(x, y))
+    if (! contains (x, y))
       return null;
 
     for (int i = 0; i < ncomponents; ++i)
       {
-        // Ignore invisible children...
-        if (!component[i].isVisible())
-          continue;
-
-        int x2 = x - component[i].x;
-        int y2 = y - component[i].y;
-        // We don't do the contains() check right away because
-        // findComponentAt would redundantly do it first thing.
-        if (component[i] instanceof Container)
-          {
-            Container k = (Container) component[i];
-            Component r = k.findComponentAt(x2, y2);
-            if (r != null)
-              return r;
-          }
-        else if (component[i].contains(x2, y2))
-          return component[i];
+	// Ignore invisible children...
+	if (!component[i].isVisible())
+	  continue;
+
+	int x2 = x - component[i].x;
+	int y2 = y - component[i].y;
+	// We don't do the contains() check right away because
+	// findComponentAt would redundantly do it first thing.
+	if (component[i] instanceof Container)
+	  {
+	    Container k = (Container) component[i];
+	    Component r = k.findComponentAt (x2, y2);
+	    if (r != null)
+	      return r;
+	  }
+	else if (component[i].contains (x2, y2))
+	  return component[i];
       }
 
     return this;
@@ -855,12 +903,22 @@
    * to create its peer.  Peers for any child components will also be
    * created.
    */
-  public void addNotify()
+  public void addNotify ()
   {
-    addNotifyContainerChildren();
+    addNotifyContainerChildren ();
     super.addNotify();
   }
 
+  private void addNotifyContainerChildren()
+  {
+    for (int i = ncomponents;  --i >= 0; )
+      {
+	component[i].addNotify();
+	if (component[i].isLightweight())
+	  enableEvents(component[i].eventMask);
+      }
+  }
+
   /**
    * Called when this container is removed from its parent container to
    * inform it to destroy its peer.  This causes the peers of all child
@@ -869,7 +927,7 @@
   public void removeNotify()
   {
     for (int i = 0; i < ncomponents; ++i)
-      component[i].removeNotify();
+      component[i].removeNotify ();
     super.removeNotify();
   }
 
@@ -882,15 +940,15 @@
    * @return <code>true</code> if this container is an ancestor of the
    * specified component, <code>false</code>.
    */
-  public boolean isAncestorOf(Component comp)
+  public boolean isAncestorOf (Component comp)
   {
-    while (true)
+    for (;;)
       {
-        if (comp == null)
-          return false;
-        if (comp == this)
-          return true;
-        comp = comp.getParent();
+	if (comp == null)
+	  return false;
+	if (comp == this)
+	  return true;
+	comp = comp.getParent();
       }
   }
 
@@ -916,11 +974,11 @@
    * @param stream The <code>PrintStream</code> to write to.
    * @param indent The indentation point.
    */
-  public void list(PrintStream out, int indent)
+  public void list (PrintStream out, int indent)
   {
-    super.list(out, indent);
+    super.list (out, indent);
     for (int i = 0; i < ncomponents; ++i)
-      component[i].list(out, indent + 2);
+      component[i].list (out, indent + 2);
   }
 
   /**
@@ -932,193 +990,11 @@
    */
   public void list(PrintWriter out, int indent)
   {
-    super.list(out, indent);
-    for (int i = 0; i < ncomponents; ++i)
-      component[i].list(out, indent + 2);
-  }
-
-  public void setFocusTraversalKeys(int id, Set keys)
-  {
-  }
-  public Set getFocusTraversalKeys(int id)
-  {
-    return null;
-  }
-  public boolean areFocusTraversalKeysSet(int id)
-  {
-    return false;
-  }
-  public boolean isFocusCycleRoot(Container c)
-  {
-    return false;
-  }
-  public void transferFocusBackward()
-  {
-  }
-  public void setFocusTraversalPolicy(FocusTraversalPolicy policy)
-  {
-  }
-  public FocusTraversalPolicy getFocusTraversalPolicy()
-  {
-    return null;
-  }
-  public boolean isFocusTraversalPolicySet()
-  {
-    return false;
-  }
-  public void setFocusCycleRoot(boolean focusCycleRoot)
-  {
-  }
-  public boolean isFocusCycleRoot()
-  {
-    return false;
-  }
-  public void transferFocusDownCycle()
-  {
-  }
-  public void applyComponentOrientation(ComponentOrientation o)
-  {
-  }
-  public void addPropertyChangeListener(PropertyChangeListener l)
-  {
-  }
-  public void addPropertyChangeListener(String name, PropertyChangeListener l)
-  {
-  }
-
-
-  // Hidden helper methods.
-
-  /**
-   * Perform a graphics operation on the children of this container.
-   * For each applicable child, the visitChild() method will be called
-   * to perform the graphics operation.
-   *
-   * @param gfx The graphics object that will be used to derive new
-   * graphics objects for the children.
-   *
-   * @param visitor Object encapsulating the graphics operation that
-   * should be performed.
-   *
-   * @param lightweightOnly If true, only lightweight components will
-   * be visited.
-   */
-  private void visitChildren(Graphics gfx, GfxVisitor visitor,
-                             boolean lightweightOnly)
-  {
-    // FIXME: do locking
-
+    super.list (out, indent);
     for (int i = 0; i < ncomponents; ++i)
-      {
-        Component comp = component[i];
-        boolean applicable = comp.isVisible()
-          && (comp.isLightweight() || !lightweightOnly);
-
-        if (applicable)
-          visitChild(gfx, visitor, comp);
-      }
-  }
-
-  /**
-   * Perform a graphics operation on a child. A translated and clipped
-   * graphics object will be created, and the visit() method of the
-   * visitor will be called to perform the operation.
-   *
-   * @param gfx The graphics object that will be used to derive new
-   * graphics objects for the child.
-   *
-   * @param visitor Object encapsulating the graphics operation that
-   * should be performed.
-   *
-   * @param comp The child component that should be visited.
-   */
-  private void visitChild(Graphics gfx, GfxVisitor visitor,
-                          Component comp)
-  {
-    Rectangle bounds = comp.getBounds();
-    Rectangle clip = gfx.getClipBounds().intersection(bounds);
-
-    if (clip.isEmpty()) return;
-
-    Graphics gfx2 = gfx.create();
-    gfx2.setClip(clip.x, clip.y, clip.width, clip.height);
-    gfx2.translate(bounds.x, bounds.y);
-
-    visitor.visit(comp, gfx2);
-  }
-
-  void dispatchEventImpl(AWTEvent e)
-  {
-    if ((e.id <= ContainerEvent.CONTAINER_LAST
-             && e.id >= ContainerEvent.CONTAINER_FIRST)
-        && (containerListener != null
-            || (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0))
-      processEvent(e);
-    else
-      super.dispatchEventImpl(e);
+      component[i].list (out, indent + 2);
   }
 
-  // This is used to implement Component.transferFocus.
-  Component findNextFocusComponent(Component child)
-  {
-    int start, end;
-    if (child != null)
-      {
-        for (start = 0; start < ncomponents; ++start)
-          {
-            if (component[start] == child)
-              break;
-          }
-        end = start;
-        // This special case lets us be sure to terminate.
-        if (end == 0)
-          end = ncomponents;
-        ++start;
-      }
-    else
-      {
-        start = 0;
-        end = ncomponents;
-      }
-
-    for (int j = start; j != end; ++j)
-      {
-        if (j >= ncomponents)
-          {
-            // The JCL says that we should wrap here.  However, that
-            // seems wrong.  To me it seems that focus order should be
-            // global within in given window.  So instead if we reach
-            // the end we try to look in our parent, if we have one.
-            if (parent != null)
-              return parent.findNextFocusComponent(this);
-            j -= ncomponents;
-          }
-        if (component[j] instanceof Container)
-          {
-            Component c = component[j];
-            c = c.findNextFocusComponent(null);
-            if (c != null)
-              return c;
-          }
-        else if (component[j].isFocusTraversable())
-          return component[j];
-      }
-
-    return null;
-  }
-
-  private void addNotifyContainerChildren()
-  {
-    for (int i = ncomponents;  --i >= 0; )
-      {
-        component[i].addNotify();
-        if (component[i].isLightweight())
-          enableEvents(component[i].eventMask);
-      }
-  }
-
-
-  // Nested classes.
 
   /* The following classes are used in concert with the
      visitChildren() method to implement all the graphics operations
@@ -1153,177 +1029,52 @@
     public static final GfxVisitor INSTANCE = new GfxPrintAllVisitor();
   }
 
-  /**
-   * This class provides accessibility support for subclasses of container.
-   *
-   * @author Eric Blake <ebb9@email.byu.edu>
-   * @since 1.3
-   */
-  protected class AccessibleAWTContainer extends AccessibleAWTComponent
+  // This is used to implement Component.transferFocus.
+  Component findNextFocusComponent (Component child)
   {
-    /**
-     * Compatible with JDK 1.4+.
-     */
-    private static final long serialVersionUID = 5081320404842566097L;
-
-    /**
-     * The handler to fire PropertyChange when children are added or removed.
-     *
-     * @serial the handler for property changes
-     */
-    protected ContainerListener accessibleContainerHandler
-      = new AccessibleContainerHandler();
-
-    /**
-     * The default constructor.
-     */
-    protected AccessibleAWTContainer()
-    {
-      Container.this.addContainerListener(accessibleContainerHandler);
-    }
-
-    /**
-     * Return the number of accessible children of the containing accessible
-     * object (at most the total number of its children).
-     *
-     * @return the number of accessible children
-     */
-    public int getAccessibleChildrenCount()
-    {
-      int count = 0;
-      int i = component == null ? 0 : component.length;
-      while (--i >= 0)
-        if (component[i] instanceof Accessible)
-          count++;
-      return count;
-    }
-
-    /**
-     * Return the nth accessible child of the containing accessible object.
-     *
-     * @param i the child to grab, zero-based
-     * @return the accessible child, or null
-     */
-    public Accessible getAccessibleChild(int i)
-    {
-      if (component == null)
-        return null;
-      int index = -1;
-      while (i >= 0 && ++index < component.length)
-        if (component[index] instanceof Accessible)
-          i--;
-      if (i < 0)
-        return (Accessible) component[index];
-      return null;
-    }
-
-    /**
-     * Return the accessible child located at point (in the parent's
-     * coordinates), if one exists.
-     *
-     * @param p the point to look at
-     * @return an accessible object at that point, or null
-     * @throws NullPointerException if p is null
-     */
-    public Accessible getAccessibleAt(Point p)
-    {
-      Component c = getComponentAt(p.x, p.y);
-      return c != Container.this && c instanceof Accessible ? (Accessible) c
-        : null;
-    }
-
-    /**
-     * This class fires a <code>PropertyChange</code> listener, if registered,
-     * when children are added or removed from the enclosing accessible object.
-     *
-     * @author Eric Blake <ebb9@email.byu.edu>
-     * @since 1.3
-     */
-    protected class AccessibleContainerHandler implements ContainerListener
-    {
-      /**
-       * Default constructor.
-       */
-      protected AccessibleContainerHandler()
+    int start, end;
+    if (child != null)
       {
+	for (start = 0; start < ncomponents; ++start)
+	  {
+	    if (component[start] == child)
+	      break;
+	  }
+	end = start;
+	// This special case lets us be sure to terminate.
+	if (end == 0)
+	  end = ncomponents;
+	++start;
       }
-
-      /**
-       * Fired when a component is added; forwards to the PropertyChange
-       * listener.
-       *
-       * @param e the container event for adding
-       */
-      public void componentAdded(ContainerEvent e)
+    else
       {
-        AccessibleAWTContainer.this.firePropertyChange
-          (ACCESSIBLE_CHILD_PROPERTY, null, e.getChild());
+	start = 0;
+	end = ncomponents;
       }
 
-      /**
-       * Fired when a component is removed; forwards to the PropertyChange
-       * listener.
-       *
-       * @param e the container event for removing
-       */
-      public void componentRemoved(ContainerEvent e)
+    for (int j = start; j != end; ++j)
       {
-        AccessibleAWTContainer.this.firePropertyChange
-          (ACCESSIBLE_CHILD_PROPERTY, e.getChild(), null);
+	if (j >= ncomponents)
+	  {
+	    // The JCL says that we should wrap here.  However, that
+	    // seems wrong.  To me it seems that focus order should be
+	    // global within in given window.  So instead if we reach
+	    // the end we try to look in our parent, if we have one.
+	    if (parent != null)
+	      return parent.findNextFocusComponent (this);
+	    j -= ncomponents;
+	  }
+	if (component[j] instanceof Container)
+	  {
+	    Component c = component[j];
+	    c = c.findNextFocusComponent (null);
+	    if (c != null)
+	      return c;
+	  }
+	else if (component[j].isFocusTraversable ())
+	  return component[j];
       }
-    } // class AccessibleContainerHandler
-  } // class AccessibleAWTPanel
-} // class Container
-
-
-/**
- * Undocumented helper class.
- * STUBBED
- */
-class LightweightDispatcher implements Serializable, AWTEventListener
-{
-  private static final long serialVersionUID = 5184291520170872969L;
-  private Container nativeContainer;
-  private Component focus;
-  private transient Component mouseEventTarget;
-  private transient Component targetLastEntered;
-  private transient boolean isMouseInNativeContainer;
-  private Cursor nativeCursor;
-  private long eventMask;
-  LightweightDispatcher(Container c)
-  {
-  }
-  void dispose()
-  {
-  }
-  void enableEvents(long l)
-  {
-  }
-  boolean dispatchEvent(AWTEvent e)
-  {
-    return true;
-  }
-  boolean isMouseGrab(MouseEvent e)
-  {
-    return true;
-  }
-  boolean processMouseEvent(MouseEvent e)
-  {
-    return true;
-  }
-  void trackMouseEnterExit(Component c, MouseEvent e)
-  {
-  }
-  void startListeningForOtherDrags()
-  {
-  }
-  void stopListeningForOtherDrags()
-  {
-  }
-  public void eventDispatched(AWTEvent e)
-  {
-  }
-  void retargetMouseEvent(Component c, int i, MouseEvent e)
-  {
+
+    return null;
   }
-} // class LightweightDispatcher
+}
