--- /home/tromey/gnu/classpath/classpath/java/io/ObjectOutputStream.java	Mon Mar 25 00:05:17 2002
+++ java/io/ObjectOutputStream.java	Tue Jan 22 16:01:33 2002
@@ -46,7 +46,6 @@
 
 import gnu.java.io.ObjectIdentityWrapper;
 import gnu.java.lang.reflect.TypeSignature;
-import gnu.classpath.Configuration;
 
 /**
    An <code>ObjectOutputStream</code> can be used to write objects
@@ -168,247 +167,229 @@
   public final void writeObject (Object obj) throws IOException
   {
     if (useSubclassMethod)
-      {
-	writeObjectOverride (obj);
-	return;
-      }
-    
+    {
+      writeObjectOverride (obj);
+      return;
+    }
+
     boolean was_serializing = isSerializing;
-    
-    boolean old_mode = setBlockDataMode (false);
-    
+
+    if (! was_serializing)
+      setBlockDataMode (false);
+
     try
+    {
+      isSerializing = true;
+      boolean replaceDone = false;
+
+      drain ();
+
+      while (true)
       {
-	isSerializing = true;
-	boolean replaceDone = false;
-	
-	Object replacedObject = null;
-	
-	while (true)
+	if (obj == null)
+	{
+	  realOutput.writeByte (TC_NULL);
+	  break;
+	}
+
+	Integer handle = findHandle (obj);
+	if (handle != null)
+	{
+	  realOutput.writeByte (TC_REFERENCE);
+	  realOutput.writeInt (handle.intValue ());
+	  break;
+	}
+
+	if (obj instanceof Class)
+	{
+	  realOutput.writeByte (TC_CLASS);
+	  writeObject (ObjectStreamClass.lookup ((Class)obj));
+	  assignNewHandle (obj);
+	  break;
+	}
+
+	if (obj instanceof ObjectStreamClass)
+	{
+	  ObjectStreamClass osc = (ObjectStreamClass)obj;
+	  realOutput.writeByte (TC_CLASSDESC);
+	  realOutput.writeUTF (osc.getName ());
+	  realOutput.writeLong (osc.getSerialVersionUID ());
+	  assignNewHandle (obj);
+
+	  int flags = osc.getFlags ();
+
+	  if (protocolVersion == PROTOCOL_VERSION_2
+	      && osc.isExternalizable ())
+	    flags |= SC_BLOCK_DATA;
+
+	  realOutput.writeByte (flags);
+
+	  ObjectStreamField[] fields = osc.fields;
+	  realOutput.writeShort (fields.length);
+
+	  ObjectStreamField field;
+	  for (int i=0; i < fields.length; i++)
 	  {
-	    if (obj == null)
+	    field = fields[i];
+	    realOutput.writeByte (field.getTypeCode ());
+	    realOutput.writeUTF (field.getName ());
+
+	    if (! field.isPrimitive ())
+	      writeObject (field.getTypeString ());
+	  }
+
+	  setBlockDataMode (true);
+	  annotateClass (osc.forClass ());
+	  setBlockDataMode (false);
+	  realOutput.writeByte (TC_ENDBLOCKDATA);
+
+	  if (osc.isSerializable ())
+	    writeObject (osc.getSuper ());
+	  else
+	    writeObject (null);
+	  break;
+	}
+
+
+	Object replacedObject = null;
+
+	if ((replacementEnabled || obj instanceof Serializable)
+	    && ! replaceDone)
+	{
+	  replacedObject = obj;
+
+	  if (obj instanceof Serializable)
+	    {
+	      Method m = null;
+	      try
 	      {
-		realOutput.writeByte (TC_NULL);
-		break;
+	        Class classArgs[] = {};
+		m = obj.getClass ().getDeclaredMethod ("writeReplace",
+						       classArgs);
+		// m can't be null by definition since an exception would
+		// have been thrown so a check for null is not needed.
+		obj = m.invoke (obj, new Object[] {});
 	      }
-	    
-	    Integer handle = findHandle (obj);
-	    if (handle != null)
+	      catch (NoSuchMethodException ignore)
 	      {
-		realOutput.writeByte (TC_REFERENCE);
-		realOutput.writeInt (handle.intValue ());
-		break;
 	      }
-	    
-	    if (obj instanceof Class)
+	      catch (IllegalAccessException ignore)
 	      {
-		Class cl = (Class)obj;
-		ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (cl);
-		assignNewHandle (obj);
-		realOutput.writeByte (TC_CLASS);
-		if (!osc.isProxyClass ())
-		  {
-		    writeObject (osc);
-		  }
-		else
-		  {
-		    realOutput.writeByte (TC_PROXYCLASSDESC);
-		    Class[] intfs = cl.getInterfaces();
-		    realOutput.writeInt(intfs.length);
-		    for (int i = 0; i < intfs.length; i++)
-		      realOutput.writeUTF(intfs[i].getName());
-		    
-		    boolean oldmode = setBlockDataMode (true);
-		    annotateProxyClass(cl);
-		    setBlockDataMode (oldmode);
-		    realOutput.writeByte(TC_ENDBLOCKDATA);
-		    
-		    writeObject (osc.getSuper());
-		  }
-		break;
 	      }
-
-
-	    if (obj instanceof ObjectStreamClass)
+	      catch (InvocationTargetException ignore)
 	      {
-		ObjectStreamClass osc = (ObjectStreamClass)obj;
-		realOutput.writeByte (TC_CLASSDESC);
-		realOutput.writeUTF (osc.getName ());
-		realOutput.writeLong (osc.getSerialVersionUID ());
-		assignNewHandle (obj);
-
-		int flags = osc.getFlags ();
-
-		if (protocolVersion == PROTOCOL_VERSION_2
-		    && osc.isExternalizable ())
-		  flags |= SC_BLOCK_DATA;
-
-		realOutput.writeByte (flags);
-		
-		ObjectStreamField[] fields = osc.fields;
-		realOutput.writeShort (fields.length);
-
-		ObjectStreamField field;
-		for (int i=0; i < fields.length; i++)
-		  {
-		    field = fields[i];
-		    realOutput.writeByte (field.getTypeCode ());
-		    realOutput.writeUTF (field.getName ());
-
-		    if (! field.isPrimitive ())
-		      writeObject (field.getTypeString ());
-		  }
-
-		boolean oldmode = setBlockDataMode (true);
-		annotateClass (osc.forClass ());
-		setBlockDataMode (oldmode);
-		realOutput.writeByte (TC_ENDBLOCKDATA);
-
-		if (osc.isSerializable ())
-		  writeObject (osc.getSuper ());
-		else
-		  writeObject (null);
-		break;
 	      }
+	    }
 
+	  if (replacementEnabled)
+	    obj = replaceObject (obj);
 
-	    if ((replacementEnabled || obj instanceof Serializable)
-		&& ! replaceDone)
-	      {
-		replacedObject = obj;
+	  replaceDone = true;
+	  continue;
+	}
+
+	if (obj instanceof String)
+	{
+	  realOutput.writeByte (TC_STRING);
+	  assignNewHandle (obj);
+	  realOutput.writeUTF ((String)obj);
+	  break;
+	}
+
+	Class clazz = obj.getClass ();
+	ObjectStreamClass osc = ObjectStreamClass.lookup (clazz);
+	if (osc == null)
+	  throw new NotSerializableException (clazz.getName ());
+
+	if (clazz.isArray ())
+	{
+	  realOutput.writeByte (TC_ARRAY);
+	  writeObject (osc);
+	  assignNewHandle (obj);
+	  writeArraySizeAndElements (obj, clazz.getComponentType ());
+	  break;
+	}
+
+	realOutput.writeByte (TC_OBJECT);
+	writeObject (osc);
+
+	if (replaceDone)
+	  assignNewHandle (replacedObject);
+	else
+	  assignNewHandle (obj);
+
+	if (obj instanceof Externalizable)
+	{
+	  if (protocolVersion == PROTOCOL_VERSION_2)
+	    setBlockDataMode (true);
 
-		if (obj instanceof Serializable)
-		  {
-		    Method m = null;
-		    try
-		      {
-			Class classArgs[] = {};
-			m = obj.getClass ().getDeclaredMethod ("writeReplace",
-							       classArgs);
-			// m can't be null by definition since an exception would
-			// have been thrown so a check for null is not needed.
-			obj = m.invoke (obj, new Object[] {});
-		      }
-		    catch (NoSuchMethodException ignore)
-		      {
-		      }
-		    catch (IllegalAccessException ignore)
-		      {
-		      }
-		    catch (InvocationTargetException ignore)
-		      {
-		      }
-		  }
-		
-		if (replacementEnabled)
-		  obj = replaceObject (obj);
-		
-		replaceDone = true;
-		continue;
-	      }
+	  ((Externalizable)obj).writeExternal (this);
 
-	    if (obj instanceof String)
-	      {
-		realOutput.writeByte (TC_STRING);
-		assignNewHandle (obj);
-		realOutput.writeUTF ((String)obj);
-		break;
-	      }
+	  if (protocolVersion == PROTOCOL_VERSION_2)
+	  {
+	    setBlockDataMode (false);
+	    drain ();
+	  }
 
-	    Class clazz = obj.getClass ();
-	    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (clazz);
-	    if (osc == null)
-	      throw new NotSerializableException (clazz.getName ());
+	  break;
+	}
 
-	    if (clazz.isArray ())
-	      {
-		realOutput.writeByte (TC_ARRAY);
-		writeObject (osc);
-		assignNewHandle (obj);
-		writeArraySizeAndElements (obj, clazz.getComponentType ());
-		break;
-	      }
+	if (obj instanceof Serializable)
+	{
+	  currentObject = obj;
+	  ObjectStreamClass[] hierarchy =
+	    ObjectStreamClass.getObjectStreamClasses (clazz);
 
-	    realOutput.writeByte (TC_OBJECT);
-	    writeObject (osc);
+	  boolean has_write;
+	  for (int i=0; i < hierarchy.length; i++)
+	  {
+	    currentObjectStreamClass = hierarchy[i];
 
-	    if (replaceDone)
-	      assignNewHandle (replacedObject);
-	    else
-	      assignNewHandle (obj);
+	    fieldsAlreadyWritten = false;
+	    has_write = currentObjectStreamClass.hasWriteMethod ();
 
-	    if (obj instanceof Externalizable)
-	      {
-		if (protocolVersion == PROTOCOL_VERSION_2)
-		  setBlockDataMode (true);
+	    writeFields (obj, currentObjectStreamClass.fields,
+			 has_write);
 
-		((Externalizable)obj).writeExternal (this);
+	    if (has_write)
+	    {
+	      drain ();
+	      realOutput.writeByte (TC_ENDBLOCKDATA);
+	    }
+	  }
 
-		if (protocolVersion == PROTOCOL_VERSION_2)
-		  {
-		    setBlockDataMode (false);
-		    realOutput.writeByte (TC_ENDBLOCKDATA);
-		  }
-		
-		break;
-	      }
+	  currentObject = null;
+	  currentObjectStreamClass = null;
+	  currentPutField = null;
+	  break;
+	}
 
-	    if (obj instanceof Serializable)
-	      {
-		currentObject = obj;
-		ObjectStreamClass[] hierarchy =
-		  ObjectStreamClass.getObjectStreamClasses (clazz);
-
-		boolean has_write;
-		for (int i=0; i < hierarchy.length; i++)
-		  {
-		    currentObjectStreamClass = hierarchy[i];
-
-		    fieldsAlreadyWritten = false;
-		    has_write = currentObjectStreamClass.hasWriteMethod ();
-
-		    writeFields (obj, currentObjectStreamClass.fields,
-				 has_write);
-
-// 		    if (has_write)
-// 		      {
-// 			drain ();
-// 			realOutput.writeByte (TC_ENDBLOCKDATA);
-// 		      }
-		  }
-
-		currentObject = null;
-		currentObjectStreamClass = null;
-		currentPutField = null;
-		break;
-	      }
+	throw new NotSerializableException (clazz.getName ());
+      } // end pseudo-loop
+    }
+    catch (IOException e)
+    {
+      realOutput.writeByte (TC_EXCEPTION);
+      reset (true);
 
-	    throw new NotSerializableException (clazz.getName ());
-	  } // end pseudo-loop
+      try
+      {
+	writeObject (e);
       }
-    catch (IOException e)
+      catch (IOException ioe)
       {
-	realOutput.writeByte (TC_EXCEPTION);
-	reset (true);
-
-	setBlockDataMode (false); // ??
-	try
-	  {
-	    writeObject (e);
-	  }
-	catch (IOException ioe)
-	  {
-	    throw new StreamCorruptedException ("Exception " + ioe + " thrown while exception was being written to stream.");
-	  }
+	throw new StreamCorruptedException ("Exception " + ioe + " thrown while exception was being written to stream.");
+      }
 
-	reset (true);
+      reset (true);
     }
     finally
-      {
-	isSerializing = was_serializing;
-	
-	setBlockDataMode (old_mode);
-      }
+    {
+      isSerializing = was_serializing;
+
+      if (! was_serializing)
+	setBlockDataMode (true);
+    }
   }
 
 
@@ -547,8 +528,6 @@
   protected void annotateClass (Class cl) throws IOException
   {}
 
-  protected void annotateProxyClass(Class cl) throws IOException
-  {}
 
   /**
      Allows subclasses to replace objects that are written to the
@@ -668,7 +647,7 @@
   /**
      @see java.io.DataOutputStream#write (byte[])
   */
-  public void write (byte b[]) throws IOException
+  public void write (byte[] b) throws IOException
   {
     write (b, 0, b.length);
   }
@@ -677,7 +656,7 @@
   /**
      @see java.io.DataOutputStream#write (byte[],int,int)
   */
-  public void write (byte b[], int off, int len) throws IOException
+  public void write (byte[] b, int off, int len) throws IOException
   {
     if (writeDataAsBlocks)
     {
@@ -723,8 +702,7 @@
     if (blockDataCount == 0)
       return;
 
-    if (writeDataAsBlocks) // ??
-      writeBlockDataHeader (blockDataCount);
+    writeBlockDataHeader (blockDataCount);
     realOutput.write (blockData, 0, blockDataCount);
     blockDataCount = 0;
   }
@@ -735,7 +713,7 @@
   */
   public void close () throws IOException
   {
-    flush ();
+    drain ();
     realOutput.close ();
   }
 
@@ -745,7 +723,7 @@
   */
   public void writeBoolean (boolean data) throws IOException
   {
-    blockDataOutput.writeBoolean (data);
+    dataOutput.writeBoolean (data);
   }
 
 
@@ -754,7 +732,7 @@
   */
   public void writeByte (int data) throws IOException
   {
-    blockDataOutput.writeByte (data);
+    dataOutput.writeByte (data);
   }
 
 
@@ -763,7 +741,7 @@
   */
   public void writeShort (int data) throws IOException
   {
-    blockDataOutput.writeShort (data);
+    dataOutput.writeShort (data);
   }
 
 
@@ -772,7 +750,7 @@
   */
   public void writeChar (int data) throws IOException
   {
-    blockDataOutput.writeChar (data);
+    dataOutput.writeChar (data);
   }
 
 
@@ -781,7 +759,7 @@
   */
   public void writeInt (int data) throws IOException
   {
-    blockDataOutput.writeInt (data);
+    dataOutput.writeInt (data);
   }
 
 
@@ -790,7 +768,7 @@
   */
   public void writeLong (long data) throws IOException
   {
-    blockDataOutput.writeLong (data);
+    dataOutput.writeLong (data);
   }
 
 
@@ -799,7 +777,7 @@
   */
   public void writeFloat (float data) throws IOException
   {
-    blockDataOutput.writeFloat (data);
+    dataOutput.writeFloat (data);
   }
 
 
@@ -808,7 +786,7 @@
   */
   public void writeDouble (double data) throws IOException
   {
-    blockDataOutput.writeDouble (data);
+    dataOutput.writeDouble (data);
   }
 
 
@@ -817,7 +795,7 @@
   */
   public void writeBytes (String data) throws IOException
   {
-    blockDataOutput.writeBytes (data);
+    dataOutput.writeBytes (data);
   }
 
 
@@ -987,9 +965,6 @@
 	  {
 	    ObjectStreamField field
 	      = currentObjectStreamClass.getField (name);
-	    if (field == null)
-	      throw new IllegalArgumentException ();
-	    
 	    if (value != null &&
 	    	! field.getType ().isAssignableFrom (value.getClass ()))
 	      throw new IllegalArgumentException ();
@@ -1001,11 +976,11 @@
 	    // Apparently Block data is not used with PutField as per
 	    // empirical evidence against JDK 1.2.  Also see Mauve test
 	    // java.io.ObjectInputOutput.Test.GetPutField.
-	    boolean oldmode = setBlockDataMode (false);
+	    setBlockDataMode (false);
 	    out.write (prim_field_data);
 	    for (int i = 0; i < objs.length; ++ i)
 	      out.writeObject (objs[i]);
-	    setBlockDataMode (oldmode);
+	    setBlockDataMode (true);
 	  }
 
 	private void checkType (ObjectStreamField field, char type)
@@ -1092,7 +1067,8 @@
       {
 	byte[] cast_array = (byte[])array;
 	realOutput.writeInt (length);
-	realOutput.write(cast_array, 0, length);
+	for (int i=0; i < length; i++)
+	  realOutput.writeByte (cast_array[i]);
 	return;
       }
       if (clazz == Character.TYPE)
@@ -1166,11 +1142,9 @@
       setBlockDataMode (true);
       callWriteMethod (obj);
       setBlockDataMode (false);
-      realOutput.writeByte (TC_ENDBLOCKDATA);
       return;
     }
 
-    boolean oldmode = setBlockDataMode (false); //??
     String field_name;
     Class type;
     for (int i=0; i < fields.length; i++)
@@ -1196,44 +1170,196 @@
 	realOutput.writeShort (getShortField (obj, field_name));
       else
 	writeObject (getObjectField (obj, field_name,
-				     fields[i].getTypeString ()));
+				     TypeSignature.getEncodingOfClass (type)));
     }
-    setBlockDataMode (oldmode); // ??
   }
 
 
   // Toggles writing primitive data to block-data buffer.
-  private boolean setBlockDataMode (boolean on) throws IOException
+  private void setBlockDataMode (boolean on)
   {
-    if (on == writeDataAsBlocks)
-      return on;
-    
-    drain();
-    boolean oldmode = writeDataAsBlocks;
-    
     writeDataAsBlocks = on;
 
     if (on)
       dataOutput = blockDataOutput;
     else
       dataOutput = realOutput;
+  }
+
 
-    return oldmode;
+  private void callWriteMethod (Object obj) throws IOException
+  {
+    Class klass = obj.getClass ();
+    try
+      {
+	Class classArgs[] = {ObjectOutputStream.class};
+	Method m = getMethod (klass, "writeObject", classArgs);
+	if (m == null)
+	  return;
+	Object args[] = {this};
+	m.invoke (obj, args);	
+      }
+    catch (InvocationTargetException x)
+      {
+        /* Rethrow if possible. */
+	Throwable exception = x.getTargetException();
+	if (exception instanceof RuntimeException)
+	  throw (RuntimeException) exception;
+	if (exception instanceof IOException)
+	  throw (IOException) exception;
+
+	throw new IOException ("Exception thrown from writeObject() on " +
+			       klass + ": " + exception.getClass().getName());
+      }
+    catch (Exception x)
+      {
+	throw new IOException ("Failure invoking writeObject() on " +
+			       klass + ": " + x.getClass().getName());
+      }
   }
 
+  private boolean getBooleanField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	boolean b = f.getBoolean (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
 
-  private native void callWriteMethod (Object obj);
-  private native boolean getBooleanField (Object obj, String field_name);
-  private native byte getByteField (Object obj, String field_name);
-  private native char getCharField (Object obj, String field_name);
-  private native double getDoubleField (Object obj, String field_name);
-  private native float getFloatField (Object obj, String field_name);
-  private native int getIntField (Object obj, String field_name);
-  private native long getLongField (Object obj, String field_name);
-  private native short getShortField (Object obj, String field_name);
-  private native Object getObjectField (Object obj, String field_name,
-					String type_code);
+  private byte getByteField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	byte b = f.getByte (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
 
+  private char getCharField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	char b = f.getChar (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private double getDoubleField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	double b = f.getDouble (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private float getFloatField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	float b = f.getFloat (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private int getIntField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	int b = f.getInt (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private long getLongField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	long b = f.getLong (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private short getShortField (Object obj, String field_name) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	short b = f.getShort (obj);
+	return b;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private Object getObjectField (Object obj, String field_name,
+				 String type_code) throws IOException
+  {
+    try
+      {
+	Class klass = obj.getClass ();
+	Field f = getField (klass, field_name);
+	Object o = f.get (obj);
+	// FIXME: We should check the type_code here
+	return o;
+      }
+    catch (Exception _)
+      {
+	throw new IOException ();
+      }    
+  }
+
+  private static native Field getField (Class klass, String name)
+    throws java.lang.NoSuchFieldException;
+
+  private static native Method getMethod (Class klass, String name, Class[] args)
+    throws java.lang.NoSuchMethodException;
 
   // this value comes from 1.2 spec, but is used in 1.1 as well
   private final static int BUFFER_SIZE = 1024;
@@ -1256,13 +1382,4 @@
   private Hashtable OIDLookupTable;
   private int protocolVersion;
   private boolean useSubclassMethod;
-
-  static
-  {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javaio");
-      }
-  }
 }
-
