--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectOutputStream.java	2004-01-03 02:20:33.000000000 -0700
+++ java/io/ObjectOutputStream.java	2004-06-22 02:18:34.000000000 -0600
@@ -144,6 +144,13 @@
     protocolVersion = defaultProtocolVersion;
     useSubclassMethod = false;
     writeStreamHeader();
+
+    if (Configuration.DEBUG)
+      {
+	String val = System.getProperty("gcj.dumpobjects");
+	if (val != null && !val.equals(""))
+	  dump = true;
+      }
   }
 
   /**
@@ -172,10 +179,18 @@
   {
     if (useSubclassMethod)
       {
+	if (dump)
+	  dumpElementln ("WRITE OVERRIDE: " + obj);
+	  
 	writeObjectOverride(obj);
 	return;
       }
 
+    if (dump)
+      dumpElementln ("WRITE: " + obj);
+    
+    depth += 2;    
+
     boolean was_serializing = isSerializing;
     boolean old_mode = setBlockDataMode(false);
     try
@@ -318,6 +333,8 @@
 
 	    if (obj instanceof Serializable)
 	      {
+		Object prevObject = this.currentObject;
+		ObjectStreamClass prevObjectStreamClass = this.currentObjectStreamClass;
 		currentObject = obj;
 		ObjectStreamClass[] hierarchy =
 		  ObjectStreamClass.getObjectStreamClasses(clazz);
@@ -329,17 +346,25 @@
 		    fieldsAlreadyWritten = false;
 		    if (currentObjectStreamClass.hasWriteMethod())
 		      {
+			if (dump)
+			  dumpElementln ("WRITE METHOD CALLED FOR: " + obj);
 			setBlockDataMode(true);
 			callWriteMethod(obj, currentObjectStreamClass);
 			setBlockDataMode(false);
 			realOutput.writeByte(TC_ENDBLOCKDATA);
+			if (dump)
+			  dumpElementln ("WRITE ENDBLOCKDATA FOR: " + obj);
 		      }
 		    else
+		      {
+			if (dump)
+			  dumpElementln ("WRITE FIELDS CALLED FOR: " + obj);
 		      writeFields(obj, currentObjectStreamClass);
 		  }
+		  }
 
-		currentObject = null;
-		currentObjectStreamClass = null;
+		this.currentObject = prevObject;
+		this.currentObjectStreamClass = prevObjectStreamClass;
 		currentPutField = null;
 		break;
 	      }
@@ -360,12 +385,22 @@
 	setBlockDataMode(false);
 	try
 	  {
+	    if (Configuration.DEBUG)
+	      {
+		e.printStackTrace(System.out);
+	      }
 	    writeObject(e);
 	  }
 	catch (IOException ioe)
 	  {
-	    throw new StreamCorruptedException
-	      ("Exception " + ioe + " thrown while exception was being written to stream.");
+	    StreamCorruptedException ex = 
+	      new StreamCorruptedException
+	      (ioe + " thrown while exception was being written to stream.");
+	    if (Configuration.DEBUG)
+	      {
+		ex.printStackTrace(System.out);
+	      }
+	    throw ex;
 	  }
 
 	reset (true);
@@ -375,6 +410,10 @@
       {
 	isSerializing = was_serializing;
 	setBlockDataMode(old_mode);
+	depth -= 2;
+
+	if (dump)
+	  dumpElementln ("END: " + obj);
       }
   }
 
@@ -1171,6 +1210,9 @@
 	field_name = fields[i].getName();
 	type = fields[i].getType();
 
+	if (dump)
+	  dumpElementln ("WRITE FIELD: " + field_name + " type=" + type);
+
 	if (type == Boolean.TYPE)
 	  realOutput.writeBoolean(getBooleanField(obj, osc.forClass(), field_name));
 	else if (type == Byte.TYPE)
@@ -1512,6 +1554,14 @@
     return m;
   }
 
+  private void dumpElementln (String msg)
+  {
+    for (int i = 0; i < depth; i++)
+      System.out.print (" ");
+    System.out.print (Thread.currentThread() + ": ");
+    System.out.println(msg);
+  }
+
   // this value comes from 1.2 spec, but is used in 1.1 as well
   private final static int BUFFER_SIZE = 1024;
 
@@ -1534,6 +1584,12 @@
   private int protocolVersion;
   private boolean useSubclassMethod;
 
+  // The nesting depth for debugging output
+  private int depth = 0;
+
+  // Set if we're generating debugging dumps
+  private boolean dump = false;
+
   static
   {
     if (Configuration.INIT_LOAD_LIBRARY)
