--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectOutputStream.java	2003-12-03 02:20:26.000000000 -0700
+++ java/io/ObjectOutputStream.java	2003-12-31 02:18:37.000000000 -0700
@@ -132,18 +132,18 @@
    */
   public ObjectOutputStream (OutputStream out) throws IOException
   {
-    realOutput = new DataOutputStream (out);
+    realOutput = new DataOutputStream(out);
     blockData = new byte[ BUFFER_SIZE ];
     blockDataCount = 0;
-    blockDataOutput = new DataOutputStream (this);
-    setBlockDataMode (true);
+    blockDataOutput = new DataOutputStream(this);
+    setBlockDataMode(true);
     replacementEnabled = false;
     isSerializing = false;
     nextOID = baseWireHandle;
-    OIDLookupTable = new Hashtable ();
+    OIDLookupTable = new Hashtable();
     protocolVersion = defaultProtocolVersion;
     useSubclassMethod = false;
-    writeStreamHeader ();
+    writeStreamHeader();
   }
 
   /**
@@ -162,22 +162,19 @@
    * @exception NotSerializableException An attempt was made to
    * serialize an <code>Object</code> that is not serializable.
    *
-   * @exception InvalidClassException Somebody tried to serialize
-   * an object which is wrongly formatted.
-   *
    * @exception IOException Exception from underlying
    * <code>OutputStream</code>.
    */
-  public final void writeObject (Object obj) throws IOException
+  public final void writeObject(Object obj) throws IOException
   {
     if (useSubclassMethod)
       {
-	writeObjectOverride (obj);
+	writeObjectOverride(obj);
 	return;
       }
 
     boolean was_serializing = isSerializing;
-    boolean old_mode = setBlockDataMode (false);
+    boolean old_mode = setBlockDataMode(false);
     try
       {
 	isSerializing = true;
@@ -188,49 +185,49 @@
 	  {
 	    if (obj == null)
 	      {
-		realOutput.writeByte (TC_NULL);
+		realOutput.writeByte(TC_NULL);
 		break;
 	      }
 
-	    Integer handle = findHandle (obj);
+	    Integer handle = findHandle(obj);
 	    if (handle != null)
 	      {
-		realOutput.writeByte (TC_REFERENCE);
-		realOutput.writeInt (handle.intValue ());
+		realOutput.writeByte(TC_REFERENCE);
+		realOutput.writeInt(handle.intValue());
 		break;
 	      }
 
 	    if (obj instanceof Class)
 	      {
 		Class cl = (Class)obj;
-		ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (cl);
-		assignNewHandle (obj);
-		realOutput.writeByte (TC_CLASS);
+		ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(cl);
+		assignNewHandle(obj);
+		realOutput.writeByte(TC_CLASS);
 		if (!osc.isProxyClass)
 		  {
 		    writeObject (osc);
 		  }
 		else
 		  {
-		    realOutput.writeByte (TC_PROXYCLASSDESC);
+		    realOutput.writeByte(TC_PROXYCLASSDESC);
 		    Class[] intfs = cl.getInterfaces();
 		    realOutput.writeInt(intfs.length);
 		    for (int i = 0; i < intfs.length; i++)
 		      realOutput.writeUTF(intfs[i].getName());
 		    
-		    boolean oldmode = setBlockDataMode (true);
+		    boolean oldmode = setBlockDataMode(true);
 		    annotateProxyClass(cl);
-		    setBlockDataMode (oldmode);
+		    setBlockDataMode(oldmode);
 		    realOutput.writeByte(TC_ENDBLOCKDATA);
 		    
-		    writeObject (osc.getSuper());
+		    writeObject(osc.getSuper());
 		  }
 		break;
 	      }
 
 	    if (obj instanceof ObjectStreamClass)
 	      {
-		writeClassDescriptor ((ObjectStreamClass) obj);
+		writeClassDescriptor((ObjectStreamClass) obj);
 		break;
 	      }
 
@@ -238,7 +235,7 @@
 		&& ! replaceDone)
 	      {
 		replacedObject = obj;
-
+		
 		if (obj instanceof Serializable)
 		  {
 		    Method m = null;
@@ -250,7 +247,7 @@
 			// m can't be null by definition since an
 			// exception would have been thrown so a check
 			// for null is not needed.
-			obj = m.invoke (obj, new Object[] {});
+			obj = m.invoke(obj, new Object[] {});
 		      }
 		    catch (NoSuchMethodException ignore)
 		      {
@@ -262,55 +259,55 @@
 		      {
 		      }
 		  }
-
+		
 		if (replacementEnabled)
-		  obj = replaceObject (obj);
-
+		  obj = replaceObject(obj);
+		
 		replaceDone = true;
 		continue;
 	      }
 
 	    if (obj instanceof String)
 	      {
-		realOutput.writeByte (TC_STRING);
-		assignNewHandle (obj);
-		realOutput.writeUTF ((String)obj);
+		realOutput.writeByte(TC_STRING);
+		assignNewHandle(obj);
+		realOutput.writeUTF((String)obj);
 		break;
 	      }
 
-	    Class clazz = obj.getClass ();
-	    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (clazz);
+	    Class clazz = obj.getClass();
+	    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(clazz);
 	    if (osc == null)
-	      throw new NotSerializableException (clazz.getName ());
+	      throw new NotSerializableException(clazz.getName());
 	    
 	    if (clazz.isArray ())
 	      {
-		realOutput.writeByte (TC_ARRAY);
-		writeObject (osc);
-		assignNewHandle (obj);
-		writeArraySizeAndElements (obj, clazz.getComponentType ());
+		realOutput.writeByte(TC_ARRAY);
+		writeObject(osc);
+		assignNewHandle(obj);
+		writeArraySizeAndElements(obj, clazz.getComponentType());
 		break;
 	      }
-
-	    realOutput.writeByte (TC_OBJECT);
-	    writeObject (osc);
+	    
+	    realOutput.writeByte(TC_OBJECT);
+	    writeObject(osc);
 
 	    if (replaceDone)
-	      assignNewHandle (replacedObject);
+	      assignNewHandle(replacedObject);
 	    else
-	      assignNewHandle (obj);
+	      assignNewHandle(obj);
 
 	    if (obj instanceof Externalizable)
 	      {
 		if (protocolVersion == PROTOCOL_VERSION_2)
-		  setBlockDataMode (true);
+		  setBlockDataMode(true);
 		
-		((Externalizable)obj).writeExternal (this);
+		((Externalizable)obj).writeExternal(this);
 		
 		if (protocolVersion == PROTOCOL_VERSION_2)
 		  {
-		    setBlockDataMode (false);
-		    realOutput.writeByte (TC_ENDBLOCKDATA);
+		    setBlockDataMode(false);
+		    realOutput.writeByte(TC_ENDBLOCKDATA);
 		  }
 
 		break;
@@ -320,22 +317,22 @@
 	      {
 		currentObject = obj;
 		ObjectStreamClass[] hierarchy =
-		  ObjectStreamClass.getObjectStreamClasses (clazz);
+		  ObjectStreamClass.getObjectStreamClasses(clazz);
 		
-		for (int i=0; i < hierarchy.length; i++)
+		for (int i = 0; i < hierarchy.length; i++)
 		  {
 		    currentObjectStreamClass = hierarchy[i];
 		    
 		    fieldsAlreadyWritten = false;
-		    if (currentObjectStreamClass.hasWriteMethod ())
+		    if (currentObjectStreamClass.hasWriteMethod())
 		      {
-			setBlockDataMode (true);
-			callWriteMethod (obj, currentObjectStreamClass);
-			setBlockDataMode (false);
-			realOutput.writeByte (TC_ENDBLOCKDATA);
+			setBlockDataMode(true);
+			callWriteMethod(obj, currentObjectStreamClass);
+			setBlockDataMode(false);
+			realOutput.writeByte(TC_ENDBLOCKDATA);
 		      }
 		    else
-		      writeFields (obj, currentObjectStreamClass);
+		      writeFields(obj, currentObjectStreamClass);
 		  }
 
 		currentObject = null;
@@ -344,7 +341,7 @@
 		break;
 	      }
 
-	    throw new NotSerializableException (clazz.getName ());
+	    throw new NotSerializableException(clazz.getName ());
 	  } // end pseudo-loop
       }
     catch (ObjectStreamException ose)
@@ -354,17 +351,18 @@
       }
     catch (IOException e)
       {
-	realOutput.writeByte (TC_EXCEPTION);
-	reset (true);
+	realOutput.writeByte(TC_EXCEPTION);
+	reset(true);
 
-	setBlockDataMode (false);
+	setBlockDataMode(false);
 	try
 	  {
-	    writeObject (e);
+	    writeObject(e);
 	  }
 	catch (IOException ioe)
 	  {
-	    throw new StreamCorruptedException ("Exception " + ioe + " thrown while exception was being written to stream.");
+	    throw new StreamCorruptedException
+	      ("Exception " + ioe + " thrown while exception was being written to stream.");
 	  }
 
 	reset (true);
@@ -373,224 +371,227 @@
     finally
       {
 	isSerializing = was_serializing;
-	setBlockDataMode (old_mode);
+	setBlockDataMode(old_mode);
       }
   }
 
-  protected void writeClassDescriptor (ObjectStreamClass osc) throws IOException
+  protected void writeClassDescriptor(ObjectStreamClass osc) throws IOException
   {
-    realOutput.writeByte (TC_CLASSDESC);
-    realOutput.writeUTF (osc.getName ());
-    realOutput.writeLong (osc.getSerialVersionUID ());
-    assignNewHandle (osc);
+    realOutput.writeByte(TC_CLASSDESC);
+    realOutput.writeUTF(osc.getName());
+    realOutput.writeLong(osc.getSerialVersionUID());
+    assignNewHandle(osc);
 
-    int flags = osc.getFlags ();
+    int flags = osc.getFlags();
 
     if (protocolVersion == PROTOCOL_VERSION_2
-	&& osc.isExternalizable ())
+	&& osc.isExternalizable())
       flags |= SC_BLOCK_DATA;
 
-    realOutput.writeByte (flags);
+    realOutput.writeByte(flags);
 
     ObjectStreamField[] fields = osc.fields;
-    realOutput.writeShort (fields.length);
+    realOutput.writeShort(fields.length);
 
     ObjectStreamField field;
-    for (int i=0; i < fields.length; i++)
+    for (int i = 0; i < fields.length; i++)
       {
 	field = fields[i];
-	realOutput.writeByte (field.getTypeCode ());
-	realOutput.writeUTF (field.getName ());
+	realOutput.writeByte(field.getTypeCode ());
+	realOutput.writeUTF(field.getName ());
 
-	if (! field.isPrimitive ())
-	  writeObject (field.getTypeString ());
+	if (! field.isPrimitive())
+	  writeObject(field.getTypeString());
       }
 
-    boolean oldmode = setBlockDataMode (true);
-    annotateClass (osc.forClass ());
-    setBlockDataMode (oldmode);
-    realOutput.writeByte (TC_ENDBLOCKDATA);
-    
-    if (osc.isSerializable ())
-      writeObject (osc.getSuper ());
+    boolean oldmode = setBlockDataMode(true);
+    annotateClass(osc.forClass());
+    setBlockDataMode(oldmode);
+    realOutput.writeByte(TC_ENDBLOCKDATA);
+
+    if (osc.isSerializable() || osc.isExternalizable())
+      writeObject(osc.getSuper());
     else
-      writeObject (null);
+      writeObject(null);
   }
   
   /**
-     Writes the current objects non-transient, non-static fields from
-     the current class to the underlying output stream.
-
-     This method is intended to be called from within a object's
-     <code>private void writeObject (ObjectOutputStream)</code>
-     method.
-
-     @exception NotActiveException This method was called from a
-     context other than from the current object's and current class's
-     <code>private void writeObject (ObjectOutputStream)</code>
-     method.
-
-     @exception IOException Exception from underlying
-     <code>OutputStream</code>.
-  */
-  public void defaultWriteObject ()
+   * Writes the current objects non-transient, non-static fields from
+   * the current class to the underlying output stream.
+   *
+   * This method is intended to be called from within a object's
+   * <code>private void writeObject (ObjectOutputStream)</code>
+   * method.
+   *
+   * @exception NotActiveException This method was called from a
+   * context other than from the current object's and current class's
+   * <code>private void writeObject (ObjectOutputStream)</code>
+   * method.
+   *
+   * @exception IOException Exception from underlying
+   * <code>OutputStream</code>.
+   */
+  public void defaultWriteObject()
     throws IOException, NotActiveException
   {
-    markFieldsWritten ();
-    writeFields (currentObject, currentObjectStreamClass);
+    markFieldsWritten();
+    writeFields(currentObject, currentObjectStreamClass);
   }
 
 
-  private void markFieldsWritten () throws IOException
+  private void markFieldsWritten() throws IOException
   {
     if (currentObject == null || currentObjectStreamClass == null)
-      throw new NotActiveException ("defaultWriteObject called by non-active class and/or object");
+      throw new NotActiveException
+	("defaultWriteObject called by non-active class and/or object");
 
     if (fieldsAlreadyWritten)
-      throw new IOException ("Only one of putFields and defaultWriteObject may be called, and it may only be called once");
+      throw new IOException
+	("Only one of putFields and defaultWriteObject may be called, and it may only be called once");
 
     fieldsAlreadyWritten = true;
   }
 
-
   /**
-     Resets stream to state equivalent to the state just after it was
-     constructed.
-
-     Causes all objects previously written to the stream to be
-     forgotten.  A notification of this reset is also written to the
-     underlying stream.
-
-     @exception IOException Exception from underlying
-     <code>OutputStream</code> or reset called while serialization is
-     in progress.
-  */
-  public void reset () throws IOException
+   * Resets stream to state equivalent to the state just after it was
+   * constructed.
+   *
+   * Causes all objects previously written to the stream to be
+   * forgotten.  A notification of this reset is also written to the
+   * underlying stream.
+   *
+   * @exception IOException Exception from underlying
+   * <code>OutputStream</code> or reset called while serialization is
+   * in progress.
+   */
+  public void reset() throws IOException
   {
-    reset (false);
+    reset(false);
   }
 
 
-  private void reset (boolean internal) throws IOException
+  private void reset(boolean internal) throws IOException
   {
     if (!internal)
       {
 	if (isSerializing)
-	  throw new IOException ("Reset called while serialization in progress");
+	  throw new IOException("Reset called while serialization in progress");
 
-	realOutput.writeByte (TC_RESET);
+	realOutput.writeByte(TC_RESET);
       }
-
-    clearHandles ();
+    
+    clearHandles();
   }
 
 
   /**
-     Informs this <code>ObjectOutputStream</code> to write data
-     according to the specified protocol.  There are currently two
-     different protocols, specified by <code>PROTOCOL_VERSION_1</code>
-     and <code>PROTOCOL_VERSION_2</code>.  This implementation writes
-     data using <code>PROTOCOL_VERSION_2</code> by default, as is done
-     by the JDK 1.2.
-
-     A non-portable method, <code>setDefaultProtocolVersion (int
-     version)</code> is provided to change the default protocol
-     version.
-
-     For an explination of the differences beween the two protocols
-     see XXX: the Java ObjectSerialization Specification.
-
-     @exception IOException if <code>version</code> is not a valid
-     protocol
-
-     @see #setDefaultProtocolVersion(int)
-  */
-  public void useProtocolVersion (int version) throws IOException
+   * Informs this <code>ObjectOutputStream</code> to write data
+   * according to the specified protocol.  There are currently two
+   * different protocols, specified by <code>PROTOCOL_VERSION_1</code>
+   * and <code>PROTOCOL_VERSION_2</code>.  This implementation writes
+   * data using <code>PROTOCOL_VERSION_2</code> by default, as is done
+   * by the JDK 1.2.
+   *
+   * A non-portable method, <code>setDefaultProtocolVersion (int
+   * version)</code> is provided to change the default protocol
+   * version.
+   *
+   * For an explination of the differences beween the two protocols
+   * see XXX: the Java ObjectSerialization Specification.
+   *
+   * @exception IOException if <code>version</code> is not a valid
+   * protocol
+   *
+   * @see #setDefaultProtocolVersion(int)
+   */
+  public void useProtocolVersion(int version) throws IOException
   {
     if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)
-      throw new IOException ("Invalid protocol version requested.");
+      throw new IOException("Invalid protocol version requested.");
     
     protocolVersion = version;
   }
 
 
   /**
-     <em>GNU $classpath specific</em>
-
-     Changes the default stream protocol used by all
-     <code>ObjectOutputStream</code>s.  There are currently two
-     different protocols, specified by <code>PROTOCOL_VERSION_1</code>
-     and <code>PROTOCOL_VERSION_2</code>.  The default default is
-     <code>PROTOCOL_VERSION_1</code>.
-
-     @exception IOException if <code>version</code> is not a valid
-     protocol
-
-     @see #useProtocolVersion(int)
-  */
-  public static void setDefaultProtocolVersion (int version)
+   * <em>GNU $classpath specific</em>
+   *
+   * Changes the default stream protocol used by all
+   * <code>ObjectOutputStream</code>s.  There are currently two
+   * different protocols, specified by <code>PROTOCOL_VERSION_1</code>
+   * and <code>PROTOCOL_VERSION_2</code>.  The default default is
+   * <code>PROTOCOL_VERSION_1</code>.
+   *
+   * @exception IOException if <code>version</code> is not a valid
+   * protocol
+   *
+   * @see #useProtocolVersion(int)
+   */
+  public static void setDefaultProtocolVersion(int version)
     throws IOException
   {
     if (version != PROTOCOL_VERSION_1 && version != PROTOCOL_VERSION_2)
-      throw new IOException ("Invalid protocol version requested.");
+      throw new IOException("Invalid protocol version requested.");
 
     defaultProtocolVersion = version;
   }
 
 
   /**
-     An empty hook that allows subclasses to write extra information
-     about classes to the stream.  This method is called the first
-     time each class is seen, and after all of the standard
-     information about the class has been written.
-
-     @exception IOException Exception from underlying
-     <code>OutputStream</code>.
-
-     @see ObjectInputStream#resolveClass(java.io.ObjectStreamClass)
-  */
-  protected void annotateClass (Class cl) throws IOException
-  {}
+   * An empty hook that allows subclasses to write extra information
+   * about classes to the stream.  This method is called the first
+   * time each class is seen, and after all of the standard
+   * information about the class has been written.
+   *
+   * @exception IOException Exception from underlying
+   * <code>OutputStream</code>.
+   *
+   * @see ObjectInputStream#resolveClass(java.io.ObjectStreamClass)
+   */
+  protected void annotateClass(Class cl) throws IOException
+  {
+  }
 
   protected void annotateProxyClass(Class cl) throws IOException
-  {}
+  {
+  }
 
   /**
-     Allows subclasses to replace objects that are written to the
-     stream with other objects to be written in their place.  This
-     method is called the first time each object is encountered
-     (modulo reseting of the stream).
-
-     This method must be enabled before it will be called in the
-     serialization process.
-
-     @exception IOException Exception from underlying
-     <code>OutputStream</code>.
-
-     @see #enableReplaceObject(boolean)
-  */
-  protected Object replaceObject (Object obj) throws IOException
+   * Allows subclasses to replace objects that are written to the
+   * stream with other objects to be written in their place.  This
+   * method is called the first time each object is encountered
+   * (modulo reseting of the stream).
+   *
+   * This method must be enabled before it will be called in the
+   * serialization process.
+   *
+   * @exception IOException Exception from underlying
+   * <code>OutputStream</code>.
+   *
+   * @see #enableReplaceObject(boolean)
+   */
+  protected Object replaceObject(Object obj) throws IOException
   {
     return obj;
   }
 
 
   /**
-     If <code>enable</code> is <code>true</code> and this object is
-     trusted, then <code>replaceObject (Object)</code> will be called
-     in subsequent calls to <code>writeObject (Object)</code>.
-     Otherwise, <code>replaceObject (Object)</code> will not be called.
-
-     @exception SecurityException This class is not trusted.
-  */
-  protected boolean enableReplaceObject (boolean enable)
+   * If <code>enable</code> is <code>true</code> and this object is
+   * trusted, then <code>replaceObject (Object)</code> will be called
+   * in subsequent calls to <code>writeObject (Object)</code>.
+   * Otherwise, <code>replaceObject (Object)</code> will not be called.
+   *
+   * @exception SecurityException This class is not trusted.
+   */
+  protected boolean enableReplaceObject(boolean enable)
     throws SecurityException
   {
     if (enable)
       {
-	SecurityManager sm = System.getSecurityManager ();
+	SecurityManager sm = System.getSecurityManager();
 	if (sm != null)
-	  sm.checkPermission (new SerializablePermission ("enableSubstitution"));
+	  sm.checkPermission(new SerializablePermission("enableSubstitution"));
       }
 
     boolean old_val = replacementEnabled;
@@ -600,20 +601,18 @@
 
 
   /**
-     Writes stream magic and stream version information to the
-     underlying stream.
-
-     @exception IOException Exception from underlying
-     <code>OutputStream</code>.
-  */
-  protected void writeStreamHeader () throws IOException
+   * Writes stream magic and stream version information to the
+   * underlying stream.
+   *
+   * @exception IOException Exception from underlying
+   * <code>OutputStream</code>.
+   */
+  protected void writeStreamHeader() throws IOException
   {
-    realOutput.writeShort (STREAM_MAGIC);
-    realOutput.writeShort (STREAM_VERSION);
+    realOutput.writeShort(STREAM_MAGIC);
+    realOutput.writeShort(STREAM_VERSION);
   }
 
-
-
   /**
    * Protected constructor that allows subclasses to override
    * serialization.  This constructor should be called by subclasses
@@ -625,11 +624,11 @@
    *
    * @see #writeObjectOverride(Object)
    */
-  protected ObjectOutputStream () throws IOException, SecurityException
+  protected ObjectOutputStream() throws IOException, SecurityException
   {
     SecurityManager sec_man = System.getSecurityManager ();
     if (sec_man != null)
-      sec_man.checkPermission (SUBCLASS_IMPLEMENTATION_PERMISSION);
+      sec_man.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
     useSubclassMethod = true;
   }
 
@@ -646,10 +645,11 @@
    * @exception NotActiveException Subclass has arranged for this
    * method to be called, but did not implement this method.
    */
-  protected void writeObjectOverride (Object obj) throws NotActiveException,
+  protected void writeObjectOverride(Object obj) throws NotActiveException,
     IOException
   {
-    throw new NotActiveException ("Subclass of ObjectOutputStream must implement writeObjectOverride");
+    throw new NotActiveException
+      ("Subclass of ObjectOutputStream must implement writeObjectOverride");
   }
 
 
@@ -661,48 +661,48 @@
     if (writeDataAsBlocks)
       {
 	if (blockDataCount == BUFFER_SIZE)
-	  drain ();
+	  drain();
 
 	blockData[ blockDataCount++ ] = (byte)data;
       }
     else
-      realOutput.write (data);
+      realOutput.write(data);
   }
 
 
   /**
    * @see DataOutputStream#write(byte[])
    */
-  public void write (byte[] b) throws IOException
+  public void write(byte[] b) throws IOException
   {
-    write (b, 0, b.length);
+    write(b, 0, b.length);
   }
 
 
   /**
    * @see DataOutputStream#write(byte[],int,int)
    */
-  public void write (byte[] b, int off, int len) throws IOException
+  public void write(byte[] b, int off, int len) throws IOException
   {
     if (writeDataAsBlocks)
       {
 	if (len < 0)
-	  throw new IndexOutOfBoundsException ();
+	  throw new IndexOutOfBoundsException();
 
 	if (blockDataCount + len < BUFFER_SIZE)
 	  {
-	    System.arraycopy (b, off, blockData, blockDataCount, len);
+	    System.arraycopy(b, off, blockData, blockDataCount, len);
 	    blockDataCount += len;
 	  }
 	else
 	  {
-	    drain ();
-	    writeBlockDataHeader (len);
-	    realOutput.write (b, off, len);
+	    drain();
+	    writeBlockDataHeader(len);
+	    realOutput.write(b, off, len);
 	  }
       }
     else
-      realOutput.write (b, off, len);
+      realOutput.write(b, off, len);
   }
 
 
@@ -711,8 +711,8 @@
    */
   public void flush () throws IOException
   {
-    drain ();
-    realOutput.flush ();
+    drain();
+    realOutput.flush();
   }
 
 
@@ -723,14 +723,14 @@
    * @exception IOException Exception from underlying
    * <code>OutputStream</code>.
    */
-  protected void drain () throws IOException
+  protected void drain() throws IOException
   {
     if (blockDataCount == 0)
       return;
 
     if (writeDataAsBlocks)
-      writeBlockDataHeader (blockDataCount);
-    realOutput.write (blockData, 0, blockDataCount);
+      writeBlockDataHeader(blockDataCount);
+    realOutput.write(blockData, 0, blockDataCount);
     blockDataCount = 0;
   }
 
@@ -738,28 +738,28 @@
   /**
    * @see java.io.DataOutputStream#close ()
    */
-  public void close () throws IOException
+  public void close() throws IOException
   {
-    flush ();
-    realOutput.close ();
+    flush();
+    realOutput.close();
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeBoolean (boolean)
    */
-  public void writeBoolean (boolean data) throws IOException
+  public void writeBoolean(boolean data) throws IOException
   {
-    blockDataOutput.writeBoolean (data);
+    blockDataOutput.writeBoolean(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeByte (int)
    */
-  public void writeByte (int data) throws IOException
+  public void writeByte(int data) throws IOException
   {
-    blockDataOutput.writeByte (data);
+    blockDataOutput.writeByte(data);
   }
 
 
@@ -768,79 +768,79 @@
    */
   public void writeShort (int data) throws IOException
   {
-    blockDataOutput.writeShort (data);
+    blockDataOutput.writeShort(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeChar (int)
    */
-  public void writeChar (int data) throws IOException
+  public void writeChar(int data) throws IOException
   {
-    blockDataOutput.writeChar (data);
+    blockDataOutput.writeChar(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeInt (int)
    */
-  public void writeInt (int data) throws IOException
+  public void writeInt(int data) throws IOException
   {
-    blockDataOutput.writeInt (data);
+    blockDataOutput.writeInt(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeLong (long)
    */
-  public void writeLong (long data) throws IOException
+  public void writeLong(long data) throws IOException
   {
-    blockDataOutput.writeLong (data);
+    blockDataOutput.writeLong(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeFloat (float)
    */
-  public void writeFloat (float data) throws IOException
+  public void writeFloat(float data) throws IOException
   {
-    blockDataOutput.writeFloat (data);
+    blockDataOutput.writeFloat(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeDouble (double)
    */
-  public void writeDouble (double data) throws IOException
+  public void writeDouble(double data) throws IOException
   {
-    blockDataOutput.writeDouble (data);
+    blockDataOutput.writeDouble(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeBytes (java.lang.String)
    */
-  public void writeBytes (String data) throws IOException
+  public void writeBytes(String data) throws IOException
   {
-    blockDataOutput.writeBytes (data);
+    blockDataOutput.writeBytes(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeChars (java.lang.String)
    */
-  public void writeChars (String data) throws IOException
+  public void writeChars(String data) throws IOException
   {
-    dataOutput.writeChars (data);
+    dataOutput.writeChars(data);
   }
 
 
   /**
    * @see java.io.DataOutputStream#writeUTF (java.lang.String)
    */
-  public void writeUTF (String data) throws IOException
+  public void writeUTF(String data) throws IOException
   {
-    dataOutput.writeUTF (data);
+    dataOutput.writeUTF(data);
   }
 
 
@@ -868,331 +868,327 @@
     public abstract void write (ObjectOutput out) throws IOException;
   }
 
-  public PutField putFields () throws IOException
+  public PutField putFields() throws IOException
   {
-    if (currentPutField != null)
-      return currentPutField;
-
-    markFieldsWritten ();
-
-    currentPutField = new PutField ()
+    if (currentPutField == null)
       {
-	private byte[] prim_field_data
-	  = new byte[currentObjectStreamClass.primFieldSize];
-	private Object[] objs
-	  = new Object[currentObjectStreamClass.objectFieldCount];
-
-	private ObjectStreamField getField (String name)
-	{
-	  ObjectStreamField field
-	    = currentObjectStreamClass.getField (name);
-	  
-	  if (field == null)
-	    throw new IllegalArgumentException("no such serializable field " + name);
-	  
-	  return field;
-	}
-
-	public void put (String name, boolean value)
-	{
-	  ObjectStreamField field = getField (name);
-
-	  checkType (field, 'Z');
-	  prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);
-	}
-
-	public void put (String name, byte value)
-	{
-	  ObjectStreamField field = getField (name);
-
-	  checkType (field, 'B');
-	  prim_field_data[field.getOffset ()] = value;
-	}
-
-	public void put (String name, char value)
-	{
-	  ObjectStreamField field = getField (name);
-
-	  checkType (field, 'C');
-	  int off = field.getOffset ();
-	  prim_field_data[off++] = (byte)(value >>> 8);
-	  prim_field_data[off] = (byte)value;
-	}
+	currentPutField = new PutField ()
+	  {
+	    private byte[] prim_field_data =
+	      new byte[currentObjectStreamClass.primFieldSize];
+	    private Object[] objs =
+	      new Object[currentObjectStreamClass.objectFieldCount];
 
-	public void put (String name, double value)
-	{
-	  ObjectStreamField field = getField (name);
+	    public void put (String name, boolean value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'Z');
+	      prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);
+	    }
 
-	  checkType (field, 'D');
-	  int off = field.getOffset ();
-	  long l_value = Double.doubleToLongBits (value);
-	  prim_field_data[off++] = (byte)(l_value >>> 52);
-	  prim_field_data[off++] = (byte)(l_value >>> 48);
-	  prim_field_data[off++] = (byte)(l_value >>> 40);
-	  prim_field_data[off++] = (byte)(l_value >>> 32);
-	  prim_field_data[off++] = (byte)(l_value >>> 24);
-	  prim_field_data[off++] = (byte)(l_value >>> 16);
-	  prim_field_data[off++] = (byte)(l_value >>> 8);
-	  prim_field_data[off] = (byte)l_value;
-	}
+	    public void put (String name, byte value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'B');
+	      prim_field_data[field.getOffset ()] = value;
+	    }
 
-	public void put (String name, float value)
-	{
-	  ObjectStreamField field = getField (name);
+	    public void put (String name, char value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'C');
+	      int off = field.getOffset ();
+	      prim_field_data[off++] = (byte)(value >>> 8);
+	      prim_field_data[off] = (byte)value;
+	    }
 
-	  checkType (field, 'F');
-	  int off = field.getOffset ();
-	  int i_value = Float.floatToIntBits (value);
-	  prim_field_data[off++] = (byte)(i_value >>> 24);
-	  prim_field_data[off++] = (byte)(i_value >>> 16);
-	  prim_field_data[off++] = (byte)(i_value >>> 8);
-	  prim_field_data[off] = (byte)i_value;
-	}
+	    public void put (String name, double value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'D');
+	      int off = field.getOffset ();
+	      long l_value = Double.doubleToLongBits (value);
+	      prim_field_data[off++] = (byte)(l_value >>> 52);
+	      prim_field_data[off++] = (byte)(l_value >>> 48);
+	      prim_field_data[off++] = (byte)(l_value >>> 40);
+	      prim_field_data[off++] = (byte)(l_value >>> 32);
+	      prim_field_data[off++] = (byte)(l_value >>> 24);
+	      prim_field_data[off++] = (byte)(l_value >>> 16);
+	      prim_field_data[off++] = (byte)(l_value >>> 8);
+	      prim_field_data[off] = (byte)l_value;
+	    }
 
-	public void put (String name, int value)
-	{
-	  ObjectStreamField field = getField (name);
-	  checkType (field, 'I');
-	  int off = field.getOffset ();
-	  prim_field_data[off++] = (byte)(value >>> 24);
-	  prim_field_data[off++] = (byte)(value >>> 16);
-	  prim_field_data[off++] = (byte)(value >>> 8);
-	  prim_field_data[off] = (byte)value;
-	}
+	    public void put (String name, float value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'F');
+	      int off = field.getOffset ();
+	      int i_value = Float.floatToIntBits (value);
+	      prim_field_data[off++] = (byte)(i_value >>> 24);
+	      prim_field_data[off++] = (byte)(i_value >>> 16);
+	      prim_field_data[off++] = (byte)(i_value >>> 8);
+	      prim_field_data[off] = (byte)i_value;
+	    }
 
-	public void put (String name, long value)
-	{
-	  ObjectStreamField field = getField (name);
-	  checkType (field, 'J');
-	  int off = field.getOffset ();
-	  prim_field_data[off++] = (byte)(value >>> 52);
-	  prim_field_data[off++] = (byte)(value >>> 48);
-	  prim_field_data[off++] = (byte)(value >>> 40);
-	  prim_field_data[off++] = (byte)(value >>> 32);
-	  prim_field_data[off++] = (byte)(value >>> 24);
-	  prim_field_data[off++] = (byte)(value >>> 16);
-	  prim_field_data[off++] = (byte)(value >>> 8);
-	  prim_field_data[off] = (byte)value;
-	}
+	    public void put (String name, int value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'I');
+	      int off = field.getOffset ();
+	      prim_field_data[off++] = (byte)(value >>> 24);
+	      prim_field_data[off++] = (byte)(value >>> 16);
+	      prim_field_data[off++] = (byte)(value >>> 8);
+	      prim_field_data[off] = (byte)value;
+	    }
 
-	public void put (String name, short value)
-	{
-	  ObjectStreamField field = getField (name);
-	  checkType (field, 'S');
-	  int off = field.getOffset ();
-	  prim_field_data[off++] = (byte)(value >>> 8);
-	  prim_field_data[off] = (byte)value;
-	}
+	    public void put (String name, long value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'J');
+	      int off = field.getOffset ();
+	      prim_field_data[off++] = (byte)(value >>> 52);
+	      prim_field_data[off++] = (byte)(value >>> 48);
+	      prim_field_data[off++] = (byte)(value >>> 40);
+	      prim_field_data[off++] = (byte)(value >>> 32);
+	      prim_field_data[off++] = (byte)(value >>> 24);
+	      prim_field_data[off++] = (byte)(value >>> 16);
+	      prim_field_data[off++] = (byte)(value >>> 8);
+	      prim_field_data[off] = (byte)value;
+	    }
 
-	public void put (String name, Object value)
-	{
-	  ObjectStreamField field = getField (name);
+	    public void put (String name, short value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      checkType (field, 'S');
+	      int off = field.getOffset ();
+	      prim_field_data[off++] = (byte)(value >>> 8);
+	      prim_field_data[off] = (byte)value;
+	    }
 
-	  if (value != null &&
-	      ! field.getType ().isAssignableFrom (value.getClass ()))
-	    throw new IllegalArgumentException ();
-	  objs[field.getOffset ()] = value;
-	}
+	    public void put (String name, Object value)
+	    {
+	      ObjectStreamField field
+		= currentObjectStreamClass.getField (name);
+	      if (field == null)
+		throw new IllegalArgumentException ();
+	      if (value != null &&
+		  ! field.getType ().isAssignableFrom (value.getClass ()))
+		throw new IllegalArgumentException ();
+	      objs[field.getOffset ()] = value;
+	    }
 
-	public void write (ObjectOutput out) throws IOException
-	{
-	  // Apparently Block data is not used with PutField as per
-	  // empirical evidence against JDK 1.2.  Also see Mauve test
-	  // java.io.ObjectInputOutput.Test.GetPutField.
-	  boolean oldmode = setBlockDataMode (false);
-	  out.write (prim_field_data);
-	  for (int i = 0; i < objs.length; ++ i)
-	    out.writeObject (objs[i]);
-	  setBlockDataMode (oldmode);
-	}
+	    public void write (ObjectOutput out) throws IOException
+	    {
+	      // Apparently Block data is not used with PutField as per
+	      // empirical evidence against JDK 1.2.  Also see Mauve test
+	      // java.io.ObjectInputOutput.Test.GetPutField.
+	      boolean oldmode = setBlockDataMode (false);
+	      out.write (prim_field_data);
+	      for (int i = 0; i < objs.length; ++ i)
+		out.writeObject (objs[i]);
+	      setBlockDataMode (oldmode);
+	    }
 
-	private void checkType (ObjectStreamField field, char type)
-	  throws IllegalArgumentException
-	{
-	  if (TypeSignature.getEncodingOfClass (field.getType ()).charAt (0)
-	      != type)
-	    throw new IllegalArgumentException ();
-	}
-      };
-    // end PutFieldImpl
+	    private void checkType (ObjectStreamField field, char type)
+	      throws IllegalArgumentException
+	    {
+	      if (TypeSignature.getEncodingOfClass(field.getType ()).charAt(0)
+		  != type)
+		throw new IllegalArgumentException ();
+	    }
+	  };
+      }
 
     return currentPutField;
   }
 
 
-  public void writeFields () throws IOException
+  public void writeFields() throws IOException
   {
     if (currentPutField == null)
-      throw new NotActiveException ("writeFields can only be called after putFields has been called");
+      throw new NotActiveException("writeFields can only be called after putFields has been called");
+
+    // putFields may be called more than once, but not writeFields.
+    markFieldsWritten();
 
-    currentPutField.write (this);
+    currentPutField.write(this);
+    currentPutField = null;
   }
 
 
   // write out the block-data buffer, picking the correct header
   // depending on the size of the buffer
-  private void writeBlockDataHeader (int size) throws IOException
+  private void writeBlockDataHeader(int size) throws IOException
   {
     if (size < 256)
       {
-	realOutput.writeByte (TC_BLOCKDATA);
-	realOutput.write (size);
+	realOutput.writeByte(TC_BLOCKDATA);
+	realOutput.write(size);
       }
     else
       {
-	realOutput.writeByte (TC_BLOCKDATALONG);
-	realOutput.writeInt (size);
+	realOutput.writeByte(TC_BLOCKDATALONG);
+	realOutput.writeInt(size);
       }
   }
 
 
   // lookup the handle for OBJ, return null if OBJ doesn't have a
   // handle yet
-  private Integer findHandle (Object obj)
+  private Integer findHandle(Object obj)
   {
-    return (Integer)OIDLookupTable.get (new ObjectIdentityWrapper (obj));
+    return (Integer)OIDLookupTable.get(new ObjectIdentityWrapper(obj));
   }
 
 
   // assigns the next availible handle to OBJ
-  private int assignNewHandle (Object obj)
+  private int assignNewHandle(Object obj)
   {
-    OIDLookupTable.put (new ObjectIdentityWrapper (obj),
-			new Integer (nextOID));
+    OIDLookupTable.put(new ObjectIdentityWrapper(obj),
+		       new Integer(nextOID));
     return nextOID++;
   }
 
 
   // resets mapping from objects to handles
-  private void clearHandles ()
+  private void clearHandles()
   {
     nextOID = baseWireHandle;
-    OIDLookupTable.clear ();
+    OIDLookupTable.clear();
   }
 
 
   // write out array size followed by each element of the array
-  private void writeArraySizeAndElements (Object array, Class clazz)
+  private void writeArraySizeAndElements(Object array, Class clazz)
     throws IOException
   {
-    int length = Array.getLength (array);
+    int length = Array.getLength(array);
 
-    if (clazz.isPrimitive ())
+    if (clazz.isPrimitive())
       {
 	if (clazz == Boolean.TYPE)
 	  {
 	    boolean[] cast_array = (boolean[])array;
 	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeBoolean (cast_array[i]);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeBoolean(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Byte.TYPE)
 	  {
 	    byte[] cast_array = (byte[])array;
-	    realOutput.writeInt (length);
+	    realOutput.writeInt(length);
 	    realOutput.write(cast_array, 0, length);
 	    return;
 	  }
 	if (clazz == Character.TYPE)
 	  {
 	    char[] cast_array = (char[])array;
-	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeChar (cast_array[i]);
+	    realOutput.writeInt(length);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeChar(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Double.TYPE)
 	  {
 	    double[] cast_array = (double[])array;
-	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeDouble (cast_array[i]);
+	    realOutput.writeInt(length);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeDouble(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Float.TYPE)
 	  {
 	    float[] cast_array = (float[])array;
-	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeFloat (cast_array[i]);
+	    realOutput.writeInt(length);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeFloat(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Integer.TYPE)
 	  {
 	    int[] cast_array = (int[])array;
-	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeInt (cast_array[i]);
+	    realOutput.writeInt(length);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeInt(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Long.TYPE)
 	  {
 	    long[] cast_array = (long[])array;
 	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeLong (cast_array[i]);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeLong(cast_array[i]);
 	    return;
 	  }
 	if (clazz == Short.TYPE)
 	  {
 	    short[] cast_array = (short[])array;
 	    realOutput.writeInt (length);
-	    for (int i=0; i < length; i++)
-	      realOutput.writeShort (cast_array[i]);
+	    for (int i = 0; i < length; i++)
+	      realOutput.writeShort(cast_array[i]);
 	    return;
 	  }
       }
     else
       {
 	Object[] cast_array = (Object[])array;
-	realOutput.writeInt (length);
-	for (int i=0; i < length; i++)
-	  writeObject (cast_array[i]);
+	realOutput.writeInt(length);
+	for (int i = 0; i < length; i++)
+	  writeObject(cast_array[i]);
       }
   }
 
 
   // writes out FIELDS of OBJECT for the specified ObjectStreamClass.
   // FIELDS are already in canonical order.
-  private void writeFields (Object obj, ObjectStreamClass osc)
+  private void writeFields(Object obj, ObjectStreamClass osc)
     throws IOException
   {
     ObjectStreamField[] fields = osc.fields;
-    boolean oldmode = setBlockDataMode (false);
+    boolean oldmode = setBlockDataMode(false);
     String field_name;
     Class type;
-    for (int i=0; i < fields.length; i++)
+
+    for (int i = 0; i < fields.length; i++)
       {
-	field_name = fields[i].getName ();
-	type = fields[i].getType ();
+	field_name = fields[i].getName();
+	type = fields[i].getType();
 
 	if (type == Boolean.TYPE)
-	  realOutput.writeBoolean (getBooleanField (obj, osc.forClass(), field_name));
+	  realOutput.writeBoolean(getBooleanField(obj, osc.forClass(), field_name));
 	else if (type == Byte.TYPE)
-	  realOutput.writeByte (getByteField (obj, osc.forClass(), field_name));
+	  realOutput.writeByte(getByteField(obj, osc.forClass(), field_name));
 	else if (type == Character.TYPE)
-	  realOutput.writeChar (getCharField (obj, osc.forClass(), field_name));
+	  realOutput.writeChar(getCharField(obj, osc.forClass(), field_name));
 	else if (type == Double.TYPE)
-	  realOutput.writeDouble (getDoubleField (obj, osc.forClass(), field_name));
+	  realOutput.writeDouble(getDoubleField(obj, osc.forClass(), field_name));
 	else if (type == Float.TYPE)
-	  realOutput.writeFloat (getFloatField (obj, osc.forClass(), field_name));
+	  realOutput.writeFloat(getFloatField(obj, osc.forClass(), field_name));
 	else if (type == Integer.TYPE)
-	  realOutput.writeInt (getIntField (obj, osc.forClass(), field_name));
+	  realOutput.writeInt(getIntField(obj, osc.forClass(), field_name));
 	else if (type == Long.TYPE)
-	  realOutput.writeLong (getLongField (obj, osc.forClass(), field_name));
+	  realOutput.writeLong(getLongField(obj, osc.forClass(), field_name));
 	else if (type == Short.TYPE)
-	  realOutput.writeShort (getShortField (obj, osc.forClass(), field_name));
+	  realOutput.writeShort(getShortField(obj, osc.forClass(), field_name));
 	else
-	  writeObject (getObjectField (obj, osc.forClass(), field_name,
-				       fields[i].getTypeString ()));
+	  writeObject(getObjectField(obj, osc.forClass(), field_name,
+				     fields[i].getTypeString ()));
       }
-    setBlockDataMode (oldmode);
+    setBlockDataMode(oldmode);
   }
 
 
   // Toggles writing primitive data to block-data buffer.
-  private boolean setBlockDataMode (boolean on) throws IOException
+  private boolean setBlockDataMode(boolean on) throws IOException
   {
     if (on == writeDataAsBlocks)
       return on;
@@ -1210,17 +1206,16 @@
   }
 
 
-  private void callWriteMethod (Object obj, ObjectStreamClass osc)
+  private void callWriteMethod(Object obj, ObjectStreamClass osc)
     throws IOException
   {
     Class klass = osc.forClass();
-    currentPutField = null;
     try
       {
 	Class classArgs[] = {ObjectOutputStream.class};
-	Method m = getMethod (klass, "writeObject", classArgs);
+	Method m = getMethod(klass, "writeObject", classArgs);
 	Object args[] = {this};
-	m.invoke (obj, args);	
+	m.invoke(obj, args);	
       }
     catch (NoSuchMethodException nsme)
       {
@@ -1236,41 +1231,33 @@
 	  throw (IOException) exception;
 
 	IOException ioe
-	  = new IOException ("Exception thrown from writeObject() on " +
-			     klass + ": " + exception.getClass().getName());
+	  = new IOException("Exception thrown from writeObject() on " +
+			    klass + ": " + exception.getClass().getName());
 	ioe.initCause(exception);
 	throw ioe;
       }
     catch (Exception x)
       {
 	IOException ioe
-	  = new IOException ("Failure invoking writeObject() on " +
-			     klass + ": " + x.getClass().getName());
+	  = new IOException("Failure invoking writeObject() on " +
+			    klass + ": " + x.getClass().getName());
 	ioe.initCause(x);
 	throw ioe;
       }
   }
 
-  private boolean getBooleanField (Object obj, Class klass, String field_name)
+  private boolean getBooleanField(Object obj, Class klass, String field_name)
     throws IOException
   {
     try
       {
-	Field f = getField (klass, field_name);
-	boolean b = f.getBoolean (obj);
+	Field f = getField(klass, field_name);
+	boolean b = f.getBoolean(obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
+	throw new IOException("Unexpected exception " + _);
       }
   }
 
@@ -1283,17 +1270,9 @@
 	byte b = f.getByte (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
+	throw new IOException("Unexpected exception " + _);
       }    
   }
 
@@ -1306,17 +1285,9 @@
 	char b = f.getChar (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
+	throw new IOException("Unexpected exception " + _);
       }    
   }
 
@@ -1329,17 +1300,9 @@
 	double b = f.getDouble (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
+	throw new IOException("Unexpected exception " + _);
       }    
   }
 
@@ -1352,18 +1315,10 @@
 	float b = f.getFloat (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
-      }    
+	throw new IOException("Unexpected exception " + _);
+      }
   }
 
   private int getIntField (Object obj, Class klass, String field_name)
@@ -1375,18 +1330,10 @@
 	int b = f.getInt (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
-      }    
+	throw new IOException("Unexpected exception " + _);
+      }
   }
 
   private long getLongField (Object obj, Class klass, String field_name)
@@ -1398,17 +1345,9 @@
 	long b = f.getLong (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
+	throw new IOException("Unexpected exception " + _);
       }    
   }
 
@@ -1421,18 +1360,10 @@
 	short b = f.getShort (obj);
 	return b;
       }
-    catch (IllegalArgumentException _)
-      {
-	throw new InvalidClassException("invalid requested type for field " + field_name + " in class " + klass.getName());
-      }
-    catch (IOException e)
-      {
-       throw e;
-      }
     catch (Exception _)
       {
-	throw new IOException ();
-      }    
+	throw new IOException("Unexpected exception " + _);
+      }
   }
 
   private Object getObjectField (Object obj, Class klass, String field_name,
@@ -1441,20 +1372,10 @@
     try
       {
 	Field f = getField (klass, field_name);
-	ObjectStreamField of = new ObjectStreamField(f.getName(), f.getType());
-
-	if (of.getTypeString() == null ||
-	    !of.getTypeString().equals(type_code))
-	  throw new InvalidClassException("invalid type code for " + field_name + " in class " + klass.getName());
-
 	Object o = f.get (obj);
 	// FIXME: We should check the type_code here
 	return o;
       }
-    catch (IOException e)
-      {
-	throw e;
-      }
     catch (Exception e)
       {
 	throw new IOException ();
@@ -1462,25 +1383,18 @@
   }
 
   private static Field getField (Class klass, String name)
-    throws java.io.InvalidClassException
+    throws java.lang.NoSuchFieldException
   {
-    try
-      {
-	final Field f = klass.getDeclaredField(name);
-	AccessController.doPrivileged(new PrivilegedAction()
-	  {
-	    public Object run()
-	    {
-	      f.setAccessible(true);
-	      return null;
-	    }
-	  });
-	return f;
-      }
-    catch (java.lang.NoSuchFieldException e)
+    final Field f = klass.getDeclaredField(name);
+    AccessController.doPrivileged(new PrivilegedAction()
       {
-	throw new InvalidClassException ("no field called " + name + " in class " + klass.getName());
-      }
+	public Object run()
+	{
+	  f.setAccessible(true);
+	  return null;
+	}
+      });
+    return f;
   }
 
   private static Method getMethod (Class klass, String name, Class[] args)
@@ -1524,7 +1438,7 @@
   {
     if (Configuration.INIT_LOAD_LIBRARY)
       {
-        System.loadLibrary ("javaio");
+        System.loadLibrary("javaio");
       }
   }
 }
