--- /home/tromey/gnu/egcs/classpath/classpath/java/lang/Double.java	Sat Mar  2 12:13:11 2002
+++ java/lang/Double.java	Tue Jan 22 16:01:34 2002
@@ -1,4 +1,4 @@
-/* Double.java -- object wrapper for double
+/* Double.java -- object wrapper for double primitive
    Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
@@ -7,7 +7,7 @@
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
-
+ 
 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -40,6 +40,12 @@
 
 import gnu.classpath.Configuration;
 
+/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
+ * "The Java Language Specification", ISBN 0-201-63451-1
+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.
+ * Status:  Believed complete and correct.
+ */
+
 /**
  * Instances of class <code>Double</code> represent primitive
  * <code>double</code> values.
@@ -49,16 +55,15 @@
  *
  * @author Paul Fisher
  * @author Andrew Haley <aph@cygnus.com>
- * @author Eric Blake <ebb9@email.byu.edu>
- * @since 1.0
- * @status updated to 1.4
+ * @since JDK 1.0
  */
 public final class Double extends Number implements Comparable
 {
   /**
-   * Compatible with JDK 1.0+.
+   * The minimum positive value a <code>double</code> may represent
+   * is 5e-324.
    */
-  private static final long serialVersionUID = -9172774392245257468L;
+  public static final double MIN_VALUE = 5e-324;
 
   /**
    * The maximum positive value a <code>double</code> may represent
@@ -67,50 +72,43 @@
   public static final double MAX_VALUE = 1.7976931348623157e+308;
 
   /**
-   * The minimum positive value a <code>double</code> may represent
-   * is 5e-324.
-   */
-  public static final double MIN_VALUE = 5e-324;
-
-  /**
    * The value of a double representation -1.0/0.0, negative
-   * infinity.
+   * infinity.  
    */
-  public static final double NEGATIVE_INFINITY = -1.0 / 0.0;
+  public static final double NEGATIVE_INFINITY = -1.0d/0.0d;
 
   /**
    * The value of a double representing 1.0/0.0, positive infinity.
    */
-  public static final double POSITIVE_INFINITY = 1.0 / 0.0;
+  public static final double POSITIVE_INFINITY = 1.0d/0.0d;
 
   /**
    * All IEEE 754 values of NaN have the same value in Java.
    */
-  public static final double NaN = 0.0 / 0.0;
+  public static final double NaN = 0.0d/0.0d;
 
   /**
    * The primitive type <code>double</code> is represented by this
    * <code>Class</code> object.
-   * @since 1.1
    */
   public static final Class TYPE = VMClassLoader.getPrimitiveClass('D');
 
   /**
    * The immutable value of this Double.
-   *
-   * @serial the wrapped double
    */
   private final double value;
 
+  private static final long serialVersionUID = -9172774392245257468L;
+
   /**
-   * Load native routines necessary for this class.
+   * Load native routines necessary for this class.  
    */
   static
   {
     if (Configuration.INIT_LOAD_LIBRARY)
       {
-	System.loadLibrary("javalang");
-	initIDs();
+	System.loadLibrary ("javalang");
+	initIDs ();
       }
   }
 
@@ -120,421 +118,411 @@
    *
    * @param value the <code>double</code> argument
    */
-  public Double(double value)
+  public Double (double value)
   {
     this.value = value;
   }
 
   /**
-   * Create a <code>Double</code> from the specified <code>String</code>.
+   * Create a <code>Double</code> from the specified
+   * <code>String</code>.
+   *
    * This method calls <code>Double.parseDouble()</code>.
    *
+   * @exception NumberFormatException when the <code>String</code> cannot
+   *            be parsed into a <code>Float</code>.
    * @param s the <code>String</code> to convert
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>double</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @see #parseDouble(String)
+   * @see #parseDouble(java.lang.String) 
    */
-  public Double(String s)
+  public Double (String s) throws NumberFormatException
   {
-    value = parseDouble(s);
+    value = parseDouble (s);
   }
 
   /**
-   * Convert the <code>double</code> to a <code>String</code>.
-   * Floating-point string representation is fairly complex: here is a
-   * rundown of the possible values.  "<code>[-]</code>" indicates that a
-   * negative sign will be printed if the value (or exponent) is negative.
-   * "<code>&lt;number&gt;</code>" means a string of digits ('0' to '9').
-   * "<code>&lt;digit&gt;</code>" means a single digit ('0' to '9').<br>
-   *
-   * <table border=1>
-   * <tr><th>Value of Double</th><th>String Representation</th></tr>
-   * <tr><td>[+-] 0</td> <td><code>[-]0.0</code></td></tr>
-   * <tr><td>Between [+-] 10<sup>-3</sup> and 10<sup>7</sup>, exclusive</td>
-   *     <td><code>[-]number.number</code></td></tr>
-   * <tr><td>Other numeric value</td>
-   *     <td><code>[-]&lt;digit&gt;.&lt;number&gt;
-   *          E[-]&lt;number&gt;</code></td></tr>
-   * <tr><td>[+-] infinity</td> <td><code>[-]Infinity</code></td></tr>
-   * <tr><td>NaN</td> <td><code>NaN</code></td></tr>
-   * </table>
-   *
-   * Yes, negative zero <em>is</em> a possible value.  Note that there is
-   * <em>always</em> a <code>.</code> and at least one digit printed after
-   * it: even if the number is 3, it will be printed as <code>3.0</code>.
-   * After the ".", all digits will be printed except trailing zeros. The
-   * result is rounded to the shortest decimal number which will parse back
-   * to the same double.
-   *
-   * <p>To create other output formats, use {@link java.text.NumberFormat}.
-   *
-   * @XXX specify where we are not in accord with the spec.
+   * Convert the <code>double</code> value of this <code>Double</code>
+   * to a <code>String</code>.  This method calls
+   * <code>Double.toString(double)</code> to do its dirty work.
    *
-   * @param d the <code>double</code> to convert
-   * @return the <code>String</code> representing the <code>double</code>
+   * @return the <code>String</code> representation of this <code>Double</code>.
+   * @see #toString(double)
    */
-  public static String toString(double d)
+  public String toString ()
   {
-    return toString(d, false);
-  }
-
-  /**
-   * Create a new <code>Double</code> object using the <code>String</code>.
-   *
-   * @param s the <code>String</code> to convert
-   * @return the new <code>Double</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>double</code>
-   * @throws NullPointerException if <code>s</code> is null.
-   * @see #parseDouble(String)
-   */
-  public static Double valueOf(String s)
-  {
-    // XXX just call new Double(parseDouble(s));
-    if (s == null)
-      throw new NullPointerException();
-    return new Double(s);
+    return toString (value);
   }
 
   /**
-   * Parse the specified <code>String</code> as a <code>double</code>. The
-   * extended BNF grammar is as follows:<br>
-   * <pre>
-   * <em>DecodableString</em>:
-   *      ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> )
-   *    | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> )
-   *    | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em>
-   *              [ <code>f</code> | <code>F</code> | <code>d</code>
-   *                | <code>D</code>] )
-   * <em>FloatingPoint</em>:
-   *      ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ]
-   *              [ <em>Exponent</em> ] )
-   *    | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] )
-   * <em>Exponent</em>:
-   *      ( ( <code>e</code> | <code>E</code> )
-   *              [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ )
-   * <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em>
-   * </pre>
-   *
-   * <p>NaN and infinity are special cases, to allow parsing of the output
-   * of toString.  Otherwise, the result is determined by calculating
-   * <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding
-   * to the nearest double. Remember that many numbers cannot be precisely
-   * represented in floating point. In case of overflow, infinity is used,
-   * and in case of underflow, signed zero is used. Unlike Integer.parseInt,
-   * this does not accept Unicode digits outside the ASCII range.
-   *
-   * <p>If an unexpected character is found in the <code>String</code>, a
-   * <code>NumberFormatException</code> will be thrown.  Leading and trailing
-   * 'whitespace' is ignored via <code>String.trim()</code>, but spaces
-   * internal to the actual number are not allowed.
-   *
-   * <p>To parse numbers according to another format, consider using
-   * {@link java.text.NumberFormat}.
+   * If the <code>Object</code> is not <code>null</code>, is an
+   * <code>instanceof</code> <code>Double</code>, and represents
+   * the same primitive <code>double</code> value return 
+   * <code>true</code>.  Otherwise <code>false</code> is returned.
+   * <p>
+   * Note that there are two differences between <code>==</code> and
+   * <code>equals()</code>. <code>0.0d == -0.0d</code> returns <code>true</code>
+   * but <code>new Double(0.0d).equals(new Double(-0.0d))</code> returns
+   * <code>false</code>. And <code>Double.NaN == Double.NaN</code> returns
+   * <code>false</code>, but
+   * <code>new Double(Double.NaN).equals(new Double(Double.NaN))</code> returns
+   * <code>true</code>.
    *
-   * @XXX specify where/how we are not in accord with the spec.
-   *
-   * @param str the <code>String</code> to convert
-   * @return the <code>double</code> value of <code>s</code>
-   * @throws NumberFormatException if <code>s</code> cannot be parsed as a
-   *         <code>double</code>
-   * @throws NullPointerException if <code>s</code> is null
-   * @see #MIN_VALUE
-   * @see #MAX_VALUE
-   * @see #POSITIVE_INFINITY
-   * @see #NEGATIVE_INFINITY
-   * @since 1.2
-   */
-  public static native double parseDouble(String s);
-
-  /**
-   * Return <code>true</code> if the <code>double</code> has the same
-   * value as <code>NaN</code>, otherwise return <code>false</code>.
-   *
-   * @param v the <code>double</code> to compare
-   * @return whether the argument is <code>NaN</code>.
+   * @param obj the object to compare to
+   * @return whether the objects are semantically equal.
    */
-  public static boolean isNaN(double v)
+  public boolean equals (Object obj)
   {
-    // This works since NaN != NaN is the only reflexive inequality
-    // comparison which returns true.
-    return v != v;
+    if (!(obj instanceof Double))
+      return false;
+
+    double d = ((Double) obj).value;
+
+    // GCJ LOCAL: this implementation is probably faster than
+    // Classpath's, especially once we inline doubleToLongBits.
+    return doubleToLongBits (value) == doubleToLongBits (d);
+    // END GCJ LOCAL
   }
 
   /**
-   * Return <code>true</code> if the <code>double</code> has a value
-   * equal to either <code>NEGATIVE_INFINITY</code> or
-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
-   *
-   * @param v the <code>double</code> to compare
-   * @return whether the argument is (-/+) infinity.
+   * The hashcode is the value of the expression: <br>
+   * <br>
+   * <code>(int)(v^(v>>>32))</code><br>
+   * <br>
+   * where v is defined by: <br>
+   * <code>long v = Double.doubleToLongBits(this.longValue());</code><br>
    */
-  public static boolean isInfinite(double v)
+  public int hashCode ()
   {
-    return v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY;
+    long v = doubleToLongBits (value);
+    return (int) (v ^ (v >>> 32));
   }
 
   /**
-   * Return <code>true</code> if the value of this <code>Double</code>
-   * is the same as <code>NaN</code>, otherwise return <code>false</code>.
-   *
-   * @return whether this <code>Double</code> is <code>NaN</code>
+   * Return the value of this <code>Double</code> when cast to an 
+   * <code>int</code>.
    */
-  public boolean isNaN()
+  public int intValue ()
   {
-    return isNaN(value);
+    return (int) value;
   }
 
   /**
-   * Return <code>true</code> if the value of this <code>Double</code>
-   * is the same as <code>NEGATIVE_INFINITY</code> or
-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
-   *
-   * @return whether this <code>Double</code> is (-/+) infinity
+   * Return the value of this <code>Double</code> when cast to a
+   * <code>long</code>.
    */
-  public boolean isInfinite()
+  public long longValue ()
   {
-    return isInfinite(value);
+    return (long) value;
   }
 
   /**
-   * Convert the <code>double</code> value of this <code>Double</code>
-   * to a <code>String</code>.  This method calls
-   * <code>Double.toString(double)</code> to do its dirty work.
-   *
-   * @return the <code>String</code> representation
-   * @see #toString(double)
+   * Return the value of this <code>Double</code> when cast to a
+   * <code>float</code>.
    */
-  public String toString()
+  public float floatValue ()
   {
-    return toString(value);
+    return (float) value;
   }
 
   /**
-   * Return the value of this <code>Double</code> as a <code>byte</code>.
-   *
-   * @return the byte value
-   * @since 1.1
+   * Return the primitive <code>double</code> value represented by this
+   * <code>Double</code>.
    */
-  public byte byteValue()
+  public double doubleValue ()
   {
-    return (byte) value;
+    return value;
   }
 
   /**
-   * Return the value of this <code>Double</code> as a <code>short</code>.
+   * Return the result of calling <code>new Double(java.lang.String)</code>.
    *
-   * @return the short value
-   * @since 1.1
+   * @param s the <code>String</code> to convert to a <code>Double</code>.
+   * @return a new <code>Double</code> representing the <code>String</code>'s
+   *         numeric value.
+   *
+   * @exception NullPointerException thrown if <code>String</code> is 
+   * <code>null</code>.
+   * @exception NumberFormatException thrown if <code>String</code> cannot
+   * be parsed as a <code>double</code>.
+   * @see #Double(java.lang.String)
+   * @see #parseDouble(java.lang.String)
    */
-  public short shortValue()
+  public static Double valueOf (String s) throws NumberFormatException
   {
-    return (short) value;
+    return new Double (s);
   }
 
   /**
-   * Return the value of this <code>Double</code> as an <code>int</code>.
-   *
-   * @return the int value
+   * Return <code>true</code> if the value of this <code>Double</code>
+   * is the same as <code>NaN</code>, otherwise return <code>false</code>.
+   * @return whether this <code>Double</code> is <code>NaN</code>.
    */
-  public int intValue()
+  public boolean isNaN ()
   {
-    return (int) value;
+    return isNaN (value);
   }
 
   /**
-   * Return the value of this <code>Double</code> as a <code>long</code>.
+   * Return <code>true</code> if the <code>double</code> has the same
+   * value as <code>NaN</code>, otherwise return <code>false</code>.
    *
-   * @return the long value
+   * @param v the <code>double</code> to compare
+   * @return whether the argument is <code>NaN</code>.
    */
-  public long longValue()
+  public static boolean isNaN (double v)
   {
-    return (long) value;
+    // This works since NaN != NaN is the only reflexive inequality
+    // comparison which returns true.
+    return v != v;
   }
 
   /**
-   * Return the value of this <code>Double</code> as a <code>float</code>.
+   * Return <code>true</code> if the value of this <code>Double</code>
+   * is the same as <code>NEGATIVE_INFINITY</code> or 
+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
    *
-   * @return the float value
+   * @return whether this <code>Double</code> is (-/+) infinity.
    */
-  public float floatValue()
+  public boolean isInfinite ()
   {
-    return (float) value;
+    return isInfinite (value);
   }
 
   /**
-   * Return the value of this <code>Double</code>.
+   * Return <code>true</code> if the <code>double</code> has a value 
+   * equal to either <code>NEGATIVE_INFINITY</code> or 
+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.
    *
-   * @return the double value
+   * @param v the <code>double</code> to compare
+   * @return whether the argument is (-/+) infinity.
    */
-  public double doubleValue()
+  public static boolean isInfinite (double v)
   {
-    return value;
+    return (v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY);
   }
 
   /**
-   * Return a hashcode representing this Object. <code>Double</code>'s hash
-   * code is calculated by:<br>
-   * <code>long v = Double.doubleToLongBits(doubleValue());<br>
-   *    int hash = (int)(v^(v&gt;&gt;32))</code>.
-   *
-   * @return this Object's hash code
-   * @see #doubleToLongBits(double)
+   * Returns 0 if the <code>double</code> value of the argument is 
+   * equal to the value of this <code>Double</code>.  Returns a number
+   * less than zero if the value of this <code>Double</code> is less 
+   * than the <code>double</code> value of the argument, and returns a 
+   * number greater than zero if the value of this <code>Double</code> 
+   * is greater than the <code>double</code> value of the argument.
+   * <br>
+   * <code>Double.NaN</code> is greater than any number other than itself, 
+   * even <code>Double.POSITIVE_INFINITY</code>.
+   * <br>
+   * <code>0.0d</code> is greater than <code>-0.0d</code>.
+   *
+   * @param d the Double to compare to.
+   * @return  0 if the <code>Double</code>s are the same, &lt; 0 if this
+   *          <code>Double</code> is less than the <code>Double</code> in
+   *          in question, or &gt; 0 if it is greater.
+   * @since 1.2
    */
-  public int hashCode()
+  public int compareTo (Double d)
   {
-    long v = doubleToLongBits(value);
-    return (int) (v ^ (v >>> 32));
+    return compare (value, d.value);
   }
 
   /**
-   * Returns <code>true</code> if <code>obj</code> is an instance of
-   * <code>Double</code> and represents the same double value. Unlike comparing
-   * two doubles with <code>==</code>, this treats two instances of
-   * <code>Double.NaN</code> as equal, but treats <code>0.0</code> and
-   * <code>-0.0</code> as unequal.
-   *
-   * <p>Note that <code>d1.equals(d2)<code> is identical to
-   * <code>doubleToLongBits(d1.doubleValue()) ==
-   *    doubleToLongBits(d2.doubleValue())<code>.
-   *
-   * @param obj the object to compare
-   * @return whether the objects are semantically equal
+   * Returns 0 if the first argument is equal to the second argument.
+   * Returns a number less than zero if the first argument is less than the
+   * second argument, and returns a number greater than zero if the first
+   * argument is greater than the second argument.
+   * <br>
+   * <code>Double.NaN</code> is greater than any number other than itself, 
+   * even <code>Double.POSITIVE_INFINITY</code>.
+   * <br>
+   * <code>0.0d</code> is greater than <code>-0.0d</code>.
+   *
+   * @param x the first double to compare.
+   * @param y the second double to compare.
+   * @return  0 if the arguments are the same, &lt; 0 if the
+   *          first argument is less than the second argument in
+   *          in question, or &gt; 0 if it is greater.
+   * @since 1.4
    */
-  public boolean equals(Object obj)
+  public static int compare (double x, double y)
   {
-    if (! (obj instanceof Double))
-      return false;
-
-    double d = ((Double) obj).value;
+    if (isNaN (x))
+      return isNaN (y) ? 0 : 1;
+    if (isNaN (y))
+      return -1;
+    // recall that 0.0 == -0.0, so we convert to infinites and try again
+    if (x == 0 && y == 0)
+      return (int) (1 / x - 1 / y);
+    if (x == y)
+      return 0;
 
-    // Avoid call to native method. However, some implementations, like gcj,
-    // are better off using floatToIntBits(value) == floatToIntBits(f).
-    // Check common case first, then check NaN and 0.
-    if (value == d)
-      return (value != 0) || (1 / value == 1 / d);
-    return isNaN(value) && isNaN(d);
+    return x > y ? 1 : -1;
   }
 
   /**
-   * Convert the double to the IEEE 754 floating-point "double format" bit
-   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52
-   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0
-   * (masked by 0x000fffffffffffffL) are the mantissa. This function
-   * collapses all versions of NaN to 0x7ff8000000000000L. The result of this
-   * function can be used as the argument to
-   * <code>Double.longBitsToDouble(long)</code> to obtain the original
-   * <code>double</code> value.
-   *
-   * @param value the <code>double</code> to convert
-   * @return the bits of the <code>double</code>
-   * @see #longBitsToDouble(long)
+   * Compares the specified <code>Object</code> to this <code>Double</code>
+   * if and only if the <code>Object</code> is an instanceof 
+   * <code>Double</code>.
+   *
+   * @param o the Object to compare to.
+   * @return  0 if the <code>Double</code>s are the same, &lt; 0 if this
+   *          <code>Double</code> is less than the <code>Double</code> in
+   *          in question, or &gt; 0 if it is greater.
+   * @throws ClassCastException if the argument is not a <code>Double</code>
    */
-  public static native long doubleToLongBits(double value);
+  public int compareTo (Object o)
+  {
+    return compareTo ((Double) o);
+  }
 
   /**
-   * Convert the double to the IEEE 754 floating-point "double format" bit
-   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52
-   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0
-   * (masked by 0x000fffffffffffffL) are the mantissa. This function
-   * leaves NaN alone, rather than collapsing to a canonical value. The
-   * result of this function can be used as the argument to
-   * <code>Double.longBitsToDouble(long)</code> to obtain the original
-   * <code>double</code> value.
+   * Convert the <code>double</code> to a <code>String</code>.
+   * <P>
+   * 
+   * Floating-point string representation is fairly complex: here is a
+   * rundown of the possible values.  "<CODE>[-]</CODE>" indicates that a
+   * negative sign will be printed if the value (or exponent) is negative.
+   * "<CODE>&lt;number&gt;</CODE>" means a string of digits (0-9).
+   * "<CODE>&lt;digit&gt;</CODE>" means a single digit (0-9).
+   * <P>
+   *
+   * <TABLE BORDER=1>
+   * <TR><TH>Value of Float</TH><TH>String Representation</TH></TR>
+   * <TR>
+   *     <TD>[+-] 0</TD>
+   *     <TD>[<CODE>-</CODE>]<CODE>0.0</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>Between [+-] 10<SUP>-3</SUP> and 10<SUP>7</SUP></TD>
+   *     <TD><CODE>[-]number.number</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>Other numeric value</TD>
+   *     <TD><CODE>[-]&lt;digit&gt;.&lt;number&gt;E[-]&lt;number&gt;</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>[+-] infinity</TD>
+   *     <TD><CODE>[-]Infinity</CODE></TD>
+   * </TR>
+   * <TR>
+   *     <TD>NaN</TD>
+   *     <TD><CODE>NaN</CODE></TD>
+   * </TR>
+   * </TABLE>
+   *
+   * Yes, negative zero <EM>is</EM> a possible value.  Note that there is
+   * <EM>always</EM> a <CODE>.</CODE> and at least one digit printed after
+   * it: even if the number is 3, it will be printed as <CODE>3.0</CODE>.
+   * After the ".", all digits will be printed except trailing zeros.  No
+   * truncation or rounding is done by this function.
    *
-   * @param value the <code>double</code> to convert
-   * @return the bits of the <code>double</code>
-   * @see #longBitsToDouble(long)
-   */
-  public static native long doubleToRawLongBits(double value);
-
-  /**
-   * Convert the argument in IEEE 754 floating-point "double format" bit
-   * layout to the corresponding float. Bit 63 (the most significant) is the
-   * sign bit, bits 62-52 (masked by 0x7ff0000000000000L) represent the
-   * exponent, and bits 51-0 (masked by 0x000fffffffffffffL) are the mantissa.
-   * This function leaves NaN alone, so that you can recover the bit pattern
-   * with <code>Double.doubleToRawLongBits(double)</code>.
    *
-   * @param bits the bits to convert
-   * @return the <code>double</code> represented by the bits
-   * @see #doubleToLongBits(double)
-   * @see #doubleToRawLongBits(double)
-   */
-  public static native double longBitsToDouble(long bits);
-
-  /**
-   * Compare two Doubles numerically by comparing their <code>double</code>
-   * values. The result is positive if the first is greater, negative if the
-   * second is greater, and 0 if the two are equal. However, this special
-   * cases NaN and signed zero as follows: NaN is considered greater than
-   * all other doubles, including <code>POSITIVE_INFINITY</code>, and positive
-   * zero is considered greater than negative zero.
+   * @XXX specify where we are not in accord with the spec.
    *
-   * @param d the Double to compare
-   * @return the comparison
-   * @since 1.2
+   * @param d the <code>double</code> to convert
+   * @return the <code>String</code> representing the <code>double</code>.
    */
-  public int compareTo(Double d)
+  public static String toString (double d)
   {
-    return compare(value, d.value);
+    return toString (d, false);
   }
 
+  static native String toString (double d, boolean isFloat);
+
   /**
-   * Behaves like <code>compareTo(Double)</code> unless the Object
-   * is not an <code>Double</code>.
+   * Return the long bits of the specified <code>double</code>.
+   * The result of this function can be used as the argument to
+   * <code>Double.longBitsToDouble(long)</code> to obtain the
+   * original <code>double</code> value.
    *
-   * @param o the object to compare
-   * @return the comparison
-   * @throws ClassCastException if the argument is not a <code>Double</code>
-   * @see #compareTo(Double)
-   * @see Comparable
-   * @since 1.2
+   * @param value the <code>double</code> to convert
+   * @return the bits of the <code>double</code>.
    */
-  public int compareTo(Object o)
-  {
-    return compare(value, ((Double) o).value);
-  }
+  public static native long doubleToLongBits (double value);
 
   /**
-   * Behaves like <code>new Double(x).compareTo(new Double(y))</code>; in
-   * other words this compares two doubles, special casing NaN and zero,
-   * without the overhead of objects.
+   * Return the long bits of the specified <code>double</code>.
+   * The result of this function can be used as the argument to
+   * <code>Double.longBitsToDouble(long)</code> to obtain the
+   * original <code>double</code> value.  This method differs from 
+   * <code>doubleToLongBits</code> in that it does not collapse
+   * NaN values.
    *
-   * @param x the first double to compare
-   * @param y the second double to compare
-   * @return the comparison
-   * @since 1.4
+   * @param value the <code>double</code> to convert
+   * @return the bits of the <code>double</code>.
    */
-  public static int compare(double x, double y)
-  {
-    if (isNaN(x))
-      return isNaN(y) ? 0 : 1;
-    if (isNaN(y))
-      return -1;
-    // recall that 0.0 == -0.0, so we convert to infinites and try again
-    if (x == 0 && y == 0)
-      return (int) (1 / x - 1 / y);
-    if (x == y)
-      return 0;
-
-    return x > y ? 1 : -1;
-  }
+  public static native long doubleToRawLongBits (double value);
 
   /**
-   * Helper method to convert to string.
+   * Return the <code>double</code> represented by the long
+   * bits specified.
    *
-   * @param d the double to convert
-   * @param isFloat true if the conversion is requested by Float (results in
-   *        fewer digits)
+   * @param bits the long bits representing a <code>double</code>
+   * @return the <code>double</code> represented by the bits.
+   */
+  public static native double longBitsToDouble (long bits);
+
+  /**
+   * Parse the specified <code>String</code> as a <code>double</code>.
+   *
+   * The number is really read as <em>n * 10<sup>exponent</sup></em>.  The
+   * first number is <em>n</em>, and if there is an "<code>E</code>"
+   * ("<code>e</code>" is also acceptable), then the integer after that is
+   * the exponent.
+   * <P>
+   * Here are the possible forms the number can take:
+   * <BR>
+   * <TABLE BORDER=1>
+   *     <TR><TH>Form</TH><TH>Examples</TH></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]</CODE></TD><TD>345., -10, 12</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;</CODE></TD><TD>40.2, 80.00, -12.30</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]E[+-]&lt;number&gt;</CODE></TD><TD>80E12, -12e+7, 4.E-123</TD></TR>
+   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;E[+-]&lt;number&gt;</CODE></TD><TD>6.02e-22, -40.2E+6, 12.3e9</TD></TR>
+   * </TABLE>
+   *
+   * "<code>[+-]</code>" means either a plus or minus sign may go there, or
+   * neither, in which case + is assumed.
+   * <BR>
+   * "<code>[.]</code>" means a dot may be placed here, but is optional.
+   * <BR>
+   * "<code>&lt;number&gt;</code>" means a string of digits (0-9), basically
+   * an integer.  "<code>&lt;number&gt;.&lt;number&gt;</code>" is basically
+   * a real number, a floating-point value.
+   * <P>
+   *
+   * Remember that a <code>double</code> has a limited range.  If the
+   * number you specify is greater than <code>Double.MAX_VALUE</code> or less
+   * than <code>-Double.MAX_VALUE</code>, it will be set at
+   * <code>Double.POSITIVE_INFINITY</code> or
+   * <code>Double.NEGATIVE_INFINITY</code>, respectively.
+   * <P>
+   * Note also that <code>double</code> does not have perfect precision.  Many
+   * numbers cannot be precisely represented.  The number you specify
+   * will be rounded to the nearest representable value.
+   * <code>Double.MIN_VALUE</code> is the margin of error for
+   * <code>double</code> values.
+   * <P>
+   * If an unexpected character is found in the <code>String</code>, a
+   * <code>NumberFormatException</code> will be thrown.  Spaces are not
+   * allowed, and will cause the same exception.
+   *
+   * @XXX specify where/how we are not in accord with the spec.
+   *
+   * @param str the <code>String</code> to convert
+   * @return the value of the <code>String</code> as a <code>double</code>.
+   * @exception NumberFormatException when the string cannot be parsed to a
+   *            <code>double</code>.
+   * @exception NullPointerException when the string is null.
+   * @see #MIN_VALUE
+   * @see #MAX_VALUE
+   * @see #POSITIVE_INFINITY
+   * @see #NEGATIVE_INFINITY
+   * @since 1.2
    */
-  // Package visible for use by Float.
-  static native String toString(double d, boolean isFloat);
+  public static native double parseDouble (String s)
+    throws NumberFormatException;
 
   /**
-   * Initialize JNI cache.  This method is called only by the
+   * Initialize JNI cache.  This method is called only by the 
    * static initializer when using JNI.
    */
-  private static native void initIDs();
+  private static native void initIDs ();
 }
