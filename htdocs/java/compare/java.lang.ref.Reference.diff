--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/ref/Reference.java	2003-08-21 02:18:38.000000000 -0600
+++ java/lang/ref/Reference.java	2003-08-22 02:18:16.000000000 -0600
@@ -40,7 +40,7 @@
 
 /**
  * This is the base class of all references.  A reference allows
- * refering to an object without preventing the garbage collector from
+ * refering to an object without preventing the garbage collection to
  * collect it.  The only way to get the referred object is via the
  * <code>get()</code>-method.  This method will return
  * <code>null</code> if the object was collected. <br>
@@ -52,11 +52,11 @@
  * There are currently three types of references:  soft reference,
  * weak reference and phantom reference. <br>
  *
- * Soft references will be cleared if the garbage collector is told
+ * Soft references will be cleared if the garbage collection is told
  * to free some memory and there are no unreferenced or weakly referenced
  * objects.  It is useful for caches. <br>
  *
- * Weak references will be cleared as soon as the garbage collector
+ * Weak references will be cleared as soon as the garbage collection
  * determines that the refered object is only weakly reachable.  They
  * are useful as keys in hashtables (see <code>WeakHashtable</code>) as
  * you get notified when nobody has the key anymore.
@@ -74,9 +74,32 @@
 {
   /**
    * The underlying object.  This field is handled in a special way by
-   * the garbage collector.
+   * the garbage collection.
+   * GCJ LOCAL:
+   * This is a RawData because it must be disguised from the GC.
+   * END GCJ LOCAL
    */
-  Object referent;
+  gnu.gcj.RawData referent;
+
+  /**
+   * This is like REFERENT but is not scanned by the GC.  We keep a
+   * copy around so that we can clean up our internal data structure
+   * even after clear() is called.
+   * GCJ LOCAL:
+   * This field doesn't exist in Classpath.
+   * END GCJ LOCAL
+   */
+  gnu.gcj.RawData copy;
+
+  /**
+   * Set to true if {@link #clear()} is called.
+   * GCJ LOCAL:
+   * This field doesn't exist in Classpath.  It is used internally in
+   * natReference.cc, which enqueues the reference unless it is true
+   * (has been cleared).
+   * END GCJ LOCAL
+   */
+  boolean cleared = false;
 
   /**
    * The queue this reference is registered on. This is null, if this
@@ -94,7 +117,7 @@
   Reference nextOnQueue;
 
   /**
-   * This lock should be taken by the garbage collector, before
+   * This lock should be taken by the garbage collection, before
    * determining reachability.  It will prevent the get()-method to
    * return the reference so that reachability doesn't change.
    */
@@ -108,7 +131,7 @@
    */
   Reference(Object ref)
   {
-    referent = ref;
+    create (ref);
   }
 
   /**
@@ -123,18 +146,23 @@
   {
     if (q == null)
       throw new NullPointerException();
-    referent = ref;
     queue = q;
+    create (ref);
   }
 
   /**
+   * Notifies the VM that a new Reference has been created.
+   */
+  private native void create (Object o);
+
+  /**
    * Returns the object, this reference refers to.
    * @return the object, this reference refers to, or null if the 
    * reference was cleared.
    */
   public Object get()
   {
-    synchronized (lock)
+    synchronized(lock)
       {
 	return referent;
       }
@@ -143,12 +171,12 @@
   /**
    * Clears the reference, so that it doesn't refer to its object
    * anymore.  For soft and weak references this is called by the
-   * garbage collector.  For phantom references you should call 
+   * garbage collection.  For phantom references you should call 
    * this when enqueuing the reference.
    */
   public void clear()
   {
-    referent = null;
+    cleared = true;
   }
 
   /**
@@ -162,7 +190,7 @@
 
   /**
    * Enqueue an object on a reference queue.  This is normally executed
-   * by the garbage collector.
+   * by the garbage collection.
    */
   public boolean enqueue() 
   {
