--- /home/tromey/gnu/Nightly/classpath/classpath/java/awt/geom/QuadCurve2D.java	2003-10-22 02:24:24.000000000 -0600
+++ java/awt/geom/QuadCurve2D.java	2003-07-19 02:18:11.000000000 -0600
@@ -1,5 +1,5 @@
 /* QuadCurve2D.java -- represents a parameterized quadratic curve in 2-D space
-   Copyright (C) 2002, 2003 Free Software Foundation
+   Copyright (C) 2002 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -42,361 +42,124 @@
 import java.awt.Shape;
 import java.util.NoSuchElementException;
 
-
 /**
- * A two-dimensional curve that is parameterized with a quadratic
- * function.
- *
- * <p><img src="doc-files/QuadCurve2D-1.png" width="350" height="180"
- * alt="A drawing of a QuadCurve2D" />
- *
- * @author Eric Blake (ebb9@email.byu.edu)
- * @author Sascha Brawer (brawer@dandelis.ch)
- *
- * @since 1.2
+ * STUBS ONLY
+ * XXX Implement and document.
  */
-public abstract class QuadCurve2D
-  implements Shape, Cloneable
+public abstract class QuadCurve2D implements Shape, Cloneable
 {
-  /**
-   * Constructs a new QuadCurve2D. Typical users will want to
-   * construct instances of a subclass, such as {@link
-   * QuadCurve2D.Float} or {@link QuadCurve2D.Double}.
-   */
   protected QuadCurve2D()
   {
   }
 
-
-  /**
-   * Returns the <i>x</i> coordinate of the curve&#x2019;s start
-   * point.
-   */
   public abstract double getX1();
-
-
-  /**
-   * Returns the <i>y</i> coordinate of the curve&#x2019;s start
-   * point.
-   */
   public abstract double getY1();
-
-
-  /**
-   * Returns the curve&#x2019;s start point.
-   */
   public abstract Point2D getP1();
-
-
-  /**
-   * Returns the <i>x</i> coordinate of the curve&#x2019;s control
-   * point.
-   */
   public abstract double getCtrlX();
-
-
-  /**
-   * Returns the <i>y</i> coordinate of the curve&#x2019;s control
-   * point.
-   */
   public abstract double getCtrlY();
-
-
-  /**
-   * Returns the curve&#x2019;s control point.
-   */
   public abstract Point2D getCtrlPt();
-
-
-  /**
-   * Returns the <i>x</i> coordinate of the curve&#x2019;s end
-   * point.
-   */
   public abstract double getX2();
-
-
-  /**
-   * Returns the <i>y</i> coordinate of the curve&#x2019;s end
-   * point.
-   */
   public abstract double getY2();
-
-
-  /**
-   * Returns the curve&#x2019;s end point.
-   */
   public abstract Point2D getP2();
 
-
-  /**
-   * Changes the geometry of the curve.
-   *
-   * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new start
-   * point.
-   *
-   * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new start
-   * point.
-   *
-   * @param cx the <i>x</i> coordinate of the curve&#x2019;s new
-   * control point.
-   *
-   * @param cy the <i>y</i> coordinate of the curve&#x2019;s new
-   * control point.
-   *
-   * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new end
-   * point.
-   *
-   * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new end
-   * point.
-   */
   public abstract void setCurve(double x1, double y1, double cx, double cy,
                                 double x2, double y2);
-
-
   public void setCurve(double[] coords, int offset)
   {
     setCurve(coords[offset++], coords[offset++],
              coords[offset++], coords[offset++],
              coords[offset++], coords[offset++]);
   }
-
-
   public void setCurve(Point2D p1, Point2D c, Point2D p2)
   {
     setCurve(p1.getX(), p1.getY(), c.getX(), c.getY(),
              p2.getX(), p2.getY());
   }
-
-
   public void setCurve(Point2D[] pts, int offset)
   {
     setCurve(pts[offset].getX(), pts[offset++].getY(),
              pts[offset].getX(), pts[offset++].getY(),
              pts[offset].getX(), pts[offset++].getY());
   }
-
-
-  /**
-   * Changes the geometry of the curve to that of another curve.
-   *
-   * @param c the curve whose coordinates will be copied.
-   */
   public void setCurve(QuadCurve2D c)
   {
     setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(),
              c.getX2(), c.getY2());
   }
-
-
   public static double getFlatnessSq(double x1, double y1, double cx,
                                      double cy, double x2, double y2)
   {
-    return Line2D.ptSegDistSq(x1, y1, x2, y2, cx, cy);
+    // XXX Implement.
+    throw new Error("not implemented");
   }
-
-
   public static double getFlatness(double x1, double y1, double cx, double cy,
                                    double x2, double y2)
   {
-    return Line2D.ptSegDist(x1, y1, x2, y2, cx, cy);
+    return Math.sqrt(getFlatnessSq(x1, y1, cx, cy, x2, y2));
   }
-
-
   public static double getFlatnessSq(double[] coords, int offset)
   {
-    return Line2D.ptSegDistSq(coords[offset], coords[offset + 1],
-                              coords[offset + 4], coords[offset + 5],
-                              coords[offset + 2], coords[offset + 3]);
+    return getFlatnessSq(coords[offset++], coords[offset++],
+                         coords[offset++], coords[offset++],
+                         coords[offset++], coords[offset++]);
   }
-
-
   public static double getFlatness(double[] coords, int offset)
   {
-    return Line2D.ptSegDist(coords[offset], coords[offset + 1],
-                            coords[offset + 4], coords[offset + 5],
-                            coords[offset + 2], coords[offset + 3]);
+    return Math.sqrt(getFlatnessSq(coords[offset++], coords[offset++],
+                                   coords[offset++], coords[offset++],
+                                   coords[offset++], coords[offset++]));
   }
-
-
   public double getFlatnessSq()
   {
-    return Line2D.ptSegDistSq(getX1(), getY1(),
-                              getX2(), getY2(),
-                              getCtrlX(), getCtrlY());
+    return getFlatnessSq(getX1(), getY1(), getCtrlX(), getCtrlY(),
+                         getX2(), getY2());
   }
-
-
   public double getFlatness()
   {
-    return Line2D.ptSegDist(getX1(), getY1(),
-                            getX2(), getY2(),
-                            getCtrlX(), getCtrlY());
+    return Math.sqrt(getFlatnessSq(getX1(), getY1(), getCtrlX(), getCtrlY(),
+                                   getX2(), getY2()));
   }
 
-
-  /**
-   * Subdivides this curve into two halves.
-   *
-   * <p><img src="doc-files/QuadCurve2D-3.png" width="700"
-   * height="180" alt="A drawing that illustrates the effects of
-   * subdividing a QuadCurve2D" />
-   *
-   * @param left a curve whose geometry will be set to the left half
-   * of this curve, or <code>null</code> if the caller is not
-   * interested in the left half.
-   *
-   * @param right a curve whose geometry will be set to the right half
-   * of this curve, or <code>null</code> if the caller is not
-   * interested in the right half.
-   */
-  public void subdivide(QuadCurve2D left, QuadCurve2D right)
+  public void subdivide(QuadCurve2D l, QuadCurve2D r)
   {
+    if (l == null)
+      l = new QuadCurve2D.Double();
+    if (r == null)
+      r = new QuadCurve2D.Double();
     // Use empty slots at end to share single array.
     double[] d = new double[] { getX1(), getY1(), getCtrlX(), getCtrlY(),
                                 getX2(), getY2(), 0, 0, 0, 0 };
     subdivide(d, 0, d, 0, d, 4);
-    if (left != null)
-      left.setCurve(d, 0);
-    if (right != null)
-      right.setCurve(d, 4);
+    l.setCurve(d, 0);
+    r.setCurve(d, 4);
   }
-
-
-  /**
-   * Subdivides a quadratic curve into two halves.
-   *
-   * <p><img src="doc-files/QuadCurve2D-3.png" width="700"
-   * height="180" alt="A drawing that illustrates the effects of
-   * subdividing a QuadCurve2D" />
-   *
-   * @param src the curve to be subdivided.
-   *
-   * @param left a curve whose geometry will be set to the left half
-   * of <code>src</code>, or <code>null</code> if the caller is not
-   * interested in the left half.
-   *
-   * @param right a curve whose geometry will be set to the right half
-   * of <code>src</code>, or <code>null</code> if the caller is not
-   * interested in the right half.
-   */
-  public static void subdivide(QuadCurve2D src, QuadCurve2D left,
-                               QuadCurve2D right)
+  public static void subdivide(QuadCurve2D src, QuadCurve2D l, QuadCurve2D r)
   {
-    src.subdivide(left, right);
+    src.subdivide(l, r);
   }
-
-
-  /**
-   * Subdivides a quadratic curve into two halves, passing all
-   * coordinates in an array.
-   *
-   * <p><img src="doc-files/QuadCurve2D-3.png" width="700"
-   * height="180" alt="A drawing that illustrates the effects of
-   * subdividing a QuadCurve2D" />
-   *
-   * <p>The left end point and the right start point will always be
-   * identical. Memory-concious programmers thus may want to pass the
-   * same array for both <code>left</code> and <code>right</code>, and
-   * set <code>rightOff</code> to <code>leftOff + 4</code>.
-   *
-   * @param src an array containing the coordinates of the curve to be
-   * subdivided.  The <i>x</i> coordinate of the start point is
-   * located at <code>src[srcOff]</code>, its <i>y</i> at
-   * <code>src[srcOff + 1]</code>.  The <i>x</i> coordinate of the
-   * control point is located at <code>src[srcOff + 2]</code>, its
-   * <i>y</i> at <code>src[srcOff + 3]</code>.  The <i>x</i>
-   * coordinate of the end point is located at <code>src[srcOff +
-   * 4]</code>, its <i>y</i> at <code>src[srcOff + 5]</code>.
-   *
-   * @param srcOff an offset into <code>src</code>, specifying
-   * the index of the start point&#x2019;s <i>x</i> coordinate.
-   *
-   * @param left an array that will receive the coordinates of the
-   * left half of <code>src</code>. It is acceptable to pass
-   * <code>src</code>. A caller who is not interested in the left half
-   * can pass <code>null</code>.
-   *
-   * @param leftOff an offset into <code>left</code>, specifying the
-   * index where the start point&#x2019;s <i>x</i> coordinate will be
-   * stored.
-   *
-   * @param right an array that will receive the coordinates of the
-   * right half of <code>src</code>. It is acceptable to pass
-   * <code>src</code> or <code>left</code>. A caller who is not
-   * interested in the right half can pass <code>null</code>.
-   *
-   * @param rightOff an offset into <code>right</code>, specifying the
-   * index where the start point&#x2019;s <i>x</i> coordinate will be
-   * stored.
-   */
   public static void subdivide(double[] src, int srcOff,
                                double[] left, int leftOff,
                                double[] right, int rightOff)
   {
-    double x1, y1, xc, yc, x2, y2;
-
-    x1 = src[srcOff];
-    y1 = src[srcOff + 1];
-    xc = src[srcOff + 2];
-    yc = src[srcOff + 3];
-    x2 = src[srcOff + 4];
-    y2 = src[srcOff + 5];
-
-    if (left != null)
-    {
-      left[leftOff] = x1;
-      left[leftOff + 1] = y1;
-    }
-
-    if (right != null)
-    {
-      right[rightOff + 4] = x2;
-      right[rightOff + 5] = y2;
-    }
-
-    x1 = (x1 + xc) / 2;
-    x2 = (xc + x2) / 2;
-    xc = (x1 + x2) / 2;
-    y1 = (y1 + yc) / 2;
-    y2 = (y2 + yc) / 2;
-    yc = (y1 + y2) / 2;
-
-    if (left != null)
-    {
-      left[leftOff + 2] = x1;
-      left[leftOff + 3] = y1;
-      left[leftOff + 4] = xc;
-      left[leftOff + 5] = yc;
-    }
-
-    if (right != null)
-    {
-      right[rightOff] = xc;
-      right[rightOff + 1] = yc;
-      right[rightOff + 2] = x2;
-      right[rightOff + 3] = y2;
-    }
+    // XXX Implement.
+    throw new Error("not implemented");
   }
-
-
   public static int solveQuadratic(double[] eqn)
   {
     return solveQuadratic(eqn, eqn);
   }
-
-
   public static int solveQuadratic(double[] eqn, double[] res)
   {
     double c = eqn[0];
     double b = eqn[1];
     double a = eqn[2];
     if (a == 0)
-    {
-      if (b == 0)
-        return -1;
-      res[0] = -c / b;
-      return 1;
-    }
+      {
+        if (b == 0)
+          return -1;
+        res[0] = -c / b;
+        return 1;
+      }
     c /= a;
     b /= a * 2;
     double det = Math.sqrt(b * b - c);
@@ -404,74 +167,49 @@
       return 0;
     // For fewer rounding errors, we calculate the two roots differently.
     if (b > 0)
-    {
-      res[0] = -b - det;
-      res[1] = -c / (b + det);
-    }
+      {
+        res[0] = -b - det;
+        res[1] = -c / (b + det);
+      }
     else
-    {
-      res[0] = -c / (b - det);
-      res[1] = -b + det;
-    }
+      {
+        res[0] = -c / (b - det);
+        res[1] = -b + det;
+      }
     return 2;
   }
 
-
   public boolean contains(double x, double y)
   {
     // XXX Implement.
     throw new Error("not implemented");
   }
-
-
   public boolean contains(Point2D p)
   {
     return contains(p.getX(), p.getY());
   }
-
-
   public boolean intersects(double x, double y, double w, double h)
   {
     // XXX Implement.
     throw new Error("not implemented");
   }
-
-
   public boolean intersects(Rectangle2D r)
   {
     return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
   }
-
-
   public boolean contains(double x, double y, double w, double h)
   {
     // XXX Implement.
     throw new Error("not implemented");
   }
-
-
   public boolean contains(Rectangle2D r)
   {
     return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
   }
-
-
-  /**
-   * Determines the smallest rectangle that encloses the
-   * curve&#x2019;s start, end and control point. As the illustration
-   * below shows, the invisible control point may cause the bounds to
-   * be much larger than the area that is actually covered by the
-   * curve.
-   *
-   * <p><img src="doc-files/QuadCurve2D-2.png" width="350" height="180"
-   * alt="An illustration of the bounds of a QuadCurve2D" />
-   */
   public Rectangle getBounds()
   {
     return getBounds2D().getBounds();
   }
-
-
   public PathIterator getPathIterator(final AffineTransform at)
   {
     return new PathIterator()
@@ -479,190 +217,115 @@
       /** Current coordinate. */
       private int current = 0;
 
-
       public int getWindingRule()
       {
         return WIND_NON_ZERO;
       }
 
-
       public boolean isDone()
       {
         return current >= 2;
       }
 
-
       public void next()
       {
         current++;
       }
 
-
       public int currentSegment(float[] coords)
       {
         int result;
         switch (current)
-        {
-        case 0:
-          coords[0] = (float) getX1();
-          coords[1] = (float) getY1();
-          result = SEG_MOVETO;
-          break;
-
-        case 1:
-          coords[0] = (float) getCtrlX();
-          coords[1] = (float) getCtrlY();
-          coords[2] = (float) getX2();
-          coords[3] = (float) getY2();
-          result = SEG_QUADTO;
-          break;
-
-        default:
-          throw new NoSuchElementException("quad iterator out of bounds");
-        }
+          {
+          case 0:
+            coords[0] = (float) getX1();
+            coords[1] = (float) getY1();
+            result = SEG_MOVETO;
+            break;
+          case 1:
+            coords[0] = (float) getCtrlX();
+            coords[1] = (float) getCtrlY();
+            coords[2] = (float) getX2();
+            coords[3] = (float) getY2();
+            result = SEG_QUADTO;
+            break;
+          default:
+            throw new NoSuchElementException("quad iterator out of bounds");
+          }
         if (at != null)
           at.transform(coords, 0, coords, 0, 2);
         return result;
       }
 
-
       public int currentSegment(double[] coords)
       {
         int result;
         switch (current)
-        {
-        case 0:
-          coords[0] = getX1();
-          coords[1] = getY1();
-          result = SEG_MOVETO;
-          break;
-
-        case 1:
-          coords[0] = getCtrlX();
-          coords[1] = getCtrlY();
-          coords[2] = getX2();
-          coords[3] = getY2();
-          result = SEG_QUADTO;
-          break;
-
-        default:
-          throw new NoSuchElementException("quad iterator out of bounds");
-        }
+          {
+          case 0:
+            coords[0] = getX1();
+            coords[1] = getY1();
+            result = SEG_MOVETO;
+            break;
+          case 1:
+            coords[0] = getCtrlX();
+            coords[1] = getCtrlY();
+            coords[2] = getX2();
+            coords[3] = getY2();
+            result = SEG_QUADTO;
+            break;
+          default:
+            throw new NoSuchElementException("quad iterator out of bounds");
+          }
         if (at != null)
           at.transform(coords, 0, coords, 0, 2);
         return result;
       }
     };
   }
-
-
   public PathIterator getPathIterator(AffineTransform at, double flatness)
   {
     return new FlatteningPathIterator(getPathIterator(at), flatness);
   }
 
-
   /**
-   * Creates a new curve with the same contents as
+   * Create a new curve of the same run-time type with the same contents as
    * this one.
    *
-   * @return the clone.
+   * @return the clone
+   *
+   * @exception OutOfMemoryError If there is not enough memory available.
+   *
+   * @since 1.2
    */
   public Object clone()
   {
     try
-    {
-      return super.clone();
-    }
+      {
+        return super.clone();
+      }
     catch (CloneNotSupportedException e)
-    {
-      throw (Error) new InternalError().initCause(e); // Impossible
-    }
+      {
+        throw (Error) new InternalError().initCause(e); // Impossible
+      }
   }
 
-
   /**
-   * A two-dimensional curve that is parameterized with a quadratic
-   * function and stores coordinate values in double-precision
-   * floating-point format.
-   *
-   * @see QuadCurve2D.Float
-   *
-   * @author Eric Blake (ebb9@email.byu.edu)
-   * @author Sascha Brawer (brawer@dandelis.ch)
+   * STUBS ONLY
    */
-  public static class Double
-    extends QuadCurve2D
+  public static class Double extends QuadCurve2D
   {
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s start point.
-     */
     public double x1;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s start point.
-     */
     public double y1;
-
-
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s control point.
-     */
     public double ctrlx;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s control point.
-     */
     public double ctrly;
-
-
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s end point.
-     */
     public double x2;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s end point.
-     */
     public double y2;
 
-
-    /**
-     * Constructs a new QuadCurve2D that stores its coordinate values
-     * in double-precision floating-point format. All points are
-     * initially at position (0, 0).
-     */
     public Double()
     {
     }
 
-
-    /**
-     * Constructs a new QuadCurve2D that stores its coordinate values
-     * in double-precision floating-point format, specifying the
-     * initial position of each point.
-     *
-     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s start
-     * point.
-     *
-     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s start
-     * point.
-     *
-     * @param cx the <i>x</i> coordinate of the curve&#x2019;s control
-     * point.
-     *
-     * @param cy the <i>y</i> coordinate of the curve&#x2019;s control
-     * point.
-     *
-     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s end
-     * point.
-     *
-     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public Double(double x1, double y1, double cx, double cy,
                   double x2, double y2)
     {
@@ -674,115 +337,45 @@
       this.y2 = y2;
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s start
-     * point.
-     */
     public double getX1()
     {
       return x1;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s start
-     * point.
-     */
     public double getY1()
     {
       return y1;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s start point.
-     */
     public Point2D getP1()
     {
       return new Point2D.Double(x1, y1);
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s control
-     * point.
-     */
     public double getCtrlX()
     {
       return ctrlx;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s control
-     * point.
-     */
     public double getCtrlY()
     {
       return ctrly;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s control point.
-     */
     public Point2D getCtrlPt()
     {
       return new Point2D.Double(ctrlx, ctrly);
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public double getX2()
     {
       return x2;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public double getY2()
     {
       return y2;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s end point.
-     */
     public Point2D getP2()
     {
       return new Point2D.Double(x2, y2);
     }
 
-
-    /**
-     * Changes the geometry of the curve.
-     *
-     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new
-     * end point.
-     *
-     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new
-     * end point.
-     */
     public void setCurve(double x1, double y1, double cx, double cy,
                          double x2, double y2)
     {
@@ -793,18 +386,6 @@
       this.x2 = x2;
       this.y2 = y2;
     }
-
-
-    /**
-     * Determines the smallest rectangle that encloses the
-     * curve&#x2019;s start, end and control point. As the
-     * illustration below shows, the invisible control point may cause
-     * the bounds to be much larger than the area that is actually
-     * covered by the curve.
-     *
-     * <p><img src="doc-files/QuadCurve2D-2.png" width="350" height="180"
-     * alt="An illustration of the bounds of a QuadCurve2D" />
-     */
     public Rectangle2D getBounds2D()
     {
       double nx1 = Math.min(Math.min(x1, ctrlx), x2);
@@ -813,91 +394,24 @@
       double ny2 = Math.max(Math.max(y1, ctrly), y2);
       return new Rectangle2D.Double(nx1, ny1, nx2 - nx1, ny2 - ny1);
     }
-  }
-
+  } // class Double
 
   /**
-   * A two-dimensional curve that is parameterized with a quadratic
-   * function and stores coordinate values in single-precision
-   * floating-point format.
-   *
-   * @see QuadCurve2D.Double
-   *
-   * @author Eric Blake (ebb9@email.byu.edu)
-   * @author Sascha Brawer (brawer@dandelis.ch)
+   * STUBS ONLY
    */
-  public static class Float
-    extends QuadCurve2D
+  public static class Float extends QuadCurve2D
   {
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s start point.
-     */
     public float x1;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s start point.
-     */
     public float y1;
-
-
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s control point.
-     */
     public float ctrlx;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s control point.
-     */
     public float ctrly;
-
-
-    /**
-     * The <i>x</i> coordinate of the curve&#x2019;s end point.
-     */
     public float x2;
-
-
-    /**
-     * The <i>y</i> coordinate of the curve&#x2019;s end point.
-     */
     public float y2;
 
-
-    /**
-     * Constructs a new QuadCurve2D that stores its coordinate values
-     * in single-precision floating-point format. All points are
-     * initially at position (0, 0).
-     */
     public Float()
     {
     }
 
-
-    /**
-     * Constructs a new QuadCurve2D that stores its coordinate values
-     * in single-precision floating-point format, specifying the
-     * initial position of each point.
-     *
-     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s start
-     * point.
-     *
-     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s start
-     * point.
-     *
-     * @param cx the <i>x</i> coordinate of the curve&#x2019;s control
-     * point.
-     *
-     * @param cy the <i>y</i> coordinate of the curve&#x2019;s control
-     * point.
-     *
-     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s end
-     * point.
-     *
-     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public Float(float x1, float y1, float cx, float cy,
                  float x2, float y2)
     {
@@ -909,116 +423,45 @@
       this.y2 = y2;
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s start
-     * point.
-     */
     public double getX1()
     {
       return x1;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s start
-     * point.
-     */
     public double getY1()
     {
       return y1;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s start point.
-     */
     public Point2D getP1()
     {
       return new Point2D.Float(x1, y1);
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s control
-     * point.
-     */
     public double getCtrlX()
     {
       return ctrlx;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s control
-     * point.
-     */
     public double getCtrlY()
     {
       return ctrly;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s control point.
-     */
     public Point2D getCtrlPt()
     {
       return new Point2D.Float(ctrlx, ctrly);
     }
 
-
-    /**
-     * Returns the <i>x</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public double getX2()
     {
       return x2;
     }
-
-
-    /**
-     * Returns the <i>y</i> coordinate of the curve&#x2019;s end
-     * point.
-     */
     public double getY2()
     {
       return y2;
     }
-
-
-    /**
-     * Returns the curve&#x2019;s end point.
-     */
     public Point2D getP2()
     {
       return new Point2D.Float(x2, y2);
     }
 
-
-    /**
-     * Changes the geometry of the curve, specifying coordinate values
-     * as double-precision floating-point numbers.
-     *
-     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new
-     * end point.
-     *
-     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new
-     * end point.
-     */
     public void setCurve(double x1, double y1, double cx, double cy,
                          double x2, double y2)
     {
@@ -1029,30 +472,6 @@
       this.x2 = (float) x2;
       this.y2 = (float) y2;
     }
-
-
-    /**
-     * Changes the geometry of the curve, specifying coordinate values
-     * as single-precision floating-point numbers.
-     *
-     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new
-     * start point.
-     *
-     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new
-     * control point.
-     *
-     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new
-     * end point.
-     *
-     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new
-     * end point.
-     */
     public void setCurve(float x1, float y1, float cx, float cy,
                          float x2, float y2)
     {
@@ -1063,18 +482,6 @@
       this.x2 = x2;
       this.y2 = y2;
     }
-
-
-    /**
-     * Determines the smallest rectangle that encloses the
-     * curve&#x2019;s start, end and control point. As the
-     * illustration below shows, the invisible control point may cause
-     * the bounds to be much larger than the area that is actually
-     * covered by the curve.
-     *
-     * <p><img src="doc-files/QuadCurve2D-2.png" width="350" height="180"
-     * alt="An illustration of the bounds of a QuadCurve2D" />
-     */
     public Rectangle2D getBounds2D()
     {
       float nx1 = (float) Math.min(Math.min(x1, ctrlx), x2);
@@ -1083,5 +490,5 @@
       float ny2 = (float) Math.max(Math.max(y1, ctrly), y2);
       return new Rectangle2D.Float(nx1, ny1, nx2 - nx1, ny2 - ny1);
     }
-  }
-}
+  } // class Float
+} // class CubicCurve2D
