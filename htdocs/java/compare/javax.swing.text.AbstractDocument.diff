--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/text/AbstractDocument.java	2004-04-29 02:24:29.000000000 -0600
+++ javax/swing/text/AbstractDocument.java	2004-06-18 02:18:59.000000000 -0600
@@ -1,4 +1,4 @@
-/* AbstractDocument.java -- 
+/* AbstractDocument.java --
    Copyright (C) 2002, 2004 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
@@ -37,6 +37,7 @@
 
 package javax.swing.text;
 
+import java.io.Serializable;
 import java.util.Dictionary;
 import java.util.Enumeration;
 import java.util.EventListener;
@@ -44,324 +45,524 @@
 
 import javax.swing.event.DocumentEvent;
 import javax.swing.event.DocumentListener;
+import javax.swing.event.EventListenerList;
 import javax.swing.event.UndoableEditEvent;
 import javax.swing.event.UndoableEditListener;
 import javax.swing.tree.TreeNode;
+import javax.swing.undo.AbstractUndoableEdit;
+import javax.swing.undo.CompoundEdit;
 import javax.swing.undo.UndoableEdit;
 
-public abstract class AbstractDocument implements Document
-{
-    Vector doc_list = new Vector();
-    Vector undo_list = new Vector();
 
-    // these still need to be implemented by a derived class:
-    public abstract  Element getParagraphElement(int pos);
-    public abstract  Element getDefaultRootElement();
-
-    // some inner classes sun says I should have:
-    abstract class AbstractElement implements Element, TreeNode
-    {
-	int count, offset;
-	AttributeSet attr;
-	Vector elts = new Vector();
-	String name;
-	Element parent;
-	Vector kids = new Vector();
-	TreeNode tree_parent;
-	
-	public AbstractElement(Element p, AttributeSet s)
-	{ parent = p; attr = s; }
-
-	public Enumeration children()         { return kids.elements(); }
-	public boolean getAllowsChildren()    { return true; }
-	public TreeNode getChildAt(int index) { return (TreeNode) kids.elementAt(index); }
-	public int getChildCount()            { return kids.size(); }
-	public int getIndex(TreeNode  node)   { return kids.indexOf(node); }
-	public TreeNode getParent()           { return tree_parent; }
-
-	public AttributeSet getAttributes()      { return attr; }
-	public Document getDocument()            { return AbstractDocument.this; }
-	public Element getElement(int index)     { return (Element)elts.elementAt(index); }
-	public String getName()                  { return name; }
-	public Element getParentElement()        { return parent; }
-
-	public abstract boolean isLeaf();
-	public abstract int getEndOffset();
-	public abstract int getElementCount();
-	public abstract int getElementIndex(int offset);
-	public abstract int getStartOffset();
-    }
+public abstract class AbstractDocument
+  implements Document, Serializable
+{
+  public abstract class AbstractElement
+    implements Element, TreeNode, Serializable
+  {
+    private static final long serialVersionUID = 1265312733007397733L;
+    
+    int count;
+    int offset;
+    AttributeSet attr;
+    Vector elts = new Vector();
+    String name;
+    Element parent;
+    Vector kids = new Vector();
+    TreeNode tree_parent;
 
-    interface AttributeContext
+    public AbstractElement(Element p, AttributeSet s)
     {
+      parent = p;
+      attr = s;
     }
 
-    
-    class BranchElement extends AbstractElement
+    public Enumeration children()
     {
-	public BranchElement(Element e, AttributeSet a, int s, int end)
-	{  super(e, a);	}
-
-	public boolean isLeaf() { return false; }
-	public int getEndOffset() {  return 0; }
-	public int getElementCount() { return 0; }
-	public int getElementIndex(int offset) { return 0; }
-	public int getStartOffset() { return 0; }
+      return kids.elements();
     }
-    
-    interface Content
-    {
-        Position createPosition(int offset) throws BadLocationException;
-        int length();
-        UndoableEdit insertString(int where, String str) throws BadLocationException;
-        UndoableEdit remove(int where, int nitems) throws BadLocationException;	
-        String getString(int where, int len) throws BadLocationException;
-        void getChars(int where, int len, Segment txt) throws BadLocationException;
-    }
-    
-    class DefaultDocumentEvent implements DocumentEvent
+
+    public boolean getAllowsChildren()
     {
-	public int len, off;
-	public Document getDocument() { return AbstractDocument.this; }
-	public int getLength() { return len; }
-	public int getOffset() { return off; }
-	public DocumentEvent.EventType getType()  	              { return null; }
-	public DocumentEvent.ElementChange getChange(Element  elem)  { return null; }
+      return true;
     }
-    
-    static class ElementEdit
-    {
-    }    
-    
-    class LeafElement extends AbstractElement
-    {
-	LeafElement(Element e, AttributeSet a, int s, int end)
-	{  super(e, a);	}
 
-	public boolean isLeaf() { return true; }
-	public int getEndOffset() {  return 0; }
-	public int getElementCount() { return 0; }
-	public int getElementIndex(int offset) { return 0; }
-	public int getStartOffset() { return 0; }
+    public TreeNode getChildAt(int index)
+    {
+      return (TreeNode) kids.elementAt(index);
     }
-  
 
-    Content content;
-
-    AbstractDocument(Content doc)
+    public int getChildCount()
     {
-	content = doc;
+      return kids.size();
     }
-    
-    /********************************************************
-     *
-     *  the meat:
-     *
-     ***********/
-    
 
-    public void addDocumentListener(DocumentListener listener)
+    public int getIndex(TreeNode node)
     {
-	doc_list.addElement(listener);
+      return kids.indexOf(node);
     }
-  
-    public void addUndoableEditListener(UndoableEditListener listener)
+
+    public TreeNode getParent()
     {
-	undo_list.addElement(listener);
-    }
- 
-    protected  Element createBranchElement(Element parent, AttributeSet a)
-    {	
-	return new BranchElement(parent, a, 0, 0);
+      return tree_parent;
     }
- 
-    protected  Element createLeafElement(Element parent, AttributeSet a, int p0, int p1)
+
+    public AttributeSet getAttributes()
     {
-	return new LeafElement(parent, a, p0, p1-p0);
+      return attr;
     }
 
-    public Position createPosition(int offs)
+    public Document getDocument()
     {
-	final int a = offs;
-	return new Position() 
-	    {
-		public int getOffset()
-		{
-		    return a; 
-		}
-	    };
+      return AbstractDocument.this;
     }
-  
-    protected void fireChangedUpdate(DocumentEvent e)
+
+    public Element getElement(int index)
     {
+      return (Element) elts.elementAt(index);
     }
- 
-    protected  void fireInsertUpdate(DocumentEvent e)
+
+    public String getName()
     {
+      return name;
     }
- 
-    protected  void fireRemoveUpdate(DocumentEvent e)
+
+    public Element getParentElement()
     {
+      return parent;
     }
- 
-    protected  void fireUndoableEditUpdate(UndoableEditEvent e)
+
+    public abstract boolean isLeaf();
+
+    public abstract int getEndOffset();
+
+    public abstract int getElementCount();
+
+    public abstract int getElementIndex(int offset);
+
+    public abstract int getStartOffset();
+  }
+
+  public interface AttributeContext
+  {
+  }
+
+  public class BranchElement extends AbstractElement
+  {
+    private static final long serialVersionUID = -8595176318868717313L;
+    
+    public BranchElement(Element e, AttributeSet a, int s, int end)
     {
+      super(e, a);
     }
-    int getAsynchronousLoadPriority()
+
+    public boolean isLeaf()
     {
-	return 0;
+      return false;
     }
- 
-    protected  AttributeContext getAttributeContext()
+
+    public int getEndOffset()
     {
-	return null;
+      return 0;
     }
-    
-    Element getBidiRootElement()
+
+    public int getElementCount()
     {
-	return null;
+      return 0;
     }
- 
-    protected Content getContent()
+
+    public int getElementIndex(int offset)
     {
-	return content;
+      return 0;
     }
- 
-    protected  Thread getCurrentWriter()
+
+    public int getStartOffset()
     {
-	return null;
+      return 0;
     }
+  }
 
+  public interface Content
+  {
+    Position createPosition(int offset) throws BadLocationException;
 
-    public Dictionary getDocumentProperties()
-    {
-	return null;
-    }
+    int length();
+
+    UndoableEdit insertString(int where, String str)
+      throws BadLocationException;
+
+    UndoableEdit remove(int where, int nitems) throws BadLocationException;
+
+    String getString(int where, int len) throws BadLocationException;
+
+    void getChars(int where, int len, Segment txt) throws BadLocationException;
+  }
 
-    public Position getEndPosition()
+  public class DefaultDocumentEvent extends CompoundEdit
+    implements DocumentEvent
+  {
+    private static final long serialVersionUID = -7406103236022413522L;
+    
+    public int len;
+    public int off;
+
+    public Document getDocument()
     {
-	return null;
+      return AbstractDocument.this;
     }
 
     public int getLength()
     {
-	return content.length();
+      return len;
     }
-    
-    public EventListener[] getListeners(Class listenerType)
+
+    public int getOffset()
     {
-	return null;
+      return off;
     }
-    
-    public Object getProperty(Object key)
+
+    public DocumentEvent.EventType getType()
     {
-	return null;
+      return null;
     }
 
-    public Element[] getRootElements()
+    public DocumentEvent.ElementChange getChange(Element elem)
     {
-	return null;
+      return null;
     }
+  }
+
+  public static class ElementEdit extends AbstractUndoableEdit
+  {
+    private static final long serialVersionUID = -1216620962142928304L;
+  }
+
+  public class LeafElement extends AbstractElement
+  {
+    private static final long serialVersionUID = 5115368706941283802L;
     
-    public Position getStartPosition()
+    public LeafElement(Element e, AttributeSet a, int s, int end)
     {
-	return null;
+      super(e, a);
     }
 
-    public String getText(int offset, int length)
+    public boolean isLeaf()
     {
-	try {
-	    return content.getString(offset, length);
-	} catch (Exception e) {
-	    System.out.println("Hmmm, fail to getText: " + offset + " -> " + length);
-	    return null;
-	}
+      return true;
     }
-  
-    public void getText(int offset, int length, Segment txt)
-    {
-	String a = getText(offset, length);
 
-	if (a == null)
-	    {
-		txt.offset = 0;
-		txt.count = 0;
-		txt.array  = new char[0];
-		return;
-	    }
-
-	txt.offset = offset;
-	txt.count  = length;
-
-	char chars[] = new char[ a.length() ];
-	
-	a.getChars(0, a.length(), chars, 0);
-	
-	txt.array  = chars;	
-    }
-  
-    public void insertString(int offs, String str, AttributeSet a)
-    {
-	try {
-	    content.insertString(offs, str);	
-	} catch (Exception e) {
-	    System.err.println("FAILED TO INSERT-STRING: " + e + ", at:"+offs);
-	}
-    }
- 
-    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr)
-    {
-    }
- 
-    protected  void postRemoveUpdate(DefaultDocumentEvent chng)
-    {
-    }
-  
-    public void putProperty(Object key, Object value)
+    public int getEndOffset()
     {
+      return 0;
     }
-  
-    public void readLock()
-    {
-    }
-  
-    public void readUnlock()
-    {
-    }
-  
-    public void remove(int offs, int len)
-    {
-    }
-  
-    public void removeDocumentListener(DocumentListener listener)
-    {
-    }
-  
-    public void removeUndoableEditListener(UndoableEditListener listener)
-    {
-    }
- 
-    protected void removeUpdate(DefaultDocumentEvent chng)
+
+    public int getElementCount()
     {
+      return 0;
     }
-  
-    public void render(Runnable r)
+
+    public int getElementIndex(int offset)
     {
+      return 0;
     }
-      
-    void setAsynchronousLoadPriority(int p)
+
+    public int getStartOffset()
     {
+      return 0;
     }
+  }
+
+  private static final long serialVersionUID = -116069779446114664L;
+
+  protected static final String BAD_LOCATION = "document location failure";
+
+  public static final String BidiElementName = "bidi level";
+  public static final String ContentElementName = "content";
+  public static final String ParagraphElementName = "paragraph";
+  public static final String SectionElementName = "section";
+  public static final String ElementNameAttribute = "$ename";
   
-    void setDocumentProperties(Dictionary x)
-    {
-    }
- 
-    protected  void writeLock()
-    {
-    }
- 
-    protected  void writeUnlock()
-    {
-    }
+  Content content;
+
+  protected AbstractDocument(Content doc)
+  {
+    this(doc, null);
+  }
+
+  protected AbstractDocument(Content doc, AttributeContext context)
+  {
+    content = doc;
+  }
+
+  protected EventListenerList listenerList = new EventListenerList();
+
+  // these still need to be implemented by a derived class:
+  public abstract Element getParagraphElement(int pos);
+
+  public abstract Element getDefaultRootElement();
+
+  protected Element createBranchElement(Element parent, AttributeSet a)
+  {
+    return new BranchElement(parent, a, 0, 0);
+  }
+
+  protected Element createLeafElement(Element parent, AttributeSet a, int p0,
+                                      int p1)
+  {
+    return new LeafElement(parent, a, p0, p1 - p0);
+  }
+
+  public Position createPosition(int offs)
+  {
+    final int a = offs;
+    return new Position()
+      {
+	public int getOffset()
+	{
+	  return a;
+	}
+      };
+  }
+
+  protected void fireChangedUpdate(DocumentEvent event)
+  {
+    DocumentListener[] listeners = getDocumentListeners();
+
+    for (int index = 0; index < listeners.length; ++index)
+      listeners[index].changedUpdate(event);
+  }
+
+  protected void fireInsertUpdate(DocumentEvent event)
+  {
+    DocumentListener[] listeners = getDocumentListeners();
+
+    for (int index = 0; index < listeners.length; ++index)
+      listeners[index].insertUpdate(event);
+  }
+
+  protected void fireRemoveUpdate(DocumentEvent event)
+  {
+    DocumentListener[] listeners = getDocumentListeners();
+
+    for (int index = 0; index < listeners.length; ++index)
+      listeners[index].removeUpdate(event);
+  }
+
+  protected void fireUndoableEditUpdate(UndoableEditEvent event)
+  {
+    UndoableEditListener[] listeners = getUndoableEditListeners();
+    
+    for (int index = 0; index < listeners.length; ++index)
+      listeners[index].undoableEditHappened(event);
+  }
+
+  public int getAsynchronousLoadPriority()
+  {
+    return 0;
+  }
+
+  protected AttributeContext getAttributeContext()
+  {
+    return null;
+  }
+
+  public Element getBidiRootElement()
+  {
+    return null;
+  }
+
+  protected Content getContent()
+  {
+    return content;
+  }
+
+  protected Thread getCurrentWriter()
+  {
+    return null;
+  }
+
+  public Dictionary getDocumentProperties()
+  {
+    return null;
+  }
+
+  public Position getEndPosition()
+  {
+    return null;
+  }
+
+  public int getLength()
+  {
+    return content.length();
+  }
+
+  public EventListener[] getListeners(Class listenerType)
+  {
+    return listenerList.getListeners(listenerType);
+  }
+
+  public Object getProperty(Object key)
+  {
+    return null;
+  }
+
+  public Element[] getRootElements()
+  {
+    return null;
+  }
+
+  public Position getStartPosition()
+  {
+    return null;
+  }
+
+  public String getText(int offset, int length)
+  {
+    try
+      {
+	return content.getString(offset, length);
+      }
+    catch (Exception e)
+      {
+	System.out.println("Hmmm, fail to getText: " + offset + " -> "
+	                   + length);
+	return null;
+      }
+  }
+
+  public void getText(int offset, int length, Segment txt)
+  {
+    String a = getText(offset, length);
+
+    if (a == null)
+      {
+	txt.offset = 0;
+	txt.count = 0;
+	txt.array = new char[0];
+	return;
+      }
+
+    txt.offset = offset;
+    txt.count = length;
+
+    char[] chars = new char[a.length()];
+
+    a.getChars(0, a.length(), chars, 0);
+
+    txt.array = chars;
+  }
+
+  public void insertString(int offs, String str, AttributeSet a)
+    throws BadLocationException
+  {
+    content.insertString(offs, str);
+  }
+
+  protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr)
+  {
+  }
+
+  protected void postRemoveUpdate(DefaultDocumentEvent chng)
+  {
+  }
+
+  public void putProperty(Object key, Object value)
+  {
+  }
+
+  public void readLock()
+  {
+  }
+
+  public void readUnlock()
+  {
+  }
+
+  public void remove(int offs, int len)
+  {
+  }
+
+  /**
+   * Adds a <code>DocumentListener</code> object to this document.
+   *
+   * @param listener the listener to add
+   */
+  public void addDocumentListener(DocumentListener listener)
+  {
+    listenerList.add(DocumentListener.class, listener);
+  }
+
+  /**
+   * Removes a <code>DocumentListener</code> object from this document.
+   *
+   * @param listener the listener to remove
+   */
+  public void removeDocumentListener(DocumentListener listener)
+  {
+    listenerList.remove(DocumentListener.class, listener);
+  }
+
+  /**
+   * Returns add added <code>DocumentListener</code> objects.
+   *
+   * @return an array of listeners
+   */
+  public DocumentListener[] getDocumentListeners()
+  {
+    return (DocumentListener[]) getListeners(DocumentListener.class);
+  }
+
+  /**
+   * Adds a <code>UndoableEditListener</code> object to this document.
+   *
+   * @param listener the listener to add
+   */
+  public void addUndoableEditListener(UndoableEditListener listener)
+  {
+    listenerList.add(UndoableEditListener.class, listener);
+  }
+
+  /**
+   * Removes a <code>UndoableEditListener</code> object from this document.
+   *
+   * @param listener the listener to remove
+   */
+  public void removeUndoableEditListener(UndoableEditListener listener)
+  {
+    listenerList.remove(UndoableEditListener.class, listener);
+  }
+
+  /**
+   * Returns add added <code>UndoableEditListener</code> objects.
+   *
+   * @return an array of listeners
+   */
+  public UndoableEditListener[] getUndoableEditListeners()
+  {
+    return (UndoableEditListener[]) getListeners(UndoableEditListener.class);
+  }
+
+  protected void removeUpdate(DefaultDocumentEvent chng)
+  {
+  }
+
+  public void render(Runnable r)
+  {
+  }
+
+  public void setAsynchronousLoadPriority(int p)
+  {
+  }
+
+  public void setDocumentProperties(Dictionary x)
+  {
+  }
+
+  protected void writeLock()
+  {
+  }
+
+  protected void writeUnlock()
+  {
+  }
 }
