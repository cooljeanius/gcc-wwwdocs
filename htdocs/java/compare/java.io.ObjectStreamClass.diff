--- /home/tromey/gnu/classpath/classpath/java/io/ObjectStreamClass.java	Mon Mar 25 00:05:17 2002
+++ java/io/ObjectStreamClass.java	Tue Jan 22 16:01:33 2002
@@ -44,17 +44,18 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
 import java.security.DigestOutputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Hashtable;
 import java.util.Vector;
 import gnu.java.io.NullOutputStream;
 import gnu.java.lang.reflect.TypeSignature;
-import gnu.classpath.Configuration;
+import gnu.java.security.provider.Gnu;
+
 
 public class ObjectStreamClass implements Serializable
 {
@@ -75,19 +76,6 @@
     if (! (Serializable.class).isAssignableFrom (cl))
       return null;
 
-    return lookupForClassObject (cl);
-  }
-
-  /**
-   * This lookup for internal use by ObjectOutputStream.  Suppose
-   * we have a java.lang.Class object C for class A, though A is not
-   * serializable, but it's okay to serialize C.
-   */
-  static ObjectStreamClass lookupForClassObject (Class cl)
-  {
-    if (cl == null)
-      return null;
-
     ObjectStreamClass osc = (ObjectStreamClass)classLookupTable.get (cl);
 
     if (osc != null)
@@ -260,12 +248,6 @@
   }
 
 
-  final boolean isProxyClass()
-  {
-    return _isProxyClass;
-  }
-
-
   ObjectStreamClass (String name, long uid, byte flags,
 		     ObjectStreamField[] fields)
   {
@@ -275,19 +257,27 @@
     this.fields = fields;
   }
 
-
-  void setClass (Class clazz)
+  void setClass (Class cl) throws InvalidClassException
   {
-    _isProxyClass = Proxy.isProxyClass(clazz);
-    this.clazz = clazz;
-    ObjectStreamClass osc = (ObjectStreamClass)classLookupTable.get (clazz);
-    if (osc == null)
-      classLookupTable.put (clazz, this);
-    superClass = lookupForClassObject (clazz.getSuperclass ());
-    calculateOffsets ();
+    this.clazz = cl;
+    long class_uid = getClassUID (cl);
+    if (uid == 0)
+      {
+       uid = class_uid;
+       return;
+      }
+    
+    // Check that the actual UID of the resolved class matches the UID from 
+    // the stream.    
+    if (uid != class_uid)
+      {
+       String msg = cl + 
+	 ": Local class not compatible: stream serialVersionUID="
+	 + uid + ", local serialVersionUID=" + class_uid;
+       throw new InvalidClassException (msg);
+      }
   }
 
-
   void setSuperclass (ObjectStreamClass osc)
   {
     superClass = osc;
@@ -338,15 +328,12 @@
   {
     uid = 0;
     flags = 0;
-    _isProxyClass = Proxy.isProxyClass (cl);
 
     clazz = cl;
     name = cl.getName ();
     setFlags (cl);
     setFields (cl);
-    // to those class nonserializable, its uid field is 0
-    if ( (Serializable.class).isAssignableFrom (cl) )
-      setUID (cl);
+    uid = getClassUID (cl);
     superClass = lookup (cl.getSuperclass ());
   }
 
@@ -426,14 +413,7 @@
       if (all_fields[from] != null)
       {
 	Field f = all_fields[from];
-	String name = f.getName();
-	// here is a hack to interoperate with JDK
-	/* if Throwable is not align with serialized form of Java API spec,
-	   you should uncomment the following two line.
-	   if (name.equals("message") && getName().equals("java.lang.Throwable"))
-           name = "detailMessage";
-	*/
-	fields[to] = new ObjectStreamField (name, f.getType ());
+	fields[to] = new ObjectStreamField (f.getName (), f.getType ());
 	to++;
       }
 
@@ -441,33 +421,46 @@
     calculateOffsets ();
   }
 
-  // Sets uid to be serial version UID defined by class, or if that
+  // Returns the serial version UID defined by class, or if that
   // isn't present, calculates value of serial version UID.
-  private void setUID (Class cl)
+  private long getClassUID (Class cl)
   {
     try
     {
       Field suid = cl.getDeclaredField ("serialVersionUID");
       int modifiers = suid.getModifiers ();
 
-      if (Modifier.isStatic (modifiers)
-	  && Modifier.isFinal (modifiers))
-      {
-	uid = getDefinedSUID (cl);
-	return;
-      }
+      if (Modifier.isStatic (modifiers) && Modifier.isFinal (modifiers))
+	return suid.getLong (null);	  
     }
     catch (NoSuchFieldException ignore)
-    {}
+    {
+    }
+    catch (IllegalAccessException ignore)
+    {
+    }
 
     // cl didn't define serialVersionUID, so we have to compute it
     try
     {
-      MessageDigest md = MessageDigest.getInstance ("SHA");
-      DigestOutputStream digest_out =
-	new DigestOutputStream (nullOutputStream, md);
-      DataOutputStream data_out = new DataOutputStream (digest_out);
+      MessageDigest md = null;
+      DigestOutputStream digest_out = null;
+      DataOutputStream data_out = null;
 
+      try 
+	{
+	  md = MessageDigest.getInstance ("SHA");
+	}
+      catch (NoSuchAlgorithmException e)
+	{
+	  // If a provider already provides SHA, use it; otherwise, use this.
+	  Gnu gnuProvider = new Gnu();
+	  Security.addProvider(gnuProvider);
+	  md = MessageDigest.getInstance ("SHA");
+	}
+
+      digest_out = new DigestOutputStream (nullOutputStream, md);
+      data_out = new DataOutputStream (digest_out);
       data_out.writeUTF (cl.getName ());
 
       int modifiers = cl.getModifiers ();
@@ -566,7 +559,7 @@
       for (int i=0; i < len; i++)
 	result += (long)(sha[i] & 0xFF) << (8 * i);
 
-      uid = result;
+      return result;
     }
     catch (NoSuchAlgorithmException e)
     {
@@ -579,31 +572,6 @@
     }
   }
 
-
-  // Returns the value of CLAZZ's final static long field named
-  // `serialVersionUID'.
-  private long getDefinedSUID (Class clazz)
-  {
-    long l = 0;
-    try
-      {
-	// Use getDeclaredField rather than getField, since serialVersionUID
-	// may not be public AND we only want the serialVersionUID of this
-	// class, not a superclass or interface.
-	Field f = clazz.getDeclaredField ("serialVersionUID");
-	l = f.getLong (null);
-      }
-    catch (java.lang.NoSuchFieldException e)
-      {
-      }
-
-    catch (java.lang.IllegalAccessException e)
-      {
-      }
-
-    return l;
-  }
-
   // Returns the value of CLAZZ's private static final field named
   // `serialPersistentFields'.
   private ObjectStreamField[] getSerialPersistentFields (Class clazz)
@@ -638,12 +606,6 @@
 
     try
       {
-	/*
-	 * There exists a problem here, JDK run of 
-	 * clazz.getDeclaredMethod ("<clinit>", classArgs);
-	 * will always throw NoSuchMethodException, even the static 
-	 * intializer does exist.
-	 */
 	Class classArgs[] = {};
 	m = clazz.getDeclaredMethod ("<clinit>", classArgs);
       }
@@ -678,19 +640,9 @@
   int primFieldSize = -1;  // -1 if not yet calculated
   int objectFieldCount;
 
-  boolean _isProxyClass = false;
-
   // This is probably not necessary because this class is special cased already
   // but it will avoid showing up as a discrepancy when comparing SUIDs.
   private static final long serialVersionUID = -6120832682080437368L;
-
-  static
-  {
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javaio");
-      }
-  }
 }
 
 
