--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/ObjectStreamClass.java	2003-12-03 02:20:26.000000000 -0700
+++ java/io/ObjectStreamClass.java	2003-12-24 02:18:18.000000000 -0700
@@ -325,86 +325,84 @@
     isProxyClass = clazz != null && Proxy.isProxyClass (clazz);
     this.superClass = superClass;
     calculateOffsets ();
-    
+
     try
       {
-	ObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);  
-
-	if (exportedFields == null)
-	  return;
-
-	ObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];
-	int i, j, k;
-
-	/* We now check the import fields against the exported fields.
-	 * There should not be contradiction (e.g. int x and String x)
-	 * but extra virtual fields can be added to the class.
-	 */
+        ObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);
 
-	Arrays.sort(exportedFields);
+        if (exportedFields == null)
+          return;
 
-	i = 0; j = 0; k = 0;
-	while (i < fields.length && j < exportedFields.length)
-	{
-	  int comp = fields[i].getName().compareTo (exportedFields[j].getName());
+        ObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];
+        int i, j, k;
 
-	  if (comp < 0)
-	    {
-	      newFieldList[k] = fields[i];
-	      fields[i].setPersistent(false);
-	      fields[i].setToSet(false);
-	      i++;
-	    }
-	  else if (comp > 0)
-	    {
-	      /* field not found in imported fields. We add it
-	       * in the list of supported fields.
-	       */
-	      newFieldList[k] = exportedFields[j];
-	      newFieldList[k].setPersistent(true);
-	      newFieldList[k].setToSet(false);
-	      j++;
-	    }
-	  else
-	    {
-	      if (!fields[i].getType().equals (exportedFields[j].getType()))
-		throw new InvalidClassException (
-			    "serialPersistentFields must be compatible with" +
-			    " imported fields (about " + fields[i].getName() + ")");
-	      newFieldList[k] = fields[i];
-	      fields[i].setPersistent(true);
-	      i++;
-	      j++;
-	    }
-	  k++;
-	}
+        /* We now check the import fields against the exported fields.
+         * There should not be contradiction (e.g. int x and String x)
+         * but extra virtual fields can be added to the class.
+         */
+
+        Arrays.sort(exportedFields);
+
+        i = 0; j = 0; k = 0;
+        while (i < fields.length && j < exportedFields.length)
+          {
+            int comp = fields[i].getName().compareTo (exportedFields[j].getName());
+            if (comp < 0)
+              {
+                newFieldList[k] = fields[i];
+                fields[i].setPersistent(false);
+                fields[i].setToSet(false);
+                i++;
+              }
+            else if (comp > 0)
+              {
+                /* field not found in imported fields. We add it
+                 * in the list of supported fields.
+                 */
+                newFieldList[k] = exportedFields[j];
+                newFieldList[k].setPersistent(true);
+                newFieldList[k].setToSet(false);
+                j++;
+              }
+            else
+              {
+                if (!fields[i].getType().equals (exportedFields[j].getType()))
+                  throw new InvalidClassException ("serialPersistentFields must be compatible with" +
+                                                   " imported fields (about " + fields[i].getName() + ")");
+                newFieldList[k] = fields[i];
+                fields[i].setPersistent(true);
+                i++;
+                j++;
+              }
+            k++;
+          }
+
+        if (i < fields.length)
+          for (; i < fields.length; i++, k++)
+            {
+              fields[i].setPersistent(false);
+              fields[i].setToSet(false);
+              newFieldList[k] = fields[i];
+            }
+          else
+            if (j < exportedFields.length)
+              for (; j < exportedFields.length; j++, k++)
+                {
+                  exportedFields[j].setPersistent(true);
+                  exportedFields[j].setToSet(false);
+                  newFieldList[k] = exportedFields[j];
+               }
 
-	if (i < fields.length)
-	  for (;i<fields.length;i++,k++)
-	  {
-	    fields[i].setPersistent(false);
-	    fields[i].setToSet(false);
-	    newFieldList[k] = fields[i];
-	  }
-	else
-	  if (j < exportedFields.length)
-	    for (;j<exportedFields.length;j++,k++)
-	      {
-		exportedFields[j].setPersistent(true);
-		exportedFields[j].setToSet(false);
-		newFieldList[k] = exportedFields[j];
-	      }
-	
-	fields = new ObjectStreamField[k];
-	System.arraycopy (newFieldList, 0, fields, 0, k);
+        fields = new ObjectStreamField[k];
+        System.arraycopy (newFieldList, 0, fields, 0, k);
       }
     catch (NoSuchFieldException ignore)
       {
-	return;
+        return;
       }
     catch (IllegalAccessException ignore)
       {
-	return;
+        return;
       }
   }
 
@@ -518,15 +516,19 @@
 	  && Modifier.isPrivate (modifiers))
       {
 	fields = getSerialPersistentFields (cl);
-	Arrays.sort (fields);
-	calculateOffsets ();
-	return;
+	if (fields != null)
+	  {
+	    Arrays.sort(fields);
+	    calculateOffsets();
+	    return;
+	  }
       }
     }
     catch (NoSuchFieldException ignore)
-      {}
+    {}
     catch (IllegalAccessException ignore)
-      {}
+      {
+      }
 
     int num_good_fields = 0;
     Field[] all_fields = cl.getDeclaredFields ();
@@ -701,18 +703,41 @@
     }
   }
 
-  // Returns the value of CLAZZ's private static final field named
-  // `serialPersistentFields'.
-  private ObjectStreamField[] getSerialPersistentFields (Class clazz) 
+  /**
+   * Returns the value of CLAZZ's private static final field named
+   * `serialPersistentFields'. It performs some sanity checks before
+   * returning the real array. Besides, the returned array is a clean
+   * copy of the original. So it can be modified.
+   *
+   * @param clazz Class to retrieve 'serialPersistentFields' from.
+   * @return The content of 'serialPersistentFields'.
+   */
+  private ObjectStreamField[] getSerialPersistentFields (Class clazz)
     throws NoSuchFieldException, IllegalAccessException
   {
-    ObjectStreamField[] o = null;
+    ObjectStreamField[] fieldsArray = null;
+    ObjectStreamField[] o;
 
     // Use getDeclaredField rather than getField for the same reason
     // as above in getDefinedSUID.
-    Field f = clazz.getDeclaredField ("serialPersistentFields");
+    Field f = clazz.getDeclaredField("serialPersistentFields");
     f.setAccessible(true);
-    return (ObjectStreamField[])f.get (null);
+
+    int modifiers = f.getModifiers();
+    if (!(Modifier.isStatic(modifiers)
+	&& Modifier.isFinal(modifiers)
+	&& Modifier.isPrivate(modifiers)))
+      return null;
+    
+    o = (ObjectStreamField[]) f.get(null);
+    
+    if (o == null)
+      return null;
+
+    fieldsArray = new ObjectStreamField[o.length];
+    System.arraycopy(o, 0, fieldsArray, 0, o.length);
+    
+    return fieldsArray;
   }
 
   public static final ObjectStreamField[] NO_FIELDS = {};
