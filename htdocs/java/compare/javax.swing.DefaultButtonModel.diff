--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/DefaultButtonModel.java	2004-01-28 02:27:14.000000000 -0700
+++ javax/swing/DefaultButtonModel.java	2003-06-13 02:27:42.000000000 -0600
@@ -1,5 +1,5 @@
 /* DefaultButtonModel.java -- 
-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   Copyright (C) 2002 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -35,10 +35,9 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package javax.swing;
 
-import java.awt.AWTEvent;
-import java.awt.AWTEventMulticaster;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 import java.awt.event.ItemEvent;
@@ -50,412 +49,130 @@
 import javax.swing.event.ChangeListener;
 import javax.swing.event.EventListenerList;
 
-/**
- * The purpose of this class is to model the dynamic state of an abstract
- * button. The concrete button type holding this state may be a a "toggle"
- * button (checkbox, radio button) or a "push" button (menu button, button).
- * 
- * Any change to the model's properties will trigger the firing of a
- * ChangeEvent.
- *
- * Any change to the "pressed" property will trigger the firing of an
- * ItemEvent in addition to ChangeEvent.
- *
- * Any change which causes the enabled, armed and pressed properties to
- * simultaneously become <code>true</code> will trigger the firing of an
- * ActionEvent in addition to the ChangeEvent.
- *
- * @author Graydon Hoare (graydon&064;redhat.com)
- */
-public class DefaultButtonModel implements ButtonModel, Serializable
+public class DefaultButtonModel
+  implements ButtonModel, Serializable
 {
   static final long serialVersionUID = -5342609566534980231L;
 
-  /** Indicates that the button is <em>partially</em> committed to being
-   pressed, but not entirely. This usually happens when a user has pressed
-   but not yet released the mouse button. */
-  static int ARMED = 1;
-
-  /** State constant indicating that the button is enabled. Buttons cannot
-   be pressed or selected unless they are enabled. */
-  static int ENABLED = 2;
-
-  /** State constant indicating that the button has been fully
-   pressed. This usually happens when a user has released the mouse over a
-   previously "armed" button. */
-  static int PRESSED = 4;
-
-  /** State constant indicating that the mouse is currently positioned over
-      the button. */
-  static int ROLLOVER = 8;
-
-  /** State constant indicating that the button is selected. This constant
-      is only meaningful for toggle-type buttons (radio buttons,
-      checkboxes). */
-  static int SELECTED = 16;
-
-  /** Represents the "state properties" (armed, enabled, pressed, rollover
-      and selected) by a bitwise combination of integer constants. */
-  int stateMask;
-
-  /** List of ItemListeners, ChangeListeners, and ActionListeners
-      registered on this model. */
-  EventListenerList listenerList;
-
-  /** The single ChangeEvent this model (re)uses to call its
-      ChangeListeners. */
-  ChangeEvent changeEvent;
+    Vector actions          = new Vector();
 
-  /** The group this model belongs to. Only one button in a group may be
-      selected at any given time. */
+    Vector items    = new Vector();
+    Vector changes  = new Vector();
     ButtonGroup group;
+    JComponent comp;
+
+    
+    DefaultButtonModel(JComponent a)
+    {
+	comp = a;
+    }
+
 
-  /** The key code (one of {@link java.awt.event.KeyEvent} VK_*) used to
-      press this button via a keyboard interface. */
-  int mnemonic;
-
-  /** The string used as the "command" property of any ActionEvent this
-      model sends. */
-  String actionCommand;
-
-  public DefaultButtonModel()
-  {
-    stateMask = 0;
-    listenerList = new EventListenerList();    
-    changeEvent = new ChangeEvent(this);
-  }
-
-  /**
-   * Return <code>null</code>. Use {@link AbstractButton} if you wish to
-   * interface with a button via an {@link ItemSelectable} interface.
-   *
-   * @return <code>null</code>
-   */
     public Object[] getSelectedObjects()
     {
 	return null;
     }
 
-  /**
-   * Add an ActionListener to the model. Usually only called to subscribe
-   * an AbstractButton's listener to the model.
-   *
-   * @param l The listener to add
-   */
-  public void addActionListener(ActionListener l)
+
+    public void fireItemStateChanged(ItemEvent event)
+    {
+	for (int i=0;i<items.size();i++)
 	    {
-    listenerList.add(ActionListener.class, l);
+		ItemListener a = (ItemListener) items.get(i);
+		a.itemStateChanged(event);
+	    }
     }
-
-  /**
-   * Remove an ActionListener to the model. Usually only called to
-   * unsubscribe an AbstractButton's listener to the model.
-   *
-   * @param l The listener to remove
-   */
-  public void removeActionListener(ActionListener l)
-  {
-    listenerList.remove(ActionListener.class, l);
-  }
-
-  /**
-   * Add an ItemListener to the model. Usually only called to subscribe
-   * an AbstractButton's listener to the model.
-   *
-   * @param l The listener to add
-   */
-  public void addItemListener(ItemListener l)
-  {
-    listenerList.add(ItemListener.class, l);
-  }
-
-  /**
-   * Remove an ItemListener to the model. Usually only called to
-   * unsubscribe an AbstractButton's listener to the model.
-   *
-   * @param l The listener to remove
-   */
-  public void removeItemListener(ItemListener l)
-  {
-    listenerList.remove(ItemListener.class, l);
-  }
-
-  /**
-   * Add a ChangeListener to the model. Usually only called to subscribe
-   * an AbstractButton's listener to the model.
-   *
-   * @param l The listener to add
-   */
-  public void addChangeListener(ChangeListener l)
-  {
-    listenerList.add(ChangeListener.class, l);
-  }
-
-  /**
-   * Remove a ChangeListener to the model. Usually only called to
-   * unsubscribe an AbstractButton's listener to the model.
-   *
-   * @param l The listener to remove
-   */
-  public void removeChangeListener(ChangeListener l)
-  {
-    listenerList.remove(ChangeListener.class, l);
-  }
-
-  /**
-   * Inform each ItemListener in the {@link listenerList} that an ItemEvent
-   * has occurred. This happens in response to any change to the {@link
-   * stateMask} field.
-   *
-   * @param e The ItemEvent to fire
-   */
-  public void fireItemStateChanged(ItemEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ItemListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ItemListener)ll[i]).itemStateChanged(e);
-  }
-
-  /**
-   * Inform each ActionListener in the {@link listenerList} that an
-   * ActionEvent has occurred. This happens in response to the any change
-   * to the {@link stateMask} field which makes the enabled, armed and
-   * pressed properties all simultaneously <code>true</code>.
-   *
-   * @param e The ActionEvent to fire
-   */
-  public void fireActionPerformed(ActionEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ActionListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ActionListener)ll[i]).actionPerformed(e);
-  }
-
-  /**
-   * Inform each ChangeListener in the {@link listenerList} that a
-   * ChangeEvent has occurred. This happens in response to the any change
-   * to a property of the model.
-   *
-   * @param event The ChangeEvent to fire
-   */
-  public void fireStateChanged(ChangeEvent e)
-  {
-    EventListener[] ll = listenerList.getListeners(ChangeListener.class);
-    for (int i = 0; i < ll.length; i++)
-      ((ChangeListener)ll[i]).stateChanged(e);
-  }
-
-  /**
-   * Helper method to fire a ChangeEvent with the model as the event's
-   * source.
-   */
-  protected void changeState(int stateflag, boolean b)
+    public void fireStateChanged(ChangeEvent event)
     {
-    int oldstate = stateMask;
-    int newstate;
-
-    if (b)
-      newstate = oldstate | stateflag;
-    else
-      newstate = oldstate & ~stateflag;
-
-    if (oldstate == newstate)
-      return;
-
-    stateMask = newstate;
-
-    fireStateChanged(changeEvent);
-
-    if ((newstate & ENABLED) == 0)
-      return;
-
-    if ((oldstate & SELECTED) == 0
-        && (newstate & SELECTED) == SELECTED)
-      fireItemStateChanged(new ItemEvent(this, ItemEvent.ITEM_STATE_CHANGED, 
-                                         null, ItemEvent.SELECTED));
-
-    else if ((oldstate & SELECTED) == SELECTED
-             && (newstate & SELECTED) == 0)
-      fireItemStateChanged(new ItemEvent(this, ItemEvent.ITEM_STATE_CHANGED, 
-                                         null, ItemEvent.DESELECTED));
-
-    else if ((newstate & ARMED) == ARMED
-             && (newstate & PRESSED) == PRESSED)
+	for (int i=0;i<changes.size();i++)
 	    {
-        fireActionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
-                                            actionCommand));
-        stateMask = stateMask & ~(PRESSED | ARMED);
+		ChangeListener a = (ChangeListener) changes.get(i);
+		a.stateChanged(event);
 	    }
-    
     }
-
-  /**
-   * Get the value of the model's "armed" property.
-   * 
-   * @return The current "armed" property 
-   */
-  public boolean isArmed()
+    public void fireActionPerformed(ActionEvent event)
+    {
+	for (int i=0;i<actions.size();i++)
 	    {
-    return (stateMask & ARMED) == ARMED;
+		ActionListener a = (ActionListener) actions.get(i);
+		a.actionPerformed(event);
+	    }
     }
 
-  /**
-   * Set the value of the model's "armed" property.
-   *
-   * @param a The new "armed" property
-   */
-  public void setArmed(boolean a)
-  {
-    changeState(ARMED, a);
-  }
-
-  /**
-   * Get the value of the model's "enabled" property.
-   *
-   * @return The current "enabled" property.
-   */
-  public boolean isEnabled()
+    boolean arm;
+    public boolean isArmed()          { return arm; }
+    public void setArmed(boolean b)   { arm = b; }
+
+    boolean enabled = true;
+    public boolean isEnabled()         { return enabled; }
+    public void setEnabled(boolean b)  { enabled = b; }
+
+    boolean pressed;
+    public void setPressed(boolean b)  
     {
-    return (stateMask & ENABLED) == ENABLED;
+	pressed = b; 
     }
+    public boolean isPressed()         { return pressed; }
 
-  /**
-   * Set the value of the model's "enabled" property.
-   *
-   * @param e The new "enabled" property
-   */
-  public void setEnabled(boolean e)
-  {
-    changeState(ENABLED, e);
-  }
-
-  /**
-   * Set the value of the model's "pressed" property.
-   *
-   * @param p The new "pressed" property
-   */
-  public void setPressed(boolean p)
+
+    public void removeActionListener(ActionListener l) { actions.removeElement(l); }
+    public void addActionListener(ActionListener l)    
     {	
-    changeState(PRESSED, p);
+	//	comp.enableEvents( AWTEvent.ACTION_EVENT_MASK );
+	actions.addElement(l);    
     }
 
-  /**
-   * Get the value of the model's "pressed" property.
-   *
-   * @return The current "pressed" property
-   */
-  public boolean isPressed()
-  {
-    return (stateMask & PRESSED) == PRESSED;
-  }
-
-  /**
-   * Set the value of the model's "rollover" property.
-   *
-   * @param r The new "rollover" property
-   */
-  public void setRollover(boolean r)
-  {
-    changeState(ROLLOVER, r);
-  }
-
-
-  /**
-   * Set the value of the model's "selected" property.
-   *
-   * @param s The new "selected" property
-   */
-  public void setSelected(boolean s)
-  {
-    changeState(SELECTED, s);
-  }
-
-  /**
-   * Get the value of the model's "selected" property.
-   *
-   * @return The current "selected" property
-   */
-  public boolean isSelected()
-  {
-    return (stateMask & SELECTED) == SELECTED;
-  }
-
-  /**
-   * Get the value of the model's "rollover" property.
-   *
-   * @return The current "rollover" property
-   */
-  public boolean isRollover()
+    public void addItemListener(ItemListener l)        { items.addElement(l); }
+    public void removeItemListener(ItemListener l)     { items.removeElement(l); }
+
+    public void addChangeListener(ChangeListener l)    { changes.addElement(l); }
+    public void removeChangeListener(ChangeListener l) { changes.removeElement(l); }
+
+    boolean roll;
+    public void setRollover(boolean b) { roll = b; }
+    public boolean isRollover()        { return roll; }
+
+    int mne;  
+    public int  getMnemonic()        { return mne; }
+    public void setMnemonic(int key) { mne = key; }
+
+    String com;
+    public void setActionCommand(String s) { com = s; }
+    public String getActionCommand()       { return com; }
+
+    public void setGroup(ButtonGroup group)
     {
-    return (stateMask & ROLLOVER) == ROLLOVER;
+	this.group = group;
     }
 
-  /**
-   * Get the value of the model's "mnemonic" property.
-   *
-   * @return The current "mnemonic" property
-   */
-  public int getMnemonic()
+    boolean sel;
+    public void setSelected(boolean b) 
     { 
-    return mnemonic;
-  }
-
-  /**
-   * Set the value of the model's "mnemonic" property.
-   *
-   * @param key The new "mnemonic" property
-   */
-  public void setMnemonic(int key)
+	if (group != null)
 	    {
-    if (mnemonic != key)
+		if (b == true)
 		    {
-        mnemonic = key;
-        fireStateChanged(changeEvent);
+			System.out.println("selected button in group:"+this);
+			group.setSelected(this, b);
+			sel = true;
 		    }
-  }
-
-  /**
-   * Set the value of the model's "actionCommand" property. This property
-   * is used as the "command" property of the {@link ActionEvent} fired
-   * from the model.
-   *
-   * @param s The new "actionCommand" property.
-   */
-  public void setActionCommand(String s)
+		else
 		    {
-    if (actionCommand != s)
-      {
-        actionCommand = s;
-        fireStateChanged(changeEvent);
+			System.out.println("deselected button in group: " + this);
+			sel = false;
 		    }
 	    } 
-
-  /**
-   * Set the value of the model's "actionCommand" property. This property
-   * is used as the "command" property of the {@link ActionEvent} fired
-   * from the model.
-   *
-   * @return The current "actionCommand" property
-   */
-  public String getActionCommand()
+	else
 	    {
-    return actionCommand;
-  }
-
-  /**
-   * Set the value of the model's "group" property. The model is said to be
-   * a member of the {@link ButtonGroup} held in its "group" property, and
-   * only one models in a given group can have their "selected" property be
-   * <code>true</code> at a time.
-   *
-   * @param g The new "group" property
-   */
-  public void setGroup(ButtonGroup g)
-  {
-    if (group != g)
-      {
-        group = g;
-        fireStateChanged(changeEvent);
+		sel = b;
 	    }
     }
+    public boolean isSelected()        { return sel; }
 }
+
+
+
+
+
+
+
