--- /home/tromey/gnu/Nightly/classpath/classpath/gnu/java/nio/CharBufferImpl.java	Fri Dec 20 08:34:17 2002
+++ gnu/java/nio/CharBufferImpl.java	Thu Feb 20 02:17:57 2003
@@ -40,47 +40,43 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.CharBuffer;
+import java.nio.ReadOnlyBufferException;
 
+/**
+ * This is a Heap memory implementation
+ */
 public final class CharBufferImpl extends CharBuffer
 {
-  private boolean ro;
+  private boolean readOnly;
 
-  private ByteOrder endian = ByteOrder.BIG_ENDIAN;
-  
   public CharBufferImpl(int cap, int off, int lim)
   {
-    this.backing_buffer = new char[cap];
-    this.cap = cap;
-    this.limit(lim);
-    this.position(off);
+    super (cap, lim, off, 0);
+    this.backing_buffer = new char [cap];
+    readOnly = false;
   }
   
-  public CharBufferImpl(char[] array, int off, int lim)
+  public CharBufferImpl(char[] array, int offset, int length)
   {
+    super (array.length, length, offset, 0);
     this.backing_buffer = array;
-    this.cap = array.length;
-    this.limit(lim);
-    this.position(off);
+    readOnly = false;
   }
   
   public CharBufferImpl (CharBufferImpl copy)
   {
+    super (copy.capacity (), copy.limit (), copy.position (), 0);
     backing_buffer = copy.backing_buffer;
-    ro = copy.ro;
-    limit (copy.limit());
-    position (copy.position ());
-  }
-  
-  void inc_pos (int a)
-  {
-    position (position () + a);
+    readOnly = copy.isReadOnly ();
   }
   
   private static native char[] nio_cast (byte[] copy);
 
   CharBufferImpl (byte[] copy)
   {
-    this.backing_buffer = copy != null ? nio_cast (copy) : null;
+    super (copy.length / 2, copy.length / 2, 0, 0);
+    this.backing_buffer = (copy != null ? nio_cast (copy) : null);
+    readOnly = false;
   }
 
   private static native byte nio_get_Byte (CharBufferImpl b, int index, int limit);
@@ -94,16 +90,15 @@
     return res;
   }
 
+  
   public boolean isReadOnly()
   {
-    return ro;
+    return readOnly;
   }
   
   public CharBuffer slice()
   {
-    CharBufferImpl A = new CharBufferImpl(this);
-    A.array_offset = position();
-    return A;
+    return new CharBufferImpl (this);
   }
   
   public CharBuffer duplicate()
@@ -113,9 +108,9 @@
   
   public CharBuffer asReadOnlyBuffer()
   {
-    CharBufferImpl a = new CharBufferImpl(this);
-    a.ro = true;
-    return a;
+    CharBufferImpl result = new CharBufferImpl (this);
+    result.readOnly = true;
+    return result;
   }
   
   public CharBuffer compact()
@@ -125,7 +120,7 @@
   
   public boolean isDirect()
   {
-    return backing_buffer != null;
+    return false;
   }
 
   final public CharSequence subSequence (int start, int end)
@@ -141,6 +136,9 @@
                                position () + end);
   }
   
+  /**
+   * Relative get method. Reads the next character from the buffer.
+   */
   final public char get()
   {
     char e = backing_buffer[position()];
@@ -148,26 +146,61 @@
     return e;
   }
   
+  /**
+   * Relative put method. Writes <code>value</code> to the next position
+   * in the buffer.
+   * 
+   * @exception ReadOnlyBufferException If this buffer is read-only.
+   */
   final public CharBuffer put(char b)
   {
+    if (readOnly)
+      throw new ReadOnlyBufferException ();
+    
     backing_buffer[position()] = b;
     position(position()+1);
     return this;
   }
-  
+
+  /**
+   * Absolute get method. Reads the character at position <code>index</code>.
+   *
+   * @exception IndexOutOfBoundsException If index is negative or not smaller
+   * than the buffer's limit.
+   */
   final public char get(int index)
   {
+    if (index < 0
+        || index >= limit ())
+      throw new IndexOutOfBoundsException ();
+    
     return backing_buffer[index];
   }
   
+  /**
+   * Absolute put method. Writes <code>value</value> to position
+   * <code>index</code> in the buffer.
+   *
+   * @exception IndexOutOfBoundsException If index is negative or not smaller
+   * than the buffer's limit.
+   * @exception ReadOnlyBufferException If this buffer is read-only.
+   */
   final public CharBuffer put(int index, char b)
   {
+    if (index < 0
+        || index >= limit ())
+      throw new IndexOutOfBoundsException ();
+    
+    if (readOnly)
+      throw new ReadOnlyBufferException ();
+    
     backing_buffer[index] = b;
     return this;
   }
 
+
   public final ByteOrder order()
   {
-    return endian;
+    return ByteOrder.BIG_ENDIAN;
   }
 }
