--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/InetAddress.java	2003-09-28 02:20:10.000000000 -0600
+++ java/net/InetAddress.java	2003-09-25 02:18:11.000000000 -0600
@@ -43,9 +43,6 @@
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
-import java.util.HashMap;
-import java.util.StringTokenizer;
-import gnu.classpath.Configuration;
 
 /**
  * This class models an Internet address.  It does not have a public
@@ -65,94 +62,17 @@
 public class InetAddress implements Serializable
 {
   private static final long serialVersionUID = 3286316764910316507L;
-
-  /**
-   * The default DNS hash table size,
-   * Use a prime number happy with hash table.
-   */
-  private static final int DEFAULT_CACHE_SIZE = 89;
-
-  /**
-   * The default caching period in minutes.
-   */
-  private static final int DEFAULT_CACHE_PERIOD = (4 * 60);
-
-  /**
-   * Percentage of cache entries to purge when the table gets full.
-   */
-  private static final int DEFAULT_CACHE_PURGE_PCT = 30;
   
-  /**
-   * The special IP address INADDR_ANY.
-   */
-  private static InetAddress inaddr_any;
-
+  static final byte[] zeros = { 0, 0, 0, 0 };
+  
   /**
    * Dummy InetAddress, used to bind socket to any (all) network interfaces.
    */
-  static InetAddress ANY_IF;
-
-  /**
-   * The size of the cache.
-   */
-  private static int cache_size = 0;
-
-  /**
-   * The length of time we will continue to read the address from cache
-   * before forcing another lookup.
-   */
-  private static int cache_period = 0;
-
-  /**
-   * What percentage of the cache we will purge if it gets full.
-   */
-  private static int cache_purge_pct = 0;
-
-  /**
-   * HashMap to use as DNS lookup cache.
-   * Use HashMap because all accesses to cache are already synchronized.
-   */
-  private static HashMap cache;
-
-  static
-  {
-    // load the shared library needed for name resolution
-    if (Configuration.INIT_LOAD_LIBRARY)
-      {
-        System.loadLibrary ("javanet");
-      }
+  static final InetAddress ANY_IF = new InetAddress (zeros, null);
     
-    // Look for properties that override default caching behavior
-    cache_size = Integer.getInteger ("gnu.java.net.dns_cache_size",
-				     DEFAULT_CACHE_SIZE).intValue();
-    cache_period = Integer.getInteger ("gnu.java.net.dns_cache_period",
-				       DEFAULT_CACHE_PERIOD * 60
-				       * 1000).intValue();
-
-    cache_purge_pct = Integer.getInteger ("gnu.java.net.dns_cache_purge_pct",
-					  DEFAULT_CACHE_PURGE_PCT).
-      intValue ();
-
-    // Fallback to  defaults if necessary
-    if ((cache_purge_pct < 1) || (cache_purge_pct > 100))
-      cache_purge_pct = DEFAULT_CACHE_PURGE_PCT;
-
-    // Create the cache
-    if (cache_size != 0)
-      cache = new HashMap (cache_size);
+  private static final byte[] localhostAddress = { 127, 0, 0, 1 };
 
-    // precompute the ANY_IF address
-    try
-      {
-        ANY_IF = getInaddrAny ();
-      }
-    catch (UnknownHostException uhe)
-      {
-        // Hmmm, make one up and hope that it works.
-        byte[] zeros = { 0, 0, 0, 0 };
-        ANY_IF = new InetAddress (zeros);
-      }
-  }
+  private static InetAddress localhost = null;
 
   /**
    * The Serialized Form specifies that an int 'address' is saved/restored.
@@ -170,17 +90,7 @@
    * The name of the host for this address.
    */
   String hostName;
-
-  /**
-   * Backup hostname alias for this address.
-   */
-  transient String hostname_alias;
-
-  /**
-   * The time this address was looked up.
-   */
-  transient long lookup_time;
-
+  
   /**
    * The field 'family' seems to be the AF_ value.
    * FIXME: Much of the code in the other java.net classes does not make
@@ -199,7 +109,7 @@
    */
   InetAddress (byte[] address)
   {
-    this (address, null, null);
+    this (address, null);
   }
 
   /**
@@ -212,190 +122,361 @@
    */
   InetAddress (byte[] address, String hostname)
   {
-    this (address, hostname, null);
+    addr = address;
+    hostName = hostname;
+    
+    if (address != null)
+      family = getFamily (address);
   }
 
   /**
-   * Initializes this object's addr instance variable from the passed in
-   * int array.  Note that this constructor is protected and is called
-   * only by static methods in this class.
+   * Returns true if this address is a multicast address, false otherwise.
+   * An address is multicast if the high four bits are "1110".  These are
+   * also known as "Class D" addresses.
    *
-   * @param ipaddr The IP number of this address as an array of bytes
-   * @param hostname The hostname of this IP address.
-   * @param hostname_alias A backup hostname to use if hostname is null to
-   * prevent reverse lookup failures
+   * @return true if mulitcast, false if not
+   *
+   * @since 1.1
    */
-  InetAddress (byte[] ipaddr, String hostname, String hostname_alias)
+  public boolean isMulticastAddress ()
   {
-    addr = new byte [ipaddr.length];
+    int len = addr.length;
+    
+    if (len == 4)
+      return (addr [0] & 0xF0) == 0xE0;
+    
+    if (len == 16)
+      return addr [0] == (byte) 0xFF;
+    
+    return false;
+  }
 
-    for (int i = 0; i < ipaddr.length; i++)
-      addr [i] = ipaddr [i];
+  /**
+   * Utility routine to check if the InetAddress in a wildcard address
+   * 
+   * @since 1.4
+   */
+  public boolean isAnyLocalAddress ()
+  {
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
+    return addr == zeros;
+  }
 
-    this.hostName = hostname;
-    this.hostname_alias = hostname_alias;
-    lookup_time = System.currentTimeMillis();
+  /**
+   * Utility routine to check if the InetAddress is a loopback address
+   * 
+   * @since 1.4
+   */
+  public boolean isLoopbackAddress ()
+  {
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
+    
+    return addr [0] == 0x7F;
+  }
 
-    family = 2;			/* AF_INET */
-    address = addr [3] & 0xff;
-    address |= ((addr [2] << 8) & 0xff00);
-    address |= ((addr [1] << 16) & 0xff0000);
-    address |= ((addr [0] << 24) & 0xff000000);
+  /**
+   * Utility routine to check if InetAddress is a link local address
+   * 
+   * @since 1.4
+   */
+  public boolean isLinkLocalAddress ()
+  {
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
 
+    // XXX: This seems to not exist with IPv4 addresses
+    return false;
   }
 
   /**
-   * Returns true if this address is a multicast address, false otherwise.
-   * An address is multicast if the high four bits are "1110".  These are
-   * also known as "Class D" addresses.
-   *
-   * @return true if mulitcast, false if not
+   * Utility routine to check if InetAddress is a site local address
+   * 
+   * @since 1.4
    */
-  public boolean isMulticastAddress ()
+  public boolean isSiteLocalAddress ()
   {
-    if (addr.length == 0)
-      return (false);
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
+
+    // 10.0.0.0/8
+    if (addr [0] == 0x0A)
+      return true;
+
+    // XXX: Suns JDK 1.4.1 (on Linux) seems to have a bug here:
+    // it says 172.16.0.0 - 172.255.255.255 are site local addresses
 
-    // Mask against high order bits of 1110
-    if ((addr[0] & 0xF0) == 224)
-      return (true);
+    // 172.16.0.0/12
+    if (addr [0] == 0xAC
+        && (addr [1] & 0xF0) == 0x01)
+      return true;
 
-    return (false);
+    // 192.168.0.0/16
+    if (addr [0] == 0xC0
+        && addr [1] == 0xA8)
+      return true;
+
+    // XXX: Do we need to check more addresses here ?
+    return false;
   }
 
   /**
-   * Returns the hostname for this address.  This will return the IP address
-   * as a String if there is no hostname available for this address
-   *
-   * @return The hostname for this address
+   * Utility routine to check if InetAddress is a global multicast address
+   * 
+   * @since 1.4
    */
-  public String getHostName()
+  public boolean isMCGlobal ()
   {
-    if (hostName != null)
-      return hostName;
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
 
-    try
-      {
-        hostName = getHostByAddr (addr);
-        return hostName;
-      }
-    catch (UnknownHostException e)
-      {
-        if (hostname_alias != null)
-          return hostname_alias;
-        else
-          return getHostAddress();
-      }
+    // XXX: This seems to not exist with IPv4 addresses
+    return false;
   }
 
   /**
-   * Returns the IP address of this object as a int array.
-   *
-   * @return IP address
+   * Utility reoutine to check if InetAddress is a node local multicast address
+   * 
+   * @since 1.4
    */
-  public byte[] getAddress()
+  public boolean isMCNodeLocal ()
   {
-    byte[] ipaddr = new byte [addr.length];
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
 
-    for (int i = 0; i < addr.length; i++)
-      {
-        ipaddr [i] = (byte) addr [i];
-      }
+    // XXX: This seems to not exist with IPv4 addresses
+    return false;
+  }
+
+  /**
+   * Utility reoutine to check if InetAddress is a link local multicast address
+   * 
+   * @since 1.4
+   */
+  public boolean isMCLinkLocal ()
+  {
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
+    
+    if (!isMulticastAddress ())
+      return false;
 
-    return ipaddr;
+    return (addr [0] == 0xE0
+	    && addr [1] == 0x00
+	    && addr [2] == 0x00);
   }
 
   /**
-   * Returns the IP address of this object as a String.  The address is in 
-   * the dotted octet notation, for example, "127.0.0.1".
+   * Utility routine to check if InetAddress is a site local multicast address
    *
-   * @return The IP address of this object in String form
+   * @since 1.4
    */
-  public String getHostAddress()
+  public boolean isMCSiteLocal ()
   {
-    StringBuffer sb = new StringBuffer();
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
 
-    for (int i = 0; i < addr.length; i++)
-      {
-        sb.append (addr [i] & 0xff);
+    // XXX: This seems to not exist with IPv4 addresses
+    return false;
+  }
 
-        if (i < (addr.length - 1))
-          sb.append (".");
-      }
+  /**
+   * Utility reoutine to check if InetAddress is a organization local
+   * multicast address
+   * 
+   * @since 1.4
+   */
+  public boolean isMCOrgLocal ()
+  {
+    // This is the IPv4 implementation.
+    // Any class derived from InetAddress should override this.
 
-    return sb.toString();
+    // XXX: This seems to not exist with IPv4 addresses
+    return false;
   }
 
   /**
-   * Returns a hash value for this address.  Useful for creating hash
-   * tables.  Overrides Object.hashCode()
-   *
-   * @return A hash value for this address.
+   * Returns the hostname represented by this InetAddress
+   */
+  public String getHostName ()
+  {
+    if (hostName == null)
+      lookup (null, this, false);
+
+    return hostName;
+  }
+
+  /**
+   * Returns the canonical hostname represented by this InetAddress
+   * 
+   * @since 1.4
    */
-  public int hashCode()
+  public String getCanonicalHostName ()
   {
-    long val1 = 0, val2 = 0;
+    SecurityManager sm = System.getSecurityManager ();
+    if (sm != null)
+      {
+        try
+	  {
+            sm.checkConnect (hostName, -1);
+	  }
+	catch (SecurityException e)
+	  {
+	    return getHostAddress ();
+	  }
+      }
 
-    // Its obvious here that I have no idea how to generate a good
-    // hash key
-    for (int i = 0; i < addr.length; i++)
-      val1 = val1 + (addr [i] << ((addr.length - i) / 8));
+    // Try to find the FDQN now
+    InetAddress address = new InetAddress (getAddress (), null);
+    return address.getHostName ();
+  }
 
-    for (int i = 0; i < addr.length; i++)
-      val2 = val2 + (addr [i] * 10 * i);
+  /**
+   * Returns the IP address of this InetAddress as array of bytes
+   */
+  public byte[] getAddress ()
+  {
+    // An experiment shows that JDK1.2 returns a different byte array each
+    // time.  This makes sense, in terms of security.
+    return (byte[]) addr.clone ();
+  }
 
-    val1 = (val1 >> 1) ^ val2;
+  /* Helper function due to a CNI limitation.  */
+  private static InetAddress[] allocArray (int count)
+  {
+    return new InetAddress [count];
+  }
 
-    return ((int) val1);
+  /* Helper function due to a CNI limitation.  */
+  private static SecurityException checkConnect (String hostname)
+  {
+    SecurityManager s = System.getSecurityManager ();
+    
+    if (s == null)
+      return null;
+    
+    try
+      {
+	s.checkConnect (hostname, -1);
+	return null;
+      }
+    catch (SecurityException ex)
+      {
+	return ex;
+      }
   }
 
   /**
-   * Tests this address for equality against another InetAddress.  The two
-   * addresses are considered equal if they contain the exact same octets.
-   * This implementation overrides Object.equals()
-   *
-   * @param obj The address to test for equality
+   * Returns the IP address as string
    *
-   * @return true if the passed in object's address is equal to this one's,
-   * false otherwise
+   * @since 1.0.2
    */
-  public boolean equals (Object obj)
+  public String getHostAddress ()
   {
-    if (!(obj instanceof InetAddress))
-      return false;
+    StringBuffer sbuf = new StringBuffer (40);
+    int len = addr.length;
+    int i = 0;
+    if (len == 16)
+      { // An IPv6 address.
+	for (;  ;  i += 2)
+	  {
+	    if (i >= 16)
+	      return sbuf.toString ();
+	    int x = ((addr [i] & 0xFF) << 8) | (addr [i + 1] & 0xFF);
+	    boolean empty = sbuf.length () == 0;
+	    if (empty)
+	      {
+		if (i == 10 && x == 0xFFFF)
+		  { // IPv4-mapped IPv6 address.
+		    sbuf.append (":FFFF:");
+		    break;  // Continue as IPv4 address;
+		  }
+		else if (i == 12)
+		  { // IPv4-compatible IPv6 address.
+		    sbuf.append (':');
+		    break;  // Continue as IPv4 address.
+		  }
+		else if (i > 0)
+		  sbuf.append ("::");
+	      }
+	    else
+	      sbuf.append (':');
+	    if (x != 0 || i >= 14)
+	      sbuf.append (Integer.toHexString (x).toUpperCase ());
+	  }
+      }
+    for ( ;  ; )
+      {
+	sbuf.append (addr[i] & 0xFF);
+	i++;
+	if (i == len)
+	  break;
+	sbuf.append ('.');
+      }
+    
+    return sbuf.toString();
+  }
 
-    byte[] test_ip = ((InetAddress) obj).getAddress();
+  /**
+   * Returns a hashcode of the InetAddress
+   */
+  public int hashCode ()
+  {
+    // There hashing algorithm is not specified, but a simple experiment
+    // shows that it is equal to the address, as a 32-bit big-endian integer.
+    int hash = 0;
+    int len = addr.length;
+    int i = len > 4 ? len - 4 : 0;
+    
+    for ( ; i < len;  i++)
+      hash = (hash << 8) | (addr[i] & 0xFF);
+    
+    return hash;
+  }
 
-    if (test_ip.length != addr.length)
+  /**
+   * Compares the InetAddress object with another one.
+   */
+  public boolean equals (Object obj)
+  {
+    if (obj == null
+        || ! (obj instanceof InetAddress))
       return false;
-
-    for (int i = 0; i < addr.length; i++)
-      if (test_ip [i] != (byte) addr [i])
-        return false;
-
+    
+    // "The Java Class Libraries" 2nd edition says "If a machine has
+    // multiple names instances of InetAddress for different name of
+    // that same machine are not equal.  This is because they have
+    // different host names."  This violates the description in the
+    // JDK 1.2 API documentation.  A little experimentation
+    // shows that the latter is correct.
+    byte[] addr1 = addr;
+    byte[] addr2 = ((InetAddress) obj).addr;
+    
+    if (addr1.length != addr2.length)
+      return false;
+    
+    for (int i = addr1.length;  --i >= 0;  )
+      if (addr1[i] != addr2[i])
+	return false;
+    
     return true;
   }
 
   /**
-   * Converts this address to a String.  This string contains the IP in
-   * dotted decimal form. For example: "127.0.0.1"  This method is equivalent
-   * to getHostAddress() and overrides Object.toString()
-   *
-   * @return This address in String form
+   * Returns then <code>InetAddress</code> as string
    */
-  public String toString()
+  public String toString ()
   {
-    StringBuffer sb;
+    String result;
+    String address = getHostAddress ();
     
     if (hostName != null)
-      sb = new StringBuffer (hostName).append ('/');
-    else if (hostname_alias != null)
-      sb = new StringBuffer (hostname_alias).append ('/');
+      result = hostName + "/" + address;
     else
-      sb = new StringBuffer();
-
-    sb.append (getHostAddress());
-    return (sb.toString());
+      result = address;
+    
+    return result;
   }
 
   /**
@@ -413,13 +494,7 @@
   public static InetAddress getByAddress (byte[] addr)
     throws UnknownHostException
   {
-    if (addr.length != 4 && addr.length != 16)
-      throw new UnknownHostException ("IP address has illegal length");
-
-    if (addr.length == 4)
-      return new Inet4Address (addr, null);
-
-    return new Inet6Address (addr, null);
+    return getByAddress (null, addr);
   }
 
   /**
@@ -444,250 +519,164 @@
     
     throw new UnknownHostException ("IP address has illegal length");
   }
+  
+  /**
+   * If host is a valid numeric IP address, return the numeric address.
+   * Otherwise, return null.
+   */
+  private static native byte[] aton (String host);
+
+  private static native InetAddress[] lookup (String hostname,
+		                              InetAddress addr, boolean all);
+
+  private static native int getFamily (byte[] address);
 
   /**
-   * Returns an InetAddress object representing the IP address of the given
-   * hostname.  This name can be either a hostname such as "www.urbanophile.com"
-   * or an IP address in dotted decimal format such as "127.0.0.1".  If the
-   * hostname is null, the hostname of the local machine is supplied by
-   * default.  This method is equivalent to returning the first element in
-   * the InetAddress array returned from GetAllByName.
-   *
-   * @param hostname The name of the desired host, or null for the local machine
+   * Determines the IP address of a host, given the host's name.
    *
-   * @return The address of the host as an InetAddress
-   *
-   * @exception UnknownHostException If no IP address can be found for the
-   * given hostname
+   * @exception UnknownHostException If no IP address for the host could
+   * be found
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   public static InetAddress getByName (String hostname)
     throws UnknownHostException
   {
+    SecurityManager s = System.getSecurityManager ();
+    if (s != null)
+      s.checkConnect (hostname, -1);
+   
     // Default to current host if necessary
     if (hostname == null)
-      return getLocalHost();
+      return getLocalHost ();
 
-    // First, check to see if it is an IP address.  If so, then don't 
-    // do a DNS lookup.
-    StringTokenizer st = new StringTokenizer (hostname, ".");
-    
-    if (st.countTokens() == 4)
-      {
-        int i;
-        short n;
-        byte[] ip = new byte [4];
-	
-        for (i = 0; i < 4; i++)
-          {
-            try
-              {
-                n = Short.parseShort (st.nextToken());
-                
-		if ((n < 0) || (n > 255))
-                  break;
-                
-		ip [i] = (byte) n;
-              }
-            catch (NumberFormatException e)
-              {
-                break;
-              }
-          }
-        if (i == 4)
+    // Assume that the host string is an IP address
+    byte[] address = aton (hostname);
+    if (address != null)
+      {
+        if (address.length == 4)
+          return new Inet4Address (address, null);
+        else if (address.length == 16)
           {
-            return new InetAddress (ip);
-          }
+	    if ((address [10] == 0xFF) && (address [11] == 0xFF))
+	      {
+		byte[] ip4addr = new byte [4];
+		ip4addr [0] = address [12];
+		ip4addr [1] = address [13];
+		ip4addr [2] = address [14];
+		ip4addr [3] = address [15];
+		return new Inet4Address (ip4addr, null);
+	      }
+            return new Inet6Address (address, null);
+	  }
+	else
+          throw new UnknownHostException ("Address has invalid length");
       }
-
-    // Wasn't an IP, so try the lookup
+   
+    // Try to resolve the host by DNS
     InetAddress[] addresses = getAllByName (hostname);
-
     return addresses [0];
   }
 
   /**
-   * Returns an array of InetAddress objects representing all the host/ip
-   * addresses of a given host, given the host's name.  This name can be
-   * either a hostname such as "www.urbanophile.com" or an IP address in
-   * dotted decimal format such as "127.0.0.1".  If the value is null, the
-   * hostname of the local machine is supplied by default.
-   *
-   * @param hostname The name of the desired host, or null for the local machine
-   *
-   * @return All addresses of the host as an array of InetAddress's
+   * Given the name of a host, returns an array of its IP addresses,
+   * based on the configured name service on the system.
    *
-   * @exception UnknownHostException If no IP address can be found for the
-   * given hostname
+   * @exception UnknownHostException If no IP address for the host could
+   * be found
+   * @exception SecurityException If a security manager exists and its
+   * checkConnect method doesn't allow the operation
    */
   public static InetAddress[] getAllByName (String hostname)
     throws UnknownHostException
   {
-    // Default to current host if necessary
-    if (hostname == null)
-      {
-        InetAddress local = getLocalHost();
-        return getAllByName (local.getHostName());
-      }
-
-    // Check the cache for this host before doing a lookup
-    InetAddress[] addresses = checkCacheFor (hostname);
-    
-    if (addresses != null)
-      return addresses;
-
-    // Not in cache, try the lookup
-    byte[][] iplist = getHostByName (hostname);
-    
-    if (iplist.length == 0)
-      throw new UnknownHostException (hostname);
+    SecurityManager s = System.getSecurityManager ();
+    if (s != null)
+      s.checkConnect (hostname, -1);
 
-    addresses = new InetAddress [iplist.length];
-
-    for (int i = 0; i < iplist.length; i++)
+    // Check if hostname is an IP address
+    byte[] address = aton (hostname);
+    if (address != null)
       {
-        if (iplist[i].length != 4)
-          throw new UnknownHostException (hostname);
-
-        // Don't store the hostname in order to force resolution of the
-        // canonical names of these ip's when the user asks for the hostname
-        // But do specify the host alias so if the IP returned won't
-        // reverse lookup we don't throw an exception.
-        addresses[i] = new InetAddress (iplist[i], null, hostname);
+	InetAddress[] result = new InetAddress [1];
+	result [0] = new InetAddress (address, null);
+	return result;
       }
-
-    addToCache (hostname, addresses);
-    return addresses;
+   
+    // Try to resolve the hostname by DNS
+    return lookup (hostname, null, true);
   }
 
-  /**
-   * This method checks the DNS cache to see if we have looked this hostname
-   * up before. If so, we return the cached addresses unless it has been in the
-   * cache too long.
-   *
-   * @param hostname The hostname to check for
-   *
-   * @return The InetAddress for this hostname or null if not available
-   */
-  private static synchronized InetAddress[] checkCacheFor (String hostname)
-  {
-    InetAddress[]addresses = null;
-
-    if (cache_size == 0)
-      return (null);
-
-    Object obj = cache.get (hostname);
-    if (obj == null)
-      return (null);
-
-    if (obj instanceof InetAddress[])
-      addresses = (InetAddress[])obj;
-
-    if (addresses == null)
-      return (null);
-
-    if (cache_period != -1)
-      if ((System.currentTimeMillis () - addresses[0].lookup_time) >
-          cache_period)
-        {
-          cache.remove (hostname);
-          return (null);
-        }
-
-    return addresses;
-  }
+  private static native String getLocalHostname ();
 
   /**
-   * This method adds an InetAddress object to our DNS cache.  Note that
-   * if the cache is full, then we run a purge to get rid of old entries.
-   * This will cause a performance hit, thus applications using lots of
-   * lookups should set the cache size to be very large.
+   * Returns the local host
    *
-   * @param hostname The hostname to cache this address under
-   * @param obj The InetAddress or InetAddress array to store
+   * @exception UnknownHostException If no IP address for the host could
+   * be found
    */
-  private static synchronized void addToCache (String hostname, Object obj)
+  public static InetAddress getLocalHost () throws UnknownHostException
   {
-    if (cache_size == 0)
-      return;
-
-    // Check to see if hash table is full
-    if (cache_size != -1)
-      if (cache.size () == cache_size)
-        {
-          // FIXME Add code to purge later.
-        }
-
-    cache.put (hostname, obj);
+    SecurityManager s = System.getSecurityManager ();
+    
+    // Experimentation shows that JDK1.2 does cache the result.
+    // However, if there is a security manager, and the cached result
+    // is other than "localhost", we need to check again.
+    if (localhost == null
+	|| (s != null && localhost.addr != localhostAddress))
+      getLocalHost (s);
+    
+    return localhost;
   }
 
-  /**
-   * Returns the special address INADDR_ANY used for binding to a local
-   * port on all IP addresses hosted by a the local host.
-   *
-   * @return An InetAddress object representing INDADDR_ANY
-   *
-   * @exception UnknownHostException If an error occurs
-   */
-  static InetAddress getInaddrAny () throws UnknownHostException
+  private static synchronized void getLocalHost (SecurityManager s)
+    throws UnknownHostException
   {
-    if (inaddr_any == null)
+    // Check the localhost cache again, now that we've synchronized.
+    if (s == null && localhost != null)
+      return;
+    
+    String hostname = getLocalHostname ();
+    
+    if (s != null)
       {
-        byte[]tmp = lookupInaddrAny ();
-        inaddr_any = new InetAddress (tmp);
+	// "The Java Class Libraries" suggests that if the security
+	// manager disallows getting the local host name, then
+	// we use the loopback host.
+	// However, the JDK 1.2 API claims to throw SecurityException,
+	// which seems to suggest SecurityException is *not* caught.
+	// In this case, experimentation shows that former is correct.
+	try
+	  {
+	    // This is wrong, if the name returned from getLocalHostname()
+	    // is not a fully qualified name.  FIXME.
+	    s.checkConnect (hostname, -1);
+	  }
+	catch (SecurityException ex)
+	  {
+	    hostname = null;
+	  }
       }
-
-    return (inaddr_any);
-  }
-
-  /**
-   * Returns an InetAddress object representing the address of the current
-   * host.
-   *
-   * @return The local host's address
-   *
-   * @exception UnknownHostException If an error occurs
-   */
-  public static InetAddress getLocalHost () throws UnknownHostException
-  {
-    String hostname = getLocalHostName ();
-    return getByName (hostname);
+    
+    if (hostname != null)
+      {
+	try
+	  {
+	    localhost = new InetAddress (null, null);
+	    lookup (hostname, localhost, false);
+	  }
+	catch (Exception ex)
+	  {
+	  }
+      }
+    
+    if (localhost == null)
+      localhost = new InetAddress (localhostAddress, "localhost");
   }
 
   /**
-   * This native method looks up the hostname of the local machine
-   * we are on.  If the actual hostname cannot be determined, then the
-   * value "localhost" we be used.  This native method wrappers the
-   * "gethostname" function.
-   *
-   * @return The local hostname.
-   */
-  private static native String getLocalHostName ();
-
-  /**
-   * Returns the value of the special address INADDR_ANY
-   */
-  private static native byte[] lookupInaddrAny () throws UnknownHostException;
-
-  /**
-   * This method returns the hostname for a given IP address.  It will
-   * throw an UnknownHostException if the hostname cannot be determined.
-   *
-   * @param ip The IP address as a int array
-   * 
-   * @return The hostname
-   *
-   * @exception UnknownHostException If the reverse lookup fails
-   */
-  private static native String getHostByAddr (byte[] ip)
-    throws UnknownHostException;
-
-  /**
-   * Returns a list of all IP addresses for a given hostname.  Will throw
-   * an UnknownHostException if the hostname cannot be resolved.
+   * Needed for serialization
    */
-  private static native byte[][] getHostByName (String hostname)
-    throws UnknownHostException;
-
   private void readResolve () throws ObjectStreamException
   {
     // FIXME: implement this
@@ -703,7 +692,12 @@
     for (int i = 2; i >= 0; --i)
       addr [i] = (byte) (address >>= 8);
     
-    family = 2;  /* AF_INET  */
+    // Ignore family from serialized data.  Since the saved address is 32 bits
+    // the deserialized object will have an IPv4 address i.e. AF_INET family.
+    // FIXME: An alternative is to call the aton method on the deserialized
+    // hostname to get a new address.  The Serialized Form doc is silent
+    // on how these fields are used.
+    family = getFamily (addr);
   }
 
   private void writeObject (ObjectOutputStream oos) throws IOException
