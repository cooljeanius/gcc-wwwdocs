--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/Class.java	2004-08-17 02:28:53.000000000 -0600
+++ java/lang/Class.java	2004-01-29 02:18:51.000000000 -0700
@@ -42,19 +42,11 @@
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
 import java.net.URL;
-import java.security.AllPermission;
-import java.security.Permissions;
 import java.security.ProtectionDomain;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.HashSet;
 
 /**
@@ -62,11 +54,9 @@
  * objects with identical names and ClassLoaders. Primitive types, array
  * types, and void also have a Class object.
  *
- * <p>Arrays with identical type and number of dimensions share the same class.
- * The array class ClassLoader is the same as the ClassLoader of the element
- * type of the array (which can be null to indicate the bootstrap classloader).
- * The name of an array class is <code>[&lt;signature format&gt;;</code>.
- * <p> For example,
+ * <p>Arrays with identical type and number of dimensions share the same
+ * class (and null "system" ClassLoader, incidentally).  The name of an
+ * array class is <code>[&lt;signature format&gt;;</code> ... for example,
  * String[]'s class is <code>[Ljava.lang.String;</code>. boolean, byte,
  * short, char, int, long, float and double have the "type name" of
  * Z,B,S,C,I,J,F,D for the purposes of array classes.  If it's a
@@ -89,47 +79,18 @@
 public final class Class implements Serializable
 {
   /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = 3206093459760846163L;
-
-  /** The class signers. */
-  private Object[] signers = null;
-  /** The class protection domain. */
-  private final ProtectionDomain pd;
-
-  /* We use an inner class, so that Class doesn't have a static initializer */
-  private static final class StaticData
-  {
-    final static ProtectionDomain unknownProtectionDomain;
-
-    static
-    {
-      Permissions permissions = new Permissions();
-      permissions.add(new AllPermission());
-      unknownProtectionDomain = new ProtectionDomain(null, permissions);
-    }
-  }
-
-  transient final Object vmdata;
-
-  /** newInstance() caches the default constructor */
-  private transient Constructor constructor;
-
-  /**
    * Class is non-instantiable from Java code; only the VM can create
    * instances of this class.
    */
-  Class(Object vmdata)
+  private Class ()
   {
-    this(vmdata, null);
   }
 
-  Class(Object vmdata, ProtectionDomain pd)
-  {
-    this.vmdata = vmdata;
-    this.pd = pd;
-  }
+  // Initialize the class.
+  private native void initializeClass ();
+
+  // finalization
+  protected native void finalize () throws Throwable;
 
   /**
    * Use the classloader of the current class to load, link, and initialize
@@ -144,14 +105,8 @@
    * @throws ExceptionInInitializerError if the class loads, but an exception
    *         occurs during initialization
    */
-  public static Class forName(String name) throws ClassNotFoundException
-  {
-    Class result = VMClass.forName (name);
-    if (result == null)
-      result = Class.forName(name, true,
-			     VMSecurityManager.getClassContext()[1].getClassLoader());
-    return result;
-  }
+  public static native Class forName (String className)
+    throws ClassNotFoundException;
 
   /**
    * Use the specified classloader to load and link a class. If the loader
@@ -166,9 +121,6 @@
    * @param initialize whether or not to initialize the class at this time
    * @param classloader the classloader to use to find the class; null means
    *        to use the bootstrap class loader
-   *
-   * @return the class object for the given class
-   *
    * @throws ClassNotFoundException if the class was not found by the
    *         classloader
    * @throws LinkageError if linking the class fails
@@ -180,41 +132,9 @@
    * @see ClassLoader
    * @since 1.2
    */
-  public static Class forName(String name, boolean initialize,
-                              ClassLoader classloader)
-    throws ClassNotFoundException
-  {
-    if (classloader == null)
-      {
-        // Check if we may access the bootstrap classloader
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null)
-          {
-            // Get the calling class and classloader
-            Class c = VMSecurityManager.getClassContext()[1];
-            ClassLoader cl = c.getClassLoader();
-            if (cl != null)
-              sm.checkPermission(new RuntimePermission("getClassLoader"));
-          }
-	if (name.startsWith("["))
-	  return VMClass.loadArrayClass(name, null);
-	Class c = VMClassLoader.loadClass(name, true);
-	if (c != null)
-	  {
-	    if (initialize)
-	      VMClass.initialize(c);
-	    return c;
-	  }
-        throw new ClassNotFoundException(name);
-      }
-    if (name.startsWith("["))
-      return VMClass.loadArrayClass(name, classloader);
-    Class c = classloader.loadClass(name);
-    classloader.resolveClass(c);
-    if (initialize)
-      VMClass.initialize(c);
-    return c;
-  }
+  public static native Class forName (String className, boolean initialize,
+				      ClassLoader loader)
+    throws ClassNotFoundException;
   
   /**
    * Get all the public member classes and interfaces declared in this
@@ -228,31 +148,13 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Class[] getClasses()
-  {
-    memberAccessCheck(Member.PUBLIC);
-    return internalGetClasses();
-  }
-
-  /**
-   * Like <code>getClasses()</code> but without the security checks.
-   */
-  private Class[] internalGetClasses()
-  {
-    ArrayList list = new ArrayList();
-    list.addAll(Arrays.asList(getDeclaredClasses(true)));
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      list.addAll(Arrays.asList(superClass.internalGetClasses()));
-    return (Class[])list.toArray(new Class[list.size()]);
-  }
+  public native Class[] getClasses ();
   
   /**
-   * Get the ClassLoader that loaded this class.  If the class was loaded
-   * by the bootstrap classloader, this method will return null.
-   * If there is a security manager, and the caller's class loader is not
-   * an ancestor of the requested one, a security check of
-   * <code>RuntimePermission("getClassLoader")</code>
+   * Get the ClassLoader that loaded this class.  If it was loaded by the
+   * system classloader, this method will return null. If there is a security
+   * manager, and the caller's class loader does not match the requested
+   * one, a security check of <code>RuntimePermission("getClassLoader")</code>
    * must first succeed. Primitive types and void return null.
    *
    * @return the ClassLoader that loaded this class
@@ -260,25 +162,8 @@
    * @see ClassLoader
    * @see RuntimePermission
    */
-  public ClassLoader getClassLoader()
-  {
-    if (isPrimitive())
-      return null;
-
-    ClassLoader loader = VMClass.getClassLoader(this);
-    // Check if we may get the classloader
-    SecurityManager sm = System.getSecurityManager();
-    if (sm != null)
-      {
-        // Get the calling class and classloader
-        Class c = VMSecurityManager.getClassContext()[1];
-        ClassLoader cl = VMClass.getClassLoader(c);
-        if (cl != null && !cl.isAncestorOf(loader))
-          sm.checkPermission(new RuntimePermission("getClassLoader"));
-      }
-    return loader;
-  }
-
+  public native ClassLoader getClassLoader ();
+  
   /**
    * If this is an array, get the Class representing the type of array.
    * Examples: "[[Ljava.lang.String;" would return "[Ljava.lang.String;", and
@@ -289,10 +174,7 @@
    * @see Array
    * @since 1.1
    */
-  public Class getComponentType()
-  {
-    return VMClass.getComponentType (this);
-  }
+  public native Class getComponentType ();
 
   /**
    * Get a public constructor declared in this class. If the constructor takes
@@ -308,18 +190,12 @@
    * @see #getConstructors()
    * @since 1.1
    */
-  public Constructor getConstructor(Class[] types) throws NoSuchMethodException
-  {
-    memberAccessCheck(Member.PUBLIC);
-    Constructor[] constructors = getDeclaredConstructors(true);
-    for (int i = 0; i < constructors.length; i++)
-      {
-	Constructor constructor = constructors[i];
-	if (matchParameters(types, constructor.getParameterTypes()))
-	  return constructor;
-      }
-    throw new NoSuchMethodException();
-  }
+  public native Constructor getConstructor(Class[] args)
+    throws NoSuchMethodException;
+
+  // This is used to implement getConstructors and
+  // getDeclaredConstructors.
+  private native Constructor[] _getConstructors (boolean declared);
 
   /**
    * Get all the public constructors of this class. This returns an array of
@@ -335,8 +211,7 @@
    */
   public Constructor[] getConstructors()
   {
-    memberAccessCheck(Member.PUBLIC);
-    return getDeclaredConstructors(true);
+    return _getConstructors(false);
   }
 
   /**
@@ -353,19 +228,8 @@
    * @see #getDeclaredConstructors()
    * @since 1.1
    */
-  public Constructor getDeclaredConstructor(Class[] types)
-    throws NoSuchMethodException
-  {
-    memberAccessCheck(Member.DECLARED);
-    Constructor[] constructors = getDeclaredConstructors(false);
-    for (int i = 0; i < constructors.length; i++)
-      {
-	Constructor constructor = constructors[i];
-	if (matchParameters(types, constructor.getParameterTypes()))
-	  return constructor;
-      }
-    throw new NoSuchMethodException();
-  }
+  public native Constructor getDeclaredConstructor(Class[] args)
+    throws NoSuchMethodException;
 
   /**
    * Get all the declared member classes and interfaces in this class, but
@@ -379,16 +243,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Class[] getDeclaredClasses()
-  {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredClasses(false);
-  }
-
-  Class[] getDeclaredClasses (boolean publicOnly)
-  {
-    return VMClass.getDeclaredClasses (this, publicOnly);
-  }
+  public native Class[] getDeclaredClasses();
 
   /**
    * Get all the declared constructors of this class. This returns an array of
@@ -404,15 +259,9 @@
    */
   public Constructor[] getDeclaredConstructors()
   {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredConstructors(false);
+    return _getConstructors(true);
   }
 
-  Constructor[] getDeclaredConstructors (boolean publicOnly)
-  {
-    return VMClass.getDeclaredConstructors (this, publicOnly);
-  }
-  
   /**
    * Get a field declared in this class, where name is its simple name. The
    * implicit length field of arrays is not available. A security check may
@@ -426,17 +275,8 @@
    * @see #getDeclaredFields()
    * @since 1.1
    */
-  public Field getDeclaredField(String name) throws NoSuchFieldException
-  {
-    memberAccessCheck(Member.DECLARED);
-    Field[] fields = getDeclaredFields(false);
-    for (int i = 0; i < fields.length; i++)
-      {
-	if (fields[i].getName().equals(name))
-	  return fields[i];
-      }
-    throw new NoSuchFieldException();
-  }
+  public native Field getDeclaredField(String fieldName)
+    throws NoSuchFieldException;
 
   /**
    * Get all the declared fields in this class, but not those inherited from
@@ -456,16 +296,15 @@
     return getDeclaredFields(false);
   }
 
-  Field[] getDeclaredFields (boolean publicOnly)
-  {
-    return VMClass.getDeclaredFields (this, publicOnly);
-  }
+  native Field[] getDeclaredFields (boolean publicOnly);
+
+  private native Method _getDeclaredMethod(String methodName, Class[] args);
 
   /**
    * Get a method declared in this class, where name is its simple name. The
    * implicit methods of Object are not available from arrays or interfaces.
-   * Constructors (named "&lt;init&gt;" in the class file) and class initializers
-   * (name "&lt;clinit&gt;") are not available.  The Virtual Machine allows
+   * Constructors (named "<init>" in the class file) and class initializers
+   * (name "<clinit>") are not available.  The Virtual Machine allows
    * multiple methods with the same signature but differing return types; in
    * such a case the most specific return types are favored, then the final
    * choice is arbitrary. If the method takes no argument, an array of zero
@@ -482,11 +321,15 @@
    * @see #getDeclaredMethods()
    * @since 1.1
    */
-  public Method getDeclaredMethod(String methodName, Class[] types)
+  public Method getDeclaredMethod(String methodName, Class[] args)
     throws NoSuchMethodException
   {
     memberAccessCheck(Member.DECLARED);
-    Method match = matchMethod(getDeclaredMethods(false), methodName, types);
+
+    if ("<init>".equals(methodName) || "<clinit>".equals(methodName))
+      throw new NoSuchMethodException(methodName);
+
+    Method match = _getDeclaredMethod(methodName, args);
     if (match == null)
       throw new NoSuchMethodException(methodName);
     return match;
@@ -508,16 +351,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Method[] getDeclaredMethods()
-  {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredMethods(false);
-  }
-
-  Method[] getDeclaredMethods (boolean publicOnly)
-  {
-    return VMClass.getDeclaredMethods (this, publicOnly);
-  }
+  public native Method[] getDeclaredMethods();
  
   /**
    * If this is a nested or inner class, return the class that declared it.
@@ -526,10 +360,11 @@
    * @return the declaring class of this class
    * @since 1.1
    */
-  public Class getDeclaringClass()
-  {
-    return VMClass.getDeclaringClass (this);
-  }
+  // This is marked as unimplemented in the JCL book.
+  public native Class getDeclaringClass ();
+
+  private native Field getField (String fieldName, int hash)
+    throws NoSuchFieldException;
 
   /**
    * Get a public field declared or inherited in this class, where name is
@@ -550,7 +385,7 @@
     throws NoSuchFieldException
   {
     memberAccessCheck(Member.PUBLIC);
-    Field field = internalGetField(fieldName);
+    Field field = getField(fieldName, fieldName.hashCode());
     if (field == null)
       throw new NoSuchFieldException(fieldName);
     return field;
@@ -603,7 +438,14 @@
   {
     ClassLoader cl = getClassLoader();
     if (cl != null)
-      return cl.getPackage(getPackagePortion(getName()));
+      {
+        String name = getName();
+	String pkg = "";
+	int idx = name.lastIndexOf('.');
+	if (idx >= 0)
+	  pkg = name.substring(0, idx);
+	return cl.getPackage(pkg);
+      }
     return null;
   }
 
@@ -615,61 +457,19 @@
    *
    * @return the interfaces this class directly implements
    */
-  public Class[] getInterfaces()
-  {
-    return VMClass.getInterfaces (this);
-  }
+  public native Class[] getInterfaces ();
+
+  private final native void getSignature(StringBuffer buffer);
+  private static final native String getSignature(Class[] args,
+						  boolean is_construtor);
+
+  public native Method _getMethod(String methodName, Class[] args);
 
-  private static final class MethodKey
-  {
-    private String name;
-    private Class[] params;
-    private Class returnType;
-    private int hash;
-    
-    MethodKey(Method m)
-    {
-      name = m.getName();
-      params = m.getParameterTypes();
-      returnType = m.getReturnType();
-      hash = name.hashCode() ^ returnType.hashCode();
-      for(int i = 0; i < params.length; i++)
-	{
-	  hash ^= params[i].hashCode();
-	}
-    }
-    
-    public boolean equals(Object o)
-    {
-      if(o instanceof MethodKey)
-	{
-	  MethodKey m = (MethodKey)o;
-	  if(m.name.equals(name) && m.params.length == params.length && m.returnType == returnType)
-	    {
-	      for(int i = 0; i < params.length; i++)
-		{
-		  if(m.params[i] != params[i])
-		    {
-		      return false;
-		    }
-		}
-	      return true;
-	    }
-	}
-      return false;
-    }
-    
-    public int hashCode()
-    {
-      return hash;
-    }
-  }
-  
   /**
    * Get a public method declared or inherited in this class, where name is
    * its simple name. The implicit methods of Object are not available from
-   * interfaces.  Constructors (named "&lt;init&gt;" in the class file) and class
-   * initializers (name "&lt;clinit&gt;") are not available.  The Virtual
+   * interfaces.  Constructors (named "<init>" in the class file) and class
+   * initializers (name "<clinit>") are not available.  The Virtual
    * Machine allows multiple methods with the same signature but differing
    * return types, and the class can inherit multiple methods of the same
    * return type; in such a case the most specific return types are favored,
@@ -687,91 +487,21 @@
    * @see #getMethods()
    * @since 1.1
    */
-  public Method getMethod(String methodName, Class[] types)
+  public Method getMethod(String methodName, Class[] args)
     throws NoSuchMethodException
   {
     memberAccessCheck(Member.PUBLIC);
-    Method method = internalGetMethod(methodName, types);
+
+    if ("<init>".equals(methodName) || "<clinit>".equals(methodName))
+      throw new NoSuchMethodException(methodName);
+
+    Method method = _getMethod(methodName, args);
     if (method == null)
       throw new NoSuchMethodException(methodName);
     return method;
   }
 
-  /**
-   * Like <code>getMethod(String,Class[])</code> but without the security
-   * checks and returns null instead of throwing NoSuchMethodException.
-   */
-  private Method internalGetMethod(String methodName, Class[] args)
-  {
-    Method match = matchMethod(getDeclaredMethods(true), methodName, args);
-    if (match != null)
-      return match;
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      {
-	match = superClass.internalGetMethod(methodName, args);
-	if(match != null)
-	  return match;
-      }
-    Class[] interfaces = getInterfaces();
-    for (int i = 0; i < interfaces.length; i++)
-      {
-	match = interfaces[i].internalGetMethod(methodName, args);
-	if (match != null)
-	  return match;
-      }
-    return null;
-  }
-
-  /** 
-   * Find the best matching method in <code>list</code> according to
-   * the definition of ``best matching'' used by <code>getMethod()</code>
-   *
-   * <p>
-   * Returns the method if any, otherwise <code>null</code>.
-   *
-   * @param list List of methods to search
-   * @param name Name of method
-   * @param args Method parameter types
-   * @see #getMethod()
-   */
-  private static Method matchMethod(Method[] list, String name, Class[] args)
-  {
-    Method match = null;
-    for (int i = 0; i < list.length; i++)
-      {
-	Method method = list[i];
-	if (!method.getName().equals(name))
-	  continue;
-	if (!matchParameters(args, method.getParameterTypes()))
-	  continue;
-	if (match == null
-	    || match.getReturnType().isAssignableFrom(method.getReturnType()))
-	  match = method;
-      }
-    return match;
-  }
-
-  /**
-   * Check for an exact match between parameter type lists.
-   * Either list may be <code>null</code> to mean a list of
-   * length zero.
-   */
-  private static boolean matchParameters(Class[] types1, Class[] types2)
-  {
-    if (types1 == null)
-      return types2 == null || types2.length == 0;
-    if (types2 == null)
-      return types1 == null || types1.length == 0;
-    if (types1.length != types2.length)
-      return false;
-    for (int i = 0; i < types1.length; i++)
-      {
-	if (types1[i] != types2[i])
-	  return false;
-      }
-    return true;
-  }
+  private native int _getMethods (Method[] result, int offset);
   
   /**
    * Get all the public methods declared in this class or inherited from
@@ -789,48 +519,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Method[] getMethods()
-  {
-    memberAccessCheck(Member.PUBLIC);
-    // NOTE the API docs claim that no methods are returned for arrays,
-    // but Sun's implementation *does* return the public methods of Object
-    // (as would be expected), so we follow their implementation instead
-    // of their documentation.
-    return internalGetMethods();
-  }
-
-  /**
-   * Like <code>getMethods()</code> but without the security checks.
-   */
-  private Method[] internalGetMethods()
-  {
-    HashMap map = new HashMap();
-    Method[] methods;
-    Class[] interfaces = getInterfaces();
-    for(int i = 0; i < interfaces.length; i++)
-      {
-	methods = interfaces[i].internalGetMethods();
-	for(int j = 0; j < methods.length; j++)
-	  {
-	    map.put(new MethodKey(methods[j]), methods[j]);
-	  }
-      }
-    Class superClass = getSuperclass();
-    if(superClass != null)
-      {
-	methods = superClass.internalGetMethods();
-	for(int i = 0; i < methods.length; i++)
-	  {
-	    map.put(new MethodKey(methods[i]), methods[i]);
-	  }
-      }
-    methods = getDeclaredMethods(true);
-    for(int i = 0; i < methods.length; i++)
-      {
-	map.put(new MethodKey(methods[i]), methods[i]);
-      }
-    return (Method[])map.values().toArray(new Method[map.size()]);
-  }
+  public native Method[] getMethods();
 
   /**
    * Get the modifiers of this class.  These can be decoded using Modifier,
@@ -844,23 +533,12 @@
    * @see Modifer
    * @since 1.1
    */
-  public int getModifiers()
-  {
-    return VMClass.getModifiers (this);
-  }
+  public native int getModifiers ();
   
   /**
    * Get the name of this class, separated by dots for package separators.
-   * If the class represents a primitive type, or void, then the
-   * name of the type as it appears in the Java programming language
-   * is returned.  For instance, <code>Byte.TYPE.getName()</code>
-   * returns "byte".
-   *
-   * Arrays are specially encoded as shown on this table.
+   * Primitive types and arrays are encoded as:
    * <pre>
-   * array type          [<em>element type</em>
-   *                     (note that the element type is encoded per
-   *                      this table)
    * boolean             Z
    * byte                B
    * char                C
@@ -870,16 +548,13 @@
    * float               F
    * double              D
    * void                V
+   * array type          [<em>element type</em>
    * class or interface, alone: &lt;dotted name&gt;
    * class or interface, as element type: L&lt;dotted name&gt;;
-   * </pre>
    *
    * @return the name of this class
    */
-  public String getName()
-  { 
-    return VMClass.getName (this);
-  }
+  public native String getName ();
 
   /**
    * Get a resource URL using this class's package using the
@@ -887,9 +562,9 @@
    * the system classloader, ClassLoader.getSystemResource() is used instead.
    *
    * <p>If the name you supply is absolute (it starts with a <code>/</code>),
-   * then the leading <code>/</code> is removed and it is passed on to
-   * getResource(). If it is relative, the package name is prepended, and
-   * <code>.</code>'s are replaced with <code>/</code>.
+   * then it is passed on to getResource() as is.  If it is relative, the
+   * package name is prepended, and <code>.</code>'s are replaced with
+   * <code>/</code>.
    *
    * <p>The URL returned is system- and classloader-dependent, and could
    * change across implementations.
@@ -915,9 +590,9 @@
    * instead.
    *
    * <p>If the name you supply is absolute (it starts with a <code>/</code>),
-   * then the leading <code>/</code> is removed and it is passed on to
-   * getResource(). If it is relative, the package name is prepended, and
-   * <code>.</code>'s are replaced with <code>/</code>.
+   * then it is passed on to getResource() as is.  If it is relative, the
+   * package name is prepended, and <code>.</code>'s are replaced with
+   * <code>/</code>.
    *
    * <p>The URL returned is system- and classloader-dependent, and could
    * change across implementations.
@@ -938,19 +613,17 @@
 
   private String resourcePath(String resourceName)
   {
-    if (resourceName.length() > 0)
-    {
-      if (resourceName.charAt(0) != '/')
-      {
-        String pkg = getPackagePortion(getName());
-        if (pkg.length() > 0)
-          resourceName = pkg.replace('.','/') + '/' + resourceName;
-      }
-      else
-      {
-        resourceName = resourceName.substring(1);
-      }
-    }
+    if (resourceName.startsWith("/"))
+      return resourceName.substring(1);
+
+    Class c = this;
+    while (c.isArray())
+      c = c.getComponentType();
+
+    String packageName = c.getName().replace('.', '/');
+    int end = packageName.lastIndexOf('/');
+    if (end != -1)
+      return packageName.substring(0, end + 1) + resourceName;
     return resourceName;
   }
 
@@ -961,20 +634,14 @@
    * @return the signers of this class
    * @since 1.1
    */
-  public Object[] getSigners()
-  {
-    return signers == null ? null : (Object[]) signers.clone ();
-  }
+  public native Object[] getSigners ();
   
   /**
    * Set the signers of this class.
    *
    * @param signers the signers of this class
    */
-  void setSigners(Object[] signers)
-  {
-    this.signers = signers;
-  }
+  native void setSigners(Object[] signers);
 
   /**
    * Get the direct superclass of this class.  If this is an interface,
@@ -983,10 +650,7 @@
    *
    * @return the direct superclass of this class
    */
-  public Class getSuperclass()
-  {
-    return VMClass.getSuperclass (this);
-  }
+  public native Class getSuperclass ();
   
   /**
    * Return whether this class is an array type.
@@ -994,10 +658,7 @@
    * @return whether this class is an array type
    * @since 1.1
    */
-  public boolean isArray()
-  {
-    return VMClass.isArray (this);
-  }
+  public native boolean isArray ();
   
   /**
    * Discover whether an instance of the Class parameter would be an
@@ -1013,10 +674,7 @@
    * @throws NullPointerException if c is null
    * @since 1.1
    */
-  public boolean isAssignableFrom(Class c)
-  {
-    return VMClass.isAssignableFrom (this, c);
-  }
+  public native boolean isAssignableFrom (Class c);
  
   /**
    * Discover whether an Object is an instance of this Class.  Think of it
@@ -1026,10 +684,7 @@
    * @return whether o is an instance of this class
    * @since 1.1
    */
-  public boolean isInstance(Object o)
-  {
-    return VMClass.isInstance (this, o);
-  }
+  public native boolean isInstance (Object o);
   
   /**
    * Check whether this class is an interface or not.  Array types are not
@@ -1037,10 +692,7 @@
    *
    * @return whether this class is an interface or not
    */
-  public boolean isInterface()
-  {
-    return VMClass.isInterface (this);
-  }
+  public native boolean isInterface ();
   
   /**
    * Return whether this class is a primitive type.  A primitive type class
@@ -1061,10 +713,7 @@
    * @see Void#TYPE
    * @since 1.1
    */
-  public boolean isPrimitive()
-  {
-    return VMClass.isPrimitive (this);
-  }
+  public native boolean isPrimitive ();
   
   /**
    * Get a new instance of this class by calling the no-argument constructor.
@@ -1083,74 +732,18 @@
    * @throws ExceptionInInitializerError if class initialization caused by
    *         this call fails with an exception
    */
-  public Object newInstance()
-    throws InstantiationException, IllegalAccessException
-  {
-    memberAccessCheck(Member.PUBLIC);
-    Constructor constructor;
-    synchronized(this)
-      {
-	constructor = this.constructor;
-      }
-    if (constructor == null)
-      {
-	Constructor[] constructors = getDeclaredConstructors(false);
-	for (int i = 0; i < constructors.length; i++)
-	  {
-	    if (constructors[i].getParameterTypes().length == 0)
-	      {
-		constructor = constructors[i];
-		break;
-	      }
-	  }
-	if (constructor == null)
-	  throw new InstantiationException(getName());
-	if (!Modifier.isPublic(constructor.getModifiers()))
-	  {
-	    final Constructor finalConstructor = constructor;
-	    AccessController.doPrivileged(new PrivilegedAction() {
-		public Object run() {
-		  finalConstructor.setAccessible(true);
-		  return null;
-		}
-	      });
-	  }
-	synchronized(this)
-	  {
-	    if (this.constructor == null)
-	      this.constructor = constructor;
-	  }	    
-      }
-    int modifiers = constructor.getModifiers();
-    if (!Modifier.isPublic(modifiers))
-      {
-	Class caller = VMSecurityManager.getClassContext()[1];
-	if (caller != this &&
-	    (Modifier.isPrivate(modifiers)
-	     || getClassLoader() != caller.getClassLoader()
-	     || !getPackagePortion(getName())
-	     .equals(getPackagePortion(caller.getName()))))
-	  throw new IllegalAccessException(getName()
-					   + " has an inaccessible constructor");
-      }
-    try
-      {
-        return constructor.newInstance(null);
-      }
-    catch (InvocationTargetException e)
-      {
-	VMClass.throwException(e.getTargetException());
-	throw (InternalError) new InternalError
-	  ("VMClass.throwException returned").initCause(e);
-      }
-  }
+  public native Object newInstance ()
+    throws InstantiationException, IllegalAccessException;
+
+  // We need a native method to retrieve the protection domain, because we
+  // can't add fields to java.lang.Class that are accessible from Java.
+  private native ProtectionDomain getProtectionDomain0();
 
   /**
    * Returns the protection domain of this class. If the classloader did not
    * record the protection domain when creating this class the unknown
    * protection domain is returned which has a <code>null</code> code source
-   * and all permissions. A security check may be performed, with
-   * <code>RuntimePermission("getProtectionDomain")</code>.
+   * and all permissions.
    *
    * @return the protection domain
    * @throws SecurityException if the security manager exists and the caller
@@ -1162,9 +755,14 @@
   {
     SecurityManager sm = System.getSecurityManager();
     if (sm != null)
-      sm.checkPermission(new RuntimePermission("getProtectionDomain"));
+      sm.checkPermission(VMClassLoader.protectionDomainPermission);
+    
+    ProtectionDomain protectionDomain = getProtectionDomain0();
 
-    return pd == null ? StaticData.unknownProtectionDomain : pd;
+    if (protectionDomain == null)
+      return VMClassLoader.unknownProtectionDomain;
+    else
+      return protectionDomain;
   }
 
   /**
@@ -1251,32 +849,6 @@
   }
 
   /**
-   * Like <code>getField(String)</code> but without the security checks and returns null
-   * instead of throwing NoSuchFieldException.
-   */
-  private Field internalGetField(String name)
-  {
-    Field[] fields = getDeclaredFields(true);
-    for (int i = 0; i < fields.length; i++)
-      {
-	Field field = fields[i];
-	if (field.getName().equals(name))
-	  return field;
-      }
-    Class[] interfaces = getInterfaces();
-    for (int i = 0; i < interfaces.length; i++)
-      {
-	Field field = interfaces[i].internalGetField(name);
-	if(field != null)
-	  return field;
-      }
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      return superClass.internalGetField(name);
-    return null;
-  }
-
-  /**
    * Strip the last portion of the name (after the last dot).
    *
    * @param name the name to get package of
