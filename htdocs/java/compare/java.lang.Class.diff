--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/Class.java	2004-01-26 02:24:19.000000000 -0700
+++ java/lang/Class.java	2004-01-29 02:18:51.000000000 -0700
@@ -42,19 +42,11 @@
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
 import java.net.URL;
-import java.security.AllPermission;
-import java.security.Permissions;
 import java.security.ProtectionDomain;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.HashSet;
 
 /**
@@ -87,38 +79,19 @@
 public final class Class implements Serializable
 {
   /**
-   * Compatible with JDK 1.0+.
-   */
-  private static final long serialVersionUID = 3206093459760846163L;
-
-  /** The class signers. */
-  private Object[] signers = null;
-  /** The class protection domain. */
-  private ProtectionDomain pd = null;
-
-  /** The unknown protection domain. */
-  private final static ProtectionDomain unknownProtectionDomain;
-  static
-  {
-    Permissions permissions = new Permissions();
-    permissions.add(new AllPermission());
-    unknownProtectionDomain = new ProtectionDomain(null, permissions);
-  }
-
-  transient final VMClass vmClass;
-
-  /** newInstance() caches the default constructor */
-  private transient Constructor constructor;
-
-  /**
    * Class is non-instantiable from Java code; only the VM can create
    * instances of this class.
    */
-  Class(VMClass vmClass)
+  private Class ()
   {
-    this.vmClass = vmClass;
   }
 
+  // Initialize the class.
+  private native void initializeClass ();
+
+  // finalization
+  protected native void finalize () throws Throwable;
+
   /**
    * Use the classloader of the current class to load, link, and initialize
    * a class. This is equivalent to your code calling
@@ -132,14 +105,8 @@
    * @throws ExceptionInInitializerError if the class loads, but an exception
    *         occurs during initialization
    */
-  public static Class forName(String name) throws ClassNotFoundException
-  {
-    Class result = VMClass.forName (name);
-    if (result == null)
-      result = Class.forName(name, true,
-			     VMSecurityManager.getClassContext()[1].getClassLoader());
-    return result;
-  }
+  public static native Class forName (String className)
+    throws ClassNotFoundException;
 
   /**
    * Use the specified classloader to load and link a class. If the loader
@@ -165,41 +132,9 @@
    * @see ClassLoader
    * @since 1.2
    */
-  public static Class forName(String name, boolean initialize,
-                              ClassLoader classloader)
-    throws ClassNotFoundException
-  {
-    if (classloader == null)
-      {
-        // Check if we may access the bootstrap classloader
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null)
-          {
-            // Get the calling class and classloader
-            Class c = VMSecurityManager.getClassContext()[1];
-            ClassLoader cl = c.getClassLoader();
-            if (cl != null)
-              sm.checkPermission(new RuntimePermission("getClassLoader"));
-          }
-	if (name.startsWith("["))
-	  return VMClass.loadArrayClass(name, null);
-	Class c = VMClassLoader.loadClass(name, true);
-	if (c != null)
-	  {
-	    if (initialize)
-	      c.vmClass.initialize();
-	    return c;
-	  }
-        throw new ClassNotFoundException(name);
-      }
-    if (name.startsWith("["))
-      return VMClass.loadArrayClass(name, classloader);
-    Class c = classloader.loadClass(name);
-    classloader.resolveClass(c);
-    if (initialize)
-      c.vmClass.initialize();
-    return c;
-  }
+  public static native Class forName (String className, boolean initialize,
+				      ClassLoader loader)
+    throws ClassNotFoundException;
   
   /**
    * Get all the public member classes and interfaces declared in this
@@ -213,24 +148,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Class[] getClasses()
-  {
-    memberAccessCheck(Member.PUBLIC);
-    return internalGetClasses();
-  }
-
-  /**
-   * Like <code>getClasses()</code> but without the security checks.
-   */
-  private Class[] internalGetClasses()
-  {
-    ArrayList list = new ArrayList();
-    list.addAll(Arrays.asList(getDeclaredClasses(true)));
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      list.addAll(Arrays.asList(superClass.internalGetClasses()));
-    return (Class[])list.toArray(new Class[list.size()]);
-  }
+  public native Class[] getClasses ();
   
   /**
    * Get the ClassLoader that loaded this class.  If it was loaded by the
@@ -244,28 +162,7 @@
    * @see ClassLoader
    * @see RuntimePermission
    */
-  public ClassLoader getClassLoader()
-  {
-    // Check some common cases.
-    if (isPrimitive())
-      return null;
-    String name = getName();
-    if (name.startsWith("java.") || name.startsWith("gnu.java."))
-      return null;
-
-    ClassLoader loader = vmClass.getClassLoader();
-    // Check if we may get the classloader
-    SecurityManager sm = System.getSecurityManager();
-    if (sm != null)
-      {
-        // Get the calling class and classloader
-        Class c = VMSecurityManager.getClassContext()[1];
-        ClassLoader cl = c.getClassLoader();
-        if (cl != null && cl != ClassLoader.systemClassLoader)
-          sm.checkPermission(new RuntimePermission("getClassLoader"));
-      }
-    return loader;
-  }
+  public native ClassLoader getClassLoader ();
   
   /**
    * If this is an array, get the Class representing the type of array.
@@ -277,10 +174,7 @@
    * @see Array
    * @since 1.1
    */
-  public Class getComponentType()
-  {
-    return vmClass.getComponentType ();
-  }
+  public native Class getComponentType ();
 
   /**
    * Get a public constructor declared in this class. If the constructor takes
@@ -296,18 +190,12 @@
    * @see #getConstructors()
    * @since 1.1
    */
-  public Constructor getConstructor(Class[] args) throws NoSuchMethodException
-  {
-    memberAccessCheck(Member.PUBLIC);
-    Constructor[] constructors = getDeclaredConstructors(true);
-    for (int i = 0; i < constructors.length; i++)
-      {
-	Constructor constructor = constructors[i];
-	if (matchParameters(args, constructor.getParameterTypes()))
-	  return constructor;
-      }
-    throw new NoSuchMethodException();
-  }
+  public native Constructor getConstructor(Class[] args)
+    throws NoSuchMethodException;
+
+  // This is used to implement getConstructors and
+  // getDeclaredConstructors.
+  private native Constructor[] _getConstructors (boolean declared);
 
   /**
    * Get all the public constructors of this class. This returns an array of
@@ -323,8 +211,7 @@
    */
   public Constructor[] getConstructors()
   {
-    memberAccessCheck(Member.PUBLIC);
-    return getDeclaredConstructors(true);
+    return _getConstructors(false);
   }
 
   /**
@@ -341,19 +228,8 @@
    * @see #getDeclaredConstructors()
    * @since 1.1
    */
-  public Constructor getDeclaredConstructor(Class[] args)
-    throws NoSuchMethodException
-  {
-    memberAccessCheck(Member.DECLARED);
-    Constructor[] constructors = getDeclaredConstructors(false);
-    for (int i = 0; i < constructors.length; i++)
-      {
-	Constructor constructor = constructors[i];
-	if (matchParameters(args, constructor.getParameterTypes()))
-	  return constructor;
-      }
-    throw new NoSuchMethodException();
-  }
+  public native Constructor getDeclaredConstructor(Class[] args)
+    throws NoSuchMethodException;
 
   /**
    * Get all the declared member classes and interfaces in this class, but
@@ -367,16 +243,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Class[] getDeclaredClasses()
-  {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredClasses(false);
-  }
-
-  Class[] getDeclaredClasses (boolean publicOnly)
-  {
-    return vmClass.getDeclaredClasses (publicOnly);
-  }
+  public native Class[] getDeclaredClasses();
 
   /**
    * Get all the declared constructors of this class. This returns an array of
@@ -392,15 +259,9 @@
    */
   public Constructor[] getDeclaredConstructors()
   {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredConstructors(false);
+    return _getConstructors(true);
   }
 
-  Constructor[] getDeclaredConstructors (boolean publicOnly)
-  {
-    return vmClass.getDeclaredConstructors (publicOnly);
-  }
-  
   /**
    * Get a field declared in this class, where name is its simple name. The
    * implicit length field of arrays is not available. A security check may
@@ -414,17 +275,8 @@
    * @see #getDeclaredFields()
    * @since 1.1
    */
-  public Field getDeclaredField(String name) throws NoSuchFieldException
-  {
-    memberAccessCheck(Member.DECLARED);
-    Field[] fields = getDeclaredFields(false);
-    for (int i = 0; i < fields.length; i++)
-      {
-	if (fields[i].getName().equals(name))
-	  return fields[i];
-      }
-    throw new NoSuchFieldException();
-  }
+  public native Field getDeclaredField(String fieldName)
+    throws NoSuchFieldException;
 
   /**
    * Get all the declared fields in this class, but not those inherited from
@@ -444,10 +296,9 @@
     return getDeclaredFields(false);
   }
 
-  Field[] getDeclaredFields (boolean publicOnly)
-  {
-    return vmClass.getDeclaredFields (publicOnly);
-  }
+  native Field[] getDeclaredFields (boolean publicOnly);
+
+  private native Method _getDeclaredMethod(String methodName, Class[] args);
 
   /**
    * Get a method declared in this class, where name is its simple name. The
@@ -474,7 +325,11 @@
     throws NoSuchMethodException
   {
     memberAccessCheck(Member.DECLARED);
-    Method match = matchMethod(getDeclaredMethods(false), methodName, args);
+
+    if ("<init>".equals(methodName) || "<clinit>".equals(methodName))
+      throw new NoSuchMethodException(methodName);
+
+    Method match = _getDeclaredMethod(methodName, args);
     if (match == null)
       throw new NoSuchMethodException(methodName);
     return match;
@@ -496,16 +351,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Method[] getDeclaredMethods()
-  {
-    memberAccessCheck(Member.DECLARED);
-    return getDeclaredMethods(false);
-  }
-
-  Method[] getDeclaredMethods (boolean publicOnly)
-  {
-    return vmClass.getDeclaredMethods (publicOnly);
-  }
+  public native Method[] getDeclaredMethods();
  
   /**
    * If this is a nested or inner class, return the class that declared it.
@@ -514,10 +360,11 @@
    * @return the declaring class of this class
    * @since 1.1
    */
-  public Class getDeclaringClass()
-  {
-    return vmClass.getDeclaringClass ();
-  }
+  // This is marked as unimplemented in the JCL book.
+  public native Class getDeclaringClass ();
+
+  private native Field getField (String fieldName, int hash)
+    throws NoSuchFieldException;
 
   /**
    * Get a public field declared or inherited in this class, where name is
@@ -538,7 +385,7 @@
     throws NoSuchFieldException
   {
     memberAccessCheck(Member.PUBLIC);
-    Field field = internalGetField(fieldName);
+    Field field = getField(fieldName, fieldName.hashCode());
     if (field == null)
       throw new NoSuchFieldException(fieldName);
     return field;
@@ -591,7 +438,14 @@
   {
     ClassLoader cl = getClassLoader();
     if (cl != null)
-      return cl.getPackage(getPackagePortion(getName()));
+      {
+        String name = getName();
+	String pkg = "";
+	int idx = name.lastIndexOf('.');
+	if (idx >= 0)
+	  pkg = name.substring(0, idx);
+	return cl.getPackage(pkg);
+      }
     return null;
   }
 
@@ -603,56 +457,14 @@
    *
    * @return the interfaces this class directly implements
    */
-  public Class[] getInterfaces()
-  {
-    return vmClass.getInterfaces ();
-  }
+  public native Class[] getInterfaces ();
+
+  private final native void getSignature(StringBuffer buffer);
+  private static final native String getSignature(Class[] args,
+						  boolean is_construtor);
+
+  public native Method _getMethod(String methodName, Class[] args);
 
-  private static final class MethodKey
-  {
-    private String name;
-    private Class[] params;
-    private Class returnType;
-    private int hash;
-    
-    MethodKey(Method m)
-    {
-      name = m.getName();
-      params = m.getParameterTypes();
-      returnType = m.getReturnType();
-      hash = name.hashCode() ^ returnType.hashCode();
-      for(int i = 0; i < params.length; i++)
-	{
-	  hash ^= params[i].hashCode();
-	}
-    }
-    
-    public boolean equals(Object o)
-    {
-      if(o instanceof MethodKey)
-	{
-	  MethodKey m = (MethodKey)o;
-	  if(m.name.equals(name) && m.params.length == params.length && m.returnType == returnType)
-	    {
-	      for(int i = 0; i < params.length; i++)
-		{
-		  if(m.params[i] != params[i])
-		    {
-		      return false;
-		    }
-		}
-	      return true;
-	    }
-	}
-      return false;
-    }
-    
-    public int hashCode()
-    {
-      return hash;
-    }
-  }
-  
   /**
    * Get a public method declared or inherited in this class, where name is
    * its simple name. The implicit methods of Object are not available from
@@ -679,87 +491,17 @@
     throws NoSuchMethodException
   {
     memberAccessCheck(Member.PUBLIC);
-    Method method = internalGetMethod(methodName, args);
+
+    if ("<init>".equals(methodName) || "<clinit>".equals(methodName))
+      throw new NoSuchMethodException(methodName);
+
+    Method method = _getMethod(methodName, args);
     if (method == null)
       throw new NoSuchMethodException(methodName);
     return method;
   }
 
-  /**
-   * Like <code>getMethod(String,Class[])</code> but without the security
-   * checks and returns null instead of throwing NoSuchMethodException.
-   */
-  private Method internalGetMethod(String methodName, Class[] args)
-  {
-    Method match = matchMethod(getDeclaredMethods(true), methodName, args);
-    if (match != null)
-      return match;
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      {
-	match = superClass.internalGetMethod(methodName, args);
-	if(match != null)
-	  return match;
-      }
-    Class[] interfaces = getInterfaces();
-    for (int i = 0; i < interfaces.length; i++)
-      {
-	match = interfaces[i].internalGetMethod(methodName, args);
-	if (match != null)
-	  return match;
-      }
-    return null;
-  }
-
-  /** 
-   * Find the best matching method in <code>list</code> according to
-   * the definition of ``best matching'' used by <code>getMethod()</code>
-   *
-   * <p>
-   * Returns the method if any, otherwise <code>null</code>.
-   *
-   * @param list List of methods to search
-   * @param name Name of method
-   * @param args Method parameter types
-   * @see #getMethod()
-   */
-  private static Method matchMethod(Method[] list, String name, Class[] args)
-  {
-    Method match = null;
-    for (int i = 0; i < list.length; i++)
-      {
-	Method method = list[i];
-	if (!method.getName().equals(name))
-	  continue;
-	if (!matchParameters(args, method.getParameterTypes()))
-	  continue;
-	if (match == null
-	    || match.getReturnType().isAssignableFrom(method.getReturnType()))
-	  match = method;
-      }
-    return match;
-  }
-
-  /**
-   * Check for an exact match between parameter type lists.
-   * Either list may be <code>null</code> to mean a list of
-   * length zero.
-   */
-  private static boolean matchParameters(Class[] types1, Class[] types2)
-  {
-    if (types1 == null)
-      return types2 == null || types2.length == 0;
-    if (types2 == null)
-      return types1 == null || types1.length == 0;
-    if (types1.length != types2.length)
-      return false;
-    for (int i = 0; i < types1.length; i++)
-      {
-	if (types1[i] != types2[i])
-	  return false;
-      }
-    return true;
-  }
+  private native int _getMethods (Method[] result, int offset);
   
   /**
    * Get all the public methods declared in this class or inherited from
@@ -777,48 +519,7 @@
    * @throws SecurityException if the security check fails
    * @since 1.1
    */
-  public Method[] getMethods()
-  {
-    memberAccessCheck(Member.PUBLIC);
-    // NOTE the API docs claim that no methods are returned for arrays,
-    // but Sun's implementation *does* return the public methods of Object
-    // (as would be expected), so we follow their implementation instead
-    // of their documentation.
-    return internalGetMethods();
-  }
-
-  /**
-   * Like <code>getMethods()</code> but without the security checks.
-   */
-  private Method[] internalGetMethods()
-  {
-    HashMap map = new HashMap();
-    Method[] methods;
-    Class[] interfaces = getInterfaces();
-    for(int i = 0; i < interfaces.length; i++)
-      {
-	methods = interfaces[i].internalGetMethods();
-	for(int j = 0; j < methods.length; j++)
-	  {
-	    map.put(new MethodKey(methods[j]), methods[j]);
-	  }
-      }
-    Class superClass = getSuperclass();
-    if(superClass != null)
-      {
-	methods = superClass.internalGetMethods();
-	for(int i = 0; i < methods.length; i++)
-	  {
-	    map.put(new MethodKey(methods[i]), methods[i]);
-	  }
-      }
-    methods = getDeclaredMethods(true);
-    for(int i = 0; i < methods.length; i++)
-      {
-	map.put(new MethodKey(methods[i]), methods[i]);
-      }
-    return (Method[])map.values().toArray(new Method[map.size()]);
-  }
+  public native Method[] getMethods();
 
   /**
    * Get the modifiers of this class.  These can be decoded using Modifier,
@@ -832,10 +533,7 @@
    * @see Modifer
    * @since 1.1
    */
-  public int getModifiers()
-  {
-    return vmClass.getModifiers ();
-  }
+  public native int getModifiers ();
   
   /**
    * Get the name of this class, separated by dots for package separators.
@@ -856,10 +554,7 @@
    *
    * @return the name of this class
    */
-  public String getName()
-  { 
-    return vmClass.getName ();
-  }
+  public native String getName ();
 
   /**
    * Get a resource URL using this class's package using the
@@ -918,9 +613,17 @@
 
   private String resourcePath(String resourceName)
   {
-    if (resourceName.length() > 0 && resourceName.charAt(0) != '/')
-      resourceName = getPackagePortion(getName()).replace('.','/')
-        + "/" + resourceName;
+    if (resourceName.startsWith("/"))
+      return resourceName.substring(1);
+
+    Class c = this;
+    while (c.isArray())
+      c = c.getComponentType();
+
+    String packageName = c.getName().replace('.', '/');
+    int end = packageName.lastIndexOf('/');
+    if (end != -1)
+      return packageName.substring(0, end + 1) + resourceName;
     return resourceName;
   }
 
@@ -931,20 +634,14 @@
    * @return the signers of this class
    * @since 1.1
    */
-  public Object[] getSigners()
-  {
-    return signers == null ? null : (Object[]) signers.clone ();
-  }
+  public native Object[] getSigners ();
   
   /**
    * Set the signers of this class.
    *
    * @param signers the signers of this class
    */
-  void setSigners(Object[] signers)
-  {
-    this.signers = signers;
-  }
+  native void setSigners(Object[] signers);
 
   /**
    * Get the direct superclass of this class.  If this is an interface,
@@ -953,10 +650,7 @@
    *
    * @return the direct superclass of this class
    */
-  public Class getSuperclass()
-  {
-    return vmClass.getSuperclass ();
-  }
+  public native Class getSuperclass ();
   
   /**
    * Return whether this class is an array type.
@@ -964,14 +658,7 @@
    * @return whether this class is an array type
    * @since 1.1
    */
-  public boolean isArray()
-  {
-    int result = -1;
-    if ((result = vmClass.isArray ()) < 0)
-      return getName().charAt(0) == '[';
-
-    return result == 1;
-  }
+  public native boolean isArray ();
   
   /**
    * Discover whether an instance of the Class parameter would be an
@@ -987,10 +674,7 @@
    * @throws NullPointerException if c is null
    * @since 1.1
    */
-  public boolean isAssignableFrom(Class c)
-  {
-    return vmClass.isAssignableFrom (c);
-  }
+  public native boolean isAssignableFrom (Class c);
  
   /**
    * Discover whether an Object is an instance of this Class.  Think of it
@@ -1000,10 +684,7 @@
    * @return whether o is an instance of this class
    * @since 1.1
    */
-  public boolean isInstance(Object o)
-  {
-    return vmClass.isInstance (o);
-  }
+  public native boolean isInstance (Object o);
   
   /**
    * Check whether this class is an interface or not.  Array types are not
@@ -1011,10 +692,7 @@
    *
    * @return whether this class is an interface or not
    */
-  public boolean isInterface()
-  {
-    return vmClass.isInterface ();
-  }
+  public native boolean isInterface ();
   
   /**
    * Return whether this class is a primitive type.  A primitive type class
@@ -1035,10 +713,7 @@
    * @see Void#TYPE
    * @since 1.1
    */
-  public boolean isPrimitive()
-  {
-    return vmClass.isPrimitive ();
-  }
+  public native boolean isPrimitive ();
   
   /**
    * Get a new instance of this class by calling the no-argument constructor.
@@ -1057,74 +732,18 @@
    * @throws ExceptionInInitializerError if class initialization caused by
    *         this call fails with an exception
    */
-  public Object newInstance()
-    throws InstantiationException, IllegalAccessException
-  {
-    memberAccessCheck(Member.PUBLIC);
-    Constructor constructor;
-    synchronized(this)
-      {
-	constructor = this.constructor;
-      }
-    if (constructor == null)
-      {
-	Constructor[] constructors = getDeclaredConstructors(false);
-	for (int i = 0; i < constructors.length; i++)
-	  {
-	    if (constructors[i].getParameterTypes().length == 0)
-	      {
-		constructor = constructors[i];
-		break;
-	      }
-	  }
-	if (constructor == null)
-	  throw new InstantiationException(getName());
-	if (!Modifier.isPublic(constructor.getModifiers()))
-	  {
-	    final Constructor finalConstructor = constructor;
-	    AccessController.doPrivileged(new PrivilegedAction() {
-		public Object run() {
-		  finalConstructor.setAccessible(true);
-		  return null;
-		}
-	      });
-	  }
-	synchronized(this)
-	  {
-	    if (this.constructor == null)
-	      this.constructor = constructor;
-	  }	    
-      }
-    int modifiers = constructor.getModifiers();
-    if (!Modifier.isPublic(modifiers))
-      {
-	Class caller = VMSecurityManager.getClassContext()[1];
-	if (caller != this &&
-	    (Modifier.isPrivate(modifiers)
-	     || getClassLoader() != caller.getClassLoader()
-	     || !getPackagePortion(getName())
-	     .equals(getPackagePortion(caller.getName()))))
-	  throw new IllegalAccessException(getName()
-					   + " has an inaccessible constructor");
-      }
-    try
-      {
-        return constructor.newInstance(null);
-      }
-    catch (InvocationTargetException e)
-      {
-	VMClass.throwException(e.getTargetException());
-	throw (InternalError) new InternalError
-	  ("VMClass.throwException returned").initCause(e);
-      }
-  }
+  public native Object newInstance ()
+    throws InstantiationException, IllegalAccessException;
+
+  // We need a native method to retrieve the protection domain, because we
+  // can't add fields to java.lang.Class that are accessible from Java.
+  private native ProtectionDomain getProtectionDomain0();
 
   /**
    * Returns the protection domain of this class. If the classloader did not
    * record the protection domain when creating this class the unknown
    * protection domain is returned which has a <code>null</code> code source
-   * and all permissions. A security check may be performed, with
-   * <code>RuntimePermission("getProtectionDomain")</code>.
+   * and all permissions.
    *
    * @return the protection domain
    * @throws SecurityException if the security manager exists and the caller
@@ -1136,9 +755,14 @@
   {
     SecurityManager sm = System.getSecurityManager();
     if (sm != null)
-      sm.checkPermission(new RuntimePermission("getProtectionDomain"));
+      sm.checkPermission(VMClassLoader.protectionDomainPermission);
+    
+    ProtectionDomain protectionDomain = getProtectionDomain0();
 
-    return pd == null ? unknownProtectionDomain : pd;
+    if (protectionDomain == null)
+      return VMClassLoader.unknownProtectionDomain;
+    else
+      return protectionDomain;
   }
 
   /**
@@ -1225,32 +849,6 @@
   }
 
   /**
-   * Like <code>getField(String)</code> but without the security checks and returns null
-   * instead of throwing NoSuchFieldException.
-   */
-  private Field internalGetField(String name)
-  {
-    Field[] fields = getDeclaredFields(true);
-    for (int i = 0; i < fields.length; i++)
-      {
-	Field field = fields[i];
-	if (field.getName().equals(name))
-	  return field;
-      }
-    Class[] interfaces = getInterfaces();
-    for (int i = 0; i < interfaces.length; i++)
-      {
-	Field field = interfaces[i].internalGetField(name);
-	if(field != null)
-	  return field;
-      }
-    Class superClass = getSuperclass();
-    if (superClass != null)
-      return superClass.internalGetField(name);
-    return null;
-  }
-
-  /**
    * Strip the last portion of the name (after the last dot).
    *
    * @param name the name to get package of
