--- /home/tromey/gnu/Nightly/classpath/classpath/java/awt/geom/QuadCurve2D.java	2004-08-02 02:26:53.000000000 -0600
+++ java/awt/geom/QuadCurve2D.java	2004-01-06 02:18:20.000000000 -0700
@@ -1,5 +1,5 @@
 /* QuadCurve2D.java -- represents a parameterized quadratic curve in 2-D space
-   Copyright (C) 2002, 2003, 2004 Free Software Foundation
+   Copyright (C) 2002, 2003 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -35,6 +35,7 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
+
 package java.awt.geom;
 
 import java.awt.Rectangle;
@@ -52,14 +53,12 @@
  * @author Eric Blake (ebb9@email.byu.edu)
  * @author Graydon Hoare (graydon@redhat.com)
  * @author Sascha Brawer (brawer@dandelis.ch)
- * @author Sven de Marothy (sven@physto.se)
  *
  * @since 1.2
  */
-public abstract class QuadCurve2D implements Shape, Cloneable
+public abstract class QuadCurve2D
+  implements Shape, Cloneable
 {
-  private static final double BIG_VALUE = java.lang.Double.MAX_VALUE / 10.0;
-
   /**
    * Constructs a new QuadCurve2D. Typical users will want to
    * construct instances of a subclass, such as {@link
@@ -69,57 +68,67 @@
   {
   }
 
+
   /**
    * Returns the <i>x</i> coordinate of the curve&#x2019;s start
    * point.
    */
   public abstract double getX1();
 
+
   /**
    * Returns the <i>y</i> coordinate of the curve&#x2019;s start
    * point.
    */
   public abstract double getY1();
 
+
   /**
    * Returns the curve&#x2019;s start point.
    */
   public abstract Point2D getP1();
 
+
   /**
    * Returns the <i>x</i> coordinate of the curve&#x2019;s control
    * point.
    */
   public abstract double getCtrlX();
 
+
   /**
    * Returns the <i>y</i> coordinate of the curve&#x2019;s control
    * point.
    */
   public abstract double getCtrlY();
 
+
   /**
    * Returns the curve&#x2019;s control point.
    */
   public abstract Point2D getCtrlPt();
 
+
   /**
    * Returns the <i>x</i> coordinate of the curve&#x2019;s end
    * point.
    */
   public abstract double getX2();
 
+
   /**
    * Returns the <i>y</i> coordinate of the curve&#x2019;s end
    * point.
    */
   public abstract double getY2();
 
+
   /**
    * Returns the curve&#x2019;s end point.
    */
   public abstract Point2D getP2();
 
+
   /**
    * Changes the curve geometry, separately specifying each coordinate
    * value.
@@ -145,6 +154,7 @@
   public abstract void setCurve(double x1, double y1, double cx, double cy,
                                 double x2, double y2);
 
+
   /**
    * Changes the curve geometry, passing coordinate values in an
    * array.
@@ -164,10 +174,12 @@
    */
   public void setCurve(double[] coords, int offset)
   {
-    setCurve(coords[offset++], coords[offset++], coords[offset++],
-             coords[offset++], coords[offset++], coords[offset++]);
+    setCurve(coords[offset++], coords[offset++],
+             coords[offset++], coords[offset++],
+             coords[offset++], coords[offset++]);
   }
 
+
   /**
    * Changes the curve geometry, specifying coordinate values in
    * separate Point objects.
@@ -186,9 +198,11 @@
    */
   public void setCurve(Point2D p1, Point2D c, Point2D p2)
   {
-    setCurve(p1.getX(), p1.getY(), c.getX(), c.getY(), p2.getX(), p2.getY());
+    setCurve(p1.getX(), p1.getY(), c.getX(), c.getY(),
+             p2.getX(), p2.getY());
   }
 
+
   /**
    * Changes the curve geometry, specifying coordinate values in an
    * array of Point objects.
@@ -209,11 +223,12 @@
    */
   public void setCurve(Point2D[] pts, int offset)
   {
-    setCurve(pts[offset].getX(), pts[offset].getY(), pts[offset + 1].getX(),
-             pts[offset + 1].getY(), pts[offset + 2].getX(),
-             pts[offset + 2].getY());
+    setCurve(pts[offset].getX(), pts[offset].getY(),
+             pts[offset + 1].getX(), pts[offset + 1].getY(),
+             pts[offset + 2].getX(), pts[offset + 2].getY());
   }
 
+
   /**
    * Changes the geometry of the curve to that of another curve.
    *
@@ -221,10 +236,11 @@
    */
   public void setCurve(QuadCurve2D c)
   {
-    setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(), c.getX2(),
-             c.getY2());
+    setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(),
+             c.getX2(), c.getY2());
   }
 
+
   /**
    * Calculates the squared flatness of a quadratic curve, directly
    * specifying each coordinate value. The flatness is the distance of
@@ -251,6 +267,7 @@
     return Line2D.ptSegDistSq(x1, y1, x2, y2, cx, cy);
   }
 
+
   /**
    * Calculates the flatness of a quadratic curve, directly specifying
    * each coordinate value. The flatness is the distance of the
@@ -277,6 +294,7 @@
     return Line2D.ptSegDist(x1, y1, x2, y2, cx, cy);
   }
 
+
   /**
    * Calculates the squared flatness of a quadratic curve, specifying
    * the coordinate values in an array. The flatness is the distance
@@ -310,6 +328,7 @@
                               coords[offset + 2], coords[offset + 3]);
   }
 
+
   /**
    * Calculates the flatness of a quadratic curve, specifying the
    * coordinate values in an array. The flatness is the distance of
@@ -343,6 +362,7 @@
                             coords[offset + 2], coords[offset + 3]);
   }
 
+
   /**
    * Calculates the squared flatness of this curve. The flatness is
    * the distance of the control point to the line between start and
@@ -358,10 +378,12 @@
    */
   public double getFlatnessSq()
   {
-    return Line2D.ptSegDistSq(getX1(), getY1(), getX2(), getY2(), getCtrlX(),
-                              getCtrlY());
+    return Line2D.ptSegDistSq(getX1(), getY1(),
+                              getX2(), getY2(),
+                              getCtrlX(), getCtrlY());
   }
 
+
   /**
    * Calculates the flatness of this curve. The flatness is the
    * distance of the control point to the line between start and end
@@ -377,10 +399,12 @@
    */
   public double getFlatness()
   {
-    return Line2D.ptSegDist(getX1(), getY1(), getX2(), getY2(), getCtrlX(),
-                            getCtrlY());
+    return Line2D.ptSegDist(getX1(), getY1(),
+                            getX2(), getY2(),
+                            getCtrlX(), getCtrlY());
   }
 
+
   /**
    * Subdivides this curve into two halves.
    *
@@ -399,11 +423,8 @@
   public void subdivide(QuadCurve2D left, QuadCurve2D right)
   {
     // Use empty slots at end to share single array.
-    double[] d = new double[]
-                 {
-                   getX1(), getY1(), getCtrlX(), getCtrlY(), getX2(), getY2(),
-                   0, 0, 0, 0
-                 };
+    double[] d = new double[] { getX1(), getY1(), getCtrlX(), getCtrlY(),
+                                getX2(), getY2(), 0, 0, 0, 0 };
     subdivide(d, 0, d, 0, d, 4);
     if (left != null)
       left.setCurve(d, 0);
@@ -411,6 +432,7 @@
       right.setCurve(d, 4);
   }
 
+
   /**
    * Subdivides a quadratic curve into two halves.
    *
@@ -434,6 +456,7 @@
     src.subdivide(left, right);
   }
 
+
   /**
    * Subdivides a quadratic curve into two halves, passing all
    * coordinates in an array.
@@ -477,15 +500,11 @@
    * index where the start point&#x2019;s <i>x</i> coordinate will be
    * stored.
    */
-  public static void subdivide(double[] src, int srcOff, double[] left,
-                               int leftOff, double[] right, int rightOff)
+  public static void subdivide(double[] src, int srcOff,
+                               double[] left, int leftOff,
+                               double[] right, int rightOff)
   {
-    double x1;
-    double y1;
-    double xc;
-    double yc;
-    double x2;
-    double y2;
+    double x1, y1, xc, yc, x2, y2;
 
     x1 = src[srcOff];
     y1 = src[srcOff + 1];
@@ -495,16 +514,16 @@
     y2 = src[srcOff + 5];
 
     if (left != null)
-      {
-	left[leftOff] = x1;
-	left[leftOff + 1] = y1;
-      }
+    {
+      left[leftOff] = x1;
+      left[leftOff + 1] = y1;
+    }
 
     if (right != null)
-      {
-	right[rightOff + 4] = x2;
-	right[rightOff + 5] = y2;
-      }
+    {
+      right[rightOff + 4] = x2;
+      right[rightOff + 5] = y2;
+    }
 
     x1 = (x1 + xc) / 2;
     x2 = (xc + x2) / 2;
@@ -514,22 +533,23 @@
     yc = (y1 + y2) / 2;
 
     if (left != null)
-      {
-	left[leftOff + 2] = x1;
-	left[leftOff + 3] = y1;
-	left[leftOff + 4] = xc;
-	left[leftOff + 5] = yc;
-      }
+    {
+      left[leftOff + 2] = x1;
+      left[leftOff + 3] = y1;
+      left[leftOff + 4] = xc;
+      left[leftOff + 5] = yc;
+    }
 
     if (right != null)
-      {
-	right[rightOff] = xc;
-	right[rightOff + 1] = yc;
-	right[rightOff + 2] = x2;
-	right[rightOff + 3] = y2;
-      }
+    {
+      right[rightOff] = xc;
+      right[rightOff + 1] = yc;
+      right[rightOff + 2] = x2;
+      right[rightOff + 3] = y2;
+    }
   }
 
+
   /**
    * Finds the non-complex roots of a quadratic equation, placing the
    * results into the same array as the equation coefficients. The
@@ -574,6 +594,7 @@
     return solveQuadratic(eqn, eqn);
   }
 
+
   /**
    * Finds the non-complex roots of a quadratic equation. The
    * following equation is being solved:
@@ -628,10 +649,8 @@
     // The Java implementation is very similar to the GSL code, but
     // not a strict one-to-one copy. For example, GSL would sort the
     // result.
-    double a;
-    double b;
-    double c;
-    double disc;
+
+    double a, b, c, disc;
 
     c = eqn[0];
     b = eqn[1];
@@ -642,13 +661,13 @@
     // wouldn't return -1 for constant functions, and 2 instead of 1
     // for linear functions.
     if (a == 0)
-      {
-	if (b == 0)
-	  return -1;
-
-	res[0] = -c / b;
-	return 1;
-      }
+    {
+      if (b == 0)
+        return -1;
+      
+      res[0] = -c / b;
+      return 1;
+    }
 
     disc = b * b - 4 * a * c;
 
@@ -656,149 +675,96 @@
       return 0;
 
     if (disc == 0)
-      {
-	// The GNU Scientific Library returns two identical results here.
-	// We just return one.
-	res[0] = -0.5 * b / a;
-	return 1;
-      }
+    {
+      // The GNU Scientific Library returns two identical results here.
+      // We just return one.
+      res[0] = -0.5 * b / a ;
+      return 1;
+    }
 
     // disc > 0
     if (b == 0)
-      {
-	double r;
+    {
+      double r;
 
-	r = Math.abs(0.5 * Math.sqrt(disc) / a);
-	res[0] = -r;
-	res[1] = r;
-      }
+      r = Math.abs(0.5 * Math.sqrt(disc) / a);
+      res[0] = -r;
+      res[1] = r;
+    }
     else
-      {
-	double sgnb;
-	double temp;
-
-	sgnb = (b > 0 ? 1 : -1);
-	temp = -0.5 * (b + sgnb * Math.sqrt(disc));
-
-	// The GNU Scientific Library sorts the result here. We don't.
-	res[0] = temp / a;
-	res[1] = c / temp;
-      }
+    {
+      double sgnb, temp;
+      
+      sgnb = (b > 0 ? 1 : -1);
+      temp = -0.5 * (b + sgnb * Math.sqrt(disc));
+
+      // The GNU Scientific Library sorts the result here. We don't.
+      res[0] = temp / a;
+      res[1] = c / temp;
+    }
     return 2;
   }
 
+
   /**
-   * Determines whether a point is inside the area bounded
+   * Determines whether a point lies inside the area that is bounded
    * by the curve and the straight line connecting its end points.
    *
    * <p><img src="doc-files/QuadCurve2D-5.png" width="350" height="180"
    * alt="A drawing of the area spanned by the curve" />
    *
    * <p>The above drawing illustrates in which area points are
-   * considered &#x201c;inside&#x201d; a QuadCurve2D.
+   * considered &#x201c;contained&#x201d; in a QuadCurve2D.
    */
   public boolean contains(double x, double y)
   {
-    if (! getBounds2D().contains(x, y))
-      return false;
-
-    return ((getAxisIntersections(x, y, true, BIG_VALUE) & 1) != 0);
+    // XXX Implement.
+    throw new Error("not implemented");
   }
 
+
   /**
-   * Determines whether a point is inside the area bounded
+   * Determines whether a point lies inside the area that is bounded
    * by the curve and the straight line connecting its end points.
    *
    * <p><img src="doc-files/QuadCurve2D-5.png" width="350" height="180"
    * alt="A drawing of the area spanned by the curve" />
    *
    * <p>The above drawing illustrates in which area points are
-   * considered &#x201c;inside&#x201d; a QuadCurve2D.
+   * considered &#x201c;contained&#x201d; in a QuadCurve2D.
    */
   public boolean contains(Point2D p)
   {
     return contains(p.getX(), p.getY());
   }
 
-  /**
-   * Determines whether any part of a rectangle is inside the area bounded
-   * by the curve and the straight line connecting its end points.
-   *
-   * <p><img src="doc-files/QuadCurve2D-5.png" width="350" height="180"
-   * alt="A drawing of the area spanned by the curve" />
-   *
-   * <p>The above drawing illustrates in which area points are
-   * considered &#x201c;inside&#x201d; in a CubicCurve2D.
-   */
+
   public boolean intersects(double x, double y, double w, double h)
   {
-    if (! getBounds2D().contains(x, y, w, h))
-      return false;
-
-    /* Does any edge intersect? */
-    if (getAxisIntersections(x, y, true, w) != 0 /* top */
-        || getAxisIntersections(x, y + h, true, w) != 0 /* bottom */
-        || getAxisIntersections(x + w, y, false, h) != 0 /* right */
-        || getAxisIntersections(x, y, false, h) != 0) /* left */
-      return true;
-
-    /* No intersections, is any point inside? */
-    if ((getAxisIntersections(x, y, true, BIG_VALUE) & 1) != 0)
-      return true;
-
-    return false;
+    // XXX Implement.
+    throw new Error("not implemented");
   }
 
-  /**
-   * Determines whether any part of a Rectangle2D is inside the area bounded 
-   * by the curve and the straight line connecting its end points.
-   * @see #intersects(double, double, double, double)
-   */
+
   public boolean intersects(Rectangle2D r)
   {
     return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());
   }
 
-  /**
-   * Determines whether a rectangle is entirely inside the area bounded
-   * by the curve and the straight line connecting its end points.
-   *
-   * <p><img src="doc-files/QuadCurve2D-5.png" width="350" height="180"
-   * alt="A drawing of the area spanned by the curve" />
-   *
-   * <p>The above drawing illustrates in which area points are
-   * considered &#x201c;inside&#x201d; a QuadCurve2D.
-   * @see #contains(double, double)
-   */
+
   public boolean contains(double x, double y, double w, double h)
   {
-    if (! getBounds2D().intersects(x, y, w, h))
-      return false;
-
-    /* Does any edge intersect? */
-    if (getAxisIntersections(x, y, true, w) != 0 /* top */
-        || getAxisIntersections(x, y + h, true, w) != 0 /* bottom */
-        || getAxisIntersections(x + w, y, false, h) != 0 /* right */
-        || getAxisIntersections(x, y, false, h) != 0) /* left */
-      return false;
-
-    /* No intersections, is any point inside? */
-    if ((getAxisIntersections(x, y, true, BIG_VALUE) & 1) != 0)
-      return true;
-
-    return false;
+    // XXX Implement.
+    throw new Error("not implemented");
   }
 
-  /**
-   * Determines whether a Rectangle2D is entirely inside the area that is 
-   * bounded by the curve and the straight line connecting its end points.
-   * @see #contains(double, double, double, double)
-   */
+
   public boolean contains(Rectangle2D r)
   {
     return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());
   }
 
+
   /**
    * Determines the smallest rectangle that encloses the
    * curve&#x2019;s start, end and control point. As the illustration
@@ -814,194 +780,115 @@
     return getBounds2D().getBounds();
   }
 
+
   public PathIterator getPathIterator(final AffineTransform at)
   {
     return new PathIterator()
-      {
-	/** Current coordinate. */
-	private int current = 0;
-
-	public int getWindingRule()
-	{
-	  return WIND_NON_ZERO;
-	}
-
-	public boolean isDone()
-	{
-	  return current >= 2;
-	}
-
-	public void next()
-	{
-	  current++;
-	}
-
-	public int currentSegment(float[] coords)
-	{
-	  int result;
-	  switch (current)
-	    {
-	    case 0:
-	      coords[0] = (float) getX1();
-	      coords[1] = (float) getY1();
-	      result = SEG_MOVETO;
-	      break;
-	    case 1:
-	      coords[0] = (float) getCtrlX();
-	      coords[1] = (float) getCtrlY();
-	      coords[2] = (float) getX2();
-	      coords[3] = (float) getY2();
-	      result = SEG_QUADTO;
-	      break;
-	    default:
-	      throw new NoSuchElementException("quad iterator out of bounds");
-	    }
-	  if (at != null)
-	    at.transform(coords, 0, coords, 0, 2);
-	  return result;
-	}
-
-	public int currentSegment(double[] coords)
-	{
-	  int result;
-	  switch (current)
-	    {
-	    case 0:
-	      coords[0] = getX1();
-	      coords[1] = getY1();
-	      result = SEG_MOVETO;
-	      break;
-	    case 1:
-	      coords[0] = getCtrlX();
-	      coords[1] = getCtrlY();
-	      coords[2] = getX2();
-	      coords[3] = getY2();
-	      result = SEG_QUADTO;
-	      break;
-	    default:
-	      throw new NoSuchElementException("quad iterator out of bounds");
-	    }
-	  if (at != null)
-	    at.transform(coords, 0, coords, 0, 2);
-	  return result;
-	}
-      };
-  }
+    {
+      /** Current coordinate. */
+      private int current = 0;
 
-  public PathIterator getPathIterator(AffineTransform at, double flatness)
-  {
-    return new FlatteningPathIterator(getPathIterator(at), flatness);
-  }
 
-  /**
-   * Creates a new curve with the same contents as this one.
-   *
-   * @return the clone.
-   */
-  public Object clone()
-  {
-    try
-      {
-	return super.clone();
-      }
-    catch (CloneNotSupportedException e)
+      public int getWindingRule()
       {
-	throw (Error) new InternalError().initCause(e); // Impossible
+        return WIND_NON_ZERO;
       }
-  }
 
-  /**
-   * Helper method used by contains() and intersects() methods
-   * Return the number of curve/line intersections on a given axis
-   * extending from a certain point. useYaxis is true for using the Y axis,
-   * @param x x coordinate of the origin point
-   * @param y y coordinate of the origin point
-   * @param useYaxis axis to follow, if true the positive Y axis is used,
-   * false uses the positive X axis.
-   *
-   * This is an implementation of the line-crossings algorithm,
-   * Detailed in an article on Eric Haines' page:
-   * http://www.acm.org/tog/editors/erich/ptinpoly/
-   */
-  private int getAxisIntersections(double x, double y, boolean useYaxis,
-                                   double distance)
-  {
-    int nCrossings = 0;
-    double a0;
-    double a1;
-    double a2;
-    double b0;
-    double b1;
-    double b2;
-    double[] r = new double[3];
-    int nRoots;
-
-    a0 = a2 = 0.0;
 
-    if (useYaxis)
-      {
-	a0 = getY1() - y;
-	a1 = getCtrlY() - y;
-	a2 = getY2() - y;
-	b0 = getX1() - x;
-	b1 = getCtrlX() - x;
-	b2 = getX2() - x;
-      }
-    else
+      public boolean isDone()
       {
-	a0 = getX1() - x;
-	a1 = getCtrlX() - x;
-	a2 = getX2() - x;
-	b0 = getY1() - y;
-	b1 = getCtrlY() - y;
-	b2 = getY2() - y;
+        return current >= 2;
       }
 
-    /* If the axis intersects a start/endpoint, shift it up by some small 
-       amount to guarantee the line is 'inside'
-       If this is not done,bad behaviour may result for points on that axis. */
-    if (a0 == 0.0 || a2 == 0.0)
-      {
-	double small = getFlatness() * (1E-10);
-	if (a0 == 0.0)
-	  a0 += small;
 
-	if (a2 == 0.0)
-	  a2 += small;
+      public void next()
+      {
+        current++;
       }
 
-    r[0] = a0;
-    r[1] = 2 * (a1 - a0);
-    r[2] = (a2 - 2 * a1 + a0);
 
-    nRoots = solveQuadratic(r);
-    for (int i = 0; i < nRoots; i++)
+      public int currentSegment(float[] coords)
       {
-	double t = r[i];
-	if (t >= 0.0 && t <= 1.0)
-	  {
-	    double crossing = t * t * (b2 - 2 * b1 + b0) + 2 * t * (b1 - b0)
-	                      + b0;
-	    /* single root is always doubly degenerate in quads */
-	    if (crossing > 0 && crossing < distance)
-	      nCrossings += (nRoots == 1) ? 2 : 1;
-	  }
+        int result;
+        switch (current)
+        {
+        case 0:
+          coords[0] = (float) getX1();
+          coords[1] = (float) getY1();
+          result = SEG_MOVETO;
+          break;
+
+        case 1:
+          coords[0] = (float) getCtrlX();
+          coords[1] = (float) getCtrlY();
+          coords[2] = (float) getX2();
+          coords[3] = (float) getY2();
+          result = SEG_QUADTO;
+          break;
+
+        default:
+          throw new NoSuchElementException("quad iterator out of bounds");
+        }
+        if (at != null)
+          at.transform(coords, 0, coords, 0, 2);
+        return result;
       }
 
-    if (useYaxis)
-      {
-	if (Line2D.linesIntersect(b0, a0, b2, a2, 0.0, 0.0, distance, 0.0))
-	  nCrossings++;
-      }
-    else
+
+      public int currentSegment(double[] coords)
       {
-	if (Line2D.linesIntersect(a0, b0, a2, b2, 0.0, 0.0, 0.0, distance))
-	  nCrossings++;
+        int result;
+        switch (current)
+        {
+        case 0:
+          coords[0] = getX1();
+          coords[1] = getY1();
+          result = SEG_MOVETO;
+          break;
+
+        case 1:
+          coords[0] = getCtrlX();
+          coords[1] = getCtrlY();
+          coords[2] = getX2();
+          coords[3] = getY2();
+          result = SEG_QUADTO;
+          break;
+
+        default:
+          throw new NoSuchElementException("quad iterator out of bounds");
+        }
+        if (at != null)
+          at.transform(coords, 0, coords, 0, 2);
+        return result;
       }
+    };
+  }
 
-    return (nCrossings);
+
+  public PathIterator getPathIterator(AffineTransform at, double flatness)
+  {
+    return new FlatteningPathIterator(getPathIterator(at), flatness);
   }
 
+
+  /**
+   * Creates a new curve with the same contents as this one.
+   *
+   * @return the clone.
+   */
+  public Object clone()
+  {
+    try
+    {
+      return super.clone();
+    }
+    catch (CloneNotSupportedException e)
+    {
+      throw (Error) new InternalError().initCause(e); // Impossible
+    }
+  }
+
+
   /**
    * A two-dimensional curve that is parameterized with a quadratic
    * function and stores coordinate values in double-precision
@@ -1012,38 +899,45 @@
    * @author Eric Blake (ebb9@email.byu.edu)
    * @author Sascha Brawer (brawer@dandelis.ch)
    */
-  public static class Double extends QuadCurve2D
+  public static class Double
+    extends QuadCurve2D
   {
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s start point.
      */
     public double x1;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s start point.
      */
     public double y1;
 
+
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s control point.
      */
     public double ctrlx;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s control point.
      */
     public double ctrly;
 
+
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s end point.
      */
     public double x2;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s end point.
      */
     public double y2;
 
+
     /**
      * Constructs a new QuadCurve2D that stores its coordinate values
      * in double-precision floating-point format. All points are
@@ -1053,6 +947,7 @@
     {
     }
 
+
     /**
      * Constructs a new QuadCurve2D that stores its coordinate values
      * in double-precision floating-point format, specifying the
@@ -1076,8 +971,8 @@
      * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end
      * point.
      */
-    public Double(double x1, double y1, double cx, double cy, double x2,
-                  double y2)
+    public Double(double x1, double y1, double cx, double cy,
+                  double x2, double y2)
     {
       this.x1 = x1;
       this.y1 = y1;
@@ -1087,6 +982,7 @@
       this.y2 = y2;
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s start
      * point.
@@ -1096,6 +992,7 @@
       return x1;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s start
      * point.
@@ -1105,6 +1002,7 @@
       return y1;
     }
 
+
     /**
      * Returns the curve&#x2019;s start point.
      */
@@ -1113,6 +1011,7 @@
       return new Point2D.Double(x1, y1);
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s control
      * point.
@@ -1122,6 +1021,7 @@
       return ctrlx;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s control
      * point.
@@ -1131,6 +1031,7 @@
       return ctrly;
     }
 
+
     /**
      * Returns the curve&#x2019;s control point.
      */
@@ -1139,6 +1040,7 @@
       return new Point2D.Double(ctrlx, ctrly);
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s end
      * point.
@@ -1148,6 +1050,7 @@
       return x2;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s end
      * point.
@@ -1157,6 +1060,7 @@
       return y2;
     }
 
+
     /**
      * Returns the curve&#x2019;s end point.
      */
@@ -1165,6 +1069,7 @@
       return new Point2D.Double(x2, y2);
     }
 
+
     /**
      * Changes the geometry of the curve.
      *
@@ -1197,6 +1102,7 @@
       this.y2 = y2;
     }
 
+
     /**
      * Determines the smallest rectangle that encloses the
      * curve&#x2019;s start, end and control point. As the
@@ -1217,6 +1123,7 @@
     }
   }
 
+
   /**
    * A two-dimensional curve that is parameterized with a quadratic
    * function and stores coordinate values in single-precision
@@ -1227,38 +1134,45 @@
    * @author Eric Blake (ebb9@email.byu.edu)
    * @author Sascha Brawer (brawer@dandelis.ch)
    */
-  public static class Float extends QuadCurve2D
+  public static class Float
+    extends QuadCurve2D
   {
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s start point.
      */
     public float x1;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s start point.
      */
     public float y1;
 
+
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s control point.
      */
     public float ctrlx;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s control point.
      */
     public float ctrly;
 
+
     /**
      * The <i>x</i> coordinate of the curve&#x2019;s end point.
      */
     public float x2;
 
+
     /**
      * The <i>y</i> coordinate of the curve&#x2019;s end point.
      */
     public float y2;
 
+
     /**
      * Constructs a new QuadCurve2D that stores its coordinate values
      * in single-precision floating-point format. All points are
@@ -1268,6 +1182,7 @@
     {
     }
 
+
     /**
      * Constructs a new QuadCurve2D that stores its coordinate values
      * in single-precision floating-point format, specifying the
@@ -1291,7 +1206,8 @@
      * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end
      * point.
      */
-    public Float(float x1, float y1, float cx, float cy, float x2, float y2)
+    public Float(float x1, float y1, float cx, float cy,
+                 float x2, float y2)
     {
       this.x1 = x1;
       this.y1 = y1;
@@ -1301,6 +1217,7 @@
       this.y2 = y2;
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s start
      * point.
@@ -1310,6 +1227,7 @@
       return x1;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s start
      * point.
@@ -1319,6 +1237,7 @@
       return y1;
     }
 
+
     /**
      * Returns the curve&#x2019;s start point.
      */
@@ -1327,6 +1246,7 @@
       return new Point2D.Float(x1, y1);
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s control
      * point.
@@ -1336,6 +1256,7 @@
       return ctrlx;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s control
      * point.
@@ -1345,6 +1266,7 @@
       return ctrly;
     }
 
+
     /**
      * Returns the curve&#x2019;s control point.
      */
@@ -1353,6 +1275,7 @@
       return new Point2D.Float(ctrlx, ctrly);
     }
 
+
     /**
      * Returns the <i>x</i> coordinate of the curve&#x2019;s end
      * point.
@@ -1362,6 +1285,7 @@
       return x2;
     }
 
+
     /**
      * Returns the <i>y</i> coordinate of the curve&#x2019;s end
      * point.
@@ -1371,6 +1295,7 @@
       return y2;
     }
 
+
     /**
      * Returns the curve&#x2019;s end point.
      */
@@ -1379,6 +1304,7 @@
       return new Point2D.Float(x2, y2);
     }
 
+
     /**
      * Changes the geometry of the curve, specifying coordinate values
      * as double-precision floating-point numbers.
@@ -1412,6 +1338,7 @@
       this.y2 = (float) y2;
     }
 
+
     /**
      * Changes the geometry of the curve, specifying coordinate values
      * as single-precision floating-point numbers.
@@ -1434,8 +1361,8 @@
      * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new
      * end point.
      */
-    public void setCurve(float x1, float y1, float cx, float cy, float x2,
-                         float y2)
+    public void setCurve(float x1, float y1, float cx, float cy,
+                         float x2, float y2)
     {
       this.x1 = x1;
       this.y1 = y1;
@@ -1445,6 +1372,7 @@
       this.y2 = y2;
     }
 
+
     /**
      * Determines the smallest rectangle that encloses the
      * curve&#x2019;s start, end and control point. As the
