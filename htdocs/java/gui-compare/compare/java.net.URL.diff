--- /home/tromey/gnu/Nightly/classpath/classpath/java/net/URL.java	2004-07-17 02:21:35.000000000 -0600
+++ java/net/URL.java	2004-07-22 11:06:31.000000000 -0600
@@ -1,6 +1,5 @@
 /* URL.java -- Uniform Resource Locator Class
-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004
-   Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -39,8 +38,6 @@
 package java.net;
 
 import gnu.java.net.URLParseError;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
@@ -124,10 +121,7 @@
 public final class URL implements Serializable
 {
   private static final String DEFAULT_SEARCH_PATH =
-    "gnu.java.net.protocol|gnu.inet";
-
-  // Cached System ClassLoader
-  private static ClassLoader systemClassLoader;
+    "gnu.java.net.protocol|sun.net.www.protocol";
 
   /**
    * The name of the protocol for this URL.
@@ -268,8 +262,7 @@
   {
     if (protocol == null)
       throw new MalformedURLException("null protocol");
-    protocol = protocol.toLowerCase();
-    this.protocol = protocol;
+    this.protocol = protocol.toLowerCase();
 
     if (ph != null)
       {
@@ -289,7 +282,7 @@
     this.host = host;
     this.port = port;
     this.authority = (host != null) ? host : "";
-    if (port >= 0 && host != null)
+    if (port >= 0)
 	this.authority += ":" + port;
 
     int hashAt = file.indexOf('#');
@@ -519,7 +512,7 @@
    * Defined as <code>path[?query]</code>.
    * Returns the empty string if there is no file portion.
    *
-   * @return The filename specified in this URL, or an empty string if empty.
+   * @return The filename specified in this URL.
    */
   public String getFile()
   {
@@ -530,17 +523,13 @@
    * Returns the path of the URL. This is the part of the file before any '?'
    * character.
    *
-   * @return The path specified in this URL, or null if empty.
+   * @return The path specified in this URL.
    *
    * @since 1.3
    */
   public String getPath()
   {
-    // The spec says we need to return an empty string, but some
-    // applications depends on receiving null when the path is empty.
-    if (file == null)
-      return null;
-    int quest = file.indexOf('?');
+    int quest = (file == null) ? -1 : file.indexOf('?');
     return quest < 0 ? getFile() : file.substring(0, quest);
   }
 
@@ -695,8 +684,7 @@
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. This might be called
    * by the <code>parseURL()</code> method in that class. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL
    * @param host The hostname or IP address for this URL
@@ -707,18 +695,12 @@
   protected void set(String protocol, String host, int port, String file,
                      String ref)
   {
-    URLStreamHandler protocolHandler = null;
-    protocol = protocol.toLowerCase();
-    if (! this.protocol.equals(protocol))
-      protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
-      {
-	this.ph = protocolHandler;
-	this.protocol = protocol;
-      }
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    this.ph = getURLStreamHandler(protocol);
+    this.protocol = protocol.toLowerCase();
     this.authority = "";
     this.port = port;
     this.host = host;
@@ -736,8 +718,7 @@
   /**
    * Sets the specified fields of the URL. This is not a public method so
    * that only URLStreamHandlers can modify URL fields. URLs are otherwise
-   * constant. If the given protocol does not exist, it will keep the previously
-   * set protocol.
+   * constant.
    *
    * @param protocol The protocol name for this URL.
    * @param host The hostname or IP address for this URL.
@@ -753,18 +734,12 @@
   protected void set(String protocol, String host, int port, String authority,
                      String userInfo, String path, String query, String ref)
   {
-    URLStreamHandler protocolHandler = null;
-    protocol = protocol.toLowerCase();
-    if (! this.protocol.equals(protocol))
-      protocolHandler = getURLStreamHandler(protocol);
-    
-    // It is an hidden feature of the JDK. If the protocol does not exist,
-    // we keep the previously initialized protocol.
-    if (protocolHandler != null)
-      {
-	this.ph = protocolHandler;
-	this.protocol = protocol;
-      }
+    // TBD: Theoretically, a poorly written StreamHandler could pass an
+    // invalid protocol.  It will cause the handler to be set to null
+    // thus overriding a valid handler.  Callers of this method should
+    // be aware of this.
+    this.ph = getURLStreamHandler(protocol);
+    this.protocol = protocol.toLowerCase();
     this.host = host;
     this.userInfo = userInfo;
     this.port = port;
@@ -850,6 +825,24 @@
       {
 	ph = factory.createURLStreamHandler(protocol);
       }
+    else if (protocol.equals("core"))
+      {
+ 	ph = new gnu.java.net.protocol.core.Handler();
+      }
+    else if (protocol.equals("file"))
+      {
+	// This is an interesting case.  It's tempting to think that we
+	// could call Class.forName ("gnu.java.net.protocol.file.Handler") to
+	// get the appropriate class.  Unfortunately, if we do that the
+	// program will never terminate, because getURLStreamHandler is
+	// eventually called by Class.forName.
+	//
+	// Treating "file" as a special case is the minimum that will
+	// fix this problem.  If other protocols are required in a
+	// statically linked application they will need to be handled in
+	// the same way as "file".
+	ph = new gnu.java.net.protocol.file.Handler();
+      }
 
     // Non-default factory may have returned null or a factory wasn't set.
     // Use the default search algorithm to find a handler for this protocol.
@@ -871,39 +864,36 @@
 	// Finally loop through our search path looking for a match.
 	StringTokenizer pkgPrefix = new StringTokenizer(ph_search_path, "|");
 
-	// Cache the systemClassLoader
-	if (systemClassLoader == null)
-	  {
-	    systemClassLoader = (ClassLoader) AccessController.doPrivileged
-	      (new PrivilegedAction() {
-		  public Object run() {
-		    return ClassLoader.getSystemClassLoader();
-		  }
-		});
-	  }
-
 	do
 	  {
+	    String clsName =
+	      (pkgPrefix.nextToken() + "." + protocol + ".Handler");
+
 	    try
 	      {
-		// Try to get a class from the system/application
-		// classloader, initialize it, make an instance
-		// and try to cast it to a URLStreamHandler.
-		String clsName =
-		  (pkgPrefix.nextToken() + "." + protocol + ".Handler");
-		Class c = Class.forName(clsName, true, systemClassLoader);
-		ph = (URLStreamHandler) c.newInstance();
+		Object obj = Class.forName(clsName).newInstance();
+
+		if (! (obj instanceof URLStreamHandler))
+		  continue;
+		else
+		  ph = (URLStreamHandler) obj;
+	      }
+	    catch (Exception e)
+	      {
+		// Can't instantiate; handler still null,
+		// go on to next element.
 	      }
-	    catch (Throwable t) { /* ignored */ }
 	  }
-	 while (ph == null && pkgPrefix.hasMoreTokens());
+	 while ((! (ph instanceof URLStreamHandler))
+	        && pkgPrefix.hasMoreTokens());
       }
 
     // Update the hashtable with the new protocol handler.
     if (ph != null && cache_handlers)
-      ph_cache.put(protocol, ph);
-    else
-      ph = null;
+      if (ph instanceof URLStreamHandler)
+	ph_cache.put(protocol, ph);
+      else
+	ph = null;
 
     return ph;
   }
