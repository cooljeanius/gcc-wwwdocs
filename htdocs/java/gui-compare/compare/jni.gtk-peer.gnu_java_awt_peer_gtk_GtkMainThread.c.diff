--- /home/tromey/gnu/Nightly/classpath/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-07-23 02:24:16.000000000 -0600
+++ jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c	2004-07-22 11:06:59.000000000 -0600
@@ -63,9 +63,11 @@
 
 JNIEnv *gdk_env;
 
-GtkWindowGroup *global_gtk_window_group;
+#ifdef PORTABLE_NATIVE_SYNC
+JavaVM *gdk_vm;
+#endif
 
-static void init_glib_threads(JNIEnv *, jint);
+GtkWindowGroup *global_gtk_window_group;
 
 double dpi_conversion_factor;
 
@@ -76,17 +78,10 @@
 /*
  * Call gtk_init.  It is very important that this happen before any other
  * gtk calls.
- *
- * The portableNativeSync argument may have the values:
- *   1 if the Java property gnu.classpath.awt.gtk.portable.native.sync
- *     is set to "true".  
- *   0 if it is set to "false"
- *  -1 if unset.
  */
 
 JNIEXPORT void JNICALL 
-Java_gnu_java_awt_peer_gtk_GtkMainThread_gtkInit (JNIEnv *env, jclass clazz,
-                                                  jint portableNativeSync)
+Java_gnu_java_awt_peer_gtk_GtkMainThread_gtkInit (JNIEnv *env, jclass clazz)
 {
   int argc = 1;
   char **argv;
@@ -96,22 +91,23 @@
     gtkmenuitempeer, gtktextcomponentpeer, window;
 
   NSA_INIT (env, clazz);
-  gdk_env = env;
 
   /* GTK requires a program's argc and argv variables, and requires that they
-     be valid.   Set it up. */
-  argv = (char **) g_malloc (sizeof (char *) * 2);
-  argv[0] = (char *) g_malloc(1);
-#if 1
-  strcpy(argv[0], "");
-#else  /* The following is a more efficient alternative, but less intuitively
-	* expresses what we are trying to do.   This code is only run once, so
-	* I'm going for intuitive. */
-  argv[0][0] = '\0';
-#endif
+     be valid.  */
+
+  argv = (char **) malloc (sizeof (char *) * 2);
+  argv[0] = "";
   argv[1] = NULL;
 
-  init_glib_threads(env, portableNativeSync);
+  /* until we have JDK 1.2 JNI, assume we have a VM with threads that 
+     match what GLIB was compiled for */
+#ifdef PORTABLE_NATIVE_SYNC
+  (*env)->GetJavaVM( env, &gdk_vm );
+  g_thread_init ( &g_thread_jni_functions );
+  printf("called gthread init\n");
+#else
+  g_thread_init ( NULL );
+#endif
 
   /* From GDK 2.0 onwards we have to explicitly call gdk_threads_init */
   gdk_threads_init();
@@ -126,19 +122,21 @@
      we're shutting down. */
   atexit (gdk_threads_enter);
 
+  gdk_env = env;
   gdk_event_handler_set ((GdkEventFunc)awt_event_handler, NULL, NULL);
 
   if ((homedir = getenv ("HOME")))
     {
-      rcpath = (char *) g_malloc (strlen (homedir) + strlen (RC_FILE) + 2);
+      rcpath = (char *) malloc (strlen (homedir) + strlen (RC_FILE) + 2);
       sprintf (rcpath, "%s/%s", homedir, RC_FILE);
     }
   
   gtk_rc_parse ((rcpath) ? rcpath : RC_FILE);
 
-  g_free (rcpath);
-  g_free (argv[0]);
-  g_free (argv);
+  if (rcpath)
+    free (rcpath);
+
+  free (argv);
 
   /* setup cached IDs for posting GTK events to Java */
 /*    gtkgenericpeer = (*env)->FindClass (env,  */
@@ -206,37 +204,6 @@
   init_dpi_conversion_factor ();
 }
 
-
-/** Initialize GLIB's threads properly, based on the value of the
-    gnu.classpath.awt.gtk.portable.native.sync Java system property.  If
-    that's unset, use the PORTABLE_NATIVE_SYNC config.h macro.  (TODO: 
-    In some release following 0.10, that config.h macro will go away.)
-    */ 
-static void 
-init_glib_threads(JNIEnv *env, jint portableNativeSync)
-{
-  if (portableNativeSync < 0)
-    {
-#ifdef PORTABLE_NATIVE_SYNC /* Default value, if not set by the Java system
-                               property */ 
-      portableNativeSync = 1;
-#else
-      portableNativeSync = 0;
-#endif
-    }
-  
-  (*env)->GetJavaVM( env, &the_vm );
-  if (portableNativeSync)
-    g_thread_init ( &portable_native_sync_jni_functions );
-  else
-    g_thread_init ( NULL );
-
-  /* Debugging progress message; uncomment if needed: */
-  /*   printf("called gthread init\n"); */
-}
-
-
-
 /*
  * Run gtk_main and block.
  */ 
@@ -265,14 +232,12 @@
       int int_dpi;
       g_object_get (settings, "gtk-xft-dpi", &int_dpi, NULL);
       /* If int_dpi == -1 gtk-xft-dpi returns the default value. So we
-	 have to do approximate calculation here.  */
-      if (int_dpi < 0)
-	dpi_conversion_factor = PANGO_SCALE * 72.0 / 96.;
-      else
-	dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
-
+         have to do approximate calculation here.  The value is 1024 *
+         dots.  We take 96 for dots.  */
+      if (int_dpi < 0)  int_dpi = 98304;
+      dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
       g_signal_connect (settings, "notify::gtk-xft-dpi",
-			G_CALLBACK (dpi_changed_cb), NULL);
+                        G_CALLBACK (dpi_changed_cb), NULL);
     }
   else
     /* Approximate. */
@@ -281,12 +246,9 @@
 
 static void
 dpi_changed_cb (GtkSettings  *settings,
-		GParamSpec *pspec __attribute__((unused)))
+                GParamSpec *pspec __attribute__((unused)))
 {
   int int_dpi;
   g_object_get (settings, "gtk-xft-dpi", &int_dpi, NULL);
-  if (int_dpi < 0)
-    dpi_conversion_factor = PANGO_SCALE * 72.0 / 96.;
-  else
-    dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
+  dpi_conversion_factor = PANGO_SCALE * 72.0 / (int_dpi / PANGO_SCALE);
 }
