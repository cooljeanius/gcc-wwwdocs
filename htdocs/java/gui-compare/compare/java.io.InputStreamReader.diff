--- /home/tromey/gnu/Nightly/classpath/classpath/java/io/InputStreamReader.java	2004-04-18 02:22:15.000000000 -0600
+++ java/io/InputStreamReader.java	2004-07-22 11:06:27.000000000 -0600
@@ -1,5 +1,5 @@
 /* InputStreamReader.java -- Reader than transforms bytes to chars
-   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2001, 2003, 2004 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -38,8 +38,7 @@
 
 package java.io;
 
-import gnu.java.io.EncodingManager;
-import gnu.java.io.decode.Decoder;
+import gnu.gcj.convert.*;
 
 /**
  * This class reads characters from a byte input stream.   The characters
@@ -88,11 +87,20 @@
  */
 public class InputStreamReader extends Reader
 {
+  BufferedInputStream in;
+
+  // Buffer of chars read from in and converted but not consumed.
+  char[] work;
+  // Next available character (in work buffer) to read.
+  int wpos;
+  // Last available character (in work buffer) to read.
+  int wcount;
+
   /*
    * This is the byte-character decoder class that does the reading and
    * translation of bytes from the underlying stream.
    */
-  private Decoder in;
+  BytesToUnicode converter;
 
   /**
    * This method initializes a new instance of <code>InputStreamReader</code>
@@ -102,9 +110,7 @@
    */
   public InputStreamReader(InputStream in)
   {
-    if (in == null)
-      throw new NullPointerException();
-    this.in = EncodingManager.getDecoder(in);
+    this(in, BytesToUnicode.getDefaultDecoder());
   }
 
   /**
@@ -122,11 +128,23 @@
   public InputStreamReader(InputStream in, String encoding_name)
     throws UnsupportedEncodingException
   {
-    if (in == null
-        || encoding_name == null)
-      throw new NullPointerException();
-    
-    this.in = EncodingManager.getDecoder(in, encoding_name);
+    this(in, BytesToUnicode.getDecoder(encoding_name));
+  }
+
+  private InputStreamReader(InputStream in, BytesToUnicode decoder)
+  {
+    // FIXME: someone could pass in a BufferedInputStream whose buffer
+    // is smaller than the longest encoded character for this
+    // encoding.  We will probably go into an infinite loop in this
+    // case.  We probably ought to just have our own byte buffering
+    // here.
+    this.in = in instanceof BufferedInputStream
+              ? (BufferedInputStream) in
+              : new BufferedInputStream(in);
+    /* Don't need to call super(in) here as long as the lock gets set. */
+    this.lock = in;
+    converter = decoder;
+    converter.setInput(this.in.buf, 0, 0);
   }
 
   /**
@@ -142,6 +160,8 @@
 	if (in != null)
 	  in.close();
 	in = null;
+	work = null;
+	wpos = wcount = 0;
       }
   }
 
@@ -154,7 +174,7 @@
    */
   public String getEncoding()
   {
-    return in != null ? in.getSchemeName() : null;
+    return in != null ? converter.getName() : null;
   }
 
   /**
@@ -170,10 +190,19 @@
    */
   public boolean ready() throws IOException
   {
-    if (in == null)
-      throw new IOException("Reader has been closed");
-    
-    return in.ready();
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (wpos < wcount)
+	  return true;
+
+	// According to the spec, an InputStreamReader is ready if its
+	// input buffer is not empty (above), or if bytes are
+	// available on the underlying byte stream.
+	return in.available () > 0;
+      }
   }
 
   /**
@@ -191,10 +220,27 @@
    */
   public int read (char[] buf, int offset, int length) throws IOException
   {
-    if (in == null)
-      throw new IOException("Reader has been closed");
-    
-    return in.read(buf, offset, length);
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	if (length == 0)
+	  return 0;
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill their buffer.
+	    return refill(buf, offset, length);
+	  }
+
+	if (length > wavail)
+	  length = wavail;
+	System.arraycopy(work, wpos, buf, offset, length);
+	wpos += length;
+	return length;
+      }
   }
 
   /**
@@ -206,28 +252,48 @@
    */
   public int read() throws IOException
   {
-    if (in == null)
-      throw new IOException("Reader has been closed");
-    
-    return in.read();
-  }
-
-   /**
-    * Skips the specified number of chars in the stream.  It
-    * returns the actual number of chars skipped, which may be less than the
-    * requested amount.
-    *
-    * @param count The requested number of chars to skip
-    *
-    * @return The actual number of chars skipped.
-    *
-    * @exception IOException If an error occurs
-    */
-   public long skip(long count) throws IOException
-   {
-     if (in == null)
-       throw new IOException("Reader has been closed");
-     
-     return super.skip(count);
+    synchronized (lock)
+      {
+	if (in == null)
+	  throw new IOException("Stream closed");
+
+	int wavail = wcount - wpos;
+	if (wavail <= 0)
+	  {
+	    // Nothing waiting, so refill our internal buffer.
+	    wpos = wcount = 0;
+	    if (work == null)
+	       work = new char[100];
+	    int count = refill(work, 0, work.length);
+	    if (count == -1)
+	      return -1;
+	    wcount += count;
+	  }
+
+	return work[wpos++];
+      }
+  }
+
+  // Read more bytes and convert them into the specified buffer.
+  // Returns the number of converted characters or -1 on EOF.
+  private int refill(char[] buf, int offset, int length) throws IOException
+  {
+    for (;;)
+      {
+	// We have knowledge of the internals of BufferedInputStream
+	// here.  Eww.
+	in.mark (0);
+	// BufferedInputStream.refill() can only be called when
+	// `pos>=count'.
+	boolean r = in.pos < in.count || in.refill ();
+	in.reset ();
+	if (! r)
+	  return -1;
+	converter.setInput(in.buf, in.pos, in.count);
+	int count = converter.read(buf, offset, length);
+	in.skip(converter.inpos - in.pos);
+	if (count > 0)
+	  return count;
+      }
   }
 }
