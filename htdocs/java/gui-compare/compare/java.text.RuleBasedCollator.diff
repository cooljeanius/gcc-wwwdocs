--- /home/tromey/gnu/Nightly/classpath/classpath/java/text/RuleBasedCollator.java	2004-06-08 02:25:17.000000000 -0600
+++ java/text/RuleBasedCollator.java	2004-07-22 11:06:37.000000000 -0600
@@ -39,7 +39,7 @@
 
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.ArrayList;
+import java.util.Vector;
 
 /* Written using "Java Class Libraries", 2nd edition, plus online
  * API docs for JDK 1.2 from http://www.javasoft.com.
@@ -180,7 +180,7 @@
    * collation elements. It contains an instruction which specifies the new
    * state of the generator. The sequence of instruction should not contain
    * RESET (it is used by
-   * {@link #mergeRules(int,java.lang.String,java.util.ArrayList,java.util.ArrayList)})
+   * {@link #mergeRules(int,java.lang.String,java.util.Vector,java.util.Vector)})
    * as a temporary state while merging two sets of instructions.
    */
   final static class CollationSorter
@@ -304,9 +304,10 @@
    * @param patch Rules to be merged into the repository.
    * @throws ParseException if it is impossible to find an anchor point for the new rules.
    */
-  private void mergeRules(int offset, String starter, ArrayList main, ArrayList patch)
+  private void mergeRules(int offset, String starter, Vector main, Vector patch)
     throws ParseException 
   {
+    Enumeration elements = main.elements();
     int insertion_point = -1;
     int max_length = 0;
     
@@ -322,11 +323,11 @@
 	
 	while (j < main.size())
 	  {
-	    CollationSorter rule1 = (CollationSorter) patch.get(i);
-	    CollationSorter rule2 = (CollationSorter) main.get(j);
+	    CollationSorter rule1 = (CollationSorter) patch.elementAt(i);
+	    CollationSorter rule2 = (CollationSorter) main.elementAt(j);
 	    
 	    if (rule1.textElement.equals(rule2.textElement))
-	      main.remove(j);
+	      main.removeElementAt(j);
 	    else
 	      j++;
 	  }
@@ -335,7 +336,7 @@
     // Find the insertion point... O(N)
     for (int i = 0; i < main.size(); i++)
       {
-	CollationSorter sorter = (CollationSorter) main.get(i);
+	CollationSorter sorter = (CollationSorter) main.elementAt(i);
 	int length = findPrefixLength(starter, sorter.textElement);
 		
 	if (length > max_length)
@@ -361,24 +362,24 @@
 	 * sequence. The rest of the subsequence must be appended
 	 * to the end of the sequence.
 	 */
-	CollationSorter sorter = (CollationSorter) patch.get(0);
+	CollationSorter sorter = (CollationSorter) patch.elementAt(0);
 	CollationSorter expansionPrefix =
-	  (CollationSorter) main.get(insertion_point-1);
+	  (CollationSorter) main.elementAt(insertion_point-1);
 	
 	sorter.expansionOrdering = starter.substring(max_length); // Skip the first good prefix element
 		
-	main.add(insertion_point, sorter);
+	main.insertElementAt(sorter, insertion_point);
 	
 	/*
 	 * This is a new set of rules. Append to the list.
 	 */
-	patch.remove(0);
+	patch.removeElementAt(0);
 	insertion_point++;
       }
 
     // Now insert all elements of patch at the insertion point.
     for (int i = 0; i < patch.size(); i++)
-      main.add(i+insertion_point, patch.get(i));
+      main.insertElementAt(patch.elementAt(i), i+insertion_point);
   }
 
   /**
@@ -396,7 +397,7 @@
    * @throws ParseException if something turned wrong during the parsing. To get details
    * decode the message.
    */
-  private int subParseString(boolean stop_on_reset, ArrayList v,
+  private int subParseString(boolean stop_on_reset, Vector v,
 			     int base_offset, String rules)
     throws ParseException
   {
@@ -505,7 +506,7 @@
 	     * indicated by the text element.
 	     */
 	    String subrules = rules.substring(i);
-	    ArrayList sorted_rules = new ArrayList();
+	    Vector sorted_rules = new Vector();
 	    int idx;
 
 	    // Parse the subrules but do not iterate through all
@@ -590,10 +591,10 @@
    * @throws ParseException if something turned wrong during the parsing. To get details
    * decode the message.
    */
-  private ArrayList parseString(String rules) 
+  private Vector parseString(String rules) 
     throws ParseException
   {
-    ArrayList v = new ArrayList();
+    Vector v = new Vector();
 
     // result of the first subParseString is not absolute (may be -1 or a
     // positive integer). But we do not care.
@@ -606,10 +607,10 @@
    * This method uses the sorting instructions built by {@link #parseString}
    * to build collation elements which can be directly used to sort strings.
    *
-   * @param parsedElements Parsed instructions stored in a ArrayList.
+   * @param parsedElements Parsed instructions stored in a Vector.
    * @throws ParseException if the order of the instructions are not valid.
    */
-  private void buildCollationVector(ArrayList parsedElements)
+  private void buildCollationVector(Vector parsedElements)
     throws ParseException
   {
     int primary_seq = 0;
@@ -621,13 +622,13 @@
     final boolean DECREASING = false;
     final boolean INCREASING = true;
     boolean secondaryType = INCREASING;
-    ArrayList v = new ArrayList();
+    Vector v = new Vector();
 
     // elts is completely sorted.
 element_loop:
     for (int i = 0; i < parsedElements.size(); i++)
       {
-	CollationSorter elt = (CollationSorter) parsedElements.get(i);
+	CollationSorter elt = (CollationSorter) parsedElements.elementAt(i);
 	boolean ignoreChar = false;
 
 	switch (elt.comparisonType)
@@ -946,7 +947,7 @@
   public CollationKey getCollationKey(String source)
   {
     CollationElementIterator cei = getCollationElementIterator(source);
-    ArrayList vect = new ArrayList();
+    Vector vect = new Vector(25);
 
     int ord = cei.next();
     cei.reset(); //set to start of string
