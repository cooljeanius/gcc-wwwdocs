--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/Timer.java	2004-07-23 02:24:09.000000000 -0600
+++ javax/swing/Timer.java	2004-07-30 02:27:49.000000000 -0600
@@ -1,4 +1,4 @@
-/* Timer.java -- 
+/* Timer.java --
    Copyright (C) 2002, 2004  Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
@@ -35,22 +35,26 @@
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
 
-
 package javax.swing;
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 import java.io.Serializable;
 import java.util.EventListener;
-
 import javax.swing.event.EventListenerList;
 
+
+/**
+ * DOCUMENT ME!
+ */
 public class Timer implements Serializable
 {
+  /** DOCUMENT ME! */
   private static final long serialVersionUID = -1116180831621385484L;
-  
+
+  /** DOCUMENT ME! */
   protected EventListenerList listenerList = new EventListenerList();
-  
+
   // This object manages a "queue" of virtual actionEvents, maintained as a
   // simple long counter. When the timer expires, a new event is queued,
   // and a dispatcher object is pushed into the system event queue. When
@@ -58,79 +62,127 @@
   // ActionEvents as have been queued, unless the timer is set to
   // coalescing mode, in which case it will fire only one ActionEvent.
 
+  /** DOCUMENT ME! */
   private long queue;
+
+  /** DOCUMENT ME! */
   private Object queueLock = new Object();
+
+  /** DOCUMENT ME! */
+  private Waker waker;
+
+  /**
+   * DOCUMENT ME!
+   */
   private void queueEvent()
   {
     synchronized (queueLock)
       {
-        queue++;
-        if (queue == 1)
-          SwingUtilities.invokeLater(new Runnable() { public void run() { drainEvents(); } });
+	queue++;
+	if (queue == 1)
+	  SwingUtilities.invokeLater(new Runnable()
+	      {
+		public void run()
+		{
+		  drainEvents();
+		}
+	      });
+
       }
   }
 
+  /**
+   * DOCUMENT ME!
+   */
   private void drainEvents()
   {
     synchronized (queueLock)
       {
-        if (isCoalesce())
-          {
-            if (queue > 0)
-              fireActionPerformed();
-          }
-        else
-          {
-            while(queue > 0)
-              {                  
-                fireActionPerformed();
-                queue--;
-              }          
-          }
-        queue = 0;
+	if (isCoalesce())
+	  {
+	    if (queue > 0)
+	      fireActionPerformed();
+	  }
+	else
+	  {
+	    while (queue > 0)
+	      {
+		fireActionPerformed();
+		queue--;
+	      }
+	  }
+	queue = 0;
       }
   }
-  
 
   static boolean logTimers;
+
+  /** DOCUMENT ME! */
   boolean coalesce = true;
+
+  /** DOCUMENT ME! */
   boolean repeats = true;
+
+  /** DOCUMENT ME! */
   boolean running;
+
+  /** DOCUMENT ME! */
   int ticks;
+
+  /** DOCUMENT ME! */
   int delay;
+
+  /** DOCUMENT ME! */
   int initialDelay;
-    
-  private class Waker 
-    extends Thread
+
+  /**
+   * DOCUMENT ME!
+   */
+  private class Waker extends Thread
   {
+    /**
+     * DOCUMENT ME!
+     */
     public void run()
     {
       running = true;
-      try 
+      try
         {
+	  sleep(initialDelay);
 
-          sleep(initialDelay);
-          
-          while (running)
-            {
-              sleep(delay);
-              queueEvent();
-              
-              if (logTimers)
-                System.out.println("javax.swing.Timer -> clocktick");
-              
-              if (! repeats)
-                break;
-            }
-          running = false;
-      } 
-      catch (Exception e) 
+	  while (running)
+	    {
+	      try
+	        {
+		  sleep(delay);
+	        }
+	      catch (InterruptedException e)
+	        {
+		  return;
+	        }
+	      queueEvent();
+
+	      if (logTimers)
+		System.out.println("javax.swing.Timer -> clocktick");
+
+	      if (! repeats)
+		break;
+	    }
+	  running = false;
+        }
+      catch (Exception e)
         {
-          System.out.println("swing.Timer::" + e);
+	  System.out.println("swing.Timer::" + e);
         }
     }
   }
 
+  /**
+   * Creates a new Timer object.
+   *
+   * @param d DOCUMENT ME!
+   * @param listener DOCUMENT ME!
+   */
   public Timer(int d, ActionListener listener)
   {
     delay = d;
@@ -139,123 +191,213 @@
       addActionListener(listener);
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @param c DOCUMENT ME!
+   */
   public void setCoalesce(boolean c)
   {
     coalesce = c;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public boolean isCoalesce()
   {
     return coalesce;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @param listener DOCUMENT ME!
+   */
   public void addActionListener(ActionListener listener)
   {
-    listenerList.add (ActionListener.class, listener);
+    listenerList.add(ActionListener.class, listener);
   }
-  
+
+  /**
+   * DOCUMENT ME!
+   *
+   * @param listener DOCUMENT ME!
+   */
   public void removeActionListener(ActionListener listener)
   {
-    listenerList.remove (ActionListener.class, listener);
+    listenerList.remove(ActionListener.class, listener);
   }
 
   /**
+   * DOCUMENT ME!
+   *
+   * @param listenerType DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   *
    * @since 1.3
    */
-  public EventListener[] getListeners (Class listenerType)
+  public EventListener[] getListeners(Class listenerType)
   {
-    return listenerList.getListeners (listenerType);
+    return listenerList.getListeners(listenerType);
   }
-  
+
   /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   *
    * @since 1.4
    */
-  public ActionListener[] getActionListeners ()
+  public ActionListener[] getActionListeners()
   {
-    return (ActionListener[]) listenerList.getListeners (ActionListener.class);
+    return (ActionListener[]) listenerList.getListeners(ActionListener.class);
   }
 
-  protected void fireActionPerformed (ActionEvent event)
+  /**
+   * DOCUMENT ME!
+   *
+   * @param event DOCUMENT ME!
+   */
+  protected void fireActionPerformed(ActionEvent event)
   {
     ActionListener[] listeners = getActionListeners();
-    
+
     for (int i = 0; i < listeners.length; i++)
-      {
-	listeners [i].actionPerformed (event);
-      }
+      listeners[i].actionPerformed(event);
   }
 
-  void fireActionPerformed ()
+  /**
+   * DOCUMENT ME!
+   */
+  void fireActionPerformed()
   {
-    fireActionPerformed (new ActionEvent (this, ticks++, "Timer"));
+    fireActionPerformed(new ActionEvent(this, ticks++, "Timer"));
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @param lt DOCUMENT ME!
+   */
   public static void setLogTimers(boolean lt)
   {
     logTimers = lt;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public static boolean getLogTimers()
   {
     return logTimers;
   }
-    
+
+  /**
+   * DOCUMENT ME!
+   *
+   * @param d DOCUMENT ME!
+   */
   public void setDelay(int d)
   {
     delay = d;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public int getDelay()
   {
     return delay;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @param i DOCUMENT ME!
+   */
   public void setInitialDelay(int i)
   {
     initialDelay = i;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public int getInitialDelay()
   {
     return initialDelay;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @param r DOCUMENT ME!
+   */
   public void setRepeats(boolean r)
   {
     repeats = r;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public boolean isRepeats()
   {
     return repeats;
   }
 
+  /**
+   * DOCUMENT ME!
+   *
+   * @return DOCUMENT ME!
+   */
   public boolean isRunning()
   {
     return running;
   }
 
+  /**
+   * DOCUMENT ME!
+   */
   public void start()
   {
     if (isRunning())
-      {
-	System.err.println("attempt to start a running timer");
 	return;
-      }
-    new Waker().start();
+    waker = new Waker();
+    waker.start();
   }
 
+  /**
+   * DOCUMENT ME!
+   */
   public void restart()
   {
-    synchronized (queueLock)
-      {
-        queue = 0;
-      }
+    stop();
     start();
   }
 
+  /**
+   * DOCUMENT ME!
+   */
   public void stop()
   {
     running = false;
+    waker.interrupt();
+    synchronized (queueLock)
+      {
+	queue = 0;
+      }
   }
 }
