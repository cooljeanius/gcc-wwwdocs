--- /home/tromey/gnu/Nightly/classpath/classpath/javax/swing/colorchooser/DefaultHSBChooserPanel.java	2004-09-04 14:58:22.000000000 -0600
+++ javax/swing/colorchooser/DefaultHSBChooserPanel.java	2004-09-13 02:35:46.000000000 -0600
@@ -377,7 +377,7 @@
                                                                          b)));
       spinnerTrigger = false;
 
-      if (! handlingMouse)
+      if (! handlingMouse && slider != null && ! slider.getValueIsAdjusting())
         {
 	  updateImage();
 	  updateTrack();
@@ -419,11 +419,6 @@
 
     internalChange = true;
 
-    // spinnerTrigger, internalChange, and handlingMouse are used because of the
-    // we don't want things like: change spinner -> update chooser -> change spinner
-    // That's because the value from before and after the update can differ
-    // slightly because of the conversion.
-    // FIXME: Think of better way to deal with this.
     if (! spinnerTrigger)
       {
 	hSpinner.setValue(new Integer((int) (hsbVals[0] * 360)));
@@ -438,8 +433,10 @@
 	  slider.setValue(((Number) hSpinner.getValue()).intValue());
 	if (! handlingMouse)
 	  {
-	    gradientPoint.x = (int) ((1 - hsbVals[1]) * imgWidth);
-	    gradientPoint.y = (int) ((1 - hsbVals[2]) * imgHeight);
+	    gradientPoint.x = (int) ((1
+	                      - ((Number) sSpinner.getValue()).intValue() / 100f) * imgWidth);
+	    gradientPoint.y = (int) ((1
+	                      - ((Number) bSpinner.getValue()).intValue() / 100f) * imgHeight);
 	  }
 	break;
       case SLOCKED:
@@ -447,8 +444,9 @@
 	  slider.setValue(((Number) sSpinner.getValue()).intValue());
 	if (! handlingMouse)
 	  {
-	    gradientPoint.x = (int) (hsbVals[0] * imgWidth);
-	    gradientPoint.y = (int) ((1 - hsbVals[2]) * imgHeight);
+	    gradientPoint.x = (int) (((Number) hSpinner.getValue()).intValue() / 360f * imgWidth);
+	    gradientPoint.y = (int) ((1
+	                      - ((Number) bSpinner.getValue()).intValue() / 100f) * imgHeight);
 	  }
 	break;
       case BLOCKED:
@@ -456,15 +454,19 @@
 	  slider.setValue(((Number) bSpinner.getValue()).intValue());
 	if (! handlingMouse)
 	  {
-	    gradientPoint.x = (int) (hsbVals[0] * imgWidth);
-	    gradientPoint.y = (int) ((1 - hsbVals[1]) * imgHeight);
+	    gradientPoint.x = (int) (((Number) hSpinner.getValue()).intValue() / 360f * imgWidth);
+	    gradientPoint.y = (int) ((1
+	                      - ((Number) sSpinner.getValue()).intValue() / 100f) * imgHeight);
 	  }
 	break;
       }
     internalChange = false;
 
-    updateImage();
-    updateTrack();
+    if (! handlingMouse && slider != null && ! slider.getValueIsAdjusting())
+      updateImage();
+
+    if (! handlingMouse || locked != HLOCKED)
+      updateTrack();
     updateTextFields();
   }
 
@@ -857,4 +859,16 @@
     trackImage = createImage(new MemoryImageSource(trackWidth, imgHeight,
                                                    trackPix, 0, trackWidth));
   }
+
+  /**
+   * This method returns the HSB values for the currently selected color.
+   *
+   * @return The HSB values for the currently selected color.
+   */
+  private float[] getHSBValues()
+  {
+    Color c = getColorFromModel();
+    float[] f = Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(), null);
+    return f;
+  }
 }
