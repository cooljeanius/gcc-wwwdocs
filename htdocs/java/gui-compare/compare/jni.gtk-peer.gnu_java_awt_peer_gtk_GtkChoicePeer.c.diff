--- /home/tromey/gnu/Nightly/classpath/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.c	2004-03-29 02:24:15.000000000 -0700
+++ jni/gtk-peer/gnu_java_awt_peer_gtk_GtkChoicePeer.c	2004-07-27 02:24:06.000000000 -0600
@@ -39,38 +39,28 @@
 #include "gtkpeer.h"
 #include "gnu_java_awt_peer_gtk_GtkChoicePeer.h"
 
-static void connect_choice_item_selectable_hook (JNIEnv *env, 
-						 jobject peer_obj, 
-						 GtkItem *menuitem, 
-						 const char *label);
+static void selection_changed (GtkComboBox *combobox, gpointer data);
 
 JNIEXPORT void JNICALL 
 Java_gnu_java_awt_peer_gtk_GtkChoicePeer_create 
   (JNIEnv *env, jobject obj)
 {
   GtkWidget *menu;
-  GtkOptionMenu *option_menu;
-  GtkRequisition child_requisition;
+  GtkComboBox *combobox;
 
   /* Create global reference and save it for future use */
   NSA_SET_GLOBAL_REF (env, obj);
 
   gdk_threads_enter ();
   
-  option_menu = GTK_OPTION_MENU (gtk_option_menu_new ());
-  menu = gtk_menu_new ();
-  gtk_widget_show (menu);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (option_menu), menu);
-
-  gtk_widget_size_request (gtk_menu_item_new_with_label (""), 
-			   &child_requisition);
-  option_menu->width = child_requisition.width;
-  option_menu->height = child_requisition.height;
+  combobox = gtk_combo_box_new_text ();
+
+  g_signal_connect (combobox, "changed",
+                    G_CALLBACK (selection_changed), obj);
 
   gdk_threads_leave ();
 
-  NSA_SET_PTR (env, obj, option_menu);
+  NSA_SET_PTR (env, obj, combobox);
 }
 
 JNIEXPORT void JNICALL 
@@ -78,45 +68,27 @@
   (JNIEnv *env, jobject obj, jobjectArray items)
 {
   gpointer ptr;
-  GtkMenu *menu;
   jsize count, i;
-  int need_set_history = 0;
 
   ptr = NSA_GET_PTR (env, obj);
 
   gdk_threads_enter ();
 
-  menu = GTK_MENU (gtk_option_menu_get_menu (GTK_OPTION_MENU (ptr)));
-
-  /* Are we adding the first element? */
-  if (gtk_option_menu_get_history (GTK_OPTION_MENU (ptr)) < 0)
-      need_set_history = 1;
-
   count = (*env)->GetArrayLength (env, items);
 
   for (i = 0; i < count; i++) 
     {
       jobject item;
       const char *label;
-      GtkWidget *menuitem;
 
       item = (*env)->GetObjectArrayElement (env, items, i);
       label = (*env)->GetStringUTFChars (env, item, NULL);
 
-      menuitem = gtk_menu_item_new_with_label (label);
-      gtk_menu_append (menu, menuitem);
-      gtk_widget_show (menuitem);
-
-      connect_choice_item_selectable_hook (env, obj, 
-					   GTK_ITEM (menuitem), label);
+      gtk_combo_box_append_text (GTK_COMBO_BOX (ptr), label);
 
       (*env)->ReleaseStringUTFChars (env, item, label);
     }
 
-  /* If we just added the first element select it. */  
-  if (need_set_history)
-    gtk_option_menu_set_history (GTK_OPTION_MENU (ptr), 0);
-
   gdk_threads_leave ();
 }
 
@@ -126,36 +98,13 @@
 {
   void *ptr;
   const char *label;
-  GtkWidget *menu, *menuitem;
-  int current;
-  int need_set_history = 0;
 
   ptr = NSA_GET_PTR (env, obj);
   
   label = (*env)->GetStringUTFChars (env, item, 0);      
 
   gdk_threads_enter ();
-  
-  current = gtk_option_menu_get_history (GTK_OPTION_MENU (ptr));
-
-  /* Are we adding the first element or below or at the currently
-     selected one? */
-  if ((current < 0) || (current >= index))
-      need_set_history = 1;
-
-  menu = gtk_option_menu_get_menu (GTK_OPTION_MENU (ptr));
-  menuitem = gtk_menu_item_new_with_label (label);
-  gtk_menu_insert (GTK_MENU (menu), menuitem, index);
-  gtk_widget_show (menuitem);
-
-  connect_choice_item_selectable_hook (env, obj, GTK_ITEM (menuitem), label);
-
-  /* If we just added the first element select it.
-     If we added at of below the currently selected position make
-     the first item the selected one. */  
-  if (need_set_history)
-    gtk_option_menu_set_history (GTK_OPTION_MENU (ptr), 0);
-
+  gtk_combo_box_insert_text (GTK_COMBO_BOX (ptr), index, label);
   gdk_threads_leave ();
 
   (*env)->ReleaseStringUTFChars (env, item, label);
@@ -166,50 +115,35 @@
   (JNIEnv *env, jobject obj, jint index)
 {
   void *ptr;
-  GtkContainer *menu;
-  GtkWidget *menuitem;
-  GList *children;
-  int need_set_history = 0;
-  int i, from, to;
 
   ptr = NSA_GET_PTR (env, obj);
 
   gdk_threads_enter ();
+  gtk_combo_box_remove_text (GTK_COMBO_BOX (ptr), index);
+  gdk_threads_leave ();
+}
 
-  menu = GTK_CONTAINER (gtk_option_menu_get_menu (GTK_OPTION_MENU (ptr)));
-  children = gtk_container_children (menu);
+JNIEXPORT void JNICALL 
+Java_gnu_java_awt_peer_gtk_GtkChoicePeer_nativeRemoveAll 
+  (JNIEnv *env, jobject obj)
+{
+  void *ptr;
+  GtkTreeModel *model;
+  gint count, i;
 
-  if (index == -1)
-    {
-      /* Remove all elements (removeAll) */
-      from = g_list_length (children) - 1;
-      to = 0;
+  ptr = NSA_GET_PTR (env, obj);
 
-      /* Select the first item to prevent spurious activate signals */
-      gtk_option_menu_set_history (GTK_OPTION_MENU (ptr), 0);
-    }
-  else
-    {
-      /* Remove the specific index element */
-      from = index;
-      to = index;
-
-      /* Are we removing the currently selected element? */
-      if (gtk_option_menu_get_history (GTK_OPTION_MENU (ptr)) == index)
-        need_set_history = 1;
-    }
+  gdk_threads_enter ();
 
-  for (i = from; i >= to; i--)
-    {
-      menuitem = GTK_WIDGET (g_list_nth (children, i)->data);
-      gtk_container_remove (menu, menuitem);
-      gtk_widget_destroy (menuitem);
-    }
+  model = gtk_combo_box_get_model (GTK_COMBO_BOX (ptr));
+  count = gtk_tree_model_iter_n_children (model, NULL);
+
+  /* First, unselect everything, to avoid problems when removing items. */
+  gtk_combo_box_set_active (GTK_COMBO_BOX (ptr), -1);
 
-  /* If we just removed the currently selected element and there are
-     still elements left in the list, make the first item the selected one. */  
-  if (need_set_history && gtk_container_children (menu))
-    gtk_option_menu_set_history (GTK_OPTION_MENU (ptr), 0);
+  for (i = count - 1; i >= 0; i--) {
+    gtk_combo_box_remove_text (GTK_COMBO_BOX (ptr), i);
+  }
 
   gdk_threads_leave ();
 }
@@ -223,12 +157,12 @@
   ptr = NSA_GET_PTR (env, obj);
 
   gdk_threads_enter ();
-  gtk_option_menu_set_history (GTK_OPTION_MENU (ptr), index);
+  gtk_combo_box_set_active (GTK_COMBO_BOX (ptr), index);
   gdk_threads_leave ();
 }
 
 JNIEXPORT jint JNICALL 
-Java_gnu_java_awt_peer_gtk_GtkChoicePeer_getHistory 
+Java_gnu_java_awt_peer_gtk_GtkChoicePeer_nativeGetSelected 
   (JNIEnv *env, jobject obj)
 {
   void *ptr;
@@ -237,58 +171,38 @@
   ptr = NSA_GET_PTR (env, obj);
 
   gdk_threads_enter ();
-
-  index = gtk_option_menu_get_history (GTK_OPTION_MENU (ptr));
-
+  index = gtk_combo_box_get_active (GTK_COMBO_BOX (ptr));
   gdk_threads_leave ();
 
   return index;
 }
 
-static void
-item_activate (GtkItem *item __attribute__((unused)),
-	       struct item_event_hook_info *ie)
+void selection_changed (GtkComboBox *combobox, jobject peer)
 {
   jstring label;
-  gdk_threads_leave ();
+  GtkTreeModel *model;
+  GtkTreeIter iter;
+  GValue value;
+  gchar *selected;
+  gint index;
 
-  label = (*gdk_env)->NewStringUTF (gdk_env, ie->label);
-  (*gdk_env)->CallVoidMethod (gdk_env, ie->peer_obj,
-			      choicePostItemEventID,
-			      label,
-			      (jint) AWT_ITEM_SELECTED);
-  gdk_threads_enter ();
-}
-
-static void
-item_removed (gpointer data, 
-	      GClosure gc __attribute__((unused)))
-{
-  struct item_event_hook_info *ie = data;
-
-  free ((void *) ie->label);
-  free (ie);
-}
+  index = gtk_combo_box_get_active(combobox);
 
-static void
-connect_choice_item_selectable_hook (JNIEnv *env, 
-				     jobject peer_obj, 
-				     GtkItem *menuitem, 
-				     const char *label)
-{
-  struct item_event_hook_info *ie;
-  jobject *peer_objGlobPtr;
+  if (index >= 0)
+    {
+      model = gtk_combo_box_get_model (combobox);
 
-  ie = (struct item_event_hook_info *) 
-    malloc (sizeof (struct item_event_hook_info));
+      gtk_combo_box_get_active_iter (combobox, &iter);
 
-  peer_objGlobPtr = NSA_GET_GLOBAL_REF (env, peer_obj);
-  g_assert (peer_objGlobPtr);
+      gtk_tree_model_get (model, &iter, 0, &selected, -1);
 
-  ie->peer_obj = *peer_objGlobPtr;
-  ie->label = strdup (label);
+      gdk_threads_leave ();
 
-  g_signal_connect_data (G_OBJECT (menuitem), "activate", 
-		      GTK_SIGNAL_FUNC (item_activate), ie,
-		      (GClosureNotify) item_removed, 0);
+      label = (*gdk_env)->NewStringUTF (gdk_env, selected);
+      (*gdk_env)->CallVoidMethod (gdk_env, peer,
+			          choicePostItemEventID,
+			          label,
+			          (jint) AWT_ITEM_SELECTED);
+      gdk_threads_enter ();
+    }
 }
