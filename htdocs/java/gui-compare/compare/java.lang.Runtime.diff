--- /home/tromey/gnu/Nightly/classpath/classpath/java/lang/Runtime.java	2004-05-01 02:24:18.000000000 -0600
+++ java/lang/Runtime.java	2004-07-22 11:06:29.000000000 -0600
@@ -1,5 +1,5 @@
 /* Runtime.java -- access to the VM process
-   Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation
+   Copyright (C) 1998, 2002, 2003 Free Software Foundation
 
 This file is part of GNU Classpath.
 
@@ -52,7 +52,7 @@
  *
  * @author John Keiser
  * @author Eric Blake <ebb9@email.byu.edu>
- * @author Jeroen Frijters
+ * @status still missing 1.4 functionality
  */
 // No idea why this class isn't final, since you can't build a subclass!
 public class Runtime
@@ -109,7 +109,7 @@
   static Properties defaultProperties = new Properties();
   static
   {
-    VMRuntime.insertSystemProperties(defaultProperties);
+    insertSystemProperties(defaultProperties);
   }
 
   /**
@@ -127,6 +127,9 @@
    */
   private Set shutdownHooks;
 
+  /** True if we should finalize on exit.  */
+  private boolean finalizeOnExit;
+
   /**
    * The one and only runtime instance. This must appear after the default
    * properties have been initialized by the VM.
@@ -140,20 +143,13 @@
   {
     if (current != null)
       throw new InternalError("Attempt to recreate Runtime");
-    // Using defaultProperties directly avoids a security check, as well
-    // as bootstrap issues (since System is not initialized yet).
-    String path = defaultProperties.getProperty("java.library.path", ".");
-    String pathSep = defaultProperties.getProperty("path.separator", ":");
-    String fileSep = defaultProperties.getProperty("file.separator", "/");
-    StringTokenizer t = new StringTokenizer(path, pathSep);
-    libpath = new String[t.countTokens()];
-    for (int i = 0; i < libpath.length; i++)
-      {
-        String prefix = t.nextToken();
-        if (! prefix.endsWith(fileSep))
-          prefix += fileSep;
-        libpath[i] = prefix;
-      }
+
+    // We don't use libpath in the libgcj implementation.  We still
+    // set it to something to allow the various synchronizations to
+    // work.
+    libpath = new String[0];
+
+    init ();
   }
 
   /**
@@ -195,53 +191,6 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(status);
-
-    if (runShutdownHooks())
-      halt(status);
-
-    // Someone else already called runShutdownHooks().
-    // Make sure we are not/no longer in the shutdownHooks set.
-    // And wait till the thread that is calling runShutdownHooks() finishes.
-    synchronized (libpath)
-      {
-        if (shutdownHooks != null)
-          {
-            shutdownHooks.remove(Thread.currentThread());
-	    // Shutdown hooks are still running, so we clear status to
-	    // make sure we don't halt.
-	    status = 0;
-          }
-      }
-
-    // If exit() is called again after the shutdown hooks have run, but
-    // while finalization for exit is going on and the status is non-zero
-    // we halt immediately.
-    if (status != 0)
-      halt(status);
-
-    while (true)
-      try
-        {
-          exitSequence.join();
-        }
-      catch (InterruptedException e)
-        {
-          // Ignore, we've suspended indefinitely to let all shutdown
-          // hooks complete, and to let any non-zero exits through, because
-          // this is a duplicate call to exit(0).
-        }
-  }
-
-  /**
-   * On first invocation, run all the shutdown hooks and return true.
-   * Any subsequent invocations will simply return false.
-   * Note that it is package accessible so that VMRuntime can call it
-   * when VM exit is not triggered by a call to Runtime.exit().
-   * 
-   * @return was the current thread the first one to call this method?
-   */
-  boolean runShutdownHooks()
-  {
     boolean first = false;
     synchronized (libpath) // Synch on libpath, not this, to avoid deadlock.
       {
@@ -287,19 +236,48 @@
                       {
                         shutdownHooks.remove(hooks[i]);
                       }
-
-                    Thread.yield(); // Give other threads a chance.
+                try
+                  {
+                    exitSequence.sleep(1); // Give other threads a chance.
+                  }
+                catch (InterruptedException e)
+                  {
+                    // Ignore, the next loop just starts sooner.
+                  }
               }
             synchronized (libpath)
               {
                 shutdownHooks = null;
               }
           }
-	// Run finalization on all finalizable objects (even if they are
-	// still reachable).
-        VMRuntime.runFinalizationForExit();
+        // XXX Right now, it is the VM that knows whether runFinalizersOnExit
+        // is true; so the VM must look at exitSequence to decide whether
+        // this should be run on every object.
+        runFinalization();
       }
-    return first;
+    else
+      synchronized (libpath)
+        {
+          if (shutdownHooks != null)
+            {
+              shutdownHooks.remove(Thread.currentThread());
+              status = 0; // Change status to enter indefinite wait.
+            }
+        }
+    
+    if (first || status > 0)
+      halt(status);
+    while (true)
+      try
+        {
+          exitSequence.join();
+        }
+      catch (InterruptedException e)
+        {
+          // Ignore, we've suspended indefinitely to let all shutdown
+          // hooks complete, and to let any non-zero exits through, because
+          // this is a duplicate call to exit(0).
+        }
   }
 
   /**
@@ -402,7 +380,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(status);
-    VMRuntime.exit(status);
+    exitInternal(status);
   }
 
   /**
@@ -426,7 +404,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExit(0);
-    VMRuntime.runFinalizersOnExit(finalizeOnExit);
+    current.finalizeOnExit = finalizeOnExit;
   }
 
   /**
@@ -556,7 +534,7 @@
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkExec(cmd[0]);
-    return VMRuntime.exec(cmd, env, dir);
+    return execInternal(cmd, env, dir);
   }
 
   /**
@@ -566,20 +544,14 @@
    *
    * @return the number of processors available, at least 1
    */
-  public int availableProcessors()
-  {
-    return VMRuntime.availableProcessors();
-  }
+  public native int availableProcessors();
 
   /**
    * Find out how much memory is still free for allocating Objects on the heap.
    *
    * @return the number of bytes of free memory for more Objects
    */
-  public long freeMemory()
-  {
-    return VMRuntime.freeMemory();
-  }
+  public native long freeMemory();
 
   /**
    * Find out how much memory total is available on the heap for allocating
@@ -587,10 +559,7 @@
    *
    * @return the total number of bytes of memory for Objects
    */
-  public long totalMemory()
-  {
-    return VMRuntime.totalMemory();
-  }
+  public native long totalMemory();
 
   /**
    * Returns the maximum amount of memory the virtual machine can attempt to
@@ -600,10 +569,7 @@
    * @return the maximum number of bytes the virtual machine will attempt
    *         to allocate
    */
-  public long maxMemory()
-  {
-    return VMRuntime.maxMemory();
-  }
+  public native long maxMemory();
 
   /**
    * Run the garbage collector. This method is more of a suggestion than
@@ -611,10 +577,7 @@
    * have "done its best" by the time it returns. Notice that garbage
    * collection takes place even without calling this method.
    */
-  public void gc()
-  {
-    VMRuntime.gc();
-  }
+  public native void gc();
 
   /**
    * Run finalization on all Objects that are waiting to be finalized. Again,
@@ -623,10 +586,7 @@
    *
    * @see #finalize()
    */
-  public void runFinalization()
-  {
-    VMRuntime.runFinalization();
-  }
+  public native void runFinalization();
 
   /**
    * Tell the VM to trace every bytecode instruction that executes (print out
@@ -635,10 +595,7 @@
    *
    * @param on whether to turn instruction tracing on
    */
-  public void traceInstructions(boolean on)
-  {
-    VMRuntime.traceInstructions(on);
-  }
+  public native void traceInstructions(boolean on);
 
   /**
    * Tell the VM to trace every method call that executes (print out a trace
@@ -647,10 +604,7 @@
    *
    * @param on whether to turn method tracing on
    */
-  public void traceMethodCalls(boolean on)
-  {
-    VMRuntime.traceMethodCalls(on);
-  }
+  public native void traceMethodCalls(boolean on);
 
   /**
    * Load a native library using the system-dependent filename. This is similar
@@ -664,20 +618,10 @@
    */
   public void load(String filename)
   {
-    if (loadLib(filename) == 0)
-      throw new UnsatisfiedLinkError("Could not load library " + filename);
-  }
-
-  // Private version of load(String) that doesn't throw Exception on
-  // load error, but it does do security checks (which can throw
-  // SecurityExceptions). Convenience method for early bootstrap
-  // process.
-  private int loadLib(String filename)
-  {
     SecurityManager sm = securityManager; // Be thread-safe!
     if (sm != null)
       sm.checkLink(filename);
-    return VMRuntime.nativeLoad(filename);
+    _load(filename, false);
   }
 
   /**
@@ -702,26 +646,12 @@
    */
   public void loadLibrary(String libname)
   {
-    String filename;
-    ClassLoader cl = VMSecurityManager.currentClassLoader();
-    if (cl != null)
-      {
-        filename = cl.findLibrary(libname);
-        if (filename != null)
-          {
-	    // Use loadLib so no UnsatisfiedLinkError are thrown.
-            if (loadLib(filename) != 0)
-	      return;
-          }
-      }
-
-    filename = System.mapLibraryName(libname);
-    for (int i = 0; i < libpath.length; i++)
-      // Use loadLib so no UnsatisfiedLinkError are thrown.
-      if (loadLib(libpath[i] + filename) != 0)
-	return;
-
-    throw new UnsatisfiedLinkError("Could not find library " + libname + ".");
+    // This is different from the Classpath implementation, but I
+    // believe it is more correct.
+    SecurityManager sm = securityManager; // Be thread-safe!
+    if (sm != null)
+      sm.checkLink(libname);
+    _load(libname, true);
   }
 
   /**
@@ -732,7 +662,6 @@
    * @return the localized stream
    * @deprecated <code>InputStreamReader</code> is the preferred way to read
    *             local encodings
-   * @XXX This implementation does not localize, yet.
    */
   public InputStream getLocalizedInputStream(InputStream in)
   {
@@ -747,10 +676,107 @@
    * @return the localized stream
    * @deprecated <code>OutputStreamWriter</code> is the preferred way to write
    *             local encodings
-   * @XXX This implementation does not localize, yet.
    */
   public OutputStream getLocalizedOutputStream(OutputStream out)
   {
     return out;
   }
+
+  /**
+   * Native method that actually shuts down the virtual machine.
+   *
+   * @param status the status to end the process with
+   */
+  native void exitInternal(int status);
+
+  /**
+   * Load a file. If it has already been loaded, do nothing. The name has
+   * already been mapped to a true filename.
+   *
+   * @param filename the file to load
+   * @param do_search True if we should search the load path for the file
+   */
+  native void _load(String filename, boolean do_search);
+
+  /**
+   *This is a helper function for the ClassLoader which can load
+   * compiled libraries.  Returns true if library (which is just the
+   * base name -- path searching is done by this function) was loaded,
+   * false otherwise.
+   */
+  native boolean loadLibraryInternal(String libname);
+
+  /**
+   * A helper for the constructor which does some internal native
+   * initialization.
+   */
+  private native void init ();
+
+  /**
+   * Map a system-independent "short name" to the full file name, and append
+   * it to the path.
+   * XXX This method is being replaced by System.mapLibraryName.
+   *
+   * @param pathname the path
+   * @param libname the short version of the library name
+   * @return the full filename
+   */
+  static native String nativeGetLibname(String pathname, String libname);
+
+  /**
+   * Execute a process. The command line has already been tokenized, and
+   * the environment should contain name=value mappings. If directory is null,
+   * use the current working directory; otherwise start the process in that
+   * directory.
+   *
+   * @param cmd the non-null command tokens
+   * @param env the non-null environment setup
+   * @param dir the directory to use, may be null
+   * @return the newly created process
+   * @throws NullPointerException if cmd or env have null elements
+   */
+  native Process execInternal(String[] cmd, String[] env, File dir);
+
+  /**
+   * Get the system properties. This is done here, instead of in System,
+   * because of the bootstrap sequence. Note that the native code should
+   * not try to use the Java I/O classes yet, as they rely on the properties
+   * already existing. The only safe method to use to insert these default
+   * system properties is {@link Properties#setProperty(String, String)}.
+   *
+   * <p>These properties MUST include:
+   * <dl>
+   * <dt>java.version         <dd>Java version number
+   * <dt>java.vendor          <dd>Java vendor specific string
+   * <dt>java.vendor.url      <dd>Java vendor URL
+   * <dt>java.home            <dd>Java installation directory
+   * <dt>java.vm.specification.version <dd>VM Spec version
+   * <dt>java.vm.specification.vendor  <dd>VM Spec vendor
+   * <dt>java.vm.specification.name    <dd>VM Spec name
+   * <dt>java.vm.version      <dd>VM implementation version
+   * <dt>java.vm.vendor       <dd>VM implementation vendor
+   * <dt>java.vm.name         <dd>VM implementation name
+   * <dt>java.specification.version    <dd>Java Runtime Environment version
+   * <dt>java.specification.vendor     <dd>Java Runtime Environment vendor
+   * <dt>java.specification.name       <dd>Java Runtime Environment name
+   * <dt>java.class.version   <dd>Java class version number
+   * <dt>java.class.path      <dd>Java classpath
+   * <dt>java.library.path    <dd>Path for finding Java libraries
+   * <dt>java.io.tmpdir       <dd>Default temp file path
+   * <dt>java.compiler        <dd>Name of JIT to use
+   * <dt>java.ext.dirs        <dd>Java extension path
+   * <dt>os.name              <dd>Operating System Name
+   * <dt>os.arch              <dd>Operating System Architecture
+   * <dt>os.version           <dd>Operating System Version
+   * <dt>file.separator       <dd>File separator ("/" on Unix)
+   * <dt>path.separator       <dd>Path separator (":" on Unix)
+   * <dt>line.separator       <dd>Line separator ("\n" on Unix)
+   * <dt>user.name            <dd>User account name
+   * <dt>user.home            <dd>User home directory
+   * <dt>user.dir             <dd>User's current working directory
+   * </dl>
+   *
+   * @param p the Properties object to insert the system properties into
+   */
+  static native void insertSystemProperties(Properties p);
 } // class Runtime
