--- /home/tromey/gnu/Nightly/classpath/classpath/java/awt/image/AffineTransformOp.java	2004-10-02 02:25:49.000000000 -0600
+++ java/awt/image/AffineTransformOp.java	2004-11-03 02:20:31.000000000 -0700
@@ -42,6 +42,7 @@
 import java.awt.Rectangle;
 import java.awt.RenderingHints;
 import java.awt.geom.AffineTransform;
+import java.awt.geom.NoninvertibleTransformException;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 
@@ -56,13 +57,15 @@
 {
     public static final int TYPE_NEAREST_NEIGHBOR = 1;
     public static final int TYPE_BILINEAR = 2;
+    public static final int TYPE_BICUBIC = 3;
 
     private AffineTransform transform;
     private RenderingHints hints;
     
     /**
      * Construct AffineTransformOp with the given xform and interpolationType.
-     * Interpolation type can be either TYPE_BILINEAR or TYPE_NEAREST_NEIGHBOR.
+     * Interpolation type can be TYPE_BILINEAR, TYPE_BICUBIC or
+     * TYPE_NEAREST_NEIGHBOR.
      *
      * @param xform AffineTransform that will applied to the source image 
      * @param interpolationType type of interpolation used
@@ -70,15 +73,23 @@
     public AffineTransformOp (AffineTransform xform, int interpolationType)
     {
       this.transform = xform;
+      if (xform.getDeterminant() == 0)
+        throw new ImagingOpException(null);
 
-      if (interpolationType == 0) 
+      switch (interpolationType)
+      {
+      case TYPE_BILINEAR:
         hints = new RenderingHints (RenderingHints.KEY_INTERPOLATION, 
                                     RenderingHints.VALUE_INTERPOLATION_BILINEAR);
-				   
-      else
+        break;
+      case TYPE_BICUBIC:
+        hints = new RenderingHints (RenderingHints.KEY_INTERPOLATION, 
+				    RenderingHints.VALUE_INTERPOLATION_BICUBIC);
+        break;
+      default:
         hints = new RenderingHints (RenderingHints.KEY_INTERPOLATION,
                                     RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
-
+      }
     }
 
     /**
@@ -91,6 +102,8 @@
     {
       this.transform = xform;
       this.hints = hints;
+      if (xform.getDeterminant() == 0)
+        throw new ImagingOpException(null);
     }
 
     /**
@@ -183,7 +196,47 @@
      */
     public WritableRaster filter (Raster src, WritableRaster dst)
     {
-      throw new UnsupportedOperationException ("not implemented yet");	
+      if (dst == src)
+        throw new IllegalArgumentException("src image cannot be the same as"
+					   + " the dst image");
+
+      if (dst == null)
+        dst = createCompatibleDestRaster(src);
+
+      if (src.getNumBands() != dst.getNumBands())
+        throw new IllegalArgumentException("src and dst must have same number"
+					   + " of bands");
+      
+      Rectangle srcbounds = src.getBounds();
+      for (int y = dst.getMinY(); y < dst.getMinY() + dst.getHeight(); y++)
+      {
+        double[] pts = new double[dst.getWidth() * 2];
+        for (int x = 0; x < dst.getWidth(); x++)
+        {
+          pts[2 * x] = x + dst.getMinX();
+          pts[2 * x + 1] = y;
+        }
+        try {
+          transform.inverseTransform(pts, 0, pts, 0, dst.getWidth() * 2);
+        } catch (NoninvertibleTransformException e) {
+          // Can't happen since the constructor traps this
+          e.printStackTrace();
+        }
+        
+        // FIXME: nearest neighbor is hardwired here.  In fact, these should
+        // be rounded properly.
+        for (int x = 0; x < dst.getWidth(); x++)
+        {
+          if (!srcbounds.contains(pts[2 * x], pts[2 * x + 1]))
+            continue;
+          dst.setDataElements(x + dst.getMinX(), y,
+			      src.getDataElements((int)pts[2 * x],
+						  (int)pts[2 * x + 1],
+						  null));
+        }
+      }
+      
+      return dst;  
     }
 
     /**
