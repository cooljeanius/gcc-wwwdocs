<html>
<head>
<title>How to port the libgcj signal handling code</title>
</head>
<body>
<h1>How to port the libgcj signal handling code</h1>

<h2>Introduction</h2>

When a signal is sent to a Java program, the Java runtime code should
raise an exception which can be caught by Java application code.
Examples of such signals are <tt>SIGSEGV</tt> (segment violation) and
<tt>SIGFPE</tt> (arithmetic exception).  It is not always clear which
Java exceptions should be raised, but in these cases it is fairly
obvious: <tt>NullPointerException</tt> and
<tt>ArithmeticException</tt>. <p>

Unfortunately, there is no portable way to turn a signal into an
exception: this depends on the processor architecture and operating
system being used.  As a consequence of this, some porting work may be
necessary in order to catch signals.<p>

The problem is that a signal handler may be called from the OS kernel
with a stack frame which cannot be walked by signal handling code.  In
order to provide <tt>throw()</tt> with a stack which it can walk, the
signal handler may need to alter the stack frame to make it
appear that the handler has been directly called from the code which
faulted and caused the signal.<p>

<h2>Details</h2>

Firstly, you must determine the address of the instruction which
caused the signal to be sent: the point at which the Java program was
interrupted.  There is no standard way to do this, so you will need to
read the documentation of your OS, or possibly even the kernel sources
to discover where the interrupted program counter (PC) and frame
pointer (FP) are saved.  You may have to reverse engineer the kernel
trap, or use gdb to see what is on the stack at the time a signal
handler is called.<p>

Once you have done this, you'll need to write a little assembler code
to take the PC and FP at the time of call and rewrite the current
stack frame to make it appear that the signal handler was directly called from
the faulting code.<p>

Here's an i386 Linux example of code which does this:<p>

<pre>
#define MAKE_THROW_FRAME						\
{									\
  void **_p = (void **)&_dummy;						\
  struct sigcontext_struct *_regs = (struct sigcontext_struct *)++_p;	\
									\
  register unsigned long _ebp = _regs->ebp;				\
  register unsigned long _eip = _regs->eip;				\
  									\
  asm volatile ("mov %0, (%%ebp); mov %1, 4(%%ebp)"			\
		: : "r"(_ebp), "r"(_eip));				\
}
</pre>

Here, <tt>dummy</tt> is the <tt>int</tt> argument passed to a signal
handler.  Immediately below this on the stack is a <tt>struct
sigcontext_struct</tt> which contains the registers at the point the
fault occurred.  The assembly language instructions rewrite the
current stack frame to point to the code which was interrupted.<p>

Once you've written this code for processor <tt>foo</tt>, create a new
<tt>foo-signal.h</tt> file and put it in the <tt>libjava/include</tt>
directory.  Add a reference to <tt>foo-signal.h</tt> to the list in
<tt>libjava/configure.in</tt>:

<pre>
case "${host}" in
  i?86-*-linux*)
    SIGNAL_HANDLER=include/i386-signal.h
	;;
  sparc-sun-solaris*)
    SIGNAL_HANDLER=include/sparc-signal.h
	;;
  *)
    SIGNAL_HANDLER=include/default-signal.h
	;;
esac
</pre>

Specimen signal handling code for other processors is in the
<tt>libjava/include</tt> directory.<p>

The actual signal handlers are in <tt>libjava/prims.cc</tt>, and look
like this:

<pre>
static java::lang::NullPointerException *nullp;
SIGNAL_HANDLER (catch_segv)
{
  MAKE_THROW_FRAME;
  _Jv_Throw (nullp);
}
</pre>

You must ensure that the pointer to the exception has been initialized
to point to a Java exception before <tt>_Jv_Throw()</tt> is called: a
good place to do this is in <tt>JvRunMain</tt>, before the application
is started.<p>

</body>
</html>
