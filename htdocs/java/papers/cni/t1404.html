<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Class Initialization</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="The Cygnus Native Interface for C++/Java Integration"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="Strings"
HREF="t1330.html"><LINK
REL="NEXT"
TITLE="Exception Handling"
HREF="t1420.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Cygnus Native Interface for C++/Java Integration</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="t1330.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>The Cygnus Native Interface for C++/Java Integration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="t1420.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN404"
>Class Initialization</A
></H1
><P
>Java requires that each class be automatically initialized at the time 
of the first active use.  Initializing a class involves 
initializing the static fields, running code in class initializer 
methods, and initializing base classes.  There may also be 
some implementation specific actions, such as allocating 
<TT
CLASS="CLASSNAME"
>String</TT
> objects corresponding to string literals in
the code.</P
><P
>The Gcj compiler inserts calls to <TT
CLASS="LITERAL"
>JvInitClass</TT
> (actually
<TT
CLASS="LITERAL"
>_Jv_InitClass</TT
>) at appropriate places to ensure that a
class is initialized when required.  The C++ compiler does not
insert these calls automatically - it is the programmer's
responsibility to make sure classes are initialized.  However,
this is fairly painless because of the conventions assumed by the Java
system.</P
><P
>First, <TT
CLASS="LITERAL"
>libgcj</TT
> will make sure a class is initialized
before an instance of that object is created.  This is one
of the responsibilities of the <TT
CLASS="LITERAL"
>new</TT
> operation.  This is
taken care of both in Java code, and in C++ code.  (When the G++
compiler sees a <TT
CLASS="LITERAL"
>new</TT
> of a Java class, it will call
a routine in <TT
CLASS="LITERAL"
>libgcj</TT
> to allocate the object, and that
routine will take care of initializing the class.)  It follows that you can
access an instance field, or call an instance (non-static)
method and be safe in the knowledge that the class and all
of its base classes have been initialized.</P
><P
>Invoking a static method is also safe.  This is because the
Java compiler adds code to the start of a static method to make sure
the class is initialized.  However, the C++ compiler does not
add this extra code.  Hence, if you write a native static method
using CNI, you are responsible for calling <TT
CLASS="LITERAL"
>JvInitClass</TT
>
before doing anything else in the method (unless you are sure
it is safe to leave it out).</P
><P
>Accessing a static field also requires the class of the
field to be initialized.  The Java compiler will generate code
to call <TT
CLASS="LITERAL"
>_Jv_InitClass</TT
> before getting or setting the field.
However, the C++ compiler will not generate this extra code,
so it is your responsibility to make sure the class is
initialized before you access a static field.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="t1330.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="t1420.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Strings</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Exception Handling</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>