<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Methods</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="The Cygnus Native Interface for C++/Java Integration"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="Arrays"
HREF="t1215.html"><LINK
REL="NEXT"
TITLE="Object allocation"
HREF="t1307.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Cygnus Native Interface for C++/Java Integration</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="t1215.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>The Cygnus Native Interface for C++/Java Integration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="t1307.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN262"
>Methods</A
></H1
><P
>Java methods are mapped directly into C++ methods.
The header files generated by <TT
CLASS="LITERAL"
>gcjh</TT
>
include the appropriate method definitions.
Basically, the generated methods have the same names and
&#8220;corresponding&#8221; types as the Java methods,
and are called in the natural manner.</P
><H2
><A
NAME="AEN267"
>Overloading</A
></H2
><P
>Both Java and C++ provide method overloading, where multiple
methods in a class have the same name, and the correct one is chosen
(at compile time) depending on the argument types.
The rules for choosing the correct method are (as expected) more complicated
in C++ than in Java, but given a set of overloaded methods
generated by <TT
CLASS="LITERAL"
>gcjh</TT
> the C++ compiler will choose
the expected one.</P
><P
>Common assemblers and linkers are not aware of C++ overloading,
so the standard implementation strategy is to encode the
parameter types of a method into its assembly-level name.
This encoding is called <I
CLASS="FIRSTTERM"
>mangling</I
>,
and the encoded name is the <I
CLASS="FIRSTTERM"
>mangled name</I
>.
The same mechanism is used to implement Java overloading.
For C++/Java interoperability, it is important that both the Java
and C++ compilers use the <I
CLASS="EMPHASIS"
>same</I
> encoding scheme.</P
><H2
><A
NAME="AEN275"
>Static methods</A
></H2
><P
>Static Java methods are invoked in <SPAN
CLASS="ACRONYM"
>CNI</SPAN
> using the standard
C++ syntax, using the `<TT
CLASS="LITERAL"
>::</TT
>' operator rather
than the `<TT
CLASS="LITERAL"
>.</TT
>' operator.  For example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>jint i = java::lang::Math::round((jfloat) 2.3);</PRE
></TD
></TR
></TABLE
><P
>Defining a static native method uses standard C++ method
definition syntax.  For example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;java/lang/Integer.h&#62;
java::lang::Integer*
java::lang::Integer::getInteger(jstring str)
{
  ...
}</PRE
></TD
></TR
></TABLE
></P
><H2
><A
NAME="AEN284"
>Object Constructors</A
></H2
><P
>Constructors are called implicitly as part of object allocation
using the <TT
CLASS="LITERAL"
>new</TT
> operator.  For example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> 
java::lang::Int x = new java::lang::Int(234);</PRE
></TD
></TR
></TABLE
> </P
><P
>Java does not allow a constructor to be a native method.
Instead, you could define a private method which
you can have the constructor call.</P
><H2
><A
NAME="AEN290"
>Instance methods</A
></H2
><P
>Virtual method dispatch is handled essentially the same way
in C++ and Java -- <SPAN
CLASS="ABBREV"
>i.e.</SPAN
> by doing an
indirect call through a function pointer stored in a per-class virtual
function table.  C++ is more complicated because it has to support
multiple inheritance, but this does not effect Java classes.
However, G++ has historically used a different calling convention
that is not compatible with the one used by <SPAN
CLASS="ACRONYM"
>gcj</SPAN
>.
During 1999, G++ will switch to a new ABI that is compatible with
<SPAN
CLASS="ACRONYM"
>gcj</SPAN
>.  Some platforms (including Linux) have already
changed.  On other platforms, you will have to pass
the <TT
CLASS="LITERAL"
>-fvtable-thunks</TT
> flag to g++ when
compiling <SPAN
CLASS="ACRONYM"
>CNI</SPAN
> code.</P
><P
>Calling a Java instance method in <SPAN
CLASS="ACRONYM"
>CNI</SPAN
> is done
using the standard C++ syntax.  For example:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  java::lang::Number *x;
  if (x-&#62;doubleValue() &#62; 0.0) ...</PRE
></TD
></TR
></TABLE
></P
><P
>Defining a Java native instance method is also done the natural way:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;java/lang/Integer.h&#62;
jdouble
java::lang:Integer::doubleValue()
{
  return (jdouble) value;
}</PRE
></TD
></TR
></TABLE
></P
><H2
><A
NAME="AEN303"
>Interface method calls</A
></H2
><P
>In Java you can call a method using an interface reference.
This is not yet supported in <SPAN
CLASS="ACRONYM"
>CNI</SPAN
>.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="t1215.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="t1307.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Arrays</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Object allocation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>