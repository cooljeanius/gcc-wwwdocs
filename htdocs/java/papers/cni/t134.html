<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Packages</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="The Cygnus Native Interface for C++/Java Integration"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="The Cygnus Native Interface for C++/Java Integration"
HREF="t1.html"><LINK
REL="NEXT"
TITLE="Primitive types"
HREF="t187.html"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Cygnus Native Interface for C++/Java Integration</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="t1.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>The Cygnus Native Interface for C++/Java Integration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="t187.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN34"
>Packages</A
></H1
><P
>The only global names in Java are class names, and packages.
A <I
CLASS="FIRSTTERM"
>package</I
> can contain zero or more classes, and
also zero or more sub-packages.
Every class belongs to either an unnamed package or a package that
has a hierarchical and globally unique name.</P
><P
>A Java package is mapped to a C++ <I
CLASS="FIRSTTERM"
>namespace</I
>.
The Java class <TT
CLASS="LITERAL"
>java.lang.String</TT
>
is in the package <TT
CLASS="LITERAL"
>java.lang</TT
>, which is a sub-package
of <TT
CLASS="LITERAL"
>java</TT
>.  The C++ equivalent is the
class <TT
CLASS="LITERAL"
>java::lang::String</TT
>,
which is in the namespace <TT
CLASS="LITERAL"
>java::lang</TT
>,
which is in the namespace <TT
CLASS="LITERAL"
>java</TT
>.</P
><P
>Here is how you could express this:
<PRE
CLASS="PROGRAMLISTING"
>// Declare the class(es), possibly in a header file:
namespace java {
  namespace lang {
    class Object;
    class String;
    ...
  }
}

class java::lang::String : public java::lang::Object
{
  ...
};</PRE
></P
><P
>The <TT
CLASS="LITERAL"
>gcjh</TT
> tool automatically generates the
necessary namespace declarations.</P
><H2
><A
NAME="AEN50"
>Nested classes as a substitute for namespaces</A
></H2
><P
>It is not that long since g++ got complete namespace support,
and it was very recent (end of February 1999) that <TT
CLASS="LITERAL"
>libgcj</TT
>
was changed to uses namespaces.  Releases before then used
nested classes, which are the C++ equivalent of Java inner classes.
They provide similar (though less convenient) functionality.
The old syntax is:
<PRE
CLASS="PROGRAMLISTING"
>class java {
  class lang {
    class Object;
    class String;
  };
};</PRE
>
The obvious difference is the use of <TT
CLASS="LITERAL"
>class</TT
> instead
of <TT
CLASS="LITERAL"
>namespace</TT
>.  The more important difference is
that all the members of a nested class have to be declared inside
the parent class definition, while namespaces can be defined in
multiple places in the source.  This is more convenient, since it
corresponds more closely to how Java packages are defined.
The main difference is in the declarations; the syntax for
using a nested class is the same as with namespaces:
<PRE
CLASS="PROGRAMLISTING"
>class java::lang::String : public java::lang::Object
{ ... }</PRE
>
Note that the generated code (including name mangling)
using nested classes is the same as that using namespaces.</P
><H2
><A
NAME="AEN58"
>Leaving out package names</A
></H2
><P
>Having to always type the fully-qualified class name is verbose.
It also makes it more difficult to change the package containing a class.
The Java <TT
CLASS="LITERAL"
>package</TT
> declaration specifies that the
following class declarations are in the named package, without having
to explicitly name the full package qualifiers.
The <TT
CLASS="LITERAL"
>package</TT
> declaration can be followed by zero or
more <TT
CLASS="LITERAL"
>import</TT
> declarations, which allows either
a single class or all the classes in a package to be named by a simple
identifier.  C++ provides something similar
with the <TT
CLASS="LITERAL"
>using</TT
> declaration and directive.</P
><P
>A Java simple-type-import declaration:
<PRE
CLASS="PROGRAMLISTING"
>import <TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
>;</PRE
>
allows using <TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
> as a shorthand for
<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
></TT
>.
The C++ (more-or-less) equivalent is a <TT
CLASS="LITERAL"
>using</TT
>-declaration:
<PRE
CLASS="PROGRAMLISTING"
>using <TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>::<TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
>;</PRE
></P
><P
>A Java import-on-demand declaration:
<PRE
CLASS="PROGRAMLISTING"
>import <TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>.*;</PRE
>
allows using <TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
> as a shorthand for
<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>TypeName</I
></TT
></TT
>
The C++ (more-or-less) equivalent is a <TT
CLASS="LITERAL"
>using</TT
>-directive:
<PRE
CLASS="PROGRAMLISTING"
>using namespace <TT
CLASS="REPLACEABLE"
><I
>PackageName</I
></TT
>;</PRE
></P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="t1.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="t187.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Cygnus Native Interface for C++/Java Integration</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Primitive types</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
