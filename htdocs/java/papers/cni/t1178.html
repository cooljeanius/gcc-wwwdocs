<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Objects and Classes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.13"><LINK
REL="HOME"
TITLE="The Cygnus Native Interface for C++/Java Integration"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="Primitive types"
HREF="t187.html"><LINK
REL="NEXT"
TITLE="Arrays"
HREF="t1215.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Cygnus Native Interface for C++/Java Integration</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="t187.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>The Cygnus Native Interface for C++/Java Integration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="t1215.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN178"
>Objects and Classes</A
></H1
><H2
><A
NAME="AEN180"
>Classes</A
></H2
><P
>All Java classes are derived from <TT
CLASS="LITERAL"
>java.lang.Object</TT
>.
C++ does not have a unique &#8220;root&#8221;class, but we use
a C++ <TT
CLASS="LITERAL"
>java::lang::Object</TT
> as the C++ version
of the <TT
CLASS="LITERAL"
>java.lang.Object</TT
> Java class.  All
other Java classes are mapped into corresponding C++ classes
derived from <TT
CLASS="LITERAL"
>java::lang::Object</TT
>.</P
><P
>Interface inheritance (the &#8220;<TT
CLASS="LITERAL"
>implements</TT
>&#8221;
keyword) is currently not reflected in the C++ mapping.</P
><H2
><A
NAME="AEN191"
>Object references</A
></H2
><P
>We implement a Java object reference as a pointer to the start
of the referenced object.  It maps to a C++ pointer.
(We cannot use C++ references for Java references, since
once a C++ reference has been initialized, you cannot change it to
point to another object.)
The <TT
CLASS="LITERAL"
>null</TT
> Java reference maps to the <TT
CLASS="LITERAL"
>NULL</TT
>
C++ pointer.</P
><P
>Note that in some Java implementations an object reference is implemented as
a pointer to a two-word &#8220;handle&#8221;.  One word of the handle
points to the fields of the object, while the other points
to a method table.  Gcj does not use this extra indirection.</P
><H2
><A
NAME="AEN198"
>Object fields</A
></H2
><P
>Each object contains an object header, followed by the instance
fields of the class, in order.  The object header consists of
a single pointer to a dispatch or virtual function table.
(There may be extra fields &#8220;in front of&#8221; the object,
for example for
memory management, but this is invisible to the application, and
the reference to the object points to the dispatch table pointer.)</P
><P
>The fields are laid out in the same order, alignment, and size
as in C++.  Specifically, 8-bite and 16-bit native types
(<TT
CLASS="LITERAL"
>byte</TT
>, <TT
CLASS="LITERAL"
>short</TT
>, <TT
CLASS="LITERAL"
>char</TT
>,
and <TT
CLASS="LITERAL"
>boolean</TT
>) are <I
CLASS="EMPHASIS"
>not</I
>
widened to 32 bits.
Note that the Java VM does extend 8-bit and 16-bit types to 32 bits
when on the VM stack or temporary registers.</P
><P
>If you include the <TT
CLASS="LITERAL"
>gcjh</TT
>-generated header for a
class, you can access fields of Java classes in the &#8220;natural&#8221;
way.  Given the following Java class:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>public class Int
{
  public int i;
  public Integer (int i) { this.i = i; }
  public static zero = new Integer(0);
}</PRE
></TD
></TR
></TABLE
>
you can write:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;cni.h&#62;
#include &#60;Int.h&#62;
Int*
mult (Int *p, jint k)
{
  if (k == 0)
    return Int::zero;  // static member access.
  return new Int(p-&#62;i * k);
}</PRE
></TD
></TR
></TABLE
></P
><P
><SPAN
CLASS="ACRONYM"
>CNI</SPAN
> does not strictly enforce the Java access
specifiers, because Java permissions cannot be directly mapped
into C++ permission.  Private Java fields and methods are mapped
to private C++ fields and methods, but other fields and methods
are mapped to public fields and methods.</P
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="t187.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="t1215.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Primitive types</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Arrays</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>