<html>
<head>
<title>The GCJ Projects List</title>
</head>
<body bgcolor="#FFFFFF">

<GCJNAV>

 <br>
      <br>
      <h1>The GCJ Projects List</h1>

What follows is a list of projects that the GCJ community would love
to see someone pick up and run with.  If you're interested in any of
these, be sure to send a note with your questions, ideas or intentions
to the <a
href="mailto:java@gcc.gnu.org">java-discuss</a>
mailing list.  Similarly, if you would like to see a project listed
here that isn't, send a patch for this HTML file to the <a
href="mailto:java-patches@gcc.gnu.org">java-patches</a> list.

<p>

<br>
<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
jar support
 </th>
</tr>
</table>
<br>

We currently bundle libgcj class files as a zip file.  The <a
href="http://java.sun.com/docs/books/tutorial/jar/">jar format</a> is
the preferred archiving format, and we should switch to using it.  There
is a <a href="http://fastjar.sourceforge.net">Free jar
implementation</a> written in C that we should import into our tree (and then
remove <tt>libgcj/zip</tt>).
This is preferable to creating one written in java because it doesn't
require java running on the host development system when building a
cross compiler.  Once it has been imported, the following tasks remain:
<ul>
<li>modify gcj to obey the contraints layed out by the jar file manifest file.
</ul>
<p>

<br>
<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Plugin for Mozilla
 </th>
</tr>
</table>
<br>

<a href="http://mozilla.org/">Mozilla</a> is open-source web browser,
designed for standards compliance, performance and portability.  The
<a href="http://www.mozilla.org/oji/">Open JVM Integration project</a>
(OJI) is a Mozilla sub-project, and is working to extend the browser
to allow Java virtual machines to be plugged into Mozilla.  A gij
based plugin would be very nice indeed (gijzilla?).
<p>
This project will eventually need a bytecode verifier
<p>

<br>
<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Bytecode Verifier
 </th>
</tr>
</table>
<br>

Some applications written in the Java programming language expect to
be able to download and execute classes from untrusted sources.
<a href="http://java.sun.com/sfaq/verifier.html">Bytecode
verification</a> is the process of analyzing class file bytecode to
ensure the integrity of the security model.

<p> 

GCJ contains a <a
href="http://gcc.gnu.org/cgi-bin/cvsweb.cgi/~checkout~/gcc/gcc/java/verify.c">verifier</a>
to ensure the validity of natively compiled code.  What's really needed is
a verification package that the libgcj ClassLoader can use to 
verify dynamically loaded bytecode.  It may be possible to use
GCJ's <code>verify.c</code> as a starting point.  It may even be possible
(with suitable macros and typedefs) to use the same verifier both in
GCJ and the run-time.
<p>

<br>
<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Benchmark infrastructure
 </th>
</tr>
</table>
<br>

Measuring performance is tricky business.  We currently do all our
performance measurements in an ad hoc manner.  What is needed is some
infrastructure we can use to track performance regressions and
identify opportunities for improvement.
<p>
<a href="mailto:bryce@albatross.co.nz">Bryce McKinlay</a> has put
together a list of some <a
href="http://waitaki.otago.ac.nz/~bryce/gcj/">benchmarks that run on
GCJ</a>.  IBM has also recently released a set of "micro benchmarks"
called <a
href="http://oss.software.ibm.com/developerworks/opensource/jmocha/index.html">jMocha</a>. Building
some infrastructure around these would be incredibly useful.
<p>

<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Performance improvements
 </th>
</tr>
</table>
<br>

There are a few concrete performance improvements that we already know
we want:
	<ul>
	  <li>If an object or array is allocated in static code that is
          executed at most once (i.e. not in a loop or in a non-private
	  method), then we have the option of pre-allocating the object
	  or array in the static data or bss segment.  This is most
	  obviously the right thing to do when the expression is an array
	  brace initializer whose elements are compile-time constants, since
	  then we can initialize the array statically.  (This is already
	  implemented.)  It also makes sense for array elements that
          are initialized to link-time constants, such as references
	  to other statically allocated objects, as you might get
	  from a multi-dimensional array brace-initializer.
	  <p>
	  It may also make sense to pre-allocate a non-array object.
	  It makes most sense when the object constructor is inlined,
	  especially if it turns out that most or all of the fields get
	  initialized to constants.  Even if the constructor is not inlined,
	  it may still make sense to pre-allocate the object if it is
	  being assigned to a static final field:  The tradeoff is that
	  you save the space needed for the call to allocate the object, but
	  you use more space if it turns out the class is never initialized.
	  <p>
	  Note that if a statically allocated object contains
          pointer fields then the gc has to know about the object.
          The cleanest way is to make sure the object header has
	  appropriate flags so that the gc recognizes that the object is
	  static but has pointer fields.  There is no need to register the
	  static object with the gc, since if it is live, it will get
	  traversed anyway (typically via the fields table of the declaring
          class).
	  <li>Write the runtime side of
	  <tt>-fhash-synchronization</tt> and see how it affects
	  performance.

	  <li>Change the current lock implementation to use thin
	  locks, and see how that affects performance.  (This has been
	  discussed on the java mailing list several times.)
	</ul>
<p>

<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Compiler improvements
 </th>
</tr>
</table>
<br>

	  <ul>
	    <li>We'd like gcj to do tree-level inlining like the C++
	    compiler.  We're most of the way there (when compiling
	    from Java source code), since gcj already represents
	    entire functions as trees.

            <li>Once we have tree-level inlining, we can use it to
            sometimes eliminate unnecessary synchronizations.
            Combined with a simple "no escape" flag, this could also
            let us further optimize string concatenation without
            having to introduce a new class in the runtime.

	    <li>When compiling from bytecode, GCJ generates tree nodes
	    as long as it is within a single "statement" - i.e. no branching
	    or side effects.  However, any branching or other complications
	    causes RTL to be emitted.  This is similar to the historical
	    way the C and C++ front-ends were implemented.  Gcc now has support
	    for representing an entire method body as a tree node, and g++
	    has been converted to do that, because it makes certain
	    optimizations more practical.  Gcj already represents an entire
	    method body as a single tree structure when compiling from
	    Java source;  we should do the same
	    when compiling from bytecode.  To begin with, we can represent
	    control flow using <code>GOTO_EXPR</code>.  However, if would
	    be better if we can deduce higher-level structure.  I.e. it is
	    easy to generate
	    <code>(COND_EXPR TEST (GOTO_EXPR L1) (GOTO_EXPR L2))</code>, but it
	    would be better though harder to simplify that to a
	    <code>COND_EXPR</code> that does not use <code>GOTO_EXPR</code>.
	    The simplification is probably best done after we have generated
	    a correct but <code>GOTO</code>-based tree representation.
	    For example, if a label is only used once, we can move its code
	    to where the unique <code>GOTO</code> is.

	    <li>Add hooks to gcj and g++ to generate write barriers.
	    This would let us write a precise collector.

	    <li>Do escape analysis to detect method-local and
	    thread-local objects.  This can yield a significant
	    performance improvement in some cases.

            <li>Add exception information to <tt>_Jv_Method</tt>
            objects.  This is necessary to finish the reflection
            implementation.

            <li>Extend the existing null-pointer patch (for PR 2) to
            optionally enable it for all method calls and field
            dereferences.  This will let gcj-compiled code work
            correctly on systems without an MMU.

	    <li>The structure of <code>expand_byte_code</code> in
	    <code>expr.c</code> uses macros in a way that in retrospect
	    looks like a mistake.  It should be re-written to be a simple
	    switch statement based on the structure of
	    <code>verify_jvm_instructions</code> in <code>verify.c</code>.
            (There are actually two switch statements using the magic macros
	    in <code>expr.c</code> - look for the includes of
	    <code>"javaop.def"</code>.  They should both be re-written, but
	    second one is higher priority.)
	  </ul>
<p>

<table border="0" cellpadding="4" width="95%">
<tr bgcolor="#b0d0ff">
 <th align="left">
Runtime improvements
 </th>
</tr>
</table>
<br>
	  <ul>
	    <li>Write a program to convert existing locale data into a
	    format we can use.

            <li>It would be nice to have a way to compile a property
            file into something that could be linked into the
            application.  On Windows, it might make sense to do this
            using the standard resource mechanism.  This has been
            <a
            href="http://sources.redhat.com/ml/java/1999-q3/msg00318.html">discussed</a>
            on the mailing list a bit.
	  </ul>
<p>

</GCJNAV>

</body>
</html>

