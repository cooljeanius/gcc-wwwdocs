<html>

<head>
<title>GCC 4.1 Release Series &mdash; Changes, New Features, and Fixes</title>
</head>

<!-- GCC maintainers, please do not hesitate to update/contribute entries
     concerning those part of GCC you maintain!  2002-03-23, Gerald.
-->

<body>
<h1>GCC 4.1 Release Series<br />Changes, New Features, and Fixes</h1>

<h2>Caveats</h2>

<h2>General Optimizer Improvements</h2>

  <ul>

    <li>GCC now has infrastructure for inter-procedural optimizations and
	the following inter-procedural optimizations are implemented:<br />
	<ul>
	    <li>Profile guided inlining.  When doing profile feedback
		guided optimization, GCC can now use the profile to make
		better informed decisions on whether inlining of a function
		is profitable or not.  This means that GCC will no longer
		inline functions at call sites that are not executed very
		often, and that functions at hot call sites are more likely
		to be inlined.<br />
		A new parameter <code>min-inline-recursive-probability</code>
		is also now available to throttle recursive inlining
		of functions with small average recursive depths.</li>
	    <li>Discovery of <code>pure</code> and <code>const</code>
		functions, a form of side-effects analysis.  While older GCC
		releases could also discover such special functions, the new
		IPA-based pass runs earlier so that the results are available
		to more optimizers.  The pass is also simply more powerful
		than the old one.</li>
	    <li>Analysis of references to static variables and type escape
		analysis, also forms of side-effects analysis.  The results
		of these passes allow the compiler to be less conservative
		about call-clobbered variables and references.  This results
		in more redundant loads being eliminated and in making static
		variables candidates for register promotion.</li>
	    <li>Improvement of RTL-based alias analysis.  The results of type
		escape analysis are fed to the RTL type-based alias analyzer,
		allowing it to disambiguate more memory references.</li>
	    <li>Interprocedural constant propagation and function versioning.
		This pass looks for functions that are always called with the
		same constant value for one or more of the function arguments,
		and propagates those constants into those functions.</li>
	    <li>GCC will now eliminate static variables whose usage was
		optimized out.</li>
	    <li><code>-fwhole-program --combine</code> can now be used to
	        make all functions in program static allowing whole program
		optimization.  As an exception, the <code>main</code> function
		and all functions marked with the new
		<code>externally_visible</code> attribute are kept global so
		that programs can link with runtime libraries.</li>
	</ul></li>

    <li>GCC can now do a form of partial dead code elimination (PDCE) that
	allows code motion of expressions to the paths where the result of
	the expression is actually needed.  This is not always a win, so
	the pass has been limited to only consider profitable cases.  Here
	is an example:

	<pre>
    int foo (int *, int *);
    int
    bar (int d)
    {
      int a, b, c;
      b = d + 1;
      c = d + 2;
      a = b + c;
      if (d)
        {
          foo (&amp;b, &amp;c);
          a = b + c;
        }
      printf ("%d\n", a);
    }
	</pre>

	The <code>a = b + c</code> can be sunk to right before the
	<code>printf</code>.  Normal code sinking will not do this, it will
	sink the first one above into the else-branch of the conditional
	jump, which still gives you two copies of the code.</li>

    <li>GCC now has a value range propagation pass.  This allows the compiler
	to eliminate bounds checks and branches.  The results of the pass
	can also be used to accurately compute branch probabilities.</li>

    <li>The pass to convert PHI nodes to straight-line code (a form of
	if-conversion for GIMPLE) has been improved significantly.  The two
	most significant improvements are an improved algorithm to determine
	the order in which the PHI nodes are considered, and an improvement
	that allow the pass to consider if-conversions of basic blocks with
	more than two predecessors.</li>

    <li>Alias analysis improvements.  GCC can now differentiate between
	different fields of structures in Tree-SSA's virtual operands form.
	This lets stores/loads from non-overlapping structure fields not
	conflict.  A new algorithm to compute points-to sets was contributed
	that can allows GCC to see now that <code>p-&gt;a</code> and
	<code>p-&gt;b</code>, where <code>p</code> is a pointer to a
	structure, can never point to the same field.</li>

    <li>Various enhancements to auto-vectorization:<br />
	<ul>
	    <li>Incrementally preserve SSA form when vectorizing.</li>
	    <li>Incrementally preserve loop-closed form when vectorizing.</li>
	    <li>Improvements to peeling for alignment:
                generate better code when the misalignment of an access
                is known at compile time, or when different accesses are
                known to have the same misalignment, even if the
                misalignment amount itself is unknown.</li>
	    <li>Consider dependence distance in the vectorizer.</li>
	    <li>Externalize generic parts of data reference analysis to
		make this analysis available to other passes.</li>
	    <li>Vectorization of conditional code.</li>
	    <li>Reduction support.</li>
	</ul></li>

    <li>GCC can now partition functions in sections of hot and cold code.
	This can significantly improve performance due to better instruction
	cache locality.  This feature works best together with profile
	feedback driven optimization.</li>

    <li>A new pass to avoid saving of unneeded arguments to the stack in
	<code>vararg</code> functions if the compiler can prove that they
	will not be needed.</li>

    <li>Transition of basic block profiling to tree level implementation has
        been completed.  The new implementation should be considerably more
	reliable (hopefully avoiding profile mismatch errors when using
	<code>-fprofile-use</code> or <code>-fbranch-probabilities</code>) and
	can be used to drive higher level optimizations, such as inlining.
	<p>
	The <code>-ftree-based-profiling</code> command line option was
	removed and <code>-fprofile-use</code> now implies disabling old RTL
	level loop optimizer (<code>-fno-loop-optimize</code>).  Speculative
	prefetching optimization (originally enabled by
	<code>-fspeculative-prefetching</code>) was removed.</p></li>
  </ul>

 
<h2>New Languages and Language specific improvements</h2>

<h3>C and Objective-C</h3>
  <ul>
    <li>The old Bison-based C and Objective-C parser has been replaced
	by a new, faster hand-written recursive-descent parser.</li>
  </ul>

  <h3>Ada</h3>
  <ul>
    <li>The build infrastructure for the Ada runtime library and tools
	has been changed to be better integrated with the rest of the build
	infrastructure of GCC.  This should make doing cross builds of Ada a
	bit easier.</li>
  </ul>

<h3 id="cplusplus">C++</h3>
  <ul>
    <li>ARM-style name-injection of friend declarations is no longer
        the default.  For example:

	<pre>
          struct S {
            friend void f();
          };

          void g() { f(); }</pre>

        will not be accepted; instead a declaration of <code>f</code>
        will need to be present outside of the scope of
        <code>S</code>.  The new <code>-ffriend-injection</code>
        option will enable the old behavior.</li>
  </ul>

<h3>Objective-C++</h3>
  <ul>
    <li>A new language front end for Objective-C++ has been added.  This language allows
        users to mix the object oriented features of Objective-C with those of C++.</li>
  </ul>

<h2>New Targets and Target Specific Improvements</h2>

<h3>IA-32/x86-64</h3>
  <ul>
    <li>The x86-64 medium model (that allows building applications whose data
	segment exceeds 4GB) was redesigned to match latest ABI draft.  New
	implementation split large datastructures into separate segment
	improving performance of accesses to small datastructures and also
	allows linking of small model libraries into medium model programs as
	long as the libraries are not accessing the large datastructures
	directly.  Medium model is also supported in position independent code
	now.
        <p>
	The ABI change results in partial incompatibility among medium
	model objects. Linking medium model libraries (or objects) compiled
	with new compiler into medium model program compiled with older will
	likely result in exceeding ranges of relocations.</p>
	<p>
	Binutils 2.16.91 or newer are required for compiling medium model
	now.</p></li>
  </ul>

<h3>RS6000 (POWER/PowerPC)</h3>
  <ul>
    <li>The AltiVec vector primitives in <code>&lt;altivec.h&gt;</code> are
	now implemented in a way that puts a smaller burden on the
	preprocessor, instead processing the "overloading" in the front ends.
	This should benefit compilation speed on AltiVec vector code.</li>
    <li>AltiVec initializers now are generated more efficiently.</li>
    <li>The popcountb instruction available on POWER5 now is generated.</li>
    <li>The floating point round to integer instructions available on
	POWER5+ now is generated.</li>
    <li>Floating point divides can be synthesized using the floating
	point reciprocal estimate instructions.</li>
    <li>Double precision floating point constants are initialized as single
	precision values if they can be represented exactly.</li>
  </ul>

<h3>MorphoSys</h3>
  <ul>
    <li>Support has been added for this new architecture.</li>
  </ul>

<h2><a name="obsolete_systems">Obsolete Systems</a></h2>

<h2>Documentation improvements</h2>

<h2>Other significant improvements</h2>

  <ul>
    <li>GCC can now emit code for protecting applications from stack-smashing
	attacks.  The protection is realized by buffer overflow detection and
	reordering of stack variables to avoid pointer corruption.</li>

    <li>Some built-in functions have been fortified to protect them against
	various buffer overflow (and format string) vulnerabilities. Compared
	to the mudflap bounds checking feature, the safe builtins have far
	smaller overhead.  This means that programs built using safe builtins
	should not experience any measurable slowdown.</li>
  </ul>
</body>
</html>
