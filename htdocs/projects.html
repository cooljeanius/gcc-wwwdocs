<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head>
<title>EGCS Projects</title>
</head>

<body bgcolor="white" text="black" link="#0000EE" vlink="#551A8B" alink="red">
<h1 align=center>Projects</h1>

<p>These are some potential future projects for GCC.  Most of them have
to do with the optimizer.  Some are old ideas which might not help
very much anymore, but who knows?

<p>There is a separate project list for the <a
href="proj-cpplib.html">C preprocessor</a>.

<p>Haifa scheduler (<file>haifa-sched.c</file>,
<file>loop.[ch]</file>, <file>unroll.[ch]</file>,
<file>genattrtab.c<file>): (contact <a
href="mailto:law@cygnus.com">law@cygnus.com</a> before starting any
serious haifa work)

<ul>
  <li>Fix all the formatting problems.  Simple, mindless work.

  <li>Fix/add comments throughout the code.  Many of the comments are
  from the old scheduler and are out of date and misleading.  Many new
  hunks of code don't have sufficient comments and documentation.
  Those which do have comments need to be rewritten to use complete
  sentences and proper formatting.

  <li>Someone needs make one (or more) passes over the scheduler as a
  whole to just clean it up.  Try to move the machine dependent bits
  into the target files where they belong, avoid re-creating functions
  where or near equivalents already exist (e.g. is_conditional_branch
  and friends), etc., etc.

  <li>Document the new scheduling options.  Remove those options which
  are not really useful (like reverse scheduling for example).  In
  general the haifa scheduler adds <b>way</b> too many options.  I'm
  definitely of the opinion that gcc already has too many
  <code>-f</code>options, and haifa doesn't help that situation.

  <li>Testing and benchmarking.  We've converted a few ports to using
  the Haifa scheduler (hppa, sparc, ppc, alpha).  We need to continue
  testing and benchmarking the new scheduler on additional targets.

  <li>We need to have some kind of docs for how to best describe a
  machine to the haifa scheduler to get good performance.  Some
  existing ports have been tuned to deal with the old scheduler --
  they may need to be tuned to generate good schedules with haifa.
</ul>
  
<p>Improvements to global cse and partial redundancy elimination:

<p>The current implementation of global cse uses partial redundancy
elimination as described in Chow's thesis.

<p>Long term we want to use lazy code motion as the basis for partial
redundancy elimination.  lcm will find as many (or more) redundancies
<i>and</i> it will place the remaining computations at computationally
optimal placement points within the function.  This reduces the number
of redundant operations performed as well as reducing register
lifetimes.  My experiments have shown that the cases were the current
PRE code hurts performance are greatly helped by using lazy code
motion.

<p>lcm also provides the underlying framework for several additional
optimizations such as shrink wrapping, spill code motion, dead store
elimination, and generic load/store motion (all the other examples are
subcases of load/store motion).

<p>It can probably also be used to improve the reg-stack pass of the
compiler.

<p>Contact <a href="mailto:law@cygnus.com">law@cygnus.com</a> if
you're interested in working on lazy code motion.

<hr>

<p>The old PROJECTS file.  Stuff I know has been done has been deleted.
Stuff in progress has a contact name associated with it.

<p>Better optimization.

<ol>
<li>Constants in unused inline functions

<p>It would be nice to delay output of string constants so that string
constants mentioned in unused inline functions are never generated.
Perhaps this would also take care of string constants in dead code.

<p>The difficulty is in finding a clean way for the RTL which refers
to the constant (currently, only by an assembler symbol name) to point
to the constant and cause it to be output.

<p>A related problem: if a function has been placed in a special
section via attributes, we may want to put its static data and string
constants in a special section too.  But which one?

<li>Optimize a sequence of if statements whose conditions are
exclusive.

<p>It is possible to optimize 

<pre>
if (x == 1) ...;
if (x == 2) ...;
if (x == 3) ...;
</pre>
into
<pre>
if (x == 1) ...;
else if (x == 2) ...;
else if (x == 3) ...;
</pre>
provided that x is not altered by the contents of the if statements.

<p>It's not certain whether this is worth doing.  Perhaps programmers
nearly always write the else's themselves, leaving few opportunities
to improve anything.

<li>Un-cse.

<p>Perhaps we should have an un-cse step right after cse, which tries to
replace a reg with its value if the value can be substituted for the
reg everywhere, if that looks like an improvement.  Which is if the
reg is used only a few times.  Use rtx_cost to determine if the
change is really an improvement.

<li>Clean up how cse works.

<p>The scheme is that each value has just one hash entry.  The
first_same_value and next_same_value chains are no longer needed.

<p>For arithmetic, each hash table elt has the following slots:
<ul>
	<li>Operation.  This is an rtx code.
	<li>Mode.
	<li>Operands 0, 1 and 2.  These point to other hash table elements.
</ul>

<p>So, if we want to enter <code>(plus:SI (reg:SI 30) (const_int
104))</code>, we first enter <code>(const_int 104)</code> and find the
entry that <code>(reg:SI 30)</code> now points to.  Then we put these
elts into operands 0 and 1 of a new elt.  We put PLUS and
SI into the new elt.

<p>Registers and mem refs would never be entered into the table as
such.  However, the values they contain would be entered.  There would
be a table indexed by regno which points at the hash entry for the
value in that reg.

<p>The hash entry index now plays the role of a qty number.  We still
need qty_first_reg, reg_next_eqv, etc. to record which regs share a
particular qty.

<p>When a reg is used whose contents are unknown, we need to create a
hash table entry whose contents say "unknown", as a place holder for
whatever the reg contains.  If that reg is added to something, then
the hash entry for the sum will refer to the "unknown" entry.  Use
UNKNOWN for the rtx code in this entry.  This replaces make_new_qty.

<p>For a constant, a unique hash entry would be made based on the
value of the constant.

<p>What about MEM?  Each time a memory address is referenced, we need
a qty (a hash table elt) to represent what is in it.  (Just as for a
register.)  If this isn't known, create one, just as for a reg whose
contents are unknown.

<p>We need a way to find all mem refs that still contain a certain
value.  Do this with a chain of hash elts (for memory addresses) that
point to locations that hold the value.  The hash elt for the value
itself should point to the start of the chain.  It would be good for
the hash elt for an address to point to the hash elt for the contents
of that address (but this ptr can be null if the contents have never
been entered).

<p>With this data structure, nothing need ever be invalidated except
the lists of which regs or mems hold a particular value.  It is easy
to see if there is a reg or mem that is equiv to a particular value.
If the value is constant, it is always explicitly constant.

<li>Support more general tail-recursion among different functions.

<p>This might be possible under certain circumstances, such as when
the argument lists of the functions have the same lengths.  Perhaps it
could be done with a special declaration.

<p>You would need to verify in the calling function that it does not
use the addresses of any local variables (?) and does not use setjmp.

<li>Put short statics vars at low addresses and use short addressing mode?

<p>Useful on the 68000/68020 and perhaps on the 32000 series, provided
one has a linker that works with the feature.  This is said to make a
15% speedup on the 68000.

<li>Keep global variables in registers.

<p>Here is a scheme for doing this.  A global variable, or a local variable
whose address is taken, can be kept in a register for an entire function
if it does not use non-constant memory addresses and (for globals only)
does not call other functions.  If the entire function does not meet
this criterion, a loop may.

<p>The VAR_DECL for such a variable would have to have two RTL
expressions: the true home in memory, and the pseudo-register used
temporarily.  It is necessary to emit insns to copy the memory
location into the pseudo-register at the beginning of the function or
loop, and perhaps back out at the end.  These insns should have
REG_EQUIV notes so that, if the pseudo-register does not get a hard
register, it is spilled into the memory location which exists in any
case.

<p>The easiest way to set up these insns is to modify the routine
put_var_into_stack so that it does not apply to the entire function
(sparing any loops which contain nothing dangerous) and to call it at
the end of the function regardless of where in the function the
address of a local variable is taken.  It would be called
unconditionally at the end of the function for all relevant global
variables.

<p>For debugger output, the thing to do is to invent a new binding
level around the appropriate loop and define the variable name as a
register variable with that scope.

<li>Live-range splitting.

<p>Currently a variable is allocated a hard register either for the
full extent of its use or not at all.  Sometimes it would be good to
allocate a variable a hard register for just part of a function; for
example, through a particular loop where the variable is mostly used,
or outside of a particular loop where the variable is not used.  (The
latter is nice because it might let the variable be in a register most
of the time even though the loop needs all the registers.)

Contact <a href="mailto:meissner@cygnus.com">meissner@cygnus.com</a>
before starting any work on live range splitting.

<li>Detect dead stores into memory?

<p>A store into memory is dead if it is followed by another store into
the same location; and, in between, there is no reference to anything
that might be that location (including no reference to a variable
address).

<p>This can be modeled as a partial redundancy elimination/lazy code
motion problem.  Contact <a
href="mailto:law@cygnus.com">law@cygnus.com</a> before working on dead
store elimination optimizations.

<li>Loop optimization.

<p>Strength reduction and iteration variable elimination could be
smarter.  They should know how to decide which iteration variables are
not worth making explicit because they can be computed as part of an
address calculation.  Based on this information, they should decide
when it is desirable to eliminate one iteration variable and create
another in its place.

<p>It should be possible to compute what the value of an iteration
variable will be at the end of the loop, and eliminate the variable
within the loop by computing that value at the loop end.

<p>When a loop has a simple increment that adds 1, instead of jumping
in after the increment, decrement the loop count and jump to the
increment.  This allows aob insns to be used.

<li>Using constraints on values.

<p>Many operations could be simplified based on knowledge of the
minimum and maximum possible values of a register at any particular
time.  These limits could come from the data types in the tree, via
rtl generation, or they can be deduced from operations that are
performed.  For example, the result of an <code>and</code> operation
one of whose operands is 7 must be in the range 0 to 7.  Compare
instructions also tell something about the possible values of the
operand, in the code beyond the test.

<p>Value constraints can be used to determine the results of a further
comparison.  They can also indicate that certain <code>and</code>
operations are redundant.  Constraints might permit a decrement and
branch instruction that checks zeroness to be used when the user has
specified to exit if negative.

<li>Change the type of a variable.

<p>Sometimes a variable is declared as <code>int</code>, it is
assigned only once from a value of type <code>char</code>, and then it
is used only by comparison against constants.  On many machines,
better code would result if the variable had type <code>char</code>.
If the compiler could detect this case, it could change the
declaration of the variable and change all the places that use it.

<li>Better handling for very sparse switches.

<p>There may be cases where it would be better to compile a switch
statement to use a fixed hash table rather than the current
combination of jump tables and binary search.

<li>Order of subexpressions.

<p>It might be possible to make better code by paying attention to the
order in which to generate code for subexpressions of an expression.

<li>More code motion.

<p>Consider hoisting common code up past conditional branches or tablejumps.

<p>Contact <a href="mailto:law@cygnus.com">law@cygnus.com</a> before
working on code hoisting.

<li>Trace scheduling.

<p>This technique is said to be able to figure out which way a jump
will usually go, and rearrange the code to make that path the
faster one.

<li>Distributive law.

<p>The C expression <code>*(X + 4 * (Y + C))</code> compiles better on
certain machines if rewritten as <code>*(X + 4*C + 4*Y)</code> because
of known addressing modes.  It may be tricky to determine when, and
for which machines, to use each alternative.

<p>Some work has been done on this, in combine.c.

<li>Can optimize by changing <code>if (x) y; else z;</code> into
<code>z; if (x) y;</code> if z and x do not interfere and z has no
effects not undone by y.  This is desirable if z is faster than
jumping.

<li>For a two-insn loop on the 68020, such as
<pre>
foo:	movb	a2@+,a3@+
	jne	foo
</pre>
it is better to insert <code>dbeq d0,foo</code> before the jne.
<code>d0</code> can be a junk register.  The challenge is to fit this
into a portable framework: when can you detect this situation and
still be able to allocate a junk register?
</ol>

<p>Simpler porting.

<p>Right now, describing the target machine's instructions is done
cleanly, but describing its addressing mode is done with several
ad-hoc macro definitions.  Porting would be much easier if there were
an RTL description for addressing modes like that for instructions.
Tools analogous to genflags and genrecog would generate macros from
this description.

<p>There would be one pattern in the address-description file for each
kind of addressing, and this pattern would have:

<ul>
  <li>the RTL expression for the address
  <li>C code to verify its validity (since that may depend on
      the exact data).
  <li>C code to print the address in assembly language.
  <li>C code to convert the address into a valid one, if it is not valid.
      (This would replace LEGITIMIZE_ADDRESS).
  <li>Register constraints for all indeterminates that appear
      in the RTL expression.
</ul>

<p>Other languages.

<p>We currently have front ends for C, C++, Objective C, CHILL,
Fortran, and Java.  Pascal and Ada front ends exist but have not yet
been integrated.

<p>Cobol and Modula-2 front ends might be useful.

<p>Pascal, Modula-2 and Ada require the implementation of functions
within functions.  Some of the mechanisms for this already exist.

<p>More extensions.

<ul> 
<li>Generated unique labels.  Have some way of generating distinct
labels for use in extended asm statements.  I don't know what a good
syntax would be.

<li>A way of defining a structure containing a union, in which the
choice of union alternative is controlled by a previous structure
component.

<li>Here is a possible syntax for this.
<pre>
struct foo {
  enum { INT, DOUBLE } code;
  auto union { case INT: int i; case DOUBLE: double d;} value : code;
};
</pre>

<li>Allow constructor expressions as lvalues, like this:
<pre>
(struct foo) {a, b, c} = foo();
</pre>
This would call foo, which returns a structure, and then store the
several components of the structure into the variables a, b, and c.
</ul>

<p>Generalize the machine model.

<p>Some new compiler features may be needed to do a good job on
machines where static data needs to be addressed using base registers.

<p>Some machines have two stacks in different areas of memory, one
used for scalars and another for large objects.  The compiler does not
now have a way to understand this.

<p>The scheduler does not do very well on recent RISC machines.  Haifa
helps but not enough.

<p>More warnings.

Warn about statements that are undefined because the order of
evaluation of increment operators makes a big difference.  Here is an
example:
<pre>
*foo++ = hack (*foo);
</pre>

<p>Better documentation of how GCC works and how to port it.

<p>Here is an outline proposed by Allan Adler.

<p>
<ol type="I">
<li>   Overview of this document
<li>   The machines on which GCC is implemented
  <ol type="A">
  <li> Prose description of those characteristics of target machines and
       their operating systems which are pertinent to the implementation
       of GCC.
      <ol type="i">
	<li> target machine characteristics
	<li> comparison of this system of machine characteristics with
	    other systems of machine specification currently in use
      </ol>
  <li> Tables of the characteristics of the target machines on which
       GCC is implemented.
  <li> A priori restrictions on the values of characteristics of target 
       machines, with special reference to those parts of the source code
       which entail those restrictions
      <ol type="i">
	<li> restrictions on individual characteristics 
        <li> restrictions involving relations between various characteristics
      </ol>
  <li> The use of GCC as a cross-compiler 
      <ol type="i">
	<li> cross-compilation to existing machines
	<li> cross-compilation to non-existent machines
      </ol>
  <li> Assumptions which are made regarding the target machine
      <ol type="i">
	<li>  assumptions regarding the architecture of the target machine
	<li> assumptions regarding the operating system of the target machine
	<li> assumptions regarding software resident on the target machine
	<li> where in the source code these assumptions are in effect
	made.
      </ol>
  </ol>
<li>   A systematic approach to writing the files tm.h and xm.h
  <ol type="A">
  <li> Macros which require special care or skill
  <li> Examples, with special reference to the underlying reasoning
  </ol>
<li>   A systematic approach to writing the machine description file
  <ol type="A">
  <li> Minimal viable sets of insn descriptions
  <li> Examples, with special reference to the underlying reasoning
  </ol>
<li>   Uses of the file aux-output.c
<li>   Specification of what constitutes correct performance of an 
       implementation of GCC
  <ol type="A">
  <li> The components of GCC
  <li> The itinerary of a C program through GCC
  <li> A system of benchmark programs
  <li> What your RTL and assembler should look like with these benchmarks
  <li> Fine tuning for speed and size of compiled code
  </ol>
<li>   A systematic procedure for debugging an implementation of GCC
  <ol type="A">
  <li> Use of GDB
      <ol type="i">
	<li> the macros in the file .gdbinit for GCC
	<li> obstacles to the use of GDB
	  <ol type="a">
	    <li> functions implemented as macros can't be called in
	    GDB
	  </ol>
      </ol>
  <li> Debugging without GDB
      <ol type="i">
	<li> How to turn off the normal operation of GCC and access specific
	   parts of GCC
      </ol>
  <li> Debugging tools
  <li> Debugging the parser
      <ol type="i">
	<li> how machine macros and insn definitions affect the parser
      </ol>
  <li> Debugging the recognizer
      <ol type="i">
	<li> how machine macros and insn definitions affect the
	recognizer
      </ol>
  <li>
  <li> ... ditto for other components ...
  <li>
  </ol>
<li>  Data types used by GCC, with special reference to restrictions not 
      specified in the formal definition of the data type
<li>  References to the literature for the algorithms used in GCC
</ol>

<small><i>Last modified May 15, 1999.</i></small>

<hr>
<p><a href="index.html">Return to the EGCS home page</a>

<p>
<a name="glimpsebox"></a>
<!--#include virtual="/glimpsebox.html"-->

</body> </html>
