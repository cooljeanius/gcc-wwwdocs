%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's
% default settings. Three flags below control this separately for no
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of
% screen angles and frequencies for printing process separations, which are
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add
%		sqrt 1 exch sub } def
%
%
/FMversion (4.0) def
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	FMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put
errordict /rangecheck {FrameDict /bug true put} put
FrameDict /bug false put
mark
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark
errordict /rangecheck FrameDict /tmprangecheck get put
FrameDict /bug get {
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop
			dup 10 eq {exit} if
			dup 13 eq {exit} if
			gstring exch gindex exch put
			/gindex gindex 1 add def
		} loop
		pop
		gstring 0 gindex getinterval true
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE {
	dup = flush
	FMshowpage
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto
	show FMshowpage
	FMquit
	} def
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!) FMFAILURE
		} if
	} def
/FMBADEPSF {
	(PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
	dup dup (X) search pop exch pop exch pop length
	4 -1 roll
	putinterval
	FMFAILURE
	} def
/FMLOCAL {
	FrameDict begin
	0 def
	end
	} def
/concatprocs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def
/FrameSepIs FMnone def
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK {
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB {
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK {
	1 exch sub
	3 1 roll
	1 exch sub
	3 1 roll
	1 exch sub
	3 1 roll
	3 copy
	2 copy
	le { pop } { exch pop } ifelse
	2 copy
	le { pop } { exch pop } ifelse
	dup dup dup
	6 1 roll
	4 1 roll
	7 1 roll
	sub
	6 1 roll
	sub
	5 1 roll
	sub
	4 1 roll
} bind def
/CMYKtoRGB {
	dup dup 4 -1 roll add 						
	5 1 roll 3 -1 roll add 						
	4 1 roll add 								
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	
	1 exch sub dup 0 lt {pop 0} if exch 	
	1 exch sub dup 0 lt {pop 0} if exch	  		
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor {
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep {
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors {
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors
	exch def end
	} bind def
/FrameColorInSepListCMYK {
	FrameSepColors {
       		exch dup 3 -1 roll
       		FrameCmpColorsCMYK
       		{ pop true exit } if
    	} forall
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB {
	FrameSepColors {
       		exch dup 3 -1 roll
       		FrameCmpColorsRGB
       		{ pop true exit } if
    	} forall
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end
/setgray {
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray }
		{
		FrameSepIs FMblack eq
			{ RealSetgray }
			{ FrameSepIs FMcustom eq
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor {
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ]
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch
			 	FrameSepGreen eq and exch
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub }
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse
		} ifelse
		RealSetgray
	}
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq
	{ RealSethsbcolor }
	{
		RealSethsbcolor
		currentrgbcolor
		setrgbcolor
	}
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat
		setrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor {
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor }
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch
				FrameSepYellow eq and exch
				FrameSepMagenta eq and exch
				FrameSepCyan eq and
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub }
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
FMLevel1 not {
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} if
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				FMPColor graymode and {
					0 1 3 {
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} {
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch
			FrameSepYellow eq and exch
			FrameSepMagenta eq and exch
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub }
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse
		} ifelse
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} {
			graymode not FMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen
	FMLevel1 { /setscreen load
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse
} bind def
end
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgrxfer FMLOCAL
	/orggxfer FMLOCAL
	/orgbxfer FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/orgrproc FMLOCAL
	/orggproc FMLOCAL
	/orgbproc FMLOCAL
	/organgle FMLOCAL
	/orgrangle FMLOCAL
	/orggangle FMLOCAL
	/orgbangle FMLOCAL
	/orgfreq FMLOCAL
	/orgrfreq FMLOCAL
	/orggfreq FMLOCAL
	/orgbfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/edown FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT {
	array /FMfonts exch def
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /FrameNegative exch def
	0 ne /edown exch def
	/yscale exch def
	/xscale exch def
	FMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def
		/FMoptop count def
		setpapername
		manualfeed {true} {papersize} ifelse
		{manualpapersize} {false} ifelse
		{desperatepapersize} {false} ifelse
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for
		}
		{{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
	ifelse
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def
				  /orgrfreq exch def
			currentcolortransfer
			FrameNegative {
				1 1 4 {
					pop { 1 exch sub } concatprocs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen
			cvlit /orgproc exch def
				  /organgle exch def
				  /orgfreq exch def
				
		currenttransfer
		FrameNegative {
			{ 1 exch sub } concatprocs
			dup settransfer
		} if
		cvlit /orgxfer exch def
	} ifelse
	end
} def
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE {
	FrameDict begin
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape {
		90 rotate 0 exch dup /pwid exch def neg translate pop
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave
} def
/FMENDPAGE {
	grestore
	pagesave restore
	end
	showpage
	} def
/FMFONTDEFINE {
	FrameDict begin
	findfont
	ReEncode
	1 index exch
	definefont
	FMfonts 3 1 roll
	put
	end
	} def
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end
	} def
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end
	} def
/FMNORMALIZEGRAPHICS {
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF {
	end
	/FMEPSF save def
	/showpage {} def
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/initmatrix {(initmatrix) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale
	llx neg lly neg translate
	/FMdicttop countdictstack 1 add def
	/FMoptop count def
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for
	countdictstack -1 FMdicttop {pop end} for
	FMEPSF restore
	FrameDict begin
	} bind def
FrameDict begin
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen {
	paperheight sub abs 16 lt exch
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
	/papersizedict FMLOCAL
/setpapername {
	/papersizedict 14 dict def
	papersizedict begin
	/papername /unknown def
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1
		statusdict begin
		{setpageparams} stopped
		end
		} {true} ifelse
	} bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode {
	dup
	length
	dict begin
	{
	1 index /FID ne
		{def}
		{pop pop} ifelse
	} forall
	0 eq {/Encoding DiacriticEncoding def} if
	currentdict
	end
	} bind def
FMPColor
	
	{
	/BEGINBITMAPCOLOR {
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc {
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR {
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc {
		BITMAPTRUECOLORc } def
	}
	
	{
	/BEGINBITMAPCOLOR {
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc {
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR {
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc {
		BITMAPTRUEGRAYc } def
	}
ifelse
/K {
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if
	FrameCurColors astore
	pop combineColor
} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setPatternMode {
	FMLevel1 {
		/bwidth  exch def
		/bpside  exch def
		/bstring exch def
		/onbits 0 def  /offbits 0 def
		freq sangle landscape {90 add} if
			{/y exch def
			 /x exch def
			 /xindex x 1 add 2 div bpside mul cvi def
			 /yindex y 1 add 2 div bpside mul cvi def
			 bstring yindex bwidth mul xindex 8 idiv add get
			 1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
			 {/onbits  onbits  1 add def 1}
			 {/offbits offbits 1 add def 0}
			 ifelse
			}
			setscreen
		offbits offbits onbits add div FrameNegative {1.0 exch sub} if
		/FrameCurGray exch def
	} {
		pop pop
		dup patCache exch known {
			patCache exch get
		} {
			dup
			patDict /bstring 3 -1 roll put
			patDict
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		FMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize {
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H {
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode FMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode FMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
	/fillvals FMLOCAL
/X {
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode}
	{setGrayScaleMode}
	ifelse
	} bind def
/V {
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N {
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L {
 	/n exch def
	newpath
	normalize
	moveto
	2 1 n {pop normalize lineto} for
	} bind def
/Y {
	L
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
/R {
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y
	} bind def
	/rad FMLOCAL
/rarc
	{rad
	 arcto
	} bind def
/RR {
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if
	cleartomark
	} bind def
/RRR {
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C {
	grestore
	gsave
	R
	clip
	setCurrentScreen
} bind def
/CP {
	grestore
	gsave
	Y
	clip
	setCurrentScreen
} bind def
	/FMpointsize FMLOCAL
/F {
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q {
	/FMpointsize exch def
	F
	} bind def
/T {
	moveto show
	} bind def
/RF {
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF {
	gsave
	moveto
	RF
	show
	grestore
	} bind def
/P {
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF {
	gsave
	moveto
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S {
	moveto
	0 exch ashow
	} bind def
/SF {
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B {
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF {
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G {
	gsave
	newpath
	normalize translate 0.0 0.0 moveto
	dnormalize scale
	0.0 0.0 1.0 5 3 roll arc
	closepath
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch
    normalize 2 index 2 div sub exch 3 index 2 div add exch
    translate
    scale
    0.0 0.0 1.0 5 3 roll arc
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto
	dnormalize scale
	0.0 0.0 1.0 5 3 roll arc
	closepath
	clip newpath
	restorematrix
	} bind def
/GG {
	gsave
	newpath
	normalize translate 0.0 0.0 moveto
	rotate
	dnormalize scale
	0.0 0.0 1.0 5 3 roll arc
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto
    rotate
    dnormalize scale
    0.0 0.0 1.0 5 3 roll arc
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk {
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto
    rotate
    dnormalize scale
    0.0 0.0 1.0 5 3 roll arc
    closepath
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A {
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch
	normalize 2 index 2 div sub exch 3 index 2 div add exch
	translate
	scale
	0.0 0.0 1.0 5 3 roll arc
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto
	dnormalize scale
	0.0 0.0 1.0 5 3 roll arc
	closepath
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA {
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate
	rotate
	scale
	0.0 0.0 1.0 5 3 roll arc
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto
    rotate
    dnormalize scale
    0.0 0.0 1.0 5 3 roll arc
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE {
	/FMdicttop countdictstack 1 add def
	/FMoptop count 7 sub def
	/FMsaveobject save def
	userdict begin
	/showpage {} def
	FMNORMALIZEGRAPHICS
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for
	countdictstack -1 FMdicttop {pop end} for
	FMsaveobject restore
	} bind def
/gn {
	0
	{	46 mul
		cf read pop
		32 sub
		dup 46 lt {exit} if
		46 sub add
		} loop
	add
	} bind def
	/str FMLOCAL
/cfs {
	/str sl string def
	0 1 sl 1 sub {str exch val put} for
	str def
	} bind def
/ic [
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms {
	/sl exch def
	/val 255 def
	/ws cfs
	/im cfs
	/val 0 def
	/bs cfs
	/cs cfs
	} bind def
400 ms
/ip {
	is
	0
	cf cs readline pop
	{	ic exch get exec
		add
		} forall
	pop
	
	} bind def
/rip {
	
	
	  bis ris copy pop
      is
      0
      cf cs readline pop
      {       ic exch get exec
              add
              } forall
	  pop pop
	  ris gis copy pop
	  dup is exch
	
      cf cs readline pop
      {       ic exch get exec
              add
              } forall
	  pop pop
	  gis bis copy pop
	  dup add is exch
	
      cf cs readline pop
      {       ic exch get exec
              add
              } forall
      pop
 
      } bind def
/wh {
	/len exch def
	/pos exch def
	ws 0 len getinterval im pos len getinterval copy pop
	pos len
	} bind def
/bl {
	/len exch def
	/pos exch def
	bs 0 len getinterval im pos len getinterval copy pop
	pos len
	} bind def
/s1 1 string def
/fl {
	/len exch def
	/pos exch def
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len
	} bind def
/hx {
	3 copy getinterval
	cf exch readhexstring pop pop
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes {
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc {
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc {
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc {
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc {
		
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def
	sl lb lt {lb ms} if
	/bitmapsave save def
	r
	/is im 0 lb getinterval def
	ws 0 lb getinterval is copy pop
	/cf currentfile def
	w h d [w 0 0 h neg 0 h]
	{ip} image
	bitmapsave restore
	grestore
	} bind def
/BEGINBITMAPBW {
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY {
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT {
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP {
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	r
	/is w d wbytes string def
	/cf currentfile def
	w h d [w 0 0 h neg 0 h]
	{cf is readhexstring pop} image
	bitmapsave restore
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
FMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255
		{dup red exch get 255 div
		 exch dup green exch get 255 div
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch concatprocs settransfer
} bind def
/BITMAPCOLOR {
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is w d wbytes string def
		/cf currentfile def
		w h d [w 0 0 h neg 0 h]
		{cf is readhexstring pop} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is w d wbytes string def
		/cf currentfile def
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore
	grestore
	} bind def
/BITMAPCOLORc {
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def
	sl lb lt {lb ms} if
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def
		ws 0 lb getinterval is copy pop
		/cf currentfile def
		w h d [w 0 0 h neg 0 h]
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def
		ws 0 lb getinterval is copy pop
		/cf currentfile def
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {ip} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore
	grestore
	} bind def
/BITMAPTRUECOLORc {
	/d 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def
	sl lb lt {lb ms} if
        /bitmapsave save def
 
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def
 
        ws 0 lb getinterval is copy pop
        /cf currentfile def
        w h 8 [w 0 0 h neg 0 h]
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore
        grestore
        } bind def
/BITMAPTRUECOLOR {
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def
        w h 8 [w 0 0 h neg 0 h]
        { cf is readhexstring pop }
        { cf gis readhexstring pop }
        { cf bis readhexstring pop }
        true 3 colorimage
        bitmapsave restore
        grestore
        } bind def
/BITMAPTRUEGRAYc {
	/d 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def
	sl lb lt {lb ms} if
        /bitmapsave save def
 
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def
        ws 0 lb getinterval is copy pop
        /cf currentfile def
        w h 8 [w 0 0 h neg 0 h]
        {w rip pop ris gis bis w gray} image
        bitmapsave restore
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray {
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY {
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def
        w h 8 [w 0 0 h neg 0 h]
        { cf is readhexstring pop
          cf gis readhexstring pop
          cf bis readhexstring pop w gray}  image
        bitmapsave restore
        grestore
        } bind def
/BITMAPGRAY {
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc {
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 612 792 0 1 11 FMDOCUMENT
0 0 /Times-Roman FMFONTDEFINE
1 0 /Times-Italic FMFONTDEFINE
2 0 /Times-Bold FMFONTDEFINE
3 0 /Courier-Bold FMFONTDEFINE
4 1 /Symbol FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "18" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(18) 532 42.5 T
0 11 Q
(Although it seems that branch swapping yields no results for systems based on the PowerPC 604,) 108 712.67 T
(it still useful for POWER and POWER2 systems. This transformation is applied to) 108 699.67 T
1 F
(BC) 467.94 699.67 T
0 F
(-) 482 699.67 T
1 F
(BCT) 485.66 699.67 T
0 F
( pairs.) 505.84 699.67 T
(As in the down code motion transformation, requiring the last of the two branches to be a) 108 686.67 T
1 F
(BCT) 503.95 686.67 T
0 F
(,) 523.3 686.67 T
-0.19 (usually results in such a pair occurring at the end of a loop. Consequently the code on the most fre-) 108 673.67 P
(quent path is improved. The transformation is illustrated in Figure 3.) 108 660.67 T
FMENDPAGE
%%EndPage: "18" 1
%%Page: "17" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(17) 532 42.5 T
0 11 Q
-0.18 (The transformation should be performed carefully so as not to create a new pair of close branches.) 108 421.64 P
(A suf) 108 408.64 T
(\336cient number of instructions should be left between the tar) 131.94 408.64 T
(get of the unconditional branch) 394.18 408.64 T
(and the \336rst branch following it.) 108 395.64 T
2 F
(3. DOWN CODE MOTION) 108 362.64 T
0 F
(This transformation is applicable when two conditional branches are in close proximity) 108 338.64 T
(. It is illus-) 491.32 338.64 T
(trated below for the case where the \336rst conditional branch is a regular conditional branch \050) 108 325.64 T
1 F
(BC) 509.71 325.64 T
0 F
(\051) 523.77 325.64 T
(and the second is a branch on count register \050) 108 312.64 T
1 F
(BCT) 306.87 312.64 T
0 F
(\051. The code may be improved by moving a few) 327.04 312.64 T
(of the instructions preceding the \336rst conditional branch to a location between the conditional) 108 299.64 T
(branches \050i.e. moving them down\051. The complete transformation is illustrated in Figure 2.) 108 286.64 T
(An instruction may be moved down only if there is no chain of data dependencies between it and) 108 262.64 T
(the \336rst conditional branch of the pair) 108 249.64 T
(. It should be noted that in the context of gcc, it is easy to) 273.59 249.64 T
(determine which instructions are suitable for such motions as the backward data dependencies) 108 236.64 T
(built during the second pass of scheduling are still available.) 108 223.64 T
( It is natural to require the second conditional branch to be a) 108 199.64 T
1 F
(BCT) 375.31 199.64 T
0 F
(. This pair of branches usually) 394.67 199.64 T
-0.2 (occurs at the end of a loop. As a consequence, the code in the most frequent path is improved. The) 108 186.64 P
(transformation works even if the) 108 173.64 T
1 F
(BCT) 254.33 173.64 T
0 F
( instruction is replaced by an ordinary conditional branch.) 274.51 173.64 T
-0.32 (Again, the optimal number of instructions to be moved between the two branches is determined by) 108 149.64 P
(tuning.) 108 136.64 T
2 F
(4. BRANCH SW) 108 103.64 T
(APPING) 185.31 103.64 T
119.99 428.98 528.01 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
125.99 435 521.99 714 R
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
131.99 474.02 512.99 699.02 R
5 X
V
0 11 Q
0 X
(                BEFORE:                                       AFTER:) 131.99 691.69 T
(                                                                        B  LOOP1) 131.99 643.69 T
(LOOP:                                              LOOP:) 131.99 619.69 T
(                ..........                                             BC  CR, LABEL) 131.99 595.69 T
(                                                           LOOP1:) 131.99 571.69 T
(                .........                                              ........) 131.99 523.69 T
(                BC  CR, LABEL                          BCT LOOP) 131.99 499.69 T
(                BCT  LOOP                                  BC  CR, LABEL) 131.99 475.69 T
2 12 Q
(Figur) 278.99 447.02 T
(e 3) 307.44 447.02 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "17" 2
%%Page: "16" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(16) 532 42.5 T
0 11 Q
(better exploit the superscalar features of the CPU. This is the basic idea behind the \336rst two trans-) 108 712.67 T
(formations. W) 108 699.67 T
(e simply increase the distance between any two branches. Experiments \050on con-) 170.67 699.67 T
(trived examples\051 verify the usefulness of these techniques for 604-based systems.) 108 686.67 T
(Each of the transformations is applicable to a pair of close branches instructions.) 108 662.67 T
2 F
(2. GLUING) 108 629.67 T
0 F
(The gluing transformation is applicable to the case where a conditional branch is close to an) 108 605.67 T
-0.43 (unconditional one \050a) 108 592.67 P
1 F
-0.43 (BC) 199.91 592.67 P
0 F
-0.43 (-) 213.96 592.67 P
1 F
-0.43 (B) 217.63 592.67 P
0 F
-0.43 ( pair\051. A few instructions from the tar) 224.35 592.67 P
-0.43 (get of the unconditional branch are) 386.14 592.67 P
(copied between the two branches. This transformation is illustrated in Figure 1.) 108 579.67 T
(The number of instructions to be copied depends on the number of instructions already existing) 108 555.67 T
(between the two branches. The optimal number of instructions is determined by the tuning.) 108 542.67 T
119.99 63 528.01 507.02 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
125.99 69.02 521.99 501.02 R
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
134.98 116.52 512.98 485.52 R
5 X
V
0 11 Q
0 X
(                BEFORE:                                       AFTER:) 134.98 478.19 T
(LOOP:                                              LOOP:) 134.98 430.19 T
(                .......                                                ........) 134.98 406.19 T
(                .......                                                ........) 134.98 382.19 T
(                INSN1                                           BC CR, LABEL1) 134.98 358.19 T
(                INSN2                                           INSN1) 134.98 334.19 T
(                BC  CR, LABEL                          INSN2) 134.98 310.19 T
(                BCT  LOOP                                  BCT LOOP) 134.98 286.19 T
(                ........                                               ........) 134.98 262.19 T
(                ........                                               ........) 134.98 238.19 T
(                                                                       B  LABEL) 134.98 214.19 T
(                                                         LABEL1:) 134.98 190.19 T
(                                                                       INSN1) 134.98 166.19 T
(                ........                                              INSN2) 134.98 142.19 T
(LABEL:                                          LABEL:) 134.98 118.19 T
2 12 Q
(    Figur) 269.98 86.52 T
(e 2) 310.43 86.52 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "16" 3
%%Page: "15" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(15) 532 42.5 T
2 16 Q
(  Branch Optimizations in gcc) 222.44 683.33 T
2 11 Q
(1. INTRODUCTION) 108 648.67 T
0 F
(The goal of the project is to implement a branch optimization pass in gcc. The optimizations are) 108 624.67 T
(mainly oriented to systems based on the PowerPC 604. The transformations to be implemented) 108 611.67 T
(are:) 108 598.67 T
3 12 Q
(\245) 122.4 579 T
0 11 Q
(gluing) 129.6 579 T
3 12 Q
(\245) 122.4 559 T
0 11 Q
(down code motion) 129.6 559 T
3 12 Q
(\245) 122.4 539 T
0 11 Q
(branch swapping) 129.6 539 T
(Gluing and branch swapping have been implemented in the XL family of compilers. These trans-) 108 514.67 T
(formations were designed to eliminate delays caused by branches in systems that do not have) 108 501.67 T
(dynamic branch prediction \050RS6000, POWER2 etc.\051. In such cases, measurements have shown) 108 488.67 T
(noticeable speedup.) 108 475.67 T
(In the case of the PowerPC 604, which has dynamic branch prediction, only the \336rst two transfor-) 108 451.67 T
-0.14 (mations are useful. By moving a few non-branch instructions between two close branches, we can) 108 438.67 P
119.99 63 528.01 423 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
125.99 63 521.99 417 R
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
134.99 108 512.99 408 R
5 X
V
0 11 Q
0 X
(                BEFORE:                                       AFTER:) 134.99 400.67 T
(               BC  CR, LABEL                             BC  CR, LABEL) 134.99 352.67 T
(               B   OUT                                            INSN1) 134.99 328.67 T
(               .......                                                   INSN2) 134.99 304.67 T
(                                                                         B   NEW_OUT) 134.99 280.67 T
(                                                                          .......) 134.99 256.67 T
-0.01 (              ........                                                   ........) 134.99 232.67 P
(OUT) 134.99 208.67 T
(:                                                  OUT) 157.04 208.67 T
(:) 319.66 208.67 T
(               INSN1                                              INSN1) 134.99 184.67 T
(               INSN2                                              INSN2) 134.99 160.67 T
(               ..........                       NEW_OUT) 134.99 136.67 T
(:) 319.59 136.67 T
(               ..........                                                ..........) 134.99 112.67 T
134.99 108 512.99 408 R
5 X
N
2 12 Q
0 X
(Figur) 263.99 81 T
(e 1) 292.44 81 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "15" 4
%%Page: "14" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(14) 532 42.5 T
FMENDPAGE
%%EndPage: "14" 5
%%Page: "13" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(13) 532 42.5 T
0 11 Q
(Another problem concerns the debugging information, which associates with each instruction a) 108 275.64 T
(line note. After a copy of an instruction is created, a copy of the line note associated with the) 108 262.64 T
(instruction is also created for possible use in debugging.) 108 249.64 T
160.49 293.98 487.51 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
166.49 300 481.49 714 R
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
175.48 357 274.48 570 R
5 X
V
0 11 Q
0 X
(p1: \050insn1, insn2\051) 175.48 562.67 T
(p2: \050insn1\051) 175.48 538.67 T
(L1:) 175.48 514.67 T
(     insn3  \0500, 1\051) 175.48 490.67 T
(     insn2  \0501, 2\051) 175.48 466.67 T
(     insn1  \0501, 3\051) 175.48 442.67 T
(     BCT L1) 175.48 418.67 T
(e2: \050insn3, insn2\051) 175.48 394.67 T
(e1: \050insn3\051) 175.48 370.67 T
364.48 357 463.48 708 R
5 X
V
0 X
(     insn1) 364.48 700.67 T
(     insn2) 364.48 676.67 T
(     BCF L2) 364.48 652.67 T
(     insn1) 364.48 628.67 T
(     BCF L3) 364.48 604.67 T
(L1:) 364.48 580.67 T
(     insn3) 364.48 556.67 T
(     insn2) 364.48 532.67 T
(     insn1) 364.48 508.67 T
(     BCT L1) 364.48 484.67 T
(L3:) 364.48 460.67 T
(     insn3) 364.48 436.67 T
(     insn2) 364.48 412.67 T
(L2:) 364.48 388.67 T
(     insn3) 364.48 364.67 T
(\050a\051) 211.48 339 T
(\050b\051) 400.48 339 T
2 F
(Figur) 307.31 310.63 T
(e 5) 333.39 310.63 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "13" 6
%%Page: "12" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(12) 532 42.5 T
3 12 Q
(\245) 122.4 712 T
0 11 Q
(instructions having critical path less than a given threshold are not scheduled.) 129.6 712 T
(These new heuristics ensure that the pipelining process will eventually terminate.) 108 687.67 T
2 F
(6. PROLOGUES AND EPILOGUES) 108 654.67 T
0 F
-0.38 (After the scheduling, the loop may contain instructions from the \336rst) 108 630.67 P
1 F
-0.38 (k) 408.77 630.67 P
0 F
-0.38 ( iterations. In the case where) 413.66 630.67 P
(pipelined motions have been performed \050i.e.) 108 617.25 T
(\051, the non-speculative execution of the instruc-) 326.28 617.25 T
(tions moved outside the body of the loop must be ensured.) 108 603.67 T
(The instructions from an iteration) 108 577.75 T
1 F
(j) 258.62 577.75 T
0 F
(\050) 264.43 577.75 T
(\051 which must be executed before entering the loop) 307.6 577.75 T
(are in the prologue) 108 563.25 T
( generated during the scheduling. An epilogue) 203.33 563.25 T
(, containing all the instruc-) 418.52 563.25 T
-0.34 (tion from the iteration) 108 546.4 P
1 F
-0.34 (j) 206.26 546.4 P
0 F
-0.34 ( not in) 209.32 546.4 P
-0.34 (, is built. Th epilogues are built during a traversal of the loop: if an) 248.97 546.4 P
(instruction belongs to the) 108 528.05 T
1 F
(l) 222.28 528.05 T
0 F
( iteration \050) 225.34 528.05 T
(\051, copies of it are generated in the epilogues) 310.67 528.05 T
(,) 516.09 528.05 T
-0.29 (where) 108 509.15 P
-0.29 (. At the end of each prologue) 190.89 509.15 P
-0.29 (, a BCF instruction with the tar) 329.39 509.15 P
-0.29 (get) 464.03 509.15 P
-0.29 ( is inserted) 490.46 509.15 P
(to test the counter register which controls the number of iterations of the loop.) 108 492.17 T
(Finally the prologues) 108 467.75 T
(,...,) 215.59 467.75 T
( \050in this order\051 are inserted in the code before the loop, and the) 253.54 467.75 T
(epilogues) 108 450.9 T
(,....,) 173.85 450.9 T
( \050in this order\051 are inserted in the code after the loop.) 203.94 450.9 T
(Example: For the loop and its associated data structures in Figure 5 \050a\051, the prologues) 108 423.47 T
1 F
(e1) 486.84 423.47 T
0 F
( and) 497.22 423.47 T
1 F
(e2) 518.61 423.47 T
0 F
(are generated. The \336nal code generated appears in Figure 5 \050b\051.) 108 410.47 T
2 F
(7. GLOBAL INFORMA) 108 377.47 T
(TION) 221.77 377.47 T
0 F
(In gcc the information about basic blocks \050\336rst instructions, last instructions, registers live at) 108 353.47 T
(beginning of blocks\051 is computed once, before the scheduling. This information is used and) 108 340.47 T
(updated by subsequent passes and must be accurate after the pipelining. How this accuracy is) 108 327.47 T
(enforced is described below) 108 314.47 T
(.) 230.39 314.47 T
(The information is kept in arrays of size equal to the number of basic blocks in the program, the) 108 290.47 T
(information for the block) 108 277.47 T
1 F
(i) 221.65 277.47 T
0 F
( being found at index) 224.71 277.47 T
1 F
(i) 320.95 277.47 T
0 F
(. As the pipelining creates new basic blocks \050the) 324.01 277.47 T
(prologues and the epilogues\051, new arrays to keep the information for the basic blocks must be cre-) 108 264.47 T
(ated \050the original arrays can not be extended\051. The information from the old arrays is copied into) 108 251.47 T
(the new ones. As subsequent code assumes that the code in block) 108 238.47 T
1 F
(i) 397.93 238.47 T
0 F
(is followed by the code in) 403.73 238.47 T
-0.08 (block) 108 223.55 P
-0.08 ( care must be taken to insert the information about the new basic blocks at appropriate) 159.44 223.55 P
(places in the new arrays. This is done by using an auxiliary data structure which for each basic) 108 209.47 T
(block points to the block which must precede it in the code.) 108 196.47 T
-0.27 (After the scheduling of a region, the information about the new basic blocks \050\336rst instructions, last) 108 172.47 P
(instructions, registers live at beginning\051 is computed. The computation of live information at the) 108 159.47 T
(beginning of the new blocks \050i.e. prologues and epilogues\051 is explained below) 108 146.47 T
(. First the live infor-) 450.38 146.47 T
-0.24 (mation at the end of a new block is computed using the live information at the beginning of its suc-) 108 133.47 P
-0.38 (cessors. Then the block is scanned and the live information at its beginning is computed. The order) 108 120.47 P
-0.19 (in which the new basic blocks are processed is important. A block must be processed only after its) 108 107.47 P
(successors. This means that for a pipelined loop, the live information is computed \336rst for its epi-) 108 94.47 T
(logues, then for the loop, and \336nally for its prologues.) 108 81.47 T
305.35 613 326.28 625 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 304.36 617.25 T
0 F
(1) 320.77 617.25 T
4 F
(>) 311.99 617.25 T
0 0 612 792 C
268.09 573 307.6 587 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 11 Q
0 X
0 0 0 1 0 0 0 K
(1) 269.09 577.75 T
1 F
(j) 286.13 577.75 T
(k) 300.72 577.75 T
4 F
(<) 291.93 577.75 T
(\243) 277.34 577.75 T
0 0 612 792 C
193.54 556.15 203.33 571 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 193.86 563.25 T
1 8 Q
(j) 199.78 559.6 T
0 0 612 792 C
409.23 556.15 418.52 571 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(e) 409.61 563.25 T
1 8 Q
(j) 414.92 559.6 T
0 0 612 792 C
239.18 539.3 248.97 554.15 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 239.51 546.4 T
1 8 Q
(j) 245.43 542.75 T
0 0 612 792 C
271.16 523.3 310.67 537.3 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 11 Q
0 X
0 0 0 1 0 0 0 K
(1) 272.16 528.05 T
1 F
(l) 289.2 528.05 T
(k) 303.79 528.05 T
4 F
(\243) 280.41 528.05 T
(\243) 295 528.05 T
0 0 612 792 C
505.57 520.4 516.09 537.3 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(e) 506.57 528.05 T
1 8 Q
(i) 511.87 524.4 T
0 0 612 792 C
137.33 504.4 190.89 518.4 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 11 Q
0 X
0 0 0 1 0 0 0 K
(1) 138.33 509.15 T
1 F
(i) 155.36 509.15 T
(k) 169.95 509.15 T
(l) 185.83 509.15 T
0 F
(\320) 177.59 509.15 T
4 F
(\243) 146.58 509.15 T
(\243) 161.17 509.15 T
0 0 612 792 C
319.6 502.05 329.39 516.9 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 319.92 509.15 T
1 8 Q
(j) 325.84 505.5 T
0 0 612 792 C
479.93 501.5 490.46 518.4 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(e) 480.93 509.15 T
1 8 Q
(j) 486.23 505.5 T
0 0 612 792 C
204.25 460.65 215.59 475.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 204.46 467.75 T
0 8 Q
(1) 210.38 464.1 T
0 0 612 792 C
232.09 460.65 253.54 475.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 231.58 467.75 T
1 8 Q
(k) 237.5 464.1 T
0 F
(1) 249.05 464.1 T
(\320) 243.05 464.1 T
0 0 612 792 C
152.91 443.8 173.85 458.65 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(e) 152.46 450.9 T
1 8 Q
(k) 157.76 447.25 T
0 F
(1) 169.31 447.25 T
(\320) 163.31 447.25 T
0 0 612 792 C
193.1 443.8 203.94 458.65 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(e) 193.37 450.9 T
0 8 Q
(1) 198.67 447.25 T
0 0 612 792 C
132.44 218.8 159.44 232.8 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(i) 138.88 223.55 T
0 F
(1) 153.64 223.55 T
(+) 144.69 223.55 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "12" 7
%%Page: "11" 8
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(1) 532.3 42.5 T
(1) 536 42.5 T
0 11 Q
(insn_counter\050insn3\051=0 and insn_iter\050insn2\051=2. A copy of the instruction) 108 253.67 T
1 F
(insn2) 428.68 253.67 T
0 F
( is created in) 452.52 253.67 T
1 F
(p1) 511.17 253.67 T
0 F
(.) 522.17 253.67 T
(The data structures and the loop after the motion are shown in Figure 4 \050f\051.) 108 240.67 T
(Now there two candidates for scheduling) 108 216.67 T
1 F
(insn3) 291.29 216.67 T
0 F
( \050which belongs to the second iteration\051 and) 315.13 216.67 T
1 F
(insn1) 510.65 216.67 T
0 F
-0.22 (\050which belongs to the third iteration\051. W) 108 203.67 P
-0.22 (e assume that) 283.31 203.67 P
1 F
-0.22 (insn1) 344.67 203.67 P
0 F
-0.22 ( is scheduled in a pipeline motion. The) 368.51 203.67 P
(changes after its scheduling are insn_counter\050insn1\051=0, insn_counter\050insn2\051=1 and) 108 190.67 T
(insn_iter\050insn1\051=3. A copy of the instruction) 108 177.67 T
1 F
(insn1) 307.61 177.67 T
0 F
( is created in) 331.44 177.67 T
1 F
(p2) 390.1 177.67 T
0 F
(. The data structures and the) 401.1 177.67 T
(loop after the motion are shown in Figure 5 \050a\051.) 108 164.67 T
(The computation of priorities must take into account the case where the instructions from the) 108 140.67 T
(ready list belong to dif) 108 127.67 T
(ferent iterations. New heuristics are introduced:) 207.41 127.67 T
3 12 Q
(\245) 122.4 108 T
0 11 Q
(between two instructions, the one from a previous iteration is preferred.) 129.6 108 T
3 12 Q
(\245) 122.4 88 T
0 11 Q
(each time an instruction is brought from a successive iteration its critical path \050the main heu-) 129.6 88 T
(ristic\051 is divided by 2.) 135 74.67 T
117 261 531 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
270 540 378 702 R
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
126 270 522 711 R
7 X
V
0 X
N
130.49 543 229.49 705 R
5 X
V
0 11 Q
0 X
(p1:) 130.49 697.67 T
(p2:) 130.49 673.67 T
(L1:) 130.49 649.67 T
(     insn1    \0500, 0\051) 130.49 625.67 T
(     insn2   \0501, 0\051) 130.49 601.67 T
(     insn3   \0501, 0\051) 130.49 577.67 T
(     BCT L1) 130.49 553.67 T
274.49 543 373.49 705 R
5 X
V
0 X
(p1:) 274.49 697.67 T
(p2:) 274.49 673.67 T
(L1:) 274.49 649.67 T
(     insn1   \0501, 1\051) 274.49 625.67 T
(     insn2   \0500, 0\051) 274.49 601.67 T
(     insn3   \0501, 0\051) 274.49 577.67 T
(     BCT L1) 274.49 553.67 T
418.49 543 517.49 705 R
5 X
V
0 X
(p1:) 418.49 697.67 T
(p2:) 418.49 673.67 T
(L1:) 418.49 649.67 T
(     insn1   \0500, 1\051) 418.49 625.67 T
(     insn2   \0502, 1\051) 418.49 601.67 T
(     insn3   \0500, 0\051) 418.49 577.67 T
(     BCT L1) 418.49 553.67 T
130.49 336 229.49 498 R
5 X
V
0 X
(p1: \050insn1\051) 130.49 490.67 T
(p2:) 130.49 466.67 T
(L1:) 130.49 442.67 T
(     insn2   \0501, 1\051) 130.49 418.67 T
(     insn1   \0501, 2\051) 130.49 394.67 T
(     insn3   \0500, 0\051) 130.49 370.67 T
(     BCT L1) 130.49 346.67 T
274.49 336 373.49 498 R
5 X
V
0 X
(p1: \050insn1\051) 274.49 490.67 T
(p2:) 274.49 466.67 T
(L1:) 274.49 442.67 T
(     insn2   \0500, 1\051) 274.49 418.67 T
(     insn1   \0501, 2\051) 274.49 394.67 T
(     insn3   \0501, 1\051) 274.49 370.67 T
(     BCT L1) 274.49 346.67 T
418.49 336 517.49 498 R
5 X
V
0 X
(p1: \050insn1, insn2\051) 418.49 490.67 T
(p2:) 418.49 466.67 T
(L1:) 418.49 442.67 T
(     insn1   \0500, 2\051) 418.49 418.67 T
(     insn3   \0500, 1\051) 418.49 394.67 T
(     insn2   \0502, 2\051) 418.49 370.67 T
(     BCT L1) 418.49 346.67 T
2 12 Q
(Figur) 274.82 278.21 T
(e 4) 303.28 278.21 T
0 F
(\050a\051) 157.49 525 T
(\050b\051) 310.49 525 T
(\050c\051) 454.49 525 T
(\050d\051) 165.5 314.21 T
(\050f\051) 454.49 314.21 T
0 11 Q
(\050e\051) 319.28 316.5 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "11" 8
%%Page: "10" 9
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(10) 532 42.5 T
0 11 Q
(counter is zero. At the beginning of the scheduling, the counter of the instruction is initialized to) 108 712.67 T
(the value of its real counter) 108 699.67 T
(.) 227.45 699.67 T
(After an instruction has been scheduled, the following actions are performed:) 108 675.67 T
3 12 Q
(\245) 122.4 656 T
0 11 Q
(the counter of the instruction is set to the value of its SP counter) 129.6 656 T
(.) 411 656 T
3 12 Q
(\245) 122.4 636 T
0 11 Q
(the counter of an instruction) 129.6 636 T
1 F
(insn1) 256.39 636 T
0 F
( pointed to by a real dependency of the instruction sched-) 280.22 636 T
(uled,) 135 622.67 T
1 F
(insn) 159.44 622.67 T
0 F
(, is decreased only if) 177.78 622.67 T
1 F
(insn_iter) 271.26 622.67 T
0 F
(\050) 310.37 622.67 T
1 F
(insn1) 314.04 622.67 T
0 F
(\051 -) 337.87 622.67 T
1 F
(insn_iter) 350.7 622.67 T
0 F
(\050) 389.82 622.67 T
1 F
(insn) 393.48 622.67 T
0 F
(\051 = 0.) 411.82 622.67 T
3 12 Q
(\245) 122.4 603 T
0 11 Q
(the counter of an instruction) 129.6 603 T
1 F
(insn1) 256.39 603 T
0 F
( pointed to by an SP dependency of the instruction sched-) 280.22 603 T
(uled,) 135 589.67 T
1 F
(insn) 159.44 589.67 T
0 F
(, is decreased only if) 177.78 589.67 T
1 F
(insn) 271.26 589.67 T
0 F
( =) 289.59 589.67 T
1 F
(insn1) 301.3 589.67 T
0 F
( or) 325.14 589.67 T
1 F
(insn_iter) 339.8 589.67 T
0 F
(\050) 378.91 589.67 T
1 F
(insn1) 382.58 589.67 T
0 F
(\051 -) 406.41 589.67 T
1 F
(insn_iter) 419.24 589.67 T
0 F
(\050) 458.36 589.67 T
1 F
(insn) 462.02 589.67 T
0 F
(\051 = 1.) 480.36 589.67 T
3 12 Q
(\245) 122.4 570 T
0 11 Q
(the iteration counter of the instruction scheduled is incremented.) 129.6 570 T
(An instruction may be scheduled only if it satis\336es the conditions imposed by the data dependen-) 108 545.67 T
(cies \050i.e the instruction counter is zero\051, and the conditions imposed on the control \337ow of the) 108 532.67 T
(region \050which are dependent of the type of the motion involved\051. The iteration counter of the) 108 519.67 T
(instruction chosen to be scheduled is used to dif) 108 506.67 T
(ferentiate between a local or a pipelined motion:) 318.62 506.67 T
(when it is dif) 108 493.67 T
(ferent from zero a pipelined motion will be performed.) 165.55 493.67 T
(Example \050Figure 3\051: A loop is formed from a single block, which is the header block, the latch) 108 469.67 T
-0.22 (block, the source block and the tar) 108 456.67 P
-0.22 (get block all rolled into one. The conditions imposed on the con-) 257.69 456.67 P
-0.24 (trol \337ow graph are always ful\336lled. In order to schedule an instruction, we need only check that its) 108 443.67 P
(counter is zero.) 108 430.67 T
(Besides the BCT instruction \050not shown\051 there are three instructions) 108 406.67 T
1 F
(insn1) 410.47 406.67 T
0 F
(,) 434.3 406.67 T
1 F
(insn2) 439.8 406.67 T
0 F
(,) 463.64 406.67 T
1 F
(insn3) 469.14 406.67 T
0 F
(. The SP) 492.98 406.67 T
(dependencies are drawn with dashed lines. It is assumed that only instructions from the \336rst three) 108 393.67 T
(iterations may be brought into the body of the loop, thus only two prologues) 108 380.67 T
1 F
(p1) 446.24 380.67 T
0 F
( and) 457.24 380.67 T
1 F
(p2) 478.62 380.67 T
0 F
( are neces-) 489.62 380.67 T
(sary) 108 367.67 T
(. The state at the beginning of the scheduling is shown in Figure 4 \050a\051. For each instruction) 125.61 367.67 T
(there is a couple \050) 108 354.67 T
1 F
(insn_counter) 186.2 354.67 T
0 F
(,) 243.2 354.67 T
1 F
(insn_iter) 248.7 354.67 T
0 F
(\051 with information about the instruction.) 287.82 354.67 T
-0.2 (At the start, the only instruction which may be scheduled \050in a local motion\051 is) 108 330.67 P
1 F
-0.2 (insn1) 453.24 330.67 P
0 F
-0.2 (. The changes) 477.08 330.67 P
(after its scheduling are insn_counter\050insn1\051=1, insn_counter\050insn2\051=0 and insn_iter\050insn1\051 = 1.) 108 317.67 T
(The loop and the relevant data structures after the motion are shown in Figure 4 \050b\051.) 108 304.67 T
(The only instruction which may be scheduled \050in a local motion\051 is) 108 280.67 T
1 F
(insn2) 405.58 280.67 T
0 F
(. The changes after its) 429.42 280.67 T
(scheduling are insn_counter\050insn1\051=0, insn_counter\050insn2\051=2, insn_counter\050insn3\051=0 and) 108 267.67 T
(insn_iter\050insn2\051=1. The data structures and the loop after the motion are shown in Figure 4 \050c\051.) 108 254.67 T
(Now there are two candidates for scheduling,) 108 230.67 T
1 F
(insn3) 310.22 230.67 T
0 F
( and) 334.06 230.67 T
1 F
(insn1) 355.45 230.67 T
0 F
( \050which belongs to the second itera-) 379.28 230.67 T
-0.02 (tion\051. W) 108 217.67 P
-0.02 (e assume that) 143.76 217.67 P
1 F
-0.02 (insn1) 205.71 217.67 P
0 F
-0.02 ( is scheduled \050in a pipelined motion\051. The changes after its scheduling) 229.55 217.67 P
(are insn_counter\050insn1\051=1, insn_counter\050insn2\051=1 and insn_iter\050insn1\051 = 2. A copy of the instruc-) 108 204.67 T
-0.11 (tion) 108 191.67 P
1 F
-0.11 (insn1) 127.76 191.67 P
0 F
-0.11 ( is created in) 151.6 191.67 P
1 F
-0.11 (p1) 209.82 191.67 P
0 F
-0.11 (. The data structures and the loop after the motion are shown in Figure 4) 220.82 191.67 P
(\050d\051.) 108 178.67 T
(The only instruction which may be scheduled \050in a local motion\051 is) 108 154.67 T
1 F
(insn3) 405.58 154.67 T
0 F
(. The changes after its) 429.42 154.67 T
(scheduling are insn_counter\050insn2\051=0,insn_counter\050insn3\051=1 and insn_iter\050insn3\051=1.The data) 108 141.67 T
(structures and the loop after the motion are shown in Figure 4 \050e\051.) 108 128.67 T
-0.29 (The only instruction which may be scheduled is) 108 104.67 P
1 F
-0.29 (insn2) 318.96 104.67 P
0 F
-0.29 ( \050which belongs to the second iteration\051. The) 342.8 104.67 P
(changes after its scheduling are insn_counter\050insn1\051=0, insn_counter\050insn2\051=2,) 108 91.67 T
FMENDPAGE
%%EndPage: "10" 9
%%Page: "9" 10
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(9) 536 42.5 T
0 11 Q
(The \336nal data dependency graph with forward dependencies, and the values of the two counters,) 108 323.67 T
(appears in Figure 3. The SP dependencies are drawn with dashed lines.) 108 310.67 T
2 F
(5. LIST SCHEDULING) 108 277.67 T
0 F
-0.03 (In a pipelined motion, an instruction is brought from the) 108 251.75 P
1 F
-0.03 (k) 357.93 251.75 P
0 F
-0.03 ( iteration \050) 362.82 251.75 P
-0.03 (\051, and its corresponding) 433.5 251.75 P
-0.25 (copy from the loop \050from the) 108 235.75 P
-0.25 ( iteration\051 is moved to a prologue) 261.62 235.75 P
-0.25 (. The prologue holds all) 433.72 235.75 P
(the instructions from the) 108 216.85 T
( iteration which were moved outside the body of the loop. In prac-) 242.98 216.85 T
(tice, a copy of the instruction scheduled is created in the prologue and the original instruction is) 108 202.77 T
-0.04 (moved to its new location in the body of the loop. This means that during the scheduling, the orig-) 108 189.77 P
(inal instruction from the body of the loop is used to represent all its copies from successive itera-) 108 176.77 T
(tions.) 108 163.77 T
-0.2 (An iteration counter) 108 139.77 P
1 F
-0.2 (insn_iter) 198.73 139.77 P
-0.2 (,) 236.63 139.77 P
0 F
-0.2 ( speci\336es which copy it represents \050i.e. to which iteration it belongs\051) 239.38 139.77 P
-0.18 (for the instruction scheduled. At the beginning of the scheduling,) 108 126.77 P
1 F
-0.18 (insn_iter) 395.2 126.77 P
0 F
-0.18 ( is zero for each instruc-) 434.31 126.77 P
(tion.) 108 113.77 T
-0.24 (As in the original inter) 108 89.77 P
-0.24 (-block scheduler) 206.44 89.77 P
-0.24 (, for each instruction, a counter) 278.77 89.77 P
1 F
-0.24 (insn_counter) 417.27 89.77 P
-0.24 (,) 473.49 89.77 P
0 F
-0.24 ( is maintained) 476.24 89.77 P
-0.22 (during the scheduling. An instruction may be subject to either a local or pipelined motion when its) 108 76.77 P
110.99 342 537.01 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
285.61 525 359.99 561 18 RR
7 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
287.99 417 362.36 453 18 RR
7 X
V
0 X
N
5 X
90 180 0.63 0.5 261.85 343.92 G
261.86 344.25 261.22 344.41 261.85 344.61 261.85 344.43 4 Y
0 X
V
0 12 Q
(insn2: def r5) 296.99 536.6 T
(insn3: use r5) 296.05 433.25 T
(init1: uses r5) 296.99 644.6 T
J
287.99 633 362.36 669 18 RR
7 X
V
0 X
N
J
331.63 623.75 323.99 633 335.37 629.21 333.5 626.48 4 Y
V
[7.782 6.744] 3.891 I
333.52 626.47 M
 348.73 608.8 342.22 566.58 324.58 561.75 D
N
J
316 567.88 322.8 558 311.8 562.78 313.9 565.33 4 Y
V
323.38 633 M
 302.1 625.16 302.02 583 313.91 565.32 D
N
J
331.63 515.02 323.98 524.26 335.37 520.47 333.5 517.74 4 Y
V
[7.782 6.744] 3.891 I
333.52 517.72 M
 348.73 500.05 342.22 457.84 324.58 453 D
N
J
314.22 463 320.86 453.01 309.93 457.96 312.07 460.48 4 Y
V
321.41 524.25 M
 301.4 516.88 301.13 477.55 312.08 460.47 D
N
(insn1: use r5) 296.99 644.6 T
J
302.3 573.68 303.56 561.75 296.16 571.2 299.23 572.44 4 Y
V
[7.491 6.492] 3.745 I
299.24 572.45 M
 289.6 584.66 268.3 577.89 263.77 568.34 D
 251.99 543.5 260.58 507 285.3 509.44 D
 290.66 509.97 301.66 518.54 303.57 525.25 D
N
J
116.99 351 530.99 711 R
1 H
N
J
2 F
(Figur) 281.99 369 T
(e 3) 310.44 369 T
371.99 630 443.99 666 R
5 X
V
0 11 Q
0 X
(real_counter=0) 371.99 658.67 T
(SP_counter=1) 371.99 634.67 T
371.99 522 443.99 558 R
5 X
V
0 X
(real_counter=1) 371.99 550.67 T
(SP_counter=3) 371.99 526.67 T
371.99 414 443.99 450 R
5 X
V
0 X
(real_counter=1) 371.99 442.67 T
(SP_counter=1) 371.99 418.67 T
0 0 612 792 C
408.58 247 433.5 261 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 409.58 251.75 T
0 F
(1) 426 251.75 T
4 F
(>) 417.21 251.75 T
0 0 612 792 C
237.24 231 261.62 245 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 238.24 235.75 T
0 F
(1) 254.12 235.75 T
(\320) 245.87 235.75 T
0 0 612 792 C
409.25 228.1 433.72 245 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 410.25 235.75 T
1 8 Q
(k) 416.17 232.1 T
0 F
(1) 427.72 232.1 T
(\320) 421.72 232.1 T
0 0 612 792 C
218.6 212.1 242.98 226.1 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 219.6 216.85 T
0 F
(1) 235.48 216.85 T
(\320) 227.24 216.85 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "9" 10
%%Page: "8" 11
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(8) 536 42.5 T
3 12 Q
(\245) 122.4 712 T
1 11 Q
(SP dependencies) 129.6 712 T
0 F
( which are the dependencies to the next iteration \050i.e. inter) 203.83 712 T
(-iteration depen-) 458.99 712 T
(dencies\051;) 135 698.67 T
(and two types of counters:) 108 674.67 T
3 12 Q
(\245) 122.4 655 T
0 11 Q
(a) 129.6 655 T
1 F
( r) 134.48 655 T
(eal counter) 141.11 655 T
0 F
( which counts the number of dependencies which must be resolved in order to) 190.9 655 T
(move an instruction in the same iteration \050these counters are computed by the original inter) 135 641.67 T
(-) 535.61 641.67 T
(block scheduler\051.) 135 628.67 T
3 12 Q
(\245) 122.4 609 T
0 11 Q
(an) 129.6 609 T
1 F
( SP counter) 139.98 609 T
0 F
( which counts the number of dependencies which must be resolved in order to) 191.31 609 T
(move the instruction in the previous iteration \050this counter is the sum of the real and SP) 135 595.67 T
(dependencies having the instruction as tar) 135 582.67 T
(get\051.) 319.02 582.67 T
(W) 108 558.67 T
(e need to extend the mechanism for computing data dependencies between instructions in the) 117.5 558.67 T
(same iteration \050i.e real dependencies\051 in order to also compute the dependencies between instruc-) 108 545.67 T
(tions in dif) 108 532.67 T
(ferent iterations \050i.e SP dependencies\051. After describing the computation of data depen-) 155.48 532.67 T
(dencies in the original scheduler) 108 519.67 T
(, a method for computing the inter) 249.92 519.67 T
(-iteration dependencies is) 400.33 519.67 T
(presented.) 108 506.67 T
(The original inter) 108 482.67 T
(-block scheduler \336rst computes the backward dependencies. For simplicity the) 184.77 482.67 T
(process is described only for dependencies introduced by registers. During a forward traversal,) 108 469.67 T
-0.33 (lists for pending uses and pending de\336nitions are maintained for each register) 108 456.67 P
-0.33 (. For each instruction) 445.06 456.67 P
(seen, its dependencies are updated according to the contents of the two lists. The lists are also) 108 443.67 T
(updated. This process is detailed below) 108 430.67 T
(.) 280.2 430.67 T
-0.14 (For a register) 108 406.67 P
1 F
-0.14 (r) 168.98 406.67 P
0 F
-0.14 (, its list of pending uses is denoted by) 172.82 406.67 P
1 F
-0.14 (r) 339.6 406.67 P
-0.14 (eg_last_uses\050r\051) 343.47 406.67 P
0 F
-0.14 ( and its list of pending de\336ni-) 411.29 406.67 P
(tions is denoted by) 108 393.67 T
1 F
(r) 193.56 393.67 T
(eg_last_defs\050r\051) 197.43 393.67 T
0 F
(. Let) 264.04 393.67 T
1 F
(insn) 286.95 393.67 T
0 F
(be) 308.04 393.67 T
(the current instruction being analyzed. A register) 321.17 393.67 T
1 F
(r1) 108 380.67 T
0 F
(, de\336ned in) 117.78 380.67 T
1 F
(insn) 169.72 380.67 T
0 F
(, introduces dependencies between) 188.06 380.67 T
1 F
(insn) 343.54 380.67 T
0 F
( and the instructions from the) 361.88 380.67 T
1 F
(r) 108 367.67 T
(eg_last_uses\050r1\051) 111.87 367.67 T
0 F
( and) 185.2 367.67 T
1 F
(r) 206.58 367.67 T
(eg_last_defs\050r1\051) 210.45 367.67 T
0 F
(. All the entries from) 282.56 367.67 T
1 F
(r) 377.27 367.67 T
(eg_last_defs\050r1\051) 381.14 367.67 T
0 F
( and) 453.25 367.67 T
1 F
(r) 474.63 367.67 T
(eg_last_uses) 478.5 367.67 T
0 F
-0.32 (\050) 108 354.67 P
1 F
-0.32 (r1) 111.66 354.67 P
0 F
-0.32 (\051 are then discarded, and) 121.44 354.67 P
1 F
-0.32 (insn) 230.43 354.67 P
0 F
-0.32 ( is inserted in the list) 248.76 354.67 P
1 F
-0.32 (r) 340.98 354.67 P
-0.32 (eg_last_defs\050r1\051) 344.85 354.67 P
0 F
-0.32 (. A register) 416.95 354.67 P
1 F
-0.32 (r2,) 467.93 354.67 P
0 F
-0.32 (used in) 482.89 354.67 P
1 F
-0.32 ( insn,) 514.05 354.67 P
0 F
(introduces dependencies between) 108 341.67 T
1 F
(insn) 257.98 341.67 T
0 F
( and the instructions in) 276.32 341.67 T
1 F
(r) 379.29 341.67 T
(eg_last_defs\050r2\051) 383.17 341.67 T
0 F
(. Finally) 455.27 341.67 T
1 F
(insn) 494.69 341.67 T
0 F
(is) 515.78 341.67 T
(inserted in the list) 108 328.67 T
1 F
(r) 189.28 328.67 T
(eg_last_uses\050r2) 193.15 328.67 T
0 F
(\051.) 262.81 328.67 T
(A straightforward way to compute the inter) 108 304.67 T
(-iterations dependencies is to traverse the loop twice) 298.41 304.67 T
-0.12 (and to apply the usual procedure for computing the data dependencies. Conceptually) 108 291.67 P
-0.12 (, we may con-) 478.05 291.67 P
-0.19 (sider this as a traversal of the loop unrolled twice. The pending lists at the beginning of the second) 108 278.67 P
-0.05 (traversal are exactly the pending lists at the end of the \336rst traversal \050while at the beginning of the) 108 265.67 P
(\336rst traversal these lists were empty\051. This change in the initialization of the pending lists intro-) 108 252.67 T
(duces additional data dependencies between instructions which are exactly the inter) 108 239.67 T
(-iterations) 475.59 239.67 T
(dependencies.) 108 226.67 T
2 F
(Example:) 108 202.67 T
0 F
( Figure 2 illustrates a simple example of the process described above. The loop is) 155.97 202.67 T
(formed from a single block \050which is the header and the latch of the loop\051. Besides the BCT) 108 189.67 T
(instruction \050not shown in the \336gure\051 there are three instructions) 108 176.67 T
1 F
(insn1) 389.07 176.67 T
0 F
(,) 412.91 176.67 T
1 F
(insn2) 418.41 176.67 T
0 F
(, and) 442.25 176.67 T
1 F
(insn3) 466.38 176.67 T
0 F
(. The \336rst) 490.22 176.67 T
(and the third instruction use the register) 108 163.67 T
1 F
(r5) 285.51 163.67 T
0 F
(, the second de\336nes it.) 295.29 163.67 T
(At the beginning of the \336rst traversal) 108 139.67 T
1 F
(r) 273.29 139.67 T
(eg_last_defs) 277.16 139.67 T
0 F
(\050) 332.16 139.67 T
1 F
(r5) 335.82 139.67 T
0 F
(\051=) 345.6 139.67 T
1 F
(empty) 355.47 139.67 T
0 F
( and) 381.73 139.67 T
1 F
(r) 403.12 139.67 T
(eg_last_uses) 406.99 139.67 T
0 F
(\050) 463.21 139.67 T
1 F
(r5) 466.88 139.67 T
0 F
(\051 =) 476.65 139.67 T
1 F
(empty) 492.02 139.67 T
0 F
(. At) 517.57 139.67 T
(the end of this traversal, the dependencies, drawn with continuous lines in Figure 2, are found.) 108 126.67 T
(At the end of the \336rst traversal,) 108 102.67 T
1 F
(r) 247.92 102.67 T
(eg_last_defs) 251.79 102.67 T
0 F
(\050) 306.79 102.67 T
1 F
(r5) 310.45 102.67 T
0 F
(\051={) 320.23 102.67 T
1 F
(insn2) 335.38 102.67 T
0 F
(} and r) 359.22 102.67 T
1 F
(eg_last_uses) 389.14 102.67 T
0 F
(\050) 445.36 102.67 T
1 F
(r5) 449.02 102.67 T
0 F
(\051={) 458.8 102.67 T
1 F
(insn3) 473.95 102.67 T
0 F
(}. These) 497.79 102.67 T
(lists are used at the beginning of the second traversal. During this traversal, new dependencies,) 108 89.67 T
(drawn with dashed lines in Figure 2\050b\051, are found. These are the inter) 108 76.67 T
(-iterations dependencies.) 412.66 76.67 T
FMENDPAGE
%%EndPage: "8" 11
%%Page: "7" 12
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(7) 536 42.5 T
2 11 Q
(4. DA) 108 154.81 T
(T) 134.07 154.81 T
(A DEPENDENCIES INFORMA) 140.59 154.81 T
(TION) 293.16 154.81 T
0 F
(In order to handle the data dependencies imposed by a pipelined motion, we now compute two) 108 130.81 T
(types of forward dependencies for an instruction:) 108 117.81 T
3 12 Q
(\245) 122.4 98.14 T
1 11 Q
(r) 129.6 98.14 T
(eal dependencies) 133.47 98.14 T
0 F
( which are the dependencies within the same iteration \050these dependencies) 208.92 98.14 T
(are those computed by the original inter) 135 84.81 T
(-block scheduler\051;) 310.14 84.81 T
99.97 162.14 548.03 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
99.97 162.14 548.03 720 R
7 X
0 0 0 1 0 0 0 K
V
J
2 12 Q
0 X
(Figur) 309.89 187 T
(e 2) 338.34 187 T
J
(Figur) 309.89 187 T
(e 2) 338.34 187 T
153.97 171 504.97 711 R
1 H
2 Z
N
293.31 648 367.68 684 18 RR
5 X
V
0.5 H
0 X
N
295 540.88 369.37 576.88 18 RR
5 X
V
0 X
N
0 F
(insn3: use r5) 303.06 554.87 T
J
292.7 217.12 367.08 253.12 18 RR
7 X
V
0 X
N
294.25 326.62 368.62 362.62 18 RR
7 X
V
0 X
N
296 432.38 370.37 468.38 18 RR
7 X
V
0 X
N
(insn1: use r5) 303 447.75 T
(insn2: def r5) 300.41 663.88 T
(insn2: def r5) 303.75 341.38 T
(insn3: use r5) 301.81 233 T
J
318.64 647.68 330.3 650.5 321.91 641.93 320.27 644.8 4 Y
V
[7.58 6.569] 3.79 I
320.22 644.76 M
 237.38 594.12 207.49 485.26 263.92 412.37 D
 280.45 391.02 306.33 372.37 331.43 362.62 D
N
J
319.71 537.64 331.27 540.88 323.18 532.01 321.45 534.82 4 Y
V
[7.332 6.354] 3.666 I
321.44 534.79 M
 248.89 486.39 247.15 403.72 332.18 362.62 D
N
J
327.89 424 331.33 435.5 334.51 423.93 331.2 423.96 4 Y
V
330.52 361.88 331.2 423.96 2 L
N
328.67 316.7 332.18 328.18 335.28 316.59 331.97 316.64 4 Y
V
330.93 257.29 331.98 316.63 2 L
N
J
339.18 639.39 331.31 648.38 342.75 644.92 340.97 642.16 4 Y
V
[7.274 6.304] 3.637 I
341 642.14 M
 411.16 593.43 412.77 510.36 330.43 469.04 D
N
J
0 0 612 792 C
FMENDPAGE
%%EndPage: "7" 12
%%Page: "6" 13
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(6) 536 42.5 T
0 11 Q
(Let) 108 712.67 T
1 F
(insn) 125.41 712.67 T
0 F
( be an instruction in the block) 143.75 712.67 T
1 F
(b2) 277.27 712.67 T
0 F
(, whose copy from the second iteration) 288.27 712.67 T
1 F
(insn\325) 461.79 712.67 T
0 F
( becomes a) 483.79 712.67 T
(candidate for scheduling during the scheduling of block) 108 699.67 T
1 F
(b3) 356.07 699.67 T
0 F
(. Block) 367.07 699.67 T
1 F
(b3) 401.6 699.67 T
0 F
( then becomes the tar) 412.6 699.67 T
(get) 505.88 699.67 T
(block and block) 108 686.67 T
1 F
(b2) 181.02 686.67 T
0 F
( the source block. W) 192.02 686.67 T
(e have:) 281.87 686.67 T
(As the block) 108 518.67 T
1 F
(b3) 166.35 518.67 T
0 F
( dominates the block) 177.35 518.67 T
1 F
(b4) 271.46 518.67 T
0 F
(, this pipelined motion is possible when the registers) 282.46 518.67 T
-0.37 (de\336ned in the instruction) 108 505.67 P
1 F
-0.37 (insn) 218.96 505.67 P
0 F
-0.37 ( are not live at the beginning of the blocks) 237.3 505.67 P
1 F
-0.37 (b3) 421.81 505.67 P
0 F
-0.37 ( and) 432.81 505.67 P
1 F
-0.37 (b5) 453.45 505.67 P
0 F
-0.37 (. W) 464.45 505.67 P
-0.37 (e assume that) 479.09 505.67 P
-0.29 (this conditions is ful\336lled and the instruction) 108 492.67 P
1 F
-0.29 (insn\325) 305.5 492.67 P
0 F
-0.29 ( is scheduled in block b3. The instruction) 327.5 492.67 P
1 F
-0.29 (insn) 509.41 492.67 P
0 F
-0.29 ( is) 527.74 492.67 P
(moved from the block) 108 479.67 T
1 F
(b2) 208.21 479.67 T
0 F
( in a prologue. After the move the live information is updated at the) 219.21 479.67 T
(beginning of the blocks) 108 466.67 T
1 F
(b2) 214.33 466.67 T
0 F
( and) 225.33 466.67 T
1 F
(b4) 246.71 466.67 T
0 F
(.) 257.71 466.67 T
-0.41 (W) 108 442.67 P
-0.41 (e assume further that during the scheduling of the block) 117.5 442.67 P
1 F
-0.41 (b4) 361.48 442.67 P
0 F
-0.41 (, the instruction) 372.48 442.67 P
1 F
-0.41 (insn\323) 442.75 442.67 P
0 F
-0.41 ( \050the copy of the) 467.2 442.67 P
(instruction) 108 429.67 T
1 F
(insn) 157.81 429.67 T
0 F
( in the third iteration\051 become a candidate for scheduling. Now the block) 176.15 429.67 T
1 F
(b4) 498.75 429.67 T
0 F
( is the) 509.75 429.67 T
(tar) 108 416.67 T
(get block and the block) 119.41 416.67 T
1 F
(b3) 224.81 416.67 T
0 F
( is the source block. In this case:) 235.81 416.67 T
-0.08 (All conditions required for this pipeline motion are ful\336lled. On completion of the motion, the list) 108 254.67 P
(of update blocks is empty and hence there is no need to update the live information.) 108 241.67 T
-0.07 (As we have seen, the analysis needed for pipelined motions is based on the analysis performed on) 108 217.67 P
(inter) 108 204.67 T
(-block motions. The problem which we still need to resolve is that the original scheduler has) 127.94 204.67 T
(only information \050about the domination, probability) 108 191.67 T
(, split-path and update-path\051 that is relative to) 335.23 191.67 T
-0.29 (the current tar) 108 178.67 P
-0.29 (get. It can only handle moves into the current tar) 168.92 178.67 P
-0.29 (get. T) 379.96 178.67 P
-0.29 (o overcome this limitation, we) 404.57 178.67 P
(must maintain similar information relative to the header of the loop. This information needs to be) 108 165.67 T
-0.02 (computed only once, as it does not depend on the current tar) 108 152.67 P
-0.02 (get being scheduled. In fact, the origi-) 372.73 152.67 P
(nal scheduler computes this information when the current tar) 108 139.67 T
(get is the header block, but subse-) 375.42 139.67 T
(quently overwrites it. Now) 108 126.67 T
(, if the pipelining is performed, this information is preserved in a) 225.22 126.67 T
(separate data structure.) 108 113.67 T
108 63 540 720 C
157.5 539 490.5 683 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
162 539.71 495 692.71 R
5 X
0 0 0 1 0 0 0 K
V
0 11 Q
0 X
(        dominate \050tar) 162 661.38 T
(get, latch\051 = dominate \050b3, b4\051 = true) 242.76 661.38 T
(         split_blocks \050header) 162 637.38 T
(,source\051 = split_blocks \050b1, b2\051 = {b3}) 275.21 637.38 T
(         split_blocks \050tar) 162 613.38 T
(get,latch\051 = split_blocks \050b3,b4\051 = {b5\051) 257.74 613.38 T
(         update_blocks \050header) 162 589.38 T
(, source\051 = update_blocks \050b1, b2\051 = {b2}) 285.58 589.38 T
(         update_blocks \050tar) 162 565.38 T
(get, latch\051 = update_blocks \050b3,b4\051 = {b4}) 268.12 565.38 T
108 63 540 720 C
0 0 612 792 C
108 63 540 720 C
157.01 275 490.99 413 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
156.87 279 489.87 423 R
5 X
0 0 0 1 0 0 0 K
V
0 11 Q
0 X
(         dominate \050tar) 156.87 391.67 T
(get, latch\051 = dominate \050b4, b4\051 = true) 240.38 391.67 T
(         split_blocks \050header) 156.87 367.67 T
(,source\051 = split_blocks \050b1, b3\051 = empty) 270.08 367.67 T
(         split_blocks \050tar) 156.87 343.67 T
(get,latch\051 = split_blocks \050b4,b4\051 = empty) 252.61 343.67 T
(         update_blocks \050header) 156.87 319.67 T
(, source\051 = update_blocks \050b1, b3\051 = empty) 280.45 319.67 T
(         update_blocks \050tar) 156.87 295.67 T
(get, latch\051 = update_blocks \050b4,b4\051 = empty) 262.98 295.67 T
(.) 455.54 295.67 T
108 63 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "6" 13
%%Page: "5" 14
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(5) 536 42.5 T
101.99 50.98 546.01 720 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
7 X
0 0 0 1 0 0 0 K
90 450 17.19 17.19 322.59 626.73 G
0.5 H
2 Z
0 X
90 450 17.19 17.19 322.59 626.73 A
7 X
90 450 17.8 17.19 323.58 481.98 G
0 X
90 450 17.8 17.19 323.58 481.98 A
7 X
90 450 17.19 17.19 394.09 553.98 G
0 X
90 450 17.19 17.19 394.09 553.98 A
7 X
90 450 17.19 17.19 321.47 337.85 G
0 X
90 450 17.19 17.19 321.47 337.85 A
325.67 511.32 322.34 499.8 319.06 511.34 322.36 511.33 4 Y
V
322.59 609.54 322.37 511.33 2 L
N
382.89 581.24 388.57 570.67 378.15 576.62 380.52 578.93 4 Y
V
341.38 619.11 380.52 578.93 2 L
N
345.01 500.54 334.49 494.76 340.35 505.23 342.68 502.89 4 Y
V
381.94 541.82 342.69 502.88 2 L
N
326.2 655.36 322.59 643.92 319.58 655.53 322.89 655.45 4 Y
V
323.53 680.17 322.89 655.45 2 L
N
324.99 366.52 321.46 355.05 318.38 366.64 321.68 366.58 4 Y
V
323.59 465.42 321.69 366.57 2 L
N
293.21 624.04 304.9 626.73 296.41 618.25 294.81 621.14 4 Y
V
305.41 337.85 M
 227.69 398.45 232.9 577.8 294.81 621.12 D
N
376.11 431.43 381.66 420.79 371.32 426.88 373.71 429.16 4 Y
V
335.12 469.82 373.72 429.16 2 L
N
7 X
90 450 17.19 17.19 395.84 409.1 G
0 X
90 450 17.19 17.19 395.84 409.1 A
325.76 295.57 322.91 283.91 319.15 295.31 322.46 295.44 4 Y
V
321.47 320.66 322.46 295.44 2 L
N
434.78 502.04 435.41 502.67 R
7 X
V
0 12 Q
0 X
(b1) 317.59 624.54 T
(b2) 389.47 550.16 T
(b5) 390.59 405.92 T
(b3) 316.72 479.17 T
(b4) 316.72 334.16 T
2 F
(Figur) 301.99 251.33 T
(e 1) 330.45 251.33 T
118.03 232 511.36 693.67 R
1 H
N
1 11 Q
(insn) 422.38 552.67 T
(insn\325) 350.38 482.14 T
J
356.2 614.17 350.38 624.67 360.88 618.85 358.54 616.51 4 Y
V
J
395.38 579.67 358.54 616.51 2 L
J
395.38 579.67 392.73 582.32 2 L
0.5 H
N
[6.898 5.978] 6.898 I
392.73 582.32 361.19 613.86 2 L
N
J
361.19 613.86 358.54 616.51 2 L
N
J
329.07 442.13 332.38 453.67 335.69 442.13 332.38 442.13 4 Y
V
J
332.38 363.67 332.38 442.13 2 L
J
332.38 363.67 332.38 367.42 2 L
N
[6.957 6.03] 6.957 I
332.38 367.42 332.38 438.38 2 L
N
J
332.38 438.38 332.38 442.13 2 L
N
J
0 0 612 792 C
FMENDPAGE
%%EndPage: "5" 14
%%Page: "4" 15
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(4) 536 42.5 T
144 477 477 603 R
5 X
V
108 63 540 720 R
7 X
V
2 11 Q
0 X
(2. PIPELINED REGIONS) 108 712.67 T
0 F
(The inter) 108 688.67 T
(-block scheduler splits a function into) 147.8 688.67 T
1 F
(r) 316.45 688.67 T
(egions) 320.32 688.67 T
0 F
( \050i.e. inter) 349.04 688.67 T
(-block scheduling ranges\051. A) 391.59 688.67 T
(region may be an inner loop, a basic block or the whole procedure.) 108 675.67 T
-0.2 (Only a region which is an inner loop is a candidate for pipelining. Such a loop is pipelined if it has) 108 651.67 P
-0.14 (a single latch and the number of its iterations is controlled by a BCT \050branch on count\051 instruction.) 108 638.67 P
-0.29 (In addition, in order to not adversely af) 108 614.67 P
-0.29 (fect the compilation time, only a loop having the number of) 278.04 614.67 P
(instructions under a given threshold \050by default 50 instructions\051 is pipelined.) 108 601.67 T
2 F
(3. CONTROL FLOW INFORMA) 108 568.67 T
(TION) 266.69 568.67 T
0 F
(The support for inter) 108 544.67 T
(-block motions in the original inter) 199.12 544.67 T
(-block scheduler is brie\337y described. A) 352.6 544.67 T
(candidate for scheduling may be moved from a block only into one of its dominators. In order to) 108 531.67 T
(assure the correctness of a move,) 108 518.67 T
1 F
(split) 256.15 518.67 T
(blocks) 277.85 518.67 T
0 F
( where live information is checked are computed.) 305.96 518.67 T
1 F
(Update) 108 505.67 T
(blocks) 143.13 505.67 T
0 F
( where the live information is updated after a move are also computed. For non-) 171.24 505.67 T
(speculative moves, the lists of split and update blocks are empty) 108 492.67 T
(. Associated with a move is its) 389.9 492.67 T
1 F
(pr) 108 479.67 T
(obability) 117.37 479.67 T
0 F
(, used to compare it with other moves.) 155.77 479.67 T
-0.39 (For a pipelined motion, the block containing the copy of the candidate for scheduling, is the) 108 455.67 P
1 F
-0.39 (sour) 508.72 455.67 P
-0.39 (ce) 527.87 455.67 P
(block) 108 442.67 T
0 F
(. The) 131.83 442.67 T
1 F
(tar) 157.18 442.67 T
(get block) 169.61 442.67 T
0 F
( is the block being currently scheduled. Other blocks referred to below are) 209.63 442.67 T
(the) 108 429.67 T
1 F
(header block) 124.19 429.67 T
0 F
(, the header of the loop, and the) 181.32 429.67 T
1 F
(latch block) 323.06 429.67 T
0 F
(, the latch of the loop.) 371.64 429.67 T
(From the point of view of the control \337ow) 108 405.67 T
(, a pipelined motion is equivalent to) 293.05 405.67 T
( two instruction) 451.02 405.67 T
(moves, one from the source block to the header block and the second from the latch block to the) 108 392.67 T
(tar) 108 379.67 T
(get block. The conditions imposed by the inter) 119.41 379.67 T
(-block scheduler on the control \337ow graph for) 323.9 379.67 T
(these two moves are:) 108 366.67 T
3 12 Q
(\245) 122.4 347 T
0 11 Q
(the header block must dominate the source block \050as the header of a loop dominates all the) 129.6 347 T
(blocks in the loop, this condition is always ful\336lled\051.) 135 333.67 T
3 12 Q
(\245) 122.4 314 T
0 11 Q
(the tar) 129.6 314 T
(get block must dominate the latch block.) 157.2 314 T
3 12 Q
(\245) 122.4 294 T
0 11 Q
(the live information on the split blocks of the source block relative to the header block must) 129.6 294 T
(allow the move of the instruction from one to another) 135 280.67 T
(.) 369.95 280.67 T
3 12 Q
(\245) 122.4 261 T
0 11 Q
(the live information on the split blocks of the latch block relative to the tar) 129.6 261 T
(get block must) 456.93 261 T
(allow the move of the instruction from one to another) 135 247.67 T
(.) 369.95 247.67 T
(The probability of a pipelined motion is computed by multiplying the probabilities of the two) 108 223.67 T
(moves. Similarly) 108 210.67 T
(, its update blocks are the union of the update blocks of the two moves.) 182.46 210.67 T
2 F
(Example:) 108 186.67 T
0 F
-0.14 (The loop in Figure 1 contains the blocks) 158.72 186.67 P
1 F
-0.14 (b1) 337.83 186.67 P
0 F
-0.14 (,) 348.83 186.67 P
1 F
-0.14 (b2) 354.18 186.67 P
0 F
-0.14 (,) 365.18 186.67 P
1 F
-0.14 (b3) 370.53 186.67 P
0 F
-0.14 (, and) 381.53 186.67 P
1 F
-0.14 (b4) 405.38 186.67 P
0 F
-0.14 (. The block) 416.38 186.67 P
1 F
-0.14 (b1) 468.49 186.67 P
0 F
-0.14 ( is the header) 479.49 186.67 P
(block, and the block) 108 173.67 T
1 F
(b4) 199.96 173.67 T
0 F
( is the latch block.) 210.96 173.67 T
FMENDPAGE
%%EndPage: "4" 15
%%Page: "3" 16
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(3) 536 42.5 T
2 16 Q
(  Softwar) 227.49 683.33 T
(e Pipelining for gcc) 289.41 683.33 T
2 11 Q
(1. INTRODUCTION) 108 648.67 T
0 F
(Software pipelining is a scheduling technique which attempts to overlap the execution of distinct) 108 624.67 T
(loop iterations, by creating a new loop body with instructions taken from several consecutive iter-) 108 611.67 T
(ations.) 108 598.67 T
-0.32 (First, loops which are candidates for pipelining are identi\336ed. As before, the body of such a loop is) 108 574.67 P
(scheduled by the inter) 108 561.67 T
(-block scheduler) 204.62 561.67 T
(. Until now) 277.03 561.67 T
(, only) 326.12 561.67 T
1 F
(local motions) 353.93 561.67 T
0 F
(, where the instructions) 413.51 561.67 T
(scheduled belonged to the body of the loop \050i.e the \336rst iteration\051 were done. Software pipelining) 108 548.67 T
-0.13 (enables the scheduler to do) 108 535.67 P
1 F
-0.13 (pipelined motions) 229.24 535.67 P
0 F
-0.13 ( where the instructions scheduled may belong to suc-) 307.64 535.67 P
(cessive iterations.) 108 522.67 T
(In a pipelined motion two instructions are moved:) 108 498.67 T
3 12 Q
(\245) 122.4 479 T
0 11 Q
(an instruction is brought into the body of the loop from the) 129.6 479 T
1 F
(k) 391.15 479 T
0 F
(\325) 396.03 479 T
(th \050) 399.5 479 T
(\051 iteration \050this is the) 435.4 479 T
(instruction scheduled\051.) 135 465.42 T
3 12 Q
(\245) 122.4 445.75 T
0 11 Q
(its corresponding copy from the loop, initially belonging to the) 129.6 445.75 T
( iteration, is moved to a) 429.67 445.75 T
(prologue) 135 431.75 T
(, outside the loop.) 198.3 431.75 T
(T) 108 404.32 T
(o ensure the correctness of a pipelined motion, additional conditions are imposed on the control) 113.95 404.32 T
(\337ow of the region and on the data dependencies of its instructions.) 108 391.32 T
-0.2 (After the scheduling, the loop may contain instructions from the \336rst) 108 367.32 P
1 F
-0.2 (k) 410.75 367.32 P
0 F
-0.2 ( iterations. In the case when) 415.63 367.32 P
(pipelined motions have been performed \050i.e.) 108 353.9 T
(\051, the non-speculative execution of the instruc-) 326.28 353.9 T
(tions moved outside the loop must be assured. This is done by generating appropriate prologues) 108 340.32 T
(and epilogues for these iterations) 108 327.32 T
(Care must be taken to ensure that the global information used by subsequent passes of the com-) 108 303.32 T
(piler is updated to account for changes resulting from the software scheduling.) 108 290.32 T
(This document describes and explains the enhancements to the inter) 108 266.32 T
(-block scheduler of gcc that) 406.87 266.32 T
(implement software pipelining. The main additions to the inter) 108 253.32 T
(-block scheduler are:) 383.68 253.32 T
3 12 Q
(\245) 122.4 233.65 T
0 11 Q
(identi\336cation of candidate loops for pipelining) 129.6 233.65 T
3 12 Q
(\245) 122.4 213.65 T
0 11 Q
(computation of control \337ow information for pipelined motions) 129.6 213.65 T
3 12 Q
(\245) 122.4 193.65 T
0 11 Q
(computation of data dependencies for pipelined motions) 129.6 193.65 T
3 12 Q
(\245) 122.4 173.65 T
0 11 Q
(handling of pipelined motions by the list scheduling algorithm) 129.6 173.65 T
3 12 Q
(\245) 122.4 153.65 T
0 11 Q
(generation of prologues and epilogues) 129.6 153.65 T
3 12 Q
(\245) 122.4 133.65 T
0 11 Q
(updating of global information used by gcc) 129.6 133.65 T
414.47 474.75 435.4 486.75 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 413.47 479 T
0 F
(1) 429.89 479 T
4 F
(>) 421.11 479 T
0 0 612 792 C
409.18 441.5 429.67 453.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 408.23 445.75 T
0 F
(1) 424.11 445.75 T
(\320) 415.86 445.75 T
0 0 612 792 C
176.85 424.65 198.3 439.5 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(p) 176.34 431.75 T
1 8 Q
(k) 182.26 428.1 T
0 F
(1) 193.81 428.1 T
(\320) 187.81 428.1 T
0 0 612 792 C
305.35 349.65 326.28 361.65 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
1 11 Q
0 X
0 0 0 1 0 0 0 K
(k) 304.36 353.9 T
0 F
(1) 320.77 353.9 T
4 F
(>) 311.99 353.9 T
0 0 612 792 C
FMENDPAGE
%%EndPage: "3" 16
%%Page: "2" 17
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(2) 536 42.5 T
FMENDPAGE
%%EndPage: "2" 17
%%Page: "1" 18
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(March 5, 1996) 300.56 42.5 T
(1) 536 42.5 T
0 21 Q
(PPCREF Project - High level design) 170.87 571 T
2 16 Q
(  Softwar) 252.81 532.33 T
(e Pipelining) 314.73 532.33 T
(  Branch Optimizations) 244.22 506.33 T
2 12 Q
(IBM Israel - Science and T) 230.05 429 T
(echnology) 366.61 429 T
(Matam, Haifa 31905, Israel) 253.84 413 T
FMENDPAGE
%%EndPage: "1" 18
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Descend
%%Pages: 18
%%DocumentFonts: Times-Roman
%%+ Times-Italic
%%+ Times-Bold
%%+ Courier-Bold
%%+ Symbol
%%EOF
